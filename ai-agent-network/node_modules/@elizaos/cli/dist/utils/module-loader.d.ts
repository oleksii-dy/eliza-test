/**
 * ModuleLoader provides a clean way to load modules from the project's local node_modules
 * instead of the global CLI's bundled dependencies. This solves singleton pattern issues
 * and ensures consistent module instances across the application.
 */
export declare class ModuleLoader {
    private require;
    private asyncCache;
    private syncCache;
    private projectPath;
    constructor(projectPath?: string);
    /**
     * Detect the appropriate project path, preferring monorepo root over current working directory
     */
    private detectProjectPath;
    /**
     * Load a module from the project's node_modules directory.
     * Uses caching to ensure the same instance is returned for repeated calls.
     *
     * @param moduleName - The name of the module to load (e.g., '@elizaos/server')
     * @returns The loaded module
     * @throws Error if the module cannot be found in the project
     */
    load<T = any>(moduleName: string): Promise<T>;
    /**
     * Synchronously load a module from the project's node_modules directory.
     * Uses caching to ensure the same instance is returned for repeated calls.
     *
     * @param moduleName - The name of the module to load (e.g., '@elizaos/server')
     * @returns The loaded module
     * @throws Error if the module cannot be found in the project
     */
    loadSync<T = any>(moduleName: string): T;
    /**
     * Set up environment with proper module resolution paths.
     * This ensures the same local-first guarantees as server-manager.ts.
     */
    private setupEnvironment;
    /**
     * Clear the module cache. Useful for testing or hot reloading scenarios.
     */
    clearCache(): void;
    /**
     * Get the resolved path for a module without loading it.
     * Useful for debugging or verification.
     *
     * @param moduleName - The name of the module to resolve
     * @returns The resolved file path
     */
    resolve(moduleName: string): string;
}
/**
 * Get the default module loader instance for the current project.
 * Creates a new instance if one doesn't exist.
 */
export declare function getModuleLoader(): ModuleLoader;
/**
 * Convenience function to load a module using the default loader.
 *
 * @param moduleName - The name of the module to load
 * @returns The loaded module
 */
export declare function loadModule<T = any>(moduleName: string): Promise<T>;
/**
 * Convenience function to synchronously load a module using the default loader.
 *
 * @param moduleName - The name of the module to load
 * @returns The loaded module
 */
export declare function loadModuleSync<T = any>(moduleName: string): T;
//# sourceMappingURL=module-loader.d.ts.map