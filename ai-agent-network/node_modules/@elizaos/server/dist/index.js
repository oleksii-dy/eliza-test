import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// ../../node_modules/path-to-regexp/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PathError = exports.TokenData = undefined;
  exports.parse = parse;
  exports.compile = compile;
  exports.match = match;
  exports.pathToRegexp = pathToRegexp;
  exports.stringify = stringify;
  var DEFAULT_DELIMITER = "/";
  var NOOP_VALUE = (value) => value;
  var ID_START = /^[$_\p{ID_Start}]$/u;
  var ID_CONTINUE = /^[$\u200c\u200d\p{ID_Continue}]$/u;
  var SIMPLE_TOKENS = {
    "{": "{",
    "}": "}",
    "(": "(",
    ")": ")",
    "[": "[",
    "]": "]",
    "+": "+",
    "?": "?",
    "!": "!"
  };
  function escapeText(str) {
    return str.replace(/[{}()\[\]+?!:*\\]/g, "\\$&");
  }
  function escape(str) {
    return str.replace(/[.+*?^${}()[\]|/\\]/g, "\\$&");
  }

  class TokenData {
    constructor(tokens, originalPath) {
      this.tokens = tokens;
      this.originalPath = originalPath;
    }
  }
  exports.TokenData = TokenData;

  class PathError extends TypeError {
    constructor(message, originalPath) {
      let text = message;
      if (originalPath)
        text += `: ${originalPath}`;
      text += `; visit https://git.new/pathToRegexpError for info`;
      super(text);
      this.originalPath = originalPath;
    }
  }
  exports.PathError = PathError;
  function parse(str, options = {}) {
    const { encodePath = NOOP_VALUE } = options;
    const chars = [...str];
    const tokens = [];
    let index = 0;
    let pos = 0;
    function name() {
      let value = "";
      if (ID_START.test(chars[index])) {
        do {
          value += chars[index++];
        } while (ID_CONTINUE.test(chars[index]));
      } else if (chars[index] === '"') {
        let quoteStart = index;
        while (index++ < chars.length) {
          if (chars[index] === '"') {
            index++;
            quoteStart = 0;
            break;
          }
          if (chars[index] === "\\")
            index++;
          value += chars[index];
        }
        if (quoteStart) {
          throw new PathError(`Unterminated quote at index ${quoteStart}`, str);
        }
      }
      if (!value) {
        throw new PathError(`Missing parameter name at index ${index}`, str);
      }
      return value;
    }
    while (index < chars.length) {
      const value = chars[index];
      const type = SIMPLE_TOKENS[value];
      if (type) {
        tokens.push({ type, index: index++, value });
      } else if (value === "\\") {
        tokens.push({ type: "escape", index: index++, value: chars[index++] });
      } else if (value === ":") {
        tokens.push({ type: "param", index: index++, value: name() });
      } else if (value === "*") {
        tokens.push({ type: "wildcard", index: index++, value: name() });
      } else {
        tokens.push({ type: "char", index: index++, value });
      }
    }
    tokens.push({ type: "end", index, value: "" });
    function consumeUntil(endType) {
      const output = [];
      while (true) {
        const token = tokens[pos++];
        if (token.type === endType)
          break;
        if (token.type === "char" || token.type === "escape") {
          let path = token.value;
          let cur = tokens[pos];
          while (cur.type === "char" || cur.type === "escape") {
            path += cur.value;
            cur = tokens[++pos];
          }
          output.push({
            type: "text",
            value: encodePath(path)
          });
          continue;
        }
        if (token.type === "param" || token.type === "wildcard") {
          output.push({
            type: token.type,
            name: token.value
          });
          continue;
        }
        if (token.type === "{") {
          output.push({
            type: "group",
            tokens: consumeUntil("}")
          });
          continue;
        }
        throw new PathError(`Unexpected ${token.type} at index ${token.index}, expected ${endType}`, str);
      }
      return output;
    }
    return new TokenData(consumeUntil("end"), str);
  }
  function compile(path, options = {}) {
    const { encode = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const data = typeof path === "object" ? path : parse(path, options);
    const fn = tokensToFunction(data.tokens, delimiter, encode);
    return function path(params = {}) {
      const [path2, ...missing] = fn(params);
      if (missing.length) {
        throw new TypeError(`Missing parameters: ${missing.join(", ")}`);
      }
      return path2;
    };
  }
  function tokensToFunction(tokens, delimiter, encode) {
    const encoders = tokens.map((token) => tokenToFunction(token, delimiter, encode));
    return (data) => {
      const result = [""];
      for (const encoder of encoders) {
        const [value, ...extras] = encoder(data);
        result[0] += value;
        result.push(...extras);
      }
      return result;
    };
  }
  function tokenToFunction(token, delimiter, encode) {
    if (token.type === "text")
      return () => [token.value];
    if (token.type === "group") {
      const fn = tokensToFunction(token.tokens, delimiter, encode);
      return (data) => {
        const [value, ...missing] = fn(data);
        if (!missing.length)
          return [value];
        return [""];
      };
    }
    const encodeValue = encode || NOOP_VALUE;
    if (token.type === "wildcard" && encode !== false) {
      return (data) => {
        const value = data[token.name];
        if (value == null)
          return ["", token.name];
        if (!Array.isArray(value) || value.length === 0) {
          throw new TypeError(`Expected "${token.name}" to be a non-empty array`);
        }
        return [
          value.map((value2, index) => {
            if (typeof value2 !== "string") {
              throw new TypeError(`Expected "${token.name}/${index}" to be a string`);
            }
            return encodeValue(value2);
          }).join(delimiter)
        ];
      };
    }
    return (data) => {
      const value = data[token.name];
      if (value == null)
        return ["", token.name];
      if (typeof value !== "string") {
        throw new TypeError(`Expected "${token.name}" to be a string`);
      }
      return [encodeValue(value)];
    };
  }
  function match(path, options = {}) {
    const { decode = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const { regexp, keys } = pathToRegexp(path, options);
    const decoders = keys.map((key) => {
      if (decode === false)
        return NOOP_VALUE;
      if (key.type === "param")
        return decode;
      return (value) => value.split(delimiter).map(decode);
    });
    return function match(input) {
      const m = regexp.exec(input);
      if (!m)
        return false;
      const path2 = m[0];
      const params = Object.create(null);
      for (let i = 1;i < m.length; i++) {
        if (m[i] === undefined)
          continue;
        const key = keys[i - 1];
        const decoder = decoders[i - 1];
        params[key.name] = decoder(m[i]);
      }
      return { path: path2, params };
    };
  }
  function pathToRegexp(path, options = {}) {
    const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true } = options;
    const keys = [];
    const flags = sensitive ? "" : "i";
    const sources = [];
    for (const input of pathsToArray(path, [])) {
      const data = typeof input === "object" ? input : parse(input, options);
      for (const tokens of flatten(data.tokens, 0, [])) {
        sources.push(toRegExpSource(tokens, delimiter, keys, data.originalPath));
      }
    }
    let pattern = `^(?:${sources.join("|")})`;
    if (trailing)
      pattern += `(?:${escape(delimiter)}$)?`;
    pattern += end ? "$" : `(?=${escape(delimiter)}|$)`;
    const regexp = new RegExp(pattern, flags);
    return { regexp, keys };
  }
  function pathsToArray(paths, init) {
    if (Array.isArray(paths)) {
      for (const p of paths)
        pathsToArray(p, init);
    } else {
      init.push(paths);
    }
    return init;
  }
  function* flatten(tokens, index, init) {
    if (index === tokens.length) {
      return yield init;
    }
    const token = tokens[index];
    if (token.type === "group") {
      for (const seq of flatten(token.tokens, 0, init.slice())) {
        yield* flatten(tokens, index + 1, seq);
      }
    } else {
      init.push(token);
    }
    yield* flatten(tokens, index + 1, init);
  }
  function toRegExpSource(tokens, delimiter, keys, originalPath) {
    let result = "";
    let backtrack = "";
    let isSafeSegmentParam = true;
    for (const token of tokens) {
      if (token.type === "text") {
        result += escape(token.value);
        backtrack += token.value;
        isSafeSegmentParam || (isSafeSegmentParam = token.value.includes(delimiter));
        continue;
      }
      if (token.type === "param" || token.type === "wildcard") {
        if (!isSafeSegmentParam && !backtrack) {
          throw new PathError(`Missing text before "${token.name}" ${token.type}`, originalPath);
        }
        if (token.type === "param") {
          result += `(${negate(delimiter, isSafeSegmentParam ? "" : backtrack)}+)`;
        } else {
          result += `([\\s\\S]+)`;
        }
        keys.push(token);
        backtrack = "";
        isSafeSegmentParam = false;
        continue;
      }
    }
    return result;
  }
  function negate(delimiter, backtrack) {
    if (backtrack.length < 2) {
      if (delimiter.length < 2)
        return `[^${escape(delimiter + backtrack)}]`;
      return `(?:(?!${escape(delimiter)})[^${escape(backtrack)}])`;
    }
    if (delimiter.length < 2) {
      return `(?:(?!${escape(backtrack)})[^${escape(delimiter)}])`;
    }
    return `(?:(?!${escape(backtrack)}|${escape(delimiter)})[\\s\\S])`;
  }
  function stringifyTokens(tokens) {
    let value = "";
    let i = 0;
    function name(value2) {
      const isSafe = isNameSafe(value2) && isNextNameSafe(tokens[i]);
      return isSafe ? value2 : JSON.stringify(value2);
    }
    while (i < tokens.length) {
      const token = tokens[i++];
      if (token.type === "text") {
        value += escapeText(token.value);
        continue;
      }
      if (token.type === "group") {
        value += `{${stringifyTokens(token.tokens)}}`;
        continue;
      }
      if (token.type === "param") {
        value += `:${name(token.name)}`;
        continue;
      }
      if (token.type === "wildcard") {
        value += `*${name(token.name)}`;
        continue;
      }
      throw new TypeError(`Unknown token type: ${token.type}`);
    }
    return value;
  }
  function stringify(data) {
    return stringifyTokens(data.tokens);
  }
  function isNameSafe(name) {
    const [first, ...rest] = name;
    return ID_START.test(first) && rest.every((char) => ID_CONTINUE.test(char));
  }
  function isNextNameSafe(token) {
    if (token && token.type === "text")
      return !ID_CONTINUE.test(token.value[0]);
    return true;
  }
});

// ../../node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.6.1",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    homepage: "https://github.com/motdotla/dotenv#readme",
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// ../../node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var fs4 = __require("fs");
  var path5 = __require("path");
  var os = __require("os");
  var crypto = __require("crypto");
  var packageJson = require_package();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, `
`);
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, `
`);
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    options = options || {};
    const vaultPath = _vaultPath(options);
    options.path = vaultPath;
    const result = DotenvModule.configDotenv(options);
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _warn(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  }
  function _log(message) {
    console.log(`[dotenv@${version}] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs4.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path5.resolve(process.cwd(), ".env.vault");
    }
    if (fs4.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path5.join(os.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options) {
    const debug = Boolean(options && options.debug);
    const quiet = options && "quiet" in options ? options.quiet : true;
    if (debug || !quiet) {
      _log("Loading env from encrypted .env.vault");
    }
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path5.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    const quiet = options && "quiet" in options ? options.quiet : true;
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path6 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs4.readFileSync(path6, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path6} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (debug || !quiet) {
      const keysCount = Object.keys(parsedAll).length;
      const shortPaths = [];
      for (const filePath of optionPaths) {
        try {
          const relative = path5.relative(process.cwd(), filePath);
          shortPaths.push(relative);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${filePath} ${e.message}`);
          }
          lastError = e;
        }
      }
      _log(`injecting env (${keysCount}) from ${shortPaths.join(",")}`);
    }
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// ../../node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../../node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_globalThis(), exports);
});

// ../../node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_node(), exports);
});

// ../../node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.9.0";
});

// ../../node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCompatible = exports._makeCompatibilityCheck = undefined;
  var version_1 = require_version();
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function _makeCompatibilityCheck(ownVersion) {
    const acceptedVersions = new Set([ownVersion]);
    const rejectedVersions = new Set;
    const myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return () => false;
    }
    const ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      const globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      const globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  }
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});

// ../../node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = undefined;
  var platform_1 = require_platform();
  var version_1 = require_version();
  var semver_1 = require_semver();
  var major = version_1.VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  var _global = platform_1._globalThis;
  function registerGlobal(type, instance, diag, allowOverride = false) {
    var _a;
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== undefined ? _a : {
      version: version_1.VERSION
    };
    if (!allowOverride && api[type]) {
      const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api.version !== version_1.VERSION) {
      const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
      diag.error(err.stack || err.message);
      return false;
    }
    api[type] = instance;
    diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
    return true;
  }
  exports.registerGlobal = registerGlobal;
  function getGlobal(type) {
    var _a, _b;
    const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === undefined ? undefined : _a.version;
    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
      return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === undefined ? undefined : _b[type];
  }
  exports.getGlobal = getGlobal;
  function unregisterGlobal(type, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
      delete api[type];
    }
  }
  exports.unregisterGlobal = unregisterGlobal;
});

// ../../node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagComponentLogger = undefined;
  var global_utils_1 = require_global_utils();

  class DiagComponentLogger {
    constructor(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    debug(...args) {
      return logProxy("debug", this._namespace, args);
    }
    error(...args) {
      return logProxy("error", this._namespace, args);
    }
    info(...args) {
      return logProxy("info", this._namespace, args);
    }
    warn(...args) {
      return logProxy("warn", this._namespace, args);
    }
    verbose(...args) {
      return logProxy("verbose", this._namespace, args);
    }
  }
  exports.DiagComponentLogger = DiagComponentLogger;
  function logProxy(funcName, namespace, args) {
    const logger30 = (0, global_utils_1.getGlobal)("diag");
    if (!logger30) {
      return;
    }
    args.unshift(namespace);
    return logger30[funcName](...args);
  }
});

// ../../node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagLogLevel = undefined;
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLogLevelDiagLogger = undefined;
  var types_1 = require_types();
  function createLogLevelDiagLogger(maxLevel, logger30) {
    if (maxLevel < types_1.DiagLogLevel.NONE) {
      maxLevel = types_1.DiagLogLevel.NONE;
    } else if (maxLevel > types_1.DiagLogLevel.ALL) {
      maxLevel = types_1.DiagLogLevel.ALL;
    }
    logger30 = logger30 || {};
    function _filterFunc(funcName, theLevel) {
      const theFunc = logger30[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger30);
      }
      return function() {};
    }
    return {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  }
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});

// ../../node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagAPI = undefined;
  var ComponentLogger_1 = require_ComponentLogger();
  var logLevelLogger_1 = require_logLevelLogger();
  var types_1 = require_types();
  var global_utils_1 = require_global_utils();
  var API_NAME = "diag";

  class DiagAPI {
    constructor() {
      function _logProxy(funcName) {
        return function(...args) {
          const logger30 = (0, global_utils_1.getGlobal)("diag");
          if (!logger30)
            return;
          return logger30[funcName](...args);
        };
      }
      const self = this;
      const setLogger = (logger30, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
        var _a, _b, _c;
        if (logger30 === self) {
          const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a = err.stack) !== null && _a !== undefined ? _a : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        const oldLogger = (0, global_utils_1.getGlobal)("diag");
        const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== undefined ? _b : types_1.DiagLogLevel.INFO, logger30);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          const stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : "<failed to generate stacktrace>";
          oldLogger.warn(`Current logger will be overwritten from ${stack}`);
          newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
        }
        return (0, global_utils_1.registerGlobal)("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = () => {
        (0, global_utils_1.unregisterGlobal)(API_NAME, self);
      };
      self.createComponentLogger = (options) => {
        return new ComponentLogger_1.DiagComponentLogger(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    static instance() {
      if (!this._instance) {
        this._instance = new DiagAPI;
      }
      return this._instance;
    }
  }
  exports.DiagAPI = DiagAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaggageImpl = undefined;

  class BaggageImpl {
    constructor(entries) {
      this._entries = entries ? new Map(entries) : new Map;
    }
    getEntry(key) {
      const entry = this._entries.get(key);
      if (!entry) {
        return;
      }
      return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
    }
    setEntry(key, entry) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    }
    removeEntry(key) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    }
    removeEntries(...keys) {
      const newBaggage = new BaggageImpl(this._entries);
      for (const key of keys) {
        newBaggage._entries.delete(key);
      }
      return newBaggage;
    }
    clear() {
      return new BaggageImpl;
    }
  }
  exports.BaggageImpl = BaggageImpl;
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataSymbol = undefined;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataFromString = exports.createBaggage = undefined;
  var diag_1 = require_diag();
  var baggage_impl_1 = require_baggage_impl();
  var symbol_1 = require_symbol();
  var diag = diag_1.DiagAPI.instance();
  function createBaggage(entries = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
  }
  exports.createBaggage = createBaggage;
  function baggageEntryMetadataFromString(str) {
    if (typeof str !== "string") {
      diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
      str = "";
    }
    return {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  }
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});

// ../../node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ROOT_CONTEXT = exports.createContextKey = undefined;
  function createContextKey(description) {
    return Symbol.for(description);
  }
  exports.createContextKey = createContextKey;

  class BaseContext {
    constructor(parentContext) {
      const self = this;
      self._currentContext = parentContext ? new Map(parentContext) : new Map;
      self.getValue = (key) => self._currentContext.get(key);
      self.setValue = (key, value) => {
        const context = new BaseContext(self._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self.deleteValue = (key) => {
        const context = new BaseContext(self._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
  }
  exports.ROOT_CONTEXT = new BaseContext;
});

// ../../node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagConsoleLogger = undefined;
  var consoleMap = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" }
  ];

  class DiagConsoleLogger {
    constructor() {
      function _consoleFunc(funcName) {
        return function(...args) {
          if (console) {
            let theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args);
            }
          }
        };
      }
      for (let i = 0;i < consoleMap.length; i++) {
        this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    }
  }
  exports.DiagConsoleLogger = DiagConsoleLogger;
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = undefined;

  class NoopMeter {
    constructor() {}
    createGauge(_name, _options) {
      return exports.NOOP_GAUGE_METRIC;
    }
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {}
    removeBatchObservableCallback(_callback) {}
  }
  exports.NoopMeter = NoopMeter;

  class NoopMetric {
  }
  exports.NoopMetric = NoopMetric;

  class NoopCounterMetric extends NoopMetric {
    add(_value, _attributes) {}
  }
  exports.NoopCounterMetric = NoopCounterMetric;

  class NoopUpDownCounterMetric extends NoopMetric {
    add(_value, _attributes) {}
  }
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

  class NoopGaugeMetric extends NoopMetric {
    record(_value, _attributes) {}
  }
  exports.NoopGaugeMetric = NoopGaugeMetric;

  class NoopHistogramMetric extends NoopMetric {
    record(_value, _attributes) {}
  }
  exports.NoopHistogramMetric = NoopHistogramMetric;

  class NoopObservableMetric {
    addCallback(_callback) {}
    removeCallback(_callback) {}
  }
  exports.NoopObservableMetric = NoopObservableMetric;

  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;

  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter;
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric;
  exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric;
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
  function createNoopMeter() {
    return exports.NOOP_METER;
  }
  exports.createNoopMeter = createNoopMeter;
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = undefined;
  var ValueType;
  (function(ValueType2) {
    ValueType2[ValueType2["INT"] = 0] = "INT";
    ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
  })(ValueType = exports.ValueType || (exports.ValueType = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultTextMapSetter = exports.defaultTextMapGetter = undefined;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier == null) {
        return;
      }
      return carrier[key];
    },
    keys(carrier) {
      if (carrier == null) {
        return [];
      }
      return Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value) {
      if (carrier == null) {
        return;
      }
      carrier[key] = value;
    }
  };
});

// ../../node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopContextManager = undefined;
  var context_1 = require_context();

  class NoopContextManager {
    active() {
      return context_1.ROOT_CONTEXT;
    }
    with(_context, fn, thisArg, ...args) {
      return fn.call(thisArg, ...args);
    }
    bind(_context, target) {
      return target;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  }
  exports.NoopContextManager = NoopContextManager;
});

// ../../node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContextAPI = undefined;
  var NoopContextManager_1 = require_NoopContextManager();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager;

  class ContextAPI {
    constructor() {}
    static getInstance() {
      if (!this._instance) {
        this._instance = new ContextAPI;
      }
      return this._instance;
    }
    setGlobalContextManager(contextManager) {
      return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(context, fn, thisArg, ...args) {
      return this._getContextManager().with(context, fn, thisArg, ...args);
    }
    bind(context, target) {
      return this._getContextManager().bind(context, target);
    }
    _getContextManager() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    }
    disable() {
      this._getContextManager().disable();
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.ContextAPI = ContextAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceFlags = undefined;
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = undefined;
  var trace_flags_1 = require_trace_flags();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonRecordingSpan = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();

  class NonRecordingSpan {
    constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
      this._spanContext = _spanContext;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(_key, _value) {
      return this;
    }
    setAttributes(_attributes) {
      return this;
    }
    addEvent(_name, _attributes) {
      return this;
    }
    addLink(_link) {
      return this;
    }
    addLinks(_links) {
      return this;
    }
    setStatus(_status) {
      return this;
    }
    updateName(_name) {
      return this;
    }
    end(_endTime) {}
    isRecording() {
      return false;
    }
    recordException(_exception, _time) {}
  }
  exports.NonRecordingSpan = NonRecordingSpan;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = undefined;
  var context_1 = require_context();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var context_2 = require_context2();
  var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
  }
  exports.getSpan = getSpan;
  function getActiveSpan() {
    return getSpan(context_2.ContextAPI.getInstance().active());
  }
  exports.getActiveSpan = getActiveSpan;
  function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
  }
  exports.setSpan = setSpan;
  function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
  }
  exports.deleteSpan = deleteSpan;
  function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  }
  exports.setSpanContext = setSpanContext;
  function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === undefined ? undefined : _a.spanContext();
  }
  exports.getSpanContext = getSpanContext;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  }
  exports.isValidTraceId = isValidTraceId;
  function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  }
  exports.isValidSpanId = isValidSpanId;
  function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  }
  exports.isSpanContextValid = isSpanContextValid;
  function wrapSpanContext(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  }
  exports.wrapSpanContext = wrapSpanContext;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracer = undefined;
  var context_1 = require_context2();
  var context_utils_1 = require_context_utils();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var spancontext_utils_1 = require_spancontext_utils();
  var contextApi = context_1.ContextAPI.getInstance();

  class NoopTracer {
    startSpan(name, options, context = contextApi.active()) {
      const root = Boolean(options === null || options === undefined ? undefined : options.root);
      if (root) {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
      const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
      if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
        return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, undefined, span);
    }
  }
  exports.NoopTracer = NoopTracer;
  function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracer = undefined;
  var NoopTracer_1 = require_NoopTracer();
  var NOOP_TRACER = new NoopTracer_1.NoopTracer;

  class ProxyTracer {
    constructor(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    startSpan(name, options, context) {
      return this._getTracer().startSpan(name, options, context);
    }
    startActiveSpan(_name, _options, _context, _fn) {
      const tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    }
    _getTracer() {
      if (this._delegate) {
        return this._delegate;
      }
      const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    }
  }
  exports.ProxyTracer = ProxyTracer;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracerProvider = undefined;
  var NoopTracer_1 = require_NoopTracer();

  class NoopTracerProvider {
    getTracer(_name, _version, _options) {
      return new NoopTracer_1.NoopTracer;
    }
  }
  exports.NoopTracerProvider = NoopTracerProvider;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracerProvider = undefined;
  var ProxyTracer_1 = require_ProxyTracer();
  var NoopTracerProvider_1 = require_NoopTracerProvider();
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider;

  class ProxyTracerProvider {
    getTracer(name, version, options) {
      var _a;
      return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== undefined ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options);
    }
    getDelegate() {
      var _a;
      return (_a = this._delegate) !== null && _a !== undefined ? _a : NOOP_TRACER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateTracer(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getTracer(name, version, options);
    }
  }
  exports.ProxyTracerProvider = ProxyTracerProvider;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatusCode = undefined;
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  exports.validateValue = validateValue;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceStateImpl = undefined;
  var tracestate_validators_1 = require_tracestate_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceStateImpl {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value = listMember.slice(i + 1, part.length);
          if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value)) {
            agg.set(key, value);
          } else {}
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceStateImpl;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceStateImpl = TraceStateImpl;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceState = undefined;
  var tracestate_impl_1 = require_tracestate_impl();
  function createTraceState(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  }
  exports.createTraceState = createTraceState;
});

// ../../node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.context = undefined;
  var context_1 = require_context2();
  exports.context = context_1.ContextAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diag = undefined;
  var diag_1 = require_diag();
  exports.diag = diag_1.DiagAPI.instance();
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = undefined;
  var NoopMeter_1 = require_NoopMeter();

  class NoopMeterProvider {
    getMeter(_name, _version, _options) {
      return NoopMeter_1.NOOP_METER;
    }
  }
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider;
});

// ../../node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var NoopMeterProvider_1 = require_NoopMeterProvider();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "metrics";

  class MetricsAPI {
    constructor() {}
    static getInstance() {
      if (!this._instance) {
        this._instance = new MetricsAPI;
      }
      return this._instance;
    }
    setGlobalMeterProvider(provider) {
      return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }
    getMeter(name, version, options) {
      return this.getMeterProvider().getMeter(name, version, options);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics_1 = require_metrics();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTextMapPropagator = undefined;

  class NoopTextMapPropagator {
    inject(_context, _carrier) {}
    extract(context, _carrier) {
      return context;
    }
    fields() {
      return [];
    }
  }
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = undefined;
  var context_1 = require_context2();
  var context_2 = require_context();
  var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
  }
  exports.getBaggage = getBaggage;
  function getActiveBaggage() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  }
  exports.getActiveBaggage = getActiveBaggage;
  function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
  }
  exports.setBaggage = setBaggage;
  function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
  }
  exports.deleteBaggage = deleteBaggage;
});

// ../../node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropagationAPI = undefined;
  var global_utils_1 = require_global_utils();
  var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
  var TextMapPropagator_1 = require_TextMapPropagator();
  var context_helpers_1 = require_context_helpers();
  var utils_1 = require_utils();
  var diag_1 = require_diag();
  var API_NAME = "propagation";
  var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator;

  class PropagationAPI {
    constructor() {
      this.createBaggage = utils_1.createBaggage;
      this.getBaggage = context_helpers_1.getBaggage;
      this.getActiveBaggage = context_helpers_1.getActiveBaggage;
      this.setBaggage = context_helpers_1.setBaggage;
      this.deleteBaggage = context_helpers_1.deleteBaggage;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new PropagationAPI;
      }
      return this._instance;
    }
    setGlobalPropagator(propagator) {
      return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
    }
    inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(context, carrier, setter);
    }
    extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(context, carrier, getter);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    }
  }
  exports.PropagationAPI = PropagationAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.propagation = undefined;
  var propagation_1 = require_propagation();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceAPI = undefined;
  var global_utils_1 = require_global_utils();
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  var spancontext_utils_1 = require_spancontext_utils();
  var context_utils_1 = require_context_utils();
  var diag_1 = require_diag();
  var API_NAME = "trace";

  class TraceAPI {
    constructor() {
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
      this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
      this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
      this.deleteSpan = context_utils_1.deleteSpan;
      this.getSpan = context_utils_1.getSpan;
      this.getActiveSpan = context_utils_1.getActiveSpan;
      this.getSpanContext = context_utils_1.getSpanContext;
      this.setSpan = context_utils_1.setSpan;
      this.setSpanContext = context_utils_1.setSpanContext;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new TraceAPI;
      }
      return this._instance;
    }
    setGlobalTracerProvider(provider) {
      const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    }
    getTracerProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
    }
    getTracer(name, version) {
      return this.getTracerProvider().getTracer(name, version);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
    }
  }
  exports.TraceAPI = TraceAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = undefined;
  var trace_1 = require_trace();
  exports.trace = trace_1.TraceAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = undefined;
  var utils_1 = require_utils();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
    return utils_1.baggageEntryMetadataFromString;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
    return context_1.createContextKey;
  } });
  Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
    return context_1.ROOT_CONTEXT;
  } });
  var consoleLogger_1 = require_consoleLogger();
  Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
    return consoleLogger_1.DiagConsoleLogger;
  } });
  var types_1 = require_types();
  Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
    return types_1.DiagLogLevel;
  } });
  var NoopMeter_1 = require_NoopMeter();
  Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
    return NoopMeter_1.createNoopMeter;
  } });
  var Metric_1 = require_Metric();
  Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
    return Metric_1.ValueType;
  } });
  var TextMapPropagator_1 = require_TextMapPropagator();
  Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapGetter;
  } });
  Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapSetter;
  } });
  var ProxyTracer_1 = require_ProxyTracer();
  Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
    return ProxyTracer_1.ProxyTracer;
  } });
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
    return ProxyTracerProvider_1.ProxyTracerProvider;
  } });
  var SamplingResult_1 = require_SamplingResult();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return SamplingResult_1.SamplingDecision;
  } });
  var span_kind_1 = require_span_kind();
  Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
    return span_kind_1.SpanKind;
  } });
  var status_1 = require_status();
  Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
    return status_1.SpanStatusCode;
  } });
  var trace_flags_1 = require_trace_flags();
  Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
    return trace_flags_1.TraceFlags;
  } });
  var utils_2 = require_utils2();
  Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
    return utils_2.createTraceState;
  } });
  var spancontext_utils_1 = require_spancontext_utils();
  Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
    return spancontext_utils_1.isSpanContextValid;
  } });
  Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidTraceId;
  } });
  Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidSpanId;
  } });
  var invalid_span_constants_1 = require_invalid_span_constants();
  Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPANID;
  } });
  Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_TRACEID;
  } });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
  } });
  var context_api_1 = require_context_api();
  Object.defineProperty(exports, "context", { enumerable: true, get: function() {
    return context_api_1.context;
  } });
  var diag_api_1 = require_diag_api();
  Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
    return diag_api_1.diag;
  } });
  var metrics_api_1 = require_metrics_api();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_api_1.metrics;
  } });
  var propagation_api_1 = require_propagation_api();
  Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
    return propagation_api_1.propagation;
  } });
  var trace_api_1 = require_trace_api();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return trace_api_1.trace;
  } });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});

// ../../node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = undefined;
  var api_1 = require_src();
  var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
  function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, true);
  }
  exports.suppressTracing = suppressTracing;
  function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
  }
  exports.unsuppressTracing = unsuppressTracing;
  function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === true;
  }
  exports.isTracingSuppressed = isTracingSuppressed;
});

// ../../node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = undefined;
  exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
  exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
  exports.BAGGAGE_ITEMS_SEPARATOR = ",";
  exports.BAGGAGE_HEADER = "baggage";
  exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
  exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
  exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
});

// ../../node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = undefined;
  var api_1 = require_src();
  var constants_1 = require_constants();
  function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce((hValue, current) => {
      const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
      return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, "");
  }
  exports.serializeKeyPairs = serializeKeyPairs;
  function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(([key, value]) => {
      let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
      if (value.metadata !== undefined) {
        entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
      }
      return entry;
    });
  }
  exports.getKeyPairs = getKeyPairs;
  function parsePairKeyValue(entry) {
    const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
      return;
    const keyPairPart = valueProps.shift();
    if (!keyPairPart)
      return;
    const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
    if (separatorIndex <= 0)
      return;
    const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    let metadata;
    if (valueProps.length > 0) {
      metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key, value, metadata };
  }
  exports.parsePairKeyValue = parsePairKeyValue;
  function parseKeyPairsIntoRecord(value) {
    const result = {};
    if (typeof value === "string" && value.length > 0) {
      value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).forEach((entry) => {
        const keyPair = parsePairKeyValue(entry);
        if (keyPair !== undefined && keyPair.value.length > 0) {
          result[keyPair.key] = keyPair.value;
        }
      });
    }
    return result;
  }
  exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
});

// ../../node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.W3CBaggagePropagator = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  var constants_1 = require_constants();
  var utils_1 = require_utils3();

  class W3CBaggagePropagator {
    inject(context, carrier, setter) {
      const baggage = api_1.propagation.getBaggage(context);
      if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context))
        return;
      const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
        return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
      }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
      const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
      if (headerValue.length > 0) {
        setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
      }
    }
    extract(context, carrier, getter) {
      const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
      const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
      if (!baggageString)
        return context;
      const baggage = {};
      if (baggageString.length === 0) {
        return context;
      }
      const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
      pairs.forEach((entry) => {
        const keyPair = (0, utils_1.parsePairKeyValue)(entry);
        if (keyPair) {
          const baggageEntry = { value: keyPair.value };
          if (keyPair.metadata) {
            baggageEntry.metadata = keyPair.metadata;
          }
          baggage[keyPair.key] = baggageEntry;
        }
      });
      if (Object.entries(baggage).length === 0) {
        return context;
      }
      return api_1.propagation.setBaggage(context, api_1.propagation.createBaggage(baggage));
    }
    fields() {
      return [constants_1.BAGGAGE_HEADER];
    }
  }
  exports.W3CBaggagePropagator = W3CBaggagePropagator;
});

// ../../node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnchoredClock = undefined;

  class AnchoredClock {
    _monotonicClock;
    _epochMillis;
    _performanceMillis;
    constructor(systemClock, monotonicClock) {
      this._monotonicClock = monotonicClock;
      this._epochMillis = systemClock.now();
      this._performanceMillis = monotonicClock.now();
    }
    now() {
      const delta = this._monotonicClock.now() - this._performanceMillis;
      return this._epochMillis + delta;
    }
  }
  exports.AnchoredClock = AnchoredClock;
});

// ../../node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = undefined;
  var api_1 = require_src();
  function sanitizeAttributes(attributes) {
    const out = {};
    if (typeof attributes !== "object" || attributes == null) {
      return out;
    }
    for (const [key, val] of Object.entries(attributes)) {
      if (!isAttributeKey(key)) {
        api_1.diag.warn(`Invalid attribute key: ${key}`);
        continue;
      }
      if (!isAttributeValue(val)) {
        api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
        continue;
      }
      if (Array.isArray(val)) {
        out[key] = val.slice();
      } else {
        out[key] = val;
      }
    }
    return out;
  }
  exports.sanitizeAttributes = sanitizeAttributes;
  function isAttributeKey(key) {
    return typeof key === "string" && key.length > 0;
  }
  exports.isAttributeKey = isAttributeKey;
  function isAttributeValue(val) {
    if (val == null) {
      return true;
    }
    if (Array.isArray(val)) {
      return isHomogeneousAttributeValueArray(val);
    }
    return isValidPrimitiveAttributeValue(val);
  }
  exports.isAttributeValue = isAttributeValue;
  function isHomogeneousAttributeValueArray(arr) {
    let type;
    for (const element of arr) {
      if (element == null)
        continue;
      if (!type) {
        if (isValidPrimitiveAttributeValue(element)) {
          type = typeof element;
          continue;
        }
        return false;
      }
      if (typeof element === type) {
        continue;
      }
      return false;
    }
    return true;
  }
  function isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
      case "number":
      case "boolean":
      case "string":
        return true;
    }
    return false;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loggingErrorHandler = undefined;
  var api_1 = require_src();
  function loggingErrorHandler() {
    return (ex) => {
      api_1.diag.error(stringifyException(ex));
    };
  }
  exports.loggingErrorHandler = loggingErrorHandler;
  function stringifyException(ex) {
    if (typeof ex === "string") {
      return ex;
    } else {
      return JSON.stringify(flattenException(ex));
    }
  }
  function flattenException(ex) {
    const result = {};
    let current = ex;
    while (current !== null) {
      Object.getOwnPropertyNames(current).forEach((propertyName) => {
        if (result[propertyName])
          return;
        const value = current[propertyName];
        if (value) {
          result[propertyName] = String(value);
        }
      });
      current = Object.getPrototypeOf(current);
    }
    return result;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.globalErrorHandler = exports.setGlobalErrorHandler = undefined;
  var logging_error_handler_1 = require_logging_error_handler();
  var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
  function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
  }
  exports.setGlobalErrorHandler = setGlobalErrorHandler;
  function globalErrorHandler(ex) {
    try {
      delegateHandler(ex);
    } catch {}
  }
  exports.globalErrorHandler = globalErrorHandler;
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStringListFromEnv = exports.getBooleanFromEnv = exports.getStringFromEnv = exports.getNumberFromEnv = undefined;
  var api_1 = require_src();
  var util_1 = __require("util");
  function getNumberFromEnv(key) {
    const raw = process.env[key];
    if (raw == null || raw.trim() === "") {
      return;
    }
    const value = Number(raw);
    if (isNaN(value)) {
      api_1.diag.warn(`Unknown value ${(0, util_1.inspect)(raw)} for ${key}, expected a number, using defaults`);
      return;
    }
    return value;
  }
  exports.getNumberFromEnv = getNumberFromEnv;
  function getStringFromEnv(key) {
    const raw = process.env[key];
    if (raw == null || raw.trim() === "") {
      return;
    }
    return raw;
  }
  exports.getStringFromEnv = getStringFromEnv;
  function getBooleanFromEnv(key) {
    const raw = process.env[key]?.trim().toLowerCase();
    if (raw == null || raw === "") {
      return false;
    }
    if (raw === "true") {
      return true;
    } else if (raw === "false") {
      return false;
    } else {
      api_1.diag.warn(`Unknown value ${(0, util_1.inspect)(raw)} for ${key}, expected 'true' or 'false', falling back to 'false' (default)`);
      return false;
    }
  }
  exports.getBooleanFromEnv = getBooleanFromEnv;
  function getStringListFromEnv(key) {
    return getStringFromEnv(key)?.split(",").map((v) => v.trim()).filter((s) => s !== "");
  }
  exports.getStringListFromEnv = getStringListFromEnv;
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.otperformance = undefined;
  var perf_hooks_1 = __require("perf_hooks");
  exports.otperformance = perf_hooks_1.performance;
});

// ../../node_modules/@opentelemetry/core/build/src/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "2.1.0";
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createConstMap = undefined;
  function createConstMap(values) {
    let res = {};
    const len = values.length;
    for (let lp = 0;lp < len; lp++) {
      const val = values[lp];
      if (val) {
        res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
      }
    }
    return res;
  }
  exports.createConstMap = createConstMap;
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = undefined;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = undefined;
  exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = undefined;
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = undefined;
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = undefined;
  exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = undefined;
  var utils_1 = require_utils4();
  var TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
  var TMP_DB_SYSTEM = "db.system";
  var TMP_DB_CONNECTION_STRING = "db.connection_string";
  var TMP_DB_USER = "db.user";
  var TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
  var TMP_DB_NAME = "db.name";
  var TMP_DB_STATEMENT = "db.statement";
  var TMP_DB_OPERATION = "db.operation";
  var TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
  var TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
  var TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
  var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
  var TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
  var TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
  var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
  var TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
  var TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
  var TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
  var TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
  var TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
  var TMP_DB_SQL_TABLE = "db.sql.table";
  var TMP_EXCEPTION_TYPE = "exception.type";
  var TMP_EXCEPTION_MESSAGE = "exception.message";
  var TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
  var TMP_EXCEPTION_ESCAPED = "exception.escaped";
  var TMP_FAAS_TRIGGER = "faas.trigger";
  var TMP_FAAS_EXECUTION = "faas.execution";
  var TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
  var TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
  var TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
  var TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
  var TMP_FAAS_TIME = "faas.time";
  var TMP_FAAS_CRON = "faas.cron";
  var TMP_FAAS_COLDSTART = "faas.coldstart";
  var TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
  var TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
  var TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
  var TMP_NET_TRANSPORT = "net.transport";
  var TMP_NET_PEER_IP = "net.peer.ip";
  var TMP_NET_PEER_PORT = "net.peer.port";
  var TMP_NET_PEER_NAME = "net.peer.name";
  var TMP_NET_HOST_IP = "net.host.ip";
  var TMP_NET_HOST_PORT = "net.host.port";
  var TMP_NET_HOST_NAME = "net.host.name";
  var TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
  var TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
  var TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
  var TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
  var TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
  var TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
  var TMP_PEER_SERVICE = "peer.service";
  var TMP_ENDUSER_ID = "enduser.id";
  var TMP_ENDUSER_ROLE = "enduser.role";
  var TMP_ENDUSER_SCOPE = "enduser.scope";
  var TMP_THREAD_ID = "thread.id";
  var TMP_THREAD_NAME = "thread.name";
  var TMP_CODE_FUNCTION = "code.function";
  var TMP_CODE_NAMESPACE = "code.namespace";
  var TMP_CODE_FILEPATH = "code.filepath";
  var TMP_CODE_LINENO = "code.lineno";
  var TMP_HTTP_METHOD = "http.method";
  var TMP_HTTP_URL = "http.url";
  var TMP_HTTP_TARGET = "http.target";
  var TMP_HTTP_HOST = "http.host";
  var TMP_HTTP_SCHEME = "http.scheme";
  var TMP_HTTP_STATUS_CODE = "http.status_code";
  var TMP_HTTP_FLAVOR = "http.flavor";
  var TMP_HTTP_USER_AGENT = "http.user_agent";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
  var TMP_HTTP_SERVER_NAME = "http.server_name";
  var TMP_HTTP_ROUTE = "http.route";
  var TMP_HTTP_CLIENT_IP = "http.client_ip";
  var TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
  var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
  var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
  var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
  var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
  var TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
  var TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
  var TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
  var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
  var TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
  var TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
  var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
  var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
  var TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
  var TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
  var TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
  var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
  var TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
  var TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
  var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
  var TMP_MESSAGING_SYSTEM = "messaging.system";
  var TMP_MESSAGING_DESTINATION = "messaging.destination";
  var TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
  var TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
  var TMP_MESSAGING_PROTOCOL = "messaging.protocol";
  var TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
  var TMP_MESSAGING_URL = "messaging.url";
  var TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
  var TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
  var TMP_MESSAGING_OPERATION = "messaging.operation";
  var TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
  var TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
  var TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
  var TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
  var TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
  var TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
  var TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
  var TMP_RPC_SYSTEM = "rpc.system";
  var TMP_RPC_SERVICE = "rpc.service";
  var TMP_RPC_METHOD = "rpc.method";
  var TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
  var TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
  var TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
  var TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
  var TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
  var TMP_MESSAGE_TYPE = "message.type";
  var TMP_MESSAGE_ID = "message.id";
  var TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
  var TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
  exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
  exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
  exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
  exports.SEMATTRS_DB_USER = TMP_DB_USER;
  exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
  exports.SEMATTRS_DB_NAME = TMP_DB_NAME;
  exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
  exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
  exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
  exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
  exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
  exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
  exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
  exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
  exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
  exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
  exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
  exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
  exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
  exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
  exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
  exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
  exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
  exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
  exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
  exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
  exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
  exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
  exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
  exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
  exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
  exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
  exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
  exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
  exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
  exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
  exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
  exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
  exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
  exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
  exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
  exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
  exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
  exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
  exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
  exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
  exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
  exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
  exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
  exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
  exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
  exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID;
  exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
  exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
  exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
  exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
  exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
  exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
  exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL;
  exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
  exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
  exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
  exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
  exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
  exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
  exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
  exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
  exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
  exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
  exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
  exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
  exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
  exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
  exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
  exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
  exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
  exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
  exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
  exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
  exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
  exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
  exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
  exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
  exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
  exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
  exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
  exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
  exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
  exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
  exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
  exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
  exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
  exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
  exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
  exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
  exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
  exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
  exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
  exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWS_LAMBDA_INVOKED_ARN,
    TMP_DB_SYSTEM,
    TMP_DB_CONNECTION_STRING,
    TMP_DB_USER,
    TMP_DB_JDBC_DRIVER_CLASSNAME,
    TMP_DB_NAME,
    TMP_DB_STATEMENT,
    TMP_DB_OPERATION,
    TMP_DB_MSSQL_INSTANCE_NAME,
    TMP_DB_CASSANDRA_KEYSPACE,
    TMP_DB_CASSANDRA_PAGE_SIZE,
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
    TMP_DB_CASSANDRA_TABLE,
    TMP_DB_CASSANDRA_IDEMPOTENCE,
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
    TMP_DB_CASSANDRA_COORDINATOR_ID,
    TMP_DB_CASSANDRA_COORDINATOR_DC,
    TMP_DB_HBASE_NAMESPACE,
    TMP_DB_REDIS_DATABASE_INDEX,
    TMP_DB_MONGODB_COLLECTION,
    TMP_DB_SQL_TABLE,
    TMP_EXCEPTION_TYPE,
    TMP_EXCEPTION_MESSAGE,
    TMP_EXCEPTION_STACKTRACE,
    TMP_EXCEPTION_ESCAPED,
    TMP_FAAS_TRIGGER,
    TMP_FAAS_EXECUTION,
    TMP_FAAS_DOCUMENT_COLLECTION,
    TMP_FAAS_DOCUMENT_OPERATION,
    TMP_FAAS_DOCUMENT_TIME,
    TMP_FAAS_DOCUMENT_NAME,
    TMP_FAAS_TIME,
    TMP_FAAS_CRON,
    TMP_FAAS_COLDSTART,
    TMP_FAAS_INVOKED_NAME,
    TMP_FAAS_INVOKED_PROVIDER,
    TMP_FAAS_INVOKED_REGION,
    TMP_NET_TRANSPORT,
    TMP_NET_PEER_IP,
    TMP_NET_PEER_PORT,
    TMP_NET_PEER_NAME,
    TMP_NET_HOST_IP,
    TMP_NET_HOST_PORT,
    TMP_NET_HOST_NAME,
    TMP_NET_HOST_CONNECTION_TYPE,
    TMP_NET_HOST_CONNECTION_SUBTYPE,
    TMP_NET_HOST_CARRIER_NAME,
    TMP_NET_HOST_CARRIER_MCC,
    TMP_NET_HOST_CARRIER_MNC,
    TMP_NET_HOST_CARRIER_ICC,
    TMP_PEER_SERVICE,
    TMP_ENDUSER_ID,
    TMP_ENDUSER_ROLE,
    TMP_ENDUSER_SCOPE,
    TMP_THREAD_ID,
    TMP_THREAD_NAME,
    TMP_CODE_FUNCTION,
    TMP_CODE_NAMESPACE,
    TMP_CODE_FILEPATH,
    TMP_CODE_LINENO,
    TMP_HTTP_METHOD,
    TMP_HTTP_URL,
    TMP_HTTP_TARGET,
    TMP_HTTP_HOST,
    TMP_HTTP_SCHEME,
    TMP_HTTP_STATUS_CODE,
    TMP_HTTP_FLAVOR,
    TMP_HTTP_USER_AGENT,
    TMP_HTTP_REQUEST_CONTENT_LENGTH,
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_SERVER_NAME,
    TMP_HTTP_ROUTE,
    TMP_HTTP_CLIENT_IP,
    TMP_AWS_DYNAMODB_TABLE_NAMES,
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
    TMP_AWS_DYNAMODB_CONSISTENT_READ,
    TMP_AWS_DYNAMODB_PROJECTION,
    TMP_AWS_DYNAMODB_LIMIT,
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
    TMP_AWS_DYNAMODB_INDEX_NAME,
    TMP_AWS_DYNAMODB_SELECT,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
    TMP_AWS_DYNAMODB_TABLE_COUNT,
    TMP_AWS_DYNAMODB_SCAN_FORWARD,
    TMP_AWS_DYNAMODB_SEGMENT,
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
    TMP_AWS_DYNAMODB_COUNT,
    TMP_AWS_DYNAMODB_SCANNED_COUNT,
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
    TMP_MESSAGING_SYSTEM,
    TMP_MESSAGING_DESTINATION,
    TMP_MESSAGING_DESTINATION_KIND,
    TMP_MESSAGING_TEMP_DESTINATION,
    TMP_MESSAGING_PROTOCOL,
    TMP_MESSAGING_PROTOCOL_VERSION,
    TMP_MESSAGING_URL,
    TMP_MESSAGING_MESSAGE_ID,
    TMP_MESSAGING_CONVERSATION_ID,
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
    TMP_MESSAGING_OPERATION,
    TMP_MESSAGING_CONSUMER_ID,
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
    TMP_MESSAGING_KAFKA_MESSAGE_KEY,
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
    TMP_MESSAGING_KAFKA_CLIENT_ID,
    TMP_MESSAGING_KAFKA_PARTITION,
    TMP_MESSAGING_KAFKA_TOMBSTONE,
    TMP_RPC_SYSTEM,
    TMP_RPC_SERVICE,
    TMP_RPC_METHOD,
    TMP_RPC_GRPC_STATUS_CODE,
    TMP_RPC_JSONRPC_VERSION,
    TMP_RPC_JSONRPC_REQUEST_ID,
    TMP_RPC_JSONRPC_ERROR_CODE,
    TMP_RPC_JSONRPC_ERROR_MESSAGE,
    TMP_MESSAGE_TYPE,
    TMP_MESSAGE_ID,
    TMP_MESSAGE_COMPRESSED_SIZE,
    TMP_MESSAGE_UNCOMPRESSED_SIZE
  ]);
  var TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
  var TMP_DBSYSTEMVALUES_MSSQL = "mssql";
  var TMP_DBSYSTEMVALUES_MYSQL = "mysql";
  var TMP_DBSYSTEMVALUES_ORACLE = "oracle";
  var TMP_DBSYSTEMVALUES_DB2 = "db2";
  var TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
  var TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
  var TMP_DBSYSTEMVALUES_HIVE = "hive";
  var TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
  var TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
  var TMP_DBSYSTEMVALUES_PROGRESS = "progress";
  var TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
  var TMP_DBSYSTEMVALUES_HANADB = "hanadb";
  var TMP_DBSYSTEMVALUES_INGRES = "ingres";
  var TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
  var TMP_DBSYSTEMVALUES_EDB = "edb";
  var TMP_DBSYSTEMVALUES_CACHE = "cache";
  var TMP_DBSYSTEMVALUES_ADABAS = "adabas";
  var TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
  var TMP_DBSYSTEMVALUES_DERBY = "derby";
  var TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
  var TMP_DBSYSTEMVALUES_INFORMIX = "informix";
  var TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
  var TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
  var TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
  var TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
  var TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
  var TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
  var TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
  var TMP_DBSYSTEMVALUES_SYBASE = "sybase";
  var TMP_DBSYSTEMVALUES_TERADATA = "teradata";
  var TMP_DBSYSTEMVALUES_VERTICA = "vertica";
  var TMP_DBSYSTEMVALUES_H2 = "h2";
  var TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
  var TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
  var TMP_DBSYSTEMVALUES_HBASE = "hbase";
  var TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
  var TMP_DBSYSTEMVALUES_REDIS = "redis";
  var TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
  var TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
  var TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
  var TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
  var TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
  var TMP_DBSYSTEMVALUES_GEODE = "geode";
  var TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
  var TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
  var TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
  exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
  exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
  exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
  exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
  exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
  exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
  exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
  exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
  exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
  exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
  exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
  exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
  exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
  exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
  exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
  exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
  exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
  exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
  exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
  exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
  exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
  exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
  exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
  exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
  exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
  exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
  exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
  exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
  exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
  exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
  exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
  exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
  exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
  exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
  exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
  exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
  exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
  exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
  exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
  exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
  exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
  exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
  exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
  exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
  exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
  exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
  exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
  exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBSYSTEMVALUES_OTHER_SQL,
    TMP_DBSYSTEMVALUES_MSSQL,
    TMP_DBSYSTEMVALUES_MYSQL,
    TMP_DBSYSTEMVALUES_ORACLE,
    TMP_DBSYSTEMVALUES_DB2,
    TMP_DBSYSTEMVALUES_POSTGRESQL,
    TMP_DBSYSTEMVALUES_REDSHIFT,
    TMP_DBSYSTEMVALUES_HIVE,
    TMP_DBSYSTEMVALUES_CLOUDSCAPE,
    TMP_DBSYSTEMVALUES_HSQLDB,
    TMP_DBSYSTEMVALUES_PROGRESS,
    TMP_DBSYSTEMVALUES_MAXDB,
    TMP_DBSYSTEMVALUES_HANADB,
    TMP_DBSYSTEMVALUES_INGRES,
    TMP_DBSYSTEMVALUES_FIRSTSQL,
    TMP_DBSYSTEMVALUES_EDB,
    TMP_DBSYSTEMVALUES_CACHE,
    TMP_DBSYSTEMVALUES_ADABAS,
    TMP_DBSYSTEMVALUES_FIREBIRD,
    TMP_DBSYSTEMVALUES_DERBY,
    TMP_DBSYSTEMVALUES_FILEMAKER,
    TMP_DBSYSTEMVALUES_INFORMIX,
    TMP_DBSYSTEMVALUES_INSTANTDB,
    TMP_DBSYSTEMVALUES_INTERBASE,
    TMP_DBSYSTEMVALUES_MARIADB,
    TMP_DBSYSTEMVALUES_NETEZZA,
    TMP_DBSYSTEMVALUES_PERVASIVE,
    TMP_DBSYSTEMVALUES_POINTBASE,
    TMP_DBSYSTEMVALUES_SQLITE,
    TMP_DBSYSTEMVALUES_SYBASE,
    TMP_DBSYSTEMVALUES_TERADATA,
    TMP_DBSYSTEMVALUES_VERTICA,
    TMP_DBSYSTEMVALUES_H2,
    TMP_DBSYSTEMVALUES_COLDFUSION,
    TMP_DBSYSTEMVALUES_CASSANDRA,
    TMP_DBSYSTEMVALUES_HBASE,
    TMP_DBSYSTEMVALUES_MONGODB,
    TMP_DBSYSTEMVALUES_REDIS,
    TMP_DBSYSTEMVALUES_COUCHBASE,
    TMP_DBSYSTEMVALUES_COUCHDB,
    TMP_DBSYSTEMVALUES_COSMOSDB,
    TMP_DBSYSTEMVALUES_DYNAMODB,
    TMP_DBSYSTEMVALUES_NEO4J,
    TMP_DBSYSTEMVALUES_GEODE,
    TMP_DBSYSTEMVALUES_ELASTICSEARCH,
    TMP_DBSYSTEMVALUES_MEMCACHED,
    TMP_DBSYSTEMVALUES_COCKROACHDB
  ]);
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
  exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
  ]);
  var TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
  var TMP_FAASTRIGGERVALUES_HTTP = "http";
  var TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
  var TMP_FAASTRIGGERVALUES_TIMER = "timer";
  var TMP_FAASTRIGGERVALUES_OTHER = "other";
  exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
  exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
  exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
  exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
  exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
  exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASTRIGGERVALUES_DATASOURCE,
    TMP_FAASTRIGGERVALUES_HTTP,
    TMP_FAASTRIGGERVALUES_PUBSUB,
    TMP_FAASTRIGGERVALUES_TIMER,
    TMP_FAASTRIGGERVALUES_OTHER
  ]);
  var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
  var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
  var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
  exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
  exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
  exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
  exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
  ]);
  var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
  var TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
  var TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
  exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
  exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
  exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_FAASINVOKEDPROVIDERVALUES_AWS,
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
    TMP_FAASINVOKEDPROVIDERVALUES_GCP
  ]);
  var TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
  var TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
  var TMP_NETTRANSPORTVALUES_IP = "ip";
  var TMP_NETTRANSPORTVALUES_UNIX = "unix";
  var TMP_NETTRANSPORTVALUES_PIPE = "pipe";
  var TMP_NETTRANSPORTVALUES_INPROC = "inproc";
  var TMP_NETTRANSPORTVALUES_OTHER = "other";
  exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
  exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
  exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
  exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
  exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
  exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
  exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
  exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETTRANSPORTVALUES_IP_TCP,
    TMP_NETTRANSPORTVALUES_IP_UDP,
    TMP_NETTRANSPORTVALUES_IP,
    TMP_NETTRANSPORTVALUES_UNIX,
    TMP_NETTRANSPORTVALUES_PIPE,
    TMP_NETTRANSPORTVALUES_INPROC,
    TMP_NETTRANSPORTVALUES_OTHER
  ]);
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
  exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
  exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
  exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
  exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
  ]);
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
  exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
  ]);
  var TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
  var TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
  var TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
  var TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
  var TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
  exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
  exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
  exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
  exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
  exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
  exports.HttpFlavorValues = {
    HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
    HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
    HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
    SPDY: TMP_HTTPFLAVORVALUES_SPDY,
    QUIC: TMP_HTTPFLAVORVALUES_QUIC
  };
  var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
  var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
  exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
  exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
  exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
  ]);
  var TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
  var TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
  exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
  exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
    TMP_MESSAGINGOPERATIONVALUES_PROCESS
  ]);
  var TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
  var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
  var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
  var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
  var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
  var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
  var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
  var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
  var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
  var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
  var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
  var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
  var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
  exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
  exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
  exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
  exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
  exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
  exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
  exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
  exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
  exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
  exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
  exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
  exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
  exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
  exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
  exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
  exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
  exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
  exports.RpcGrpcStatusCodeValues = {
    OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
    CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
    UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
    INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
    DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
    NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
    ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
    PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
    RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
    FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
    ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
    OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
    UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
    INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
    UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
    DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
    UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
  };
  var TMP_MESSAGETYPEVALUES_SENT = "SENT";
  var TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
  exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
  exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
  exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGETYPEVALUES_SENT,
    TMP_MESSAGETYPEVALUES_RECEIVED
  ]);
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_SemanticAttributes(), exports);
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = undefined;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = undefined;
  exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = undefined;
  var utils_1 = require_utils4();
  var TMP_CLOUD_PROVIDER = "cloud.provider";
  var TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
  var TMP_CLOUD_REGION = "cloud.region";
  var TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
  var TMP_CLOUD_PLATFORM = "cloud.platform";
  var TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
  var TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
  var TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
  var TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
  var TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
  var TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
  var TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
  var TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
  var TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
  var TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
  var TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
  var TMP_CONTAINER_NAME = "container.name";
  var TMP_CONTAINER_ID = "container.id";
  var TMP_CONTAINER_RUNTIME = "container.runtime";
  var TMP_CONTAINER_IMAGE_NAME = "container.image.name";
  var TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
  var TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
  var TMP_DEVICE_ID = "device.id";
  var TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
  var TMP_DEVICE_MODEL_NAME = "device.model.name";
  var TMP_FAAS_NAME = "faas.name";
  var TMP_FAAS_ID = "faas.id";
  var TMP_FAAS_VERSION = "faas.version";
  var TMP_FAAS_INSTANCE = "faas.instance";
  var TMP_FAAS_MAX_MEMORY = "faas.max_memory";
  var TMP_HOST_ID = "host.id";
  var TMP_HOST_NAME = "host.name";
  var TMP_HOST_TYPE = "host.type";
  var TMP_HOST_ARCH = "host.arch";
  var TMP_HOST_IMAGE_NAME = "host.image.name";
  var TMP_HOST_IMAGE_ID = "host.image.id";
  var TMP_HOST_IMAGE_VERSION = "host.image.version";
  var TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
  var TMP_K8S_NODE_NAME = "k8s.node.name";
  var TMP_K8S_NODE_UID = "k8s.node.uid";
  var TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
  var TMP_K8S_POD_UID = "k8s.pod.uid";
  var TMP_K8S_POD_NAME = "k8s.pod.name";
  var TMP_K8S_CONTAINER_NAME = "k8s.container.name";
  var TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
  var TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
  var TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
  var TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
  var TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
  var TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
  var TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
  var TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
  var TMP_K8S_JOB_UID = "k8s.job.uid";
  var TMP_K8S_JOB_NAME = "k8s.job.name";
  var TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
  var TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
  var TMP_OS_TYPE = "os.type";
  var TMP_OS_DESCRIPTION = "os.description";
  var TMP_OS_NAME = "os.name";
  var TMP_OS_VERSION = "os.version";
  var TMP_PROCESS_PID = "process.pid";
  var TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
  var TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
  var TMP_PROCESS_COMMAND = "process.command";
  var TMP_PROCESS_COMMAND_LINE = "process.command_line";
  var TMP_PROCESS_COMMAND_ARGS = "process.command_args";
  var TMP_PROCESS_OWNER = "process.owner";
  var TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
  var TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
  var TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
  var TMP_SERVICE_NAME = "service.name";
  var TMP_SERVICE_NAMESPACE = "service.namespace";
  var TMP_SERVICE_INSTANCE_ID = "service.instance.id";
  var TMP_SERVICE_VERSION = "service.version";
  var TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  var TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  var TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  var TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
  var TMP_WEBENGINE_NAME = "webengine.name";
  var TMP_WEBENGINE_VERSION = "webengine.version";
  var TMP_WEBENGINE_DESCRIPTION = "webengine.description";
  exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
  exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
  exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
  exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
  exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
  exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
  exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
  exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
  exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
  exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
  exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
  exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
  exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
  exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
  exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
  exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
  exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
  exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
  exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
  exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
  exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
  exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
  exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
  exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
  exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
  exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
  exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID;
  exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
  exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
  exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
  exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
  exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
  exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
  exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
  exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
  exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
  exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
  exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
  exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
  exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
  exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
  exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
  exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
  exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
  exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
  exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
  exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
  exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
  exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
  exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
  exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
  exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME;
  exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
  exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
  exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
  exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
  exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
  exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
  exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
  exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
  exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
  exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
  exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
  exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
  exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
  exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
  exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
  exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
  exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
  exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
  exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
  exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
  exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUD_PROVIDER,
    TMP_CLOUD_ACCOUNT_ID,
    TMP_CLOUD_REGION,
    TMP_CLOUD_AVAILABILITY_ZONE,
    TMP_CLOUD_PLATFORM,
    TMP_AWS_ECS_CONTAINER_ARN,
    TMP_AWS_ECS_CLUSTER_ARN,
    TMP_AWS_ECS_LAUNCHTYPE,
    TMP_AWS_ECS_TASK_ARN,
    TMP_AWS_ECS_TASK_FAMILY,
    TMP_AWS_ECS_TASK_REVISION,
    TMP_AWS_EKS_CLUSTER_ARN,
    TMP_AWS_LOG_GROUP_NAMES,
    TMP_AWS_LOG_GROUP_ARNS,
    TMP_AWS_LOG_STREAM_NAMES,
    TMP_AWS_LOG_STREAM_ARNS,
    TMP_CONTAINER_NAME,
    TMP_CONTAINER_ID,
    TMP_CONTAINER_RUNTIME,
    TMP_CONTAINER_IMAGE_NAME,
    TMP_CONTAINER_IMAGE_TAG,
    TMP_DEPLOYMENT_ENVIRONMENT,
    TMP_DEVICE_ID,
    TMP_DEVICE_MODEL_IDENTIFIER,
    TMP_DEVICE_MODEL_NAME,
    TMP_FAAS_NAME,
    TMP_FAAS_ID,
    TMP_FAAS_VERSION,
    TMP_FAAS_INSTANCE,
    TMP_FAAS_MAX_MEMORY,
    TMP_HOST_ID,
    TMP_HOST_NAME,
    TMP_HOST_TYPE,
    TMP_HOST_ARCH,
    TMP_HOST_IMAGE_NAME,
    TMP_HOST_IMAGE_ID,
    TMP_HOST_IMAGE_VERSION,
    TMP_K8S_CLUSTER_NAME,
    TMP_K8S_NODE_NAME,
    TMP_K8S_NODE_UID,
    TMP_K8S_NAMESPACE_NAME,
    TMP_K8S_POD_UID,
    TMP_K8S_POD_NAME,
    TMP_K8S_CONTAINER_NAME,
    TMP_K8S_REPLICASET_UID,
    TMP_K8S_REPLICASET_NAME,
    TMP_K8S_DEPLOYMENT_UID,
    TMP_K8S_DEPLOYMENT_NAME,
    TMP_K8S_STATEFULSET_UID,
    TMP_K8S_STATEFULSET_NAME,
    TMP_K8S_DAEMONSET_UID,
    TMP_K8S_DAEMONSET_NAME,
    TMP_K8S_JOB_UID,
    TMP_K8S_JOB_NAME,
    TMP_K8S_CRONJOB_UID,
    TMP_K8S_CRONJOB_NAME,
    TMP_OS_TYPE,
    TMP_OS_DESCRIPTION,
    TMP_OS_NAME,
    TMP_OS_VERSION,
    TMP_PROCESS_PID,
    TMP_PROCESS_EXECUTABLE_NAME,
    TMP_PROCESS_EXECUTABLE_PATH,
    TMP_PROCESS_COMMAND,
    TMP_PROCESS_COMMAND_LINE,
    TMP_PROCESS_COMMAND_ARGS,
    TMP_PROCESS_OWNER,
    TMP_PROCESS_RUNTIME_NAME,
    TMP_PROCESS_RUNTIME_VERSION,
    TMP_PROCESS_RUNTIME_DESCRIPTION,
    TMP_SERVICE_NAME,
    TMP_SERVICE_NAMESPACE,
    TMP_SERVICE_INSTANCE_ID,
    TMP_SERVICE_VERSION,
    TMP_TELEMETRY_SDK_NAME,
    TMP_TELEMETRY_SDK_LANGUAGE,
    TMP_TELEMETRY_SDK_VERSION,
    TMP_TELEMETRY_AUTO_VERSION,
    TMP_WEBENGINE_NAME,
    TMP_WEBENGINE_VERSION,
    TMP_WEBENGINE_DESCRIPTION
  ]);
  var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_CLOUDPROVIDERVALUES_AWS = "aws";
  var TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
  var TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
  exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
  exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
  exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
  exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_CLOUDPROVIDERVALUES_AWS,
    TMP_CLOUDPROVIDERVALUES_AZURE,
    TMP_CLOUDPROVIDERVALUES_GCP
  ]);
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
  var TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
  var TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
  var TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
  var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
  var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
  var TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
  var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
  var TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
  var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
  var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
  var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
  var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
  var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
  exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
  exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
  exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
  exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
  exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
  exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
  exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
  exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
  exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
  exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
  exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
    TMP_CLOUDPLATFORMVALUES_AWS_EC2,
    TMP_CLOUDPLATFORMVALUES_AWS_ECS,
    TMP_CLOUDPLATFORMVALUES_AWS_EKS,
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
    TMP_CLOUDPLATFORMVALUES_AZURE_VM,
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
  ]);
  var TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
  var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
  exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
  exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
  exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWSECSLAUNCHTYPEVALUES_EC2,
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
  ]);
  var TMP_HOSTARCHVALUES_AMD64 = "amd64";
  var TMP_HOSTARCHVALUES_ARM32 = "arm32";
  var TMP_HOSTARCHVALUES_ARM64 = "arm64";
  var TMP_HOSTARCHVALUES_IA64 = "ia64";
  var TMP_HOSTARCHVALUES_PPC32 = "ppc32";
  var TMP_HOSTARCHVALUES_PPC64 = "ppc64";
  var TMP_HOSTARCHVALUES_X86 = "x86";
  exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
  exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
  exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
  exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
  exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
  exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
  exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
  exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_HOSTARCHVALUES_AMD64,
    TMP_HOSTARCHVALUES_ARM32,
    TMP_HOSTARCHVALUES_ARM64,
    TMP_HOSTARCHVALUES_IA64,
    TMP_HOSTARCHVALUES_PPC32,
    TMP_HOSTARCHVALUES_PPC64,
    TMP_HOSTARCHVALUES_X86
  ]);
  var TMP_OSTYPEVALUES_WINDOWS = "windows";
  var TMP_OSTYPEVALUES_LINUX = "linux";
  var TMP_OSTYPEVALUES_DARWIN = "darwin";
  var TMP_OSTYPEVALUES_FREEBSD = "freebsd";
  var TMP_OSTYPEVALUES_NETBSD = "netbsd";
  var TMP_OSTYPEVALUES_OPENBSD = "openbsd";
  var TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
  var TMP_OSTYPEVALUES_HPUX = "hpux";
  var TMP_OSTYPEVALUES_AIX = "aix";
  var TMP_OSTYPEVALUES_SOLARIS = "solaris";
  var TMP_OSTYPEVALUES_Z_OS = "z_os";
  exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
  exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
  exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
  exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
  exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
  exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
  exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
  exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
  exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
  exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
  exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
  exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_OSTYPEVALUES_WINDOWS,
    TMP_OSTYPEVALUES_LINUX,
    TMP_OSTYPEVALUES_DARWIN,
    TMP_OSTYPEVALUES_FREEBSD,
    TMP_OSTYPEVALUES_NETBSD,
    TMP_OSTYPEVALUES_OPENBSD,
    TMP_OSTYPEVALUES_DRAGONFLYBSD,
    TMP_OSTYPEVALUES_HPUX,
    TMP_OSTYPEVALUES_AIX,
    TMP_OSTYPEVALUES_SOLARIS,
    TMP_OSTYPEVALUES_Z_OS
  ]);
  var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
  exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
  exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
  exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
  exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
  exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
  exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
  exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
  exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
  exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
  exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
  exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
  ]);
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_SemanticResourceAttributes(), exports);
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/stable_attributes.js
var require_stable_attributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ATTR_EXCEPTION_TYPE = exports.ATTR_EXCEPTION_STACKTRACE = exports.ATTR_EXCEPTION_MESSAGE = exports.ATTR_EXCEPTION_ESCAPED = exports.ERROR_TYPE_VALUE_OTHER = exports.ATTR_ERROR_TYPE = exports.DOTNET_GC_HEAP_GENERATION_VALUE_POH = exports.DOTNET_GC_HEAP_GENERATION_VALUE_LOH = exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = exports.ATTR_DOTNET_GC_HEAP_GENERATION = exports.DB_SYSTEM_NAME_VALUE_POSTGRESQL = exports.DB_SYSTEM_NAME_VALUE_MYSQL = exports.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER = exports.DB_SYSTEM_NAME_VALUE_MARIADB = exports.ATTR_DB_SYSTEM_NAME = exports.ATTR_DB_STORED_PROCEDURE_NAME = exports.ATTR_DB_RESPONSE_STATUS_CODE = exports.ATTR_DB_QUERY_TEXT = exports.ATTR_DB_QUERY_SUMMARY = exports.ATTR_DB_OPERATION_NAME = exports.ATTR_DB_OPERATION_BATCH_SIZE = exports.ATTR_DB_NAMESPACE = exports.ATTR_DB_COLLECTION_NAME = exports.ATTR_CODE_STACKTRACE = exports.ATTR_CODE_LINE_NUMBER = exports.ATTR_CODE_FUNCTION_NAME = exports.ATTR_CODE_FILE_PATH = exports.ATTR_CODE_COLUMN_NUMBER = exports.ATTR_CLIENT_PORT = exports.ATTR_CLIENT_ADDRESS = exports.ATTR_ASPNETCORE_USER_IS_AUTHENTICATED = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = undefined;
  exports.OTEL_STATUS_CODE_VALUE_ERROR = exports.ATTR_OTEL_STATUS_CODE = exports.ATTR_OTEL_SCOPE_VERSION = exports.ATTR_OTEL_SCOPE_NAME = exports.NETWORK_TYPE_VALUE_IPV6 = exports.NETWORK_TYPE_VALUE_IPV4 = exports.ATTR_NETWORK_TYPE = exports.NETWORK_TRANSPORT_VALUE_UNIX = exports.NETWORK_TRANSPORT_VALUE_UDP = exports.NETWORK_TRANSPORT_VALUE_TCP = exports.NETWORK_TRANSPORT_VALUE_QUIC = exports.NETWORK_TRANSPORT_VALUE_PIPE = exports.ATTR_NETWORK_TRANSPORT = exports.ATTR_NETWORK_PROTOCOL_VERSION = exports.ATTR_NETWORK_PROTOCOL_NAME = exports.ATTR_NETWORK_PEER_PORT = exports.ATTR_NETWORK_PEER_ADDRESS = exports.ATTR_NETWORK_LOCAL_PORT = exports.ATTR_NETWORK_LOCAL_ADDRESS = exports.JVM_THREAD_STATE_VALUE_WAITING = exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = exports.JVM_THREAD_STATE_VALUE_TERMINATED = exports.JVM_THREAD_STATE_VALUE_RUNNABLE = exports.JVM_THREAD_STATE_VALUE_NEW = exports.JVM_THREAD_STATE_VALUE_BLOCKED = exports.ATTR_JVM_THREAD_STATE = exports.ATTR_JVM_THREAD_DAEMON = exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = exports.JVM_MEMORY_TYPE_VALUE_HEAP = exports.ATTR_JVM_MEMORY_TYPE = exports.ATTR_JVM_MEMORY_POOL_NAME = exports.ATTR_JVM_GC_NAME = exports.ATTR_JVM_GC_ACTION = exports.ATTR_HTTP_ROUTE = exports.ATTR_HTTP_RESPONSE_STATUS_CODE = exports.ATTR_HTTP_RESPONSE_HEADER = exports.ATTR_HTTP_REQUEST_RESEND_COUNT = exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = exports.HTTP_REQUEST_METHOD_VALUE_TRACE = exports.HTTP_REQUEST_METHOD_VALUE_PUT = exports.HTTP_REQUEST_METHOD_VALUE_POST = exports.HTTP_REQUEST_METHOD_VALUE_PATCH = exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = exports.HTTP_REQUEST_METHOD_VALUE_HEAD = exports.HTTP_REQUEST_METHOD_VALUE_GET = exports.HTTP_REQUEST_METHOD_VALUE_DELETE = exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = exports.HTTP_REQUEST_METHOD_VALUE_OTHER = exports.ATTR_HTTP_REQUEST_METHOD = exports.ATTR_HTTP_REQUEST_HEADER = undefined;
  exports.ATTR_USER_AGENT_ORIGINAL = exports.ATTR_URL_SCHEME = exports.ATTR_URL_QUERY = exports.ATTR_URL_PATH = exports.ATTR_URL_FULL = exports.ATTR_URL_FRAGMENT = exports.ATTR_TELEMETRY_SDK_VERSION = exports.ATTR_TELEMETRY_SDK_NAME = exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = exports.ATTR_TELEMETRY_SDK_LANGUAGE = exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = exports.ATTR_SIGNALR_TRANSPORT = exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = exports.ATTR_SIGNALR_CONNECTION_STATUS = exports.ATTR_SERVICE_VERSION = exports.ATTR_SERVICE_NAME = exports.ATTR_SERVER_PORT = exports.ATTR_SERVER_ADDRESS = exports.ATTR_OTEL_STATUS_DESCRIPTION = exports.OTEL_STATUS_CODE_VALUE_OK = undefined;
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
  exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
  exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
  exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
  exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
  exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
  exports.ATTR_ASPNETCORE_USER_IS_AUTHENTICATED = "aspnetcore.user.is_authenticated";
  exports.ATTR_CLIENT_ADDRESS = "client.address";
  exports.ATTR_CLIENT_PORT = "client.port";
  exports.ATTR_CODE_COLUMN_NUMBER = "code.column.number";
  exports.ATTR_CODE_FILE_PATH = "code.file.path";
  exports.ATTR_CODE_FUNCTION_NAME = "code.function.name";
  exports.ATTR_CODE_LINE_NUMBER = "code.line.number";
  exports.ATTR_CODE_STACKTRACE = "code.stacktrace";
  exports.ATTR_DB_COLLECTION_NAME = "db.collection.name";
  exports.ATTR_DB_NAMESPACE = "db.namespace";
  exports.ATTR_DB_OPERATION_BATCH_SIZE = "db.operation.batch.size";
  exports.ATTR_DB_OPERATION_NAME = "db.operation.name";
  exports.ATTR_DB_QUERY_SUMMARY = "db.query.summary";
  exports.ATTR_DB_QUERY_TEXT = "db.query.text";
  exports.ATTR_DB_RESPONSE_STATUS_CODE = "db.response.status_code";
  exports.ATTR_DB_STORED_PROCEDURE_NAME = "db.stored_procedure.name";
  exports.ATTR_DB_SYSTEM_NAME = "db.system.name";
  exports.DB_SYSTEM_NAME_VALUE_MARIADB = "mariadb";
  exports.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER = "microsoft.sql_server";
  exports.DB_SYSTEM_NAME_VALUE_MYSQL = "mysql";
  exports.DB_SYSTEM_NAME_VALUE_POSTGRESQL = "postgresql";
  exports.ATTR_DOTNET_GC_HEAP_GENERATION = "dotnet.gc.heap.generation";
  exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = "gen0";
  exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = "gen1";
  exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = "gen2";
  exports.DOTNET_GC_HEAP_GENERATION_VALUE_LOH = "loh";
  exports.DOTNET_GC_HEAP_GENERATION_VALUE_POH = "poh";
  exports.ATTR_ERROR_TYPE = "error.type";
  exports.ERROR_TYPE_VALUE_OTHER = "_OTHER";
  exports.ATTR_EXCEPTION_ESCAPED = "exception.escaped";
  exports.ATTR_EXCEPTION_MESSAGE = "exception.message";
  exports.ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
  exports.ATTR_EXCEPTION_TYPE = "exception.type";
  var ATTR_HTTP_REQUEST_HEADER = (key) => `http.request.header.${key}`;
  exports.ATTR_HTTP_REQUEST_HEADER = ATTR_HTTP_REQUEST_HEADER;
  exports.ATTR_HTTP_REQUEST_METHOD = "http.request.method";
  exports.HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
  exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
  exports.HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
  exports.HTTP_REQUEST_METHOD_VALUE_GET = "GET";
  exports.HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
  exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
  exports.HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
  exports.HTTP_REQUEST_METHOD_VALUE_POST = "POST";
  exports.HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
  exports.HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
  exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
  exports.ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
  var ATTR_HTTP_RESPONSE_HEADER = (key) => `http.response.header.${key}`;
  exports.ATTR_HTTP_RESPONSE_HEADER = ATTR_HTTP_RESPONSE_HEADER;
  exports.ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
  exports.ATTR_HTTP_ROUTE = "http.route";
  exports.ATTR_JVM_GC_ACTION = "jvm.gc.action";
  exports.ATTR_JVM_GC_NAME = "jvm.gc.name";
  exports.ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
  exports.ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
  exports.JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
  exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
  exports.ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
  exports.ATTR_JVM_THREAD_STATE = "jvm.thread.state";
  exports.JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
  exports.JVM_THREAD_STATE_VALUE_NEW = "new";
  exports.JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
  exports.JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
  exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
  exports.JVM_THREAD_STATE_VALUE_WAITING = "waiting";
  exports.ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
  exports.ATTR_NETWORK_LOCAL_PORT = "network.local.port";
  exports.ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
  exports.ATTR_NETWORK_PEER_PORT = "network.peer.port";
  exports.ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
  exports.ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
  exports.ATTR_NETWORK_TRANSPORT = "network.transport";
  exports.NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
  exports.NETWORK_TRANSPORT_VALUE_QUIC = "quic";
  exports.NETWORK_TRANSPORT_VALUE_TCP = "tcp";
  exports.NETWORK_TRANSPORT_VALUE_UDP = "udp";
  exports.NETWORK_TRANSPORT_VALUE_UNIX = "unix";
  exports.ATTR_NETWORK_TYPE = "network.type";
  exports.NETWORK_TYPE_VALUE_IPV4 = "ipv4";
  exports.NETWORK_TYPE_VALUE_IPV6 = "ipv6";
  exports.ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
  exports.ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
  exports.ATTR_OTEL_STATUS_CODE = "otel.status_code";
  exports.OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
  exports.OTEL_STATUS_CODE_VALUE_OK = "OK";
  exports.ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
  exports.ATTR_SERVER_ADDRESS = "server.address";
  exports.ATTR_SERVER_PORT = "server.port";
  exports.ATTR_SERVICE_NAME = "service.name";
  exports.ATTR_SERVICE_VERSION = "service.version";
  exports.ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
  exports.ATTR_SIGNALR_TRANSPORT = "signalr.transport";
  exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
  exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
  exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
  exports.ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
  exports.ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  exports.ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  exports.ATTR_URL_FRAGMENT = "url.fragment";
  exports.ATTR_URL_FULL = "url.full";
  exports.ATTR_URL_PATH = "url.path";
  exports.ATTR_URL_QUERY = "url.query";
  exports.ATTR_URL_SCHEME = "url.scheme";
  exports.ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/stable_metrics.js
var require_stable_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = exports.METRIC_KESTREL_REJECTED_CONNECTIONS = exports.METRIC_KESTREL_QUEUED_REQUESTS = exports.METRIC_KESTREL_QUEUED_CONNECTIONS = exports.METRIC_KESTREL_CONNECTION_DURATION = exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = exports.METRIC_JVM_THREAD_COUNT = exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = exports.METRIC_JVM_MEMORY_USED = exports.METRIC_JVM_MEMORY_LIMIT = exports.METRIC_JVM_MEMORY_COMMITTED = exports.METRIC_JVM_GC_DURATION = exports.METRIC_JVM_CPU_TIME = exports.METRIC_JVM_CPU_RECENT_UTILIZATION = exports.METRIC_JVM_CPU_COUNT = exports.METRIC_JVM_CLASS_UNLOADED = exports.METRIC_JVM_CLASS_LOADED = exports.METRIC_JVM_CLASS_COUNT = exports.METRIC_HTTP_SERVER_REQUEST_DURATION = exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = exports.METRIC_DOTNET_TIMER_COUNT = exports.METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT = exports.METRIC_DOTNET_THREAD_POOL_THREAD_COUNT = exports.METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH = exports.METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET = exports.METRIC_DOTNET_PROCESS_CPU_TIME = exports.METRIC_DOTNET_PROCESS_CPU_COUNT = exports.METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS = exports.METRIC_DOTNET_JIT_COMPILED_METHODS = exports.METRIC_DOTNET_JIT_COMPILED_IL_SIZE = exports.METRIC_DOTNET_JIT_COMPILATION_TIME = exports.METRIC_DOTNET_GC_PAUSE_TIME = exports.METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE = exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE = exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE = exports.METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED = exports.METRIC_DOTNET_GC_COLLECTIONS = exports.METRIC_DOTNET_EXCEPTIONS = exports.METRIC_DOTNET_ASSEMBLY_COUNT = exports.METRIC_DB_CLIENT_OPERATION_DURATION = exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = undefined;
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = undefined;
  exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
  exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
  exports.METRIC_DB_CLIENT_OPERATION_DURATION = "db.client.operation.duration";
  exports.METRIC_DOTNET_ASSEMBLY_COUNT = "dotnet.assembly.count";
  exports.METRIC_DOTNET_EXCEPTIONS = "dotnet.exceptions";
  exports.METRIC_DOTNET_GC_COLLECTIONS = "dotnet.gc.collections";
  exports.METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED = "dotnet.gc.heap.total_allocated";
  exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE = "dotnet.gc.last_collection.heap.fragmentation.size";
  exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE = "dotnet.gc.last_collection.heap.size";
  exports.METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE = "dotnet.gc.last_collection.memory.committed_size";
  exports.METRIC_DOTNET_GC_PAUSE_TIME = "dotnet.gc.pause.time";
  exports.METRIC_DOTNET_JIT_COMPILATION_TIME = "dotnet.jit.compilation.time";
  exports.METRIC_DOTNET_JIT_COMPILED_IL_SIZE = "dotnet.jit.compiled_il.size";
  exports.METRIC_DOTNET_JIT_COMPILED_METHODS = "dotnet.jit.compiled_methods";
  exports.METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS = "dotnet.monitor.lock_contentions";
  exports.METRIC_DOTNET_PROCESS_CPU_COUNT = "dotnet.process.cpu.count";
  exports.METRIC_DOTNET_PROCESS_CPU_TIME = "dotnet.process.cpu.time";
  exports.METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET = "dotnet.process.memory.working_set";
  exports.METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH = "dotnet.thread_pool.queue.length";
  exports.METRIC_DOTNET_THREAD_POOL_THREAD_COUNT = "dotnet.thread_pool.thread.count";
  exports.METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT = "dotnet.thread_pool.work_item.count";
  exports.METRIC_DOTNET_TIMER_COUNT = "dotnet.timer.count";
  exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
  exports.METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
  exports.METRIC_JVM_CLASS_COUNT = "jvm.class.count";
  exports.METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
  exports.METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
  exports.METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
  exports.METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
  exports.METRIC_JVM_CPU_TIME = "jvm.cpu.time";
  exports.METRIC_JVM_GC_DURATION = "jvm.gc.duration";
  exports.METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
  exports.METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
  exports.METRIC_JVM_MEMORY_USED = "jvm.memory.used";
  exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
  exports.METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
  exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
  exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
  exports.METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
  exports.METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
  exports.METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
  exports.METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
  exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
  exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
  exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/stable_events.js
var require_stable_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EVENT_EXCEPTION = undefined;
  exports.EVENT_EXCEPTION = "exception";
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_trace2(), exports);
  __exportStar(require_resource(), exports);
  __exportStar(require_stable_attributes(), exports);
  __exportStar(require_stable_metrics(), exports);
  __exportStar(require_stable_events(), exports);
});

// ../../node_modules/@opentelemetry/core/build/src/semconv.js
var require_semconv = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ATTR_PROCESS_RUNTIME_NAME = undefined;
  exports.ATTR_PROCESS_RUNTIME_NAME = "process.runtime.name";
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SDK_INFO = undefined;
  var version_1 = require_version2();
  var semantic_conventions_1 = require_src2();
  var semconv_1 = require_semconv();
  exports.SDK_INFO = {
    [semantic_conventions_1.ATTR_TELEMETRY_SDK_NAME]: "opentelemetry",
    [semconv_1.ATTR_PROCESS_RUNTIME_NAME]: "node",
    [semantic_conventions_1.ATTR_TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
    [semantic_conventions_1.ATTR_TELEMETRY_SDK_VERSION]: version_1.VERSION
  };
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unrefTimer = undefined;
  function unrefTimer(timer) {
    timer.unref();
  }
  exports.unrefTimer = unrefTimer;
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unrefTimer = exports.SDK_INFO = exports.otperformance = exports._globalThis = exports.getStringListFromEnv = exports.getNumberFromEnv = exports.getBooleanFromEnv = exports.getStringFromEnv = undefined;
  var environment_1 = require_environment();
  Object.defineProperty(exports, "getStringFromEnv", { enumerable: true, get: function() {
    return environment_1.getStringFromEnv;
  } });
  Object.defineProperty(exports, "getBooleanFromEnv", { enumerable: true, get: function() {
    return environment_1.getBooleanFromEnv;
  } });
  Object.defineProperty(exports, "getNumberFromEnv", { enumerable: true, get: function() {
    return environment_1.getNumberFromEnv;
  } });
  Object.defineProperty(exports, "getStringListFromEnv", { enumerable: true, get: function() {
    return environment_1.getStringListFromEnv;
  } });
  var globalThis_1 = require_globalThis2();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return globalThis_1._globalThis;
  } });
  var performance_1 = require_performance();
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return performance_1.otperformance;
  } });
  var sdk_info_1 = require_sdk_info();
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return sdk_info_1.SDK_INFO;
  } });
  var timer_util_1 = require_timer_util();
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return timer_util_1.unrefTimer;
  } });
});

// ../../node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStringListFromEnv = exports.getNumberFromEnv = exports.getStringFromEnv = exports.getBooleanFromEnv = exports.unrefTimer = exports.otperformance = exports._globalThis = exports.SDK_INFO = undefined;
  var node_1 = require_node2();
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return node_1.SDK_INFO;
  } });
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return node_1._globalThis;
  } });
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return node_1.otperformance;
  } });
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return node_1.unrefTimer;
  } });
  Object.defineProperty(exports, "getBooleanFromEnv", { enumerable: true, get: function() {
    return node_1.getBooleanFromEnv;
  } });
  Object.defineProperty(exports, "getStringFromEnv", { enumerable: true, get: function() {
    return node_1.getStringFromEnv;
  } });
  Object.defineProperty(exports, "getNumberFromEnv", { enumerable: true, get: function() {
    return node_1.getNumberFromEnv;
  } });
  Object.defineProperty(exports, "getStringListFromEnv", { enumerable: true, get: function() {
    return node_1.getStringListFromEnv;
  } });
});

// ../../node_modules/@opentelemetry/core/build/src/common/time.js
var require_time = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = undefined;
  var platform_1 = require_platform2();
  var NANOSECOND_DIGITS = 9;
  var NANOSECOND_DIGITS_IN_MILLIS = 6;
  var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
  var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
  function millisToHrTime(epochMillis) {
    const epochSeconds = epochMillis / 1000;
    const seconds = Math.trunc(epochSeconds);
    const nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
    return [seconds, nanos];
  }
  exports.millisToHrTime = millisToHrTime;
  function getTimeOrigin() {
    let timeOrigin = platform_1.otperformance.timeOrigin;
    if (typeof timeOrigin !== "number") {
      const perf = platform_1.otperformance;
      timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
  }
  exports.getTimeOrigin = getTimeOrigin;
  function hrTime(performanceNow) {
    const timeOrigin = millisToHrTime(getTimeOrigin());
    const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
    return addHrTimes(timeOrigin, now);
  }
  exports.hrTime = hrTime;
  function timeInputToHrTime(time) {
    if (isTimeInputHrTime(time)) {
      return time;
    } else if (typeof time === "number") {
      if (time < getTimeOrigin()) {
        return hrTime(time);
      } else {
        return millisToHrTime(time);
      }
    } else if (time instanceof Date) {
      return millisToHrTime(time.getTime());
    } else {
      throw TypeError("Invalid input type");
    }
  }
  exports.timeInputToHrTime = timeInputToHrTime;
  function hrTimeDuration(startTime, endTime) {
    let seconds = endTime[0] - startTime[0];
    let nanos = endTime[1] - startTime[1];
    if (nanos < 0) {
      seconds -= 1;
      nanos += SECOND_TO_NANOSECONDS;
    }
    return [seconds, nanos];
  }
  exports.hrTimeDuration = hrTimeDuration;
  function hrTimeToTimeStamp(time) {
    const precision = NANOSECOND_DIGITS;
    const tmp = `${"0".repeat(precision)}${time[1]}Z`;
    const nanoString = tmp.substring(tmp.length - precision - 1);
    const date = new Date(time[0] * 1000).toISOString();
    return date.replace("000Z", nanoString);
  }
  exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
  function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
  }
  exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
  function hrTimeToMilliseconds(time) {
    return time[0] * 1000 + time[1] / 1e6;
  }
  exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
  function hrTimeToMicroseconds(time) {
    return time[0] * 1e6 + time[1] / 1000;
  }
  exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
  function isTimeInputHrTime(value) {
    return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
  }
  exports.isTimeInputHrTime = isTimeInputHrTime;
  function isTimeInput(value) {
    return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
  }
  exports.isTimeInput = isTimeInput;
  function addHrTimes(time1, time2) {
    const out = [time1[0] + time2[0], time1[1] + time2[1]];
    if (out[1] >= SECOND_TO_NANOSECONDS) {
      out[1] -= SECOND_TO_NANOSECONDS;
      out[0] += 1;
    }
    return out;
  }
  exports.addHrTimes = addHrTimes;
});

// ../../node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExportResultCode = undefined;
  var ExportResultCode;
  (function(ExportResultCode2) {
    ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
  })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
});

// ../../node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CompositePropagator = undefined;
  var api_1 = require_src();

  class CompositePropagator {
    _propagators;
    _fields;
    constructor(config = {}) {
      this._propagators = config.propagators ?? [];
      this._fields = Array.from(new Set(this._propagators.map((p) => typeof p.fields === "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
    }
    inject(context, carrier, setter) {
      for (const propagator of this._propagators) {
        try {
          propagator.inject(context, carrier, setter);
        } catch (err) {
          api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
        }
      }
    }
    extract(context, carrier, getter) {
      return this._propagators.reduce((ctx, propagator) => {
        try {
          return propagator.extract(ctx, carrier, getter);
        } catch (err) {
          api_1.diag.warn(`Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`);
        }
        return ctx;
      }, context);
    }
    fields() {
      return this._fields.slice();
    }
  }
  exports.CompositePropagator = CompositePropagator;
});

// ../../node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  exports.validateValue = validateValue;
});

// ../../node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceState = undefined;
  var validators_1 = require_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceState {
    _internalState = new Map;
    constructor(rawTraceState) {
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value = listMember.slice(i + 1, part.length);
          if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
            agg.set(key, value);
          } else {}
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceState;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceState = TraceState;
});

// ../../node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  var TraceState_1 = require_TraceState();
  exports.TRACE_PARENT_HEADER = "traceparent";
  exports.TRACE_STATE_HEADER = "tracestate";
  var VERSION = "00";
  var VERSION_PART = "(?!ff)[\\da-f]{2}";
  var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
  var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
  var FLAGS_PART = "[\\da-f]{2}";
  var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
  function parseTraceParent(traceParent) {
    const match2 = TRACE_PARENT_REGEX.exec(traceParent);
    if (!match2)
      return null;
    if (match2[1] === "00" && match2[5])
      return null;
    return {
      traceId: match2[2],
      spanId: match2[3],
      traceFlags: parseInt(match2[4], 16)
    };
  }
  exports.parseTraceParent = parseTraceParent;

  class W3CTraceContextPropagator {
    inject(context, carrier, setter) {
      const spanContext = api_1.trace.getSpanContext(context);
      if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context) || !(0, api_1.isSpanContextValid)(spanContext))
        return;
      const traceParent = `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
      setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
      if (spanContext.traceState) {
        setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
      }
    }
    extract(context, carrier, getter) {
      const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
      if (!traceParentHeader)
        return context;
      const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
      if (typeof traceParent !== "string")
        return context;
      const spanContext = parseTraceParent(traceParent);
      if (!spanContext)
        return context;
      spanContext.isRemote = true;
      const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
      if (traceStateHeader) {
        const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
        spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : undefined);
      }
      return api_1.trace.setSpanContext(context, spanContext);
    }
    fields() {
      return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
    }
  }
  exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
});

// ../../node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = undefined;
  var api_1 = require_src();
  var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
  var RPCType;
  (function(RPCType2) {
    RPCType2["HTTP"] = "http";
  })(RPCType = exports.RPCType || (exports.RPCType = {}));
  function setRPCMetadata(context, meta) {
    return context.setValue(RPC_METADATA_KEY, meta);
  }
  exports.setRPCMetadata = setRPCMetadata;
  function deleteRPCMetadata(context) {
    return context.deleteValue(RPC_METADATA_KEY);
  }
  exports.deleteRPCMetadata = deleteRPCMetadata;
  function getRPCMetadata(context) {
    return context.getValue(RPC_METADATA_KEY);
  }
  exports.getRPCMetadata = getRPCMetadata;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPlainObject = undefined;
  var objectTag = "[object Object]";
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  var objectCtorString = funcToString.call(Object);
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  var nativeObjectToString = objectProto.toString;
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
      return false;
    }
    const proto = getPrototypeOf(value);
    if (proto === null) {
      return true;
    }
    const Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
  }
  exports.isPlainObject = isPlainObject;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function getRawTag(value) {
    const isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    let unmasked = false;
    try {
      value[symToStringTag] = undefined;
      unmasked = true;
    } catch {}
    const result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var lodash_merge_1 = require_lodash_merge();
  var MAX_LEVEL = 20;
  function merge(...args) {
    let result = args.shift();
    const objects = new WeakMap;
    while (args.length > 0) {
      result = mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
  }
  exports.merge = merge;
  function takeValue(value) {
    if (isArray(value)) {
      return value.slice();
    }
    return value;
  }
  function mergeTwoObjects(one, two, level = 0, objects) {
    let result;
    if (level > MAX_LEVEL) {
      return;
    }
    level++;
    if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
      result = takeValue(two);
    } else if (isArray(one)) {
      result = one.slice();
      if (isArray(two)) {
        for (let i = 0, j = two.length;i < j; i++) {
          result.push(takeValue(two[i]));
        }
      } else if (isObject(two)) {
        const keys = Object.keys(two);
        for (let i = 0, j = keys.length;i < j; i++) {
          const key = keys[i];
          result[key] = takeValue(two[key]);
        }
      }
    } else if (isObject(one)) {
      if (isObject(two)) {
        if (!shouldMerge(one, two)) {
          return two;
        }
        result = Object.assign({}, one);
        const keys = Object.keys(two);
        for (let i = 0, j = keys.length;i < j; i++) {
          const key = keys[i];
          const twoValue = two[key];
          if (isPrimitive(twoValue)) {
            if (typeof twoValue === "undefined") {
              delete result[key];
            } else {
              result[key] = twoValue;
            }
          } else {
            const obj1 = result[key];
            const obj2 = twoValue;
            if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
              delete result[key];
            } else {
              if (isObject(obj1) && isObject(obj2)) {
                const arr1 = objects.get(obj1) || [];
                const arr2 = objects.get(obj2) || [];
                arr1.push({ obj: one, key });
                arr2.push({ obj: two, key });
                objects.set(obj1, arr1);
                objects.set(obj2, arr2);
              }
              result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
            }
          }
        }
      } else {
        result = two;
      }
    }
    return result;
  }
  function wasObjectReferenced(obj, key, objects) {
    const arr = objects.get(obj[key]) || [];
    for (let i = 0, j = arr.length;i < j; i++) {
      const info = arr[i];
      if (info.key === key && info.obj === obj) {
        return true;
      }
    }
    return false;
  }
  function isArray(value) {
    return Array.isArray(value);
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function isObject(value) {
    return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
  }
  function isPrimitive(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
  }
  function shouldMerge(one, two) {
    if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
      return false;
    }
    return true;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callWithTimeout = exports.TimeoutError = undefined;

  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, TimeoutError.prototype);
    }
  }
  exports.TimeoutError = TimeoutError;
  function callWithTimeout(promise, timeout) {
    let timeoutHandle;
    const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
      timeoutHandle = setTimeout(function timeoutHandler() {
        reject(new TimeoutError("Operation timed out."));
      }, timeout);
    });
    return Promise.race([promise, timeoutPromise]).then((result) => {
      clearTimeout(timeoutHandle);
      return result;
    }, (reason) => {
      clearTimeout(timeoutHandle);
      throw reason;
    });
  }
  exports.callWithTimeout = callWithTimeout;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isUrlIgnored = exports.urlMatches = undefined;
  function urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === "string") {
      return url === urlToMatch;
    } else {
      return !!url.match(urlToMatch);
    }
  }
  exports.urlMatches = urlMatches;
  function isUrlIgnored(url, ignoredUrls) {
    if (!ignoredUrls) {
      return false;
    }
    for (const ignoreUrl of ignoredUrls) {
      if (urlMatches(url, ignoreUrl)) {
        return true;
      }
    }
    return false;
  }
  exports.isUrlIgnored = isUrlIgnored;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deferred = undefined;

  class Deferred {
    _promise;
    _resolve;
    _reject;
    constructor() {
      this._promise = new Promise((resolve, reject) => {
        this._resolve = resolve;
        this._reject = reject;
      });
    }
    get promise() {
      return this._promise;
    }
    resolve(val) {
      this._resolve(val);
    }
    reject(err) {
      this._reject(err);
    }
  }
  exports.Deferred = Deferred;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BindOnceFuture = undefined;
  var promise_1 = require_promise();

  class BindOnceFuture {
    _callback;
    _that;
    _isCalled = false;
    _deferred = new promise_1.Deferred;
    constructor(_callback, _that) {
      this._callback = _callback;
      this._that = _that;
    }
    get isCalled() {
      return this._isCalled;
    }
    get promise() {
      return this._deferred.promise;
    }
    call(...args) {
      if (!this._isCalled) {
        this._isCalled = true;
        try {
          Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
        } catch (err) {
          this._deferred.reject(err);
        }
      }
      return this._deferred.promise;
    }
  }
  exports.BindOnceFuture = BindOnceFuture;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/configuration.js
var require_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diagLogLevelFromString = undefined;
  var api_1 = require_src();
  var logLevelMap = {
    ALL: api_1.DiagLogLevel.ALL,
    VERBOSE: api_1.DiagLogLevel.VERBOSE,
    DEBUG: api_1.DiagLogLevel.DEBUG,
    INFO: api_1.DiagLogLevel.INFO,
    WARN: api_1.DiagLogLevel.WARN,
    ERROR: api_1.DiagLogLevel.ERROR,
    NONE: api_1.DiagLogLevel.NONE
  };
  function diagLogLevelFromString(value) {
    if (value == null) {
      return;
    }
    const resolvedLogLevel = logLevelMap[value.toUpperCase()];
    if (resolvedLogLevel == null) {
      api_1.diag.warn(`Unknown log level "${value}", expected one of ${Object.keys(logLevelMap)}, using default`);
      return api_1.DiagLogLevel.INFO;
    }
    return resolvedLogLevel;
  }
  exports.diagLogLevelFromString = diagLogLevelFromString;
});

// ../../node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._export = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  function _export(exporter, arg) {
    return new Promise((resolve) => {
      api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
        exporter.export(arg, (result) => {
          resolve(result);
        });
      });
    });
  }
  exports._export = _export;
});

// ../../node_modules/@opentelemetry/core/build/src/index.js
var require_src3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.internal = exports.diagLogLevelFromString = exports.BindOnceFuture = exports.urlMatches = exports.isUrlIgnored = exports.callWithTimeout = exports.TimeoutError = exports.merge = exports.TraceState = exports.unsuppressTracing = exports.suppressTracing = exports.isTracingSuppressed = exports.setRPCMetadata = exports.getRPCMetadata = exports.deleteRPCMetadata = exports.RPCType = exports.parseTraceParent = exports.W3CTraceContextPropagator = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = exports.CompositePropagator = exports.unrefTimer = exports.otperformance = exports.getStringListFromEnv = exports.getNumberFromEnv = exports.getBooleanFromEnv = exports.getStringFromEnv = exports._globalThis = exports.SDK_INFO = exports.parseKeyPairsIntoRecord = exports.ExportResultCode = exports.timeInputToHrTime = exports.millisToHrTime = exports.isTimeInputHrTime = exports.isTimeInput = exports.hrTimeToTimeStamp = exports.hrTimeToNanoseconds = exports.hrTimeToMilliseconds = exports.hrTimeToMicroseconds = exports.hrTimeDuration = exports.hrTime = exports.getTimeOrigin = exports.addHrTimes = exports.loggingErrorHandler = exports.setGlobalErrorHandler = exports.globalErrorHandler = exports.sanitizeAttributes = exports.isAttributeValue = exports.AnchoredClock = exports.W3CBaggagePropagator = undefined;
  var W3CBaggagePropagator_1 = require_W3CBaggagePropagator();
  Object.defineProperty(exports, "W3CBaggagePropagator", { enumerable: true, get: function() {
    return W3CBaggagePropagator_1.W3CBaggagePropagator;
  } });
  var anchored_clock_1 = require_anchored_clock();
  Object.defineProperty(exports, "AnchoredClock", { enumerable: true, get: function() {
    return anchored_clock_1.AnchoredClock;
  } });
  var attributes_1 = require_attributes();
  Object.defineProperty(exports, "isAttributeValue", { enumerable: true, get: function() {
    return attributes_1.isAttributeValue;
  } });
  Object.defineProperty(exports, "sanitizeAttributes", { enumerable: true, get: function() {
    return attributes_1.sanitizeAttributes;
  } });
  var global_error_handler_1 = require_global_error_handler();
  Object.defineProperty(exports, "globalErrorHandler", { enumerable: true, get: function() {
    return global_error_handler_1.globalErrorHandler;
  } });
  Object.defineProperty(exports, "setGlobalErrorHandler", { enumerable: true, get: function() {
    return global_error_handler_1.setGlobalErrorHandler;
  } });
  var logging_error_handler_1 = require_logging_error_handler();
  Object.defineProperty(exports, "loggingErrorHandler", { enumerable: true, get: function() {
    return logging_error_handler_1.loggingErrorHandler;
  } });
  var time_1 = require_time();
  Object.defineProperty(exports, "addHrTimes", { enumerable: true, get: function() {
    return time_1.addHrTimes;
  } });
  Object.defineProperty(exports, "getTimeOrigin", { enumerable: true, get: function() {
    return time_1.getTimeOrigin;
  } });
  Object.defineProperty(exports, "hrTime", { enumerable: true, get: function() {
    return time_1.hrTime;
  } });
  Object.defineProperty(exports, "hrTimeDuration", { enumerable: true, get: function() {
    return time_1.hrTimeDuration;
  } });
  Object.defineProperty(exports, "hrTimeToMicroseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToMicroseconds;
  } });
  Object.defineProperty(exports, "hrTimeToMilliseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToMilliseconds;
  } });
  Object.defineProperty(exports, "hrTimeToNanoseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToNanoseconds;
  } });
  Object.defineProperty(exports, "hrTimeToTimeStamp", { enumerable: true, get: function() {
    return time_1.hrTimeToTimeStamp;
  } });
  Object.defineProperty(exports, "isTimeInput", { enumerable: true, get: function() {
    return time_1.isTimeInput;
  } });
  Object.defineProperty(exports, "isTimeInputHrTime", { enumerable: true, get: function() {
    return time_1.isTimeInputHrTime;
  } });
  Object.defineProperty(exports, "millisToHrTime", { enumerable: true, get: function() {
    return time_1.millisToHrTime;
  } });
  Object.defineProperty(exports, "timeInputToHrTime", { enumerable: true, get: function() {
    return time_1.timeInputToHrTime;
  } });
  var ExportResult_1 = require_ExportResult();
  Object.defineProperty(exports, "ExportResultCode", { enumerable: true, get: function() {
    return ExportResult_1.ExportResultCode;
  } });
  var utils_1 = require_utils3();
  Object.defineProperty(exports, "parseKeyPairsIntoRecord", { enumerable: true, get: function() {
    return utils_1.parseKeyPairsIntoRecord;
  } });
  var platform_1 = require_platform2();
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return platform_1.SDK_INFO;
  } });
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return platform_1._globalThis;
  } });
  Object.defineProperty(exports, "getStringFromEnv", { enumerable: true, get: function() {
    return platform_1.getStringFromEnv;
  } });
  Object.defineProperty(exports, "getBooleanFromEnv", { enumerable: true, get: function() {
    return platform_1.getBooleanFromEnv;
  } });
  Object.defineProperty(exports, "getNumberFromEnv", { enumerable: true, get: function() {
    return platform_1.getNumberFromEnv;
  } });
  Object.defineProperty(exports, "getStringListFromEnv", { enumerable: true, get: function() {
    return platform_1.getStringListFromEnv;
  } });
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return platform_1.otperformance;
  } });
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return platform_1.unrefTimer;
  } });
  var composite_1 = require_composite();
  Object.defineProperty(exports, "CompositePropagator", { enumerable: true, get: function() {
    return composite_1.CompositePropagator;
  } });
  var W3CTraceContextPropagator_1 = require_W3CTraceContextPropagator();
  Object.defineProperty(exports, "TRACE_PARENT_HEADER", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.TRACE_PARENT_HEADER;
  } });
  Object.defineProperty(exports, "TRACE_STATE_HEADER", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.TRACE_STATE_HEADER;
  } });
  Object.defineProperty(exports, "W3CTraceContextPropagator", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.W3CTraceContextPropagator;
  } });
  Object.defineProperty(exports, "parseTraceParent", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.parseTraceParent;
  } });
  var rpc_metadata_1 = require_rpc_metadata();
  Object.defineProperty(exports, "RPCType", { enumerable: true, get: function() {
    return rpc_metadata_1.RPCType;
  } });
  Object.defineProperty(exports, "deleteRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.deleteRPCMetadata;
  } });
  Object.defineProperty(exports, "getRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.getRPCMetadata;
  } });
  Object.defineProperty(exports, "setRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.setRPCMetadata;
  } });
  var suppress_tracing_1 = require_suppress_tracing();
  Object.defineProperty(exports, "isTracingSuppressed", { enumerable: true, get: function() {
    return suppress_tracing_1.isTracingSuppressed;
  } });
  Object.defineProperty(exports, "suppressTracing", { enumerable: true, get: function() {
    return suppress_tracing_1.suppressTracing;
  } });
  Object.defineProperty(exports, "unsuppressTracing", { enumerable: true, get: function() {
    return suppress_tracing_1.unsuppressTracing;
  } });
  var TraceState_1 = require_TraceState();
  Object.defineProperty(exports, "TraceState", { enumerable: true, get: function() {
    return TraceState_1.TraceState;
  } });
  var merge_1 = require_merge();
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_1.merge;
  } });
  var timeout_1 = require_timeout();
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_1.TimeoutError;
  } });
  Object.defineProperty(exports, "callWithTimeout", { enumerable: true, get: function() {
    return timeout_1.callWithTimeout;
  } });
  var url_1 = require_url();
  Object.defineProperty(exports, "isUrlIgnored", { enumerable: true, get: function() {
    return url_1.isUrlIgnored;
  } });
  Object.defineProperty(exports, "urlMatches", { enumerable: true, get: function() {
    return url_1.urlMatches;
  } });
  var callback_1 = require_callback();
  Object.defineProperty(exports, "BindOnceFuture", { enumerable: true, get: function() {
    return callback_1.BindOnceFuture;
  } });
  var configuration_1 = require_configuration();
  Object.defineProperty(exports, "diagLogLevelFromString", { enumerable: true, get: function() {
    return configuration_1.diagLogLevelFromString;
  } });
  var exporter_1 = require_exporter();
  exports.internal = {
    _export: exporter_1._export
  };
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/version.js
var require_version3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "0.204.0";
});

// ../../node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js
var require_LogRecord = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SeverityNumber = undefined;
  var SeverityNumber;
  (function(SeverityNumber2) {
    SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
    SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
    SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
    SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
    SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
    SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
    SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
    SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
    SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
    SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
    SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
    SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
    SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
    SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
    SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
    SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
    SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
    SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
    SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
    SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
    SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
    SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
    SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
    SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
  })(SeverityNumber = exports.SeverityNumber || (exports.SeverityNumber = {}));
});

// ../../node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js
var require_NoopLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER = exports.NoopLogger = undefined;

  class NoopLogger {
    emit(_logRecord) {}
  }
  exports.NoopLogger = NoopLogger;
  exports.NOOP_LOGGER = new NoopLogger;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js
var require_NoopLoggerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER_PROVIDER = exports.NoopLoggerProvider = undefined;
  var NoopLogger_1 = require_NoopLogger();

  class NoopLoggerProvider {
    getLogger(_name, _version, _options) {
      return new NoopLogger_1.NoopLogger;
    }
  }
  exports.NoopLoggerProvider = NoopLoggerProvider;
  exports.NOOP_LOGGER_PROVIDER = new NoopLoggerProvider;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/ProxyLogger.js
var require_ProxyLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyLogger = undefined;
  var NoopLogger_1 = require_NoopLogger();

  class ProxyLogger {
    constructor(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    emit(logRecord) {
      this._getLogger().emit(logRecord);
    }
    _getLogger() {
      if (this._delegate) {
        return this._delegate;
      }
      const logger30 = this._provider._getDelegateLogger(this.name, this.version, this.options);
      if (!logger30) {
        return NoopLogger_1.NOOP_LOGGER;
      }
      this._delegate = logger30;
      return this._delegate;
    }
  }
  exports.ProxyLogger = ProxyLogger;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/ProxyLoggerProvider.js
var require_ProxyLoggerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyLoggerProvider = undefined;
  var NoopLoggerProvider_1 = require_NoopLoggerProvider();
  var ProxyLogger_1 = require_ProxyLogger();

  class ProxyLoggerProvider {
    getLogger(name, version, options) {
      var _a;
      return (_a = this._getDelegateLogger(name, version, options)) !== null && _a !== undefined ? _a : new ProxyLogger_1.ProxyLogger(this, name, version, options);
    }
    _getDelegate() {
      var _a;
      return (_a = this._delegate) !== null && _a !== undefined ? _a : NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
    }
    _setDelegate(delegate) {
      this._delegate = delegate;
    }
    _getDelegateLogger(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getLogger(name, version, options);
    }
  }
  exports.ProxyLoggerProvider = ProxyLoggerProvider;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js
var require_globalThis3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js
var require_node3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  var globalThis_1 = require_globalThis3();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return globalThis_1._globalThis;
  } });
});

// ../../node_modules/@opentelemetry/api-logs/build/src/platform/index.js
var require_platform3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  var node_1 = require_node3();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return node_1._globalThis;
  } });
});

// ../../node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js
var require_global_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_LOGS_API_KEY = undefined;
  var platform_1 = require_platform3();
  exports.GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
  exports._global = platform_1._globalThis;
  function makeGetter(requiredVersion, instance, fallback) {
    return (version) => version === requiredVersion ? instance : fallback;
  }
  exports.makeGetter = makeGetter;
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = 1;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/api/logs.js
var require_logs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogsAPI = undefined;
  var global_utils_1 = require_global_utils2();
  var NoopLoggerProvider_1 = require_NoopLoggerProvider();
  var ProxyLoggerProvider_1 = require_ProxyLoggerProvider();

  class LogsAPI {
    constructor() {
      this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new LogsAPI;
      }
      return this._instance;
    }
    setGlobalLoggerProvider(provider) {
      if (global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) {
        return this.getLoggerProvider();
      }
      global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY] = (0, global_utils_1.makeGetter)(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER);
      this._proxyLoggerProvider._setDelegate(provider);
      return provider;
    }
    getLoggerProvider() {
      var _a, _b;
      return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) === null || _a === undefined ? undefined : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== undefined ? _b : this._proxyLoggerProvider;
    }
    getLogger(name, version, options) {
      return this.getLoggerProvider().getLogger(name, version, options);
    }
    disable() {
      delete global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY];
      this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider;
    }
  }
  exports.LogsAPI = LogsAPI;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/index.js
var require_src4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logs = exports.ProxyLoggerProvider = exports.ProxyLogger = exports.NoopLoggerProvider = exports.NOOP_LOGGER_PROVIDER = exports.NoopLogger = exports.NOOP_LOGGER = exports.SeverityNumber = undefined;
  var LogRecord_1 = require_LogRecord();
  Object.defineProperty(exports, "SeverityNumber", { enumerable: true, get: function() {
    return LogRecord_1.SeverityNumber;
  } });
  var NoopLogger_1 = require_NoopLogger();
  Object.defineProperty(exports, "NOOP_LOGGER", { enumerable: true, get: function() {
    return NoopLogger_1.NOOP_LOGGER;
  } });
  Object.defineProperty(exports, "NoopLogger", { enumerable: true, get: function() {
    return NoopLogger_1.NoopLogger;
  } });
  var NoopLoggerProvider_1 = require_NoopLoggerProvider();
  Object.defineProperty(exports, "NOOP_LOGGER_PROVIDER", { enumerable: true, get: function() {
    return NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
  } });
  Object.defineProperty(exports, "NoopLoggerProvider", { enumerable: true, get: function() {
    return NoopLoggerProvider_1.NoopLoggerProvider;
  } });
  var ProxyLogger_1 = require_ProxyLogger();
  Object.defineProperty(exports, "ProxyLogger", { enumerable: true, get: function() {
    return ProxyLogger_1.ProxyLogger;
  } });
  var ProxyLoggerProvider_1 = require_ProxyLoggerProvider();
  Object.defineProperty(exports, "ProxyLoggerProvider", { enumerable: true, get: function() {
    return ProxyLoggerProvider_1.ProxyLoggerProvider;
  } });
  var logs_1 = require_logs();
  exports.logs = logs_1.LogsAPI.getInstance();
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/autoLoaderUtils.js
var require_autoLoaderUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.disableInstrumentations = exports.enableInstrumentations = undefined;
  function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
    for (let i = 0, j = instrumentations.length;i < j; i++) {
      const instrumentation = instrumentations[i];
      if (tracerProvider) {
        instrumentation.setTracerProvider(tracerProvider);
      }
      if (meterProvider) {
        instrumentation.setMeterProvider(meterProvider);
      }
      if (loggerProvider && instrumentation.setLoggerProvider) {
        instrumentation.setLoggerProvider(loggerProvider);
      }
      if (!instrumentation.getConfig().enabled) {
        instrumentation.enable();
      }
    }
  }
  exports.enableInstrumentations = enableInstrumentations;
  function disableInstrumentations(instrumentations) {
    instrumentations.forEach((instrumentation) => instrumentation.disable());
  }
  exports.disableInstrumentations = disableInstrumentations;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/autoLoader.js
var require_autoLoader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.registerInstrumentations = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src4();
  var autoLoaderUtils_1 = require_autoLoaderUtils();
  function registerInstrumentations(options) {
    const tracerProvider = options.tracerProvider || api_1.trace.getTracerProvider();
    const meterProvider = options.meterProvider || api_1.metrics.getMeterProvider();
    const loggerProvider = options.loggerProvider || api_logs_1.logs.getLoggerProvider();
    const instrumentations = options.instrumentations?.flat() ?? [];
    (0, autoLoaderUtils_1.enableInstrumentations)(instrumentations, tracerProvider, meterProvider, loggerProvider);
    return () => {
      (0, autoLoaderUtils_1.disableInstrumentations)(instrumentations);
    };
  }
  exports.registerInstrumentations = registerInstrumentations;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/semver.js
var require_semver2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.satisfies = undefined;
  var api_1 = require_src();
  var VERSION_REGEXP = /^(?:v)?(?<version>(?<major>0|[1-9]\d*)\.(?<minor>0|[1-9]\d*)\.(?<patch>0|[1-9]\d*))(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<build>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
  var RANGE_REGEXP = /^(?<op><|>|=|==|<=|>=|~|\^|~>)?\s*(?:v)?(?<version>(?<major>x|X|\*|0|[1-9]\d*)(?:\.(?<minor>x|X|\*|0|[1-9]\d*))?(?:\.(?<patch>x|X|\*|0|[1-9]\d*))?)(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<build>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
  var operatorResMap = {
    ">": [1],
    ">=": [0, 1],
    "=": [0],
    "<=": [-1, 0],
    "<": [-1],
    "!=": [-1, 1]
  };
  function satisfies(version, range, options) {
    if (!_validateVersion(version)) {
      api_1.diag.error(`Invalid version: ${version}`);
      return false;
    }
    if (!range) {
      return true;
    }
    range = range.replace(/([<>=~^]+)\s+/g, "$1");
    const parsedVersion = _parseVersion(version);
    if (!parsedVersion) {
      return false;
    }
    const allParsedRanges = [];
    const checkResult = _doSatisfies(parsedVersion, range, allParsedRanges, options);
    if (checkResult && !options?.includePrerelease) {
      return _doPreleaseCheck(parsedVersion, allParsedRanges);
    }
    return checkResult;
  }
  exports.satisfies = satisfies;
  function _validateVersion(version) {
    return typeof version === "string" && VERSION_REGEXP.test(version);
  }
  function _doSatisfies(parsedVersion, range, allParsedRanges, options) {
    if (range.includes("||")) {
      const ranges = range.trim().split("||");
      for (const r of ranges) {
        if (_checkRange(parsedVersion, r, allParsedRanges, options)) {
          return true;
        }
      }
      return false;
    } else if (range.includes(" - ")) {
      range = replaceHyphen(range, options);
    } else if (range.includes(" ")) {
      const ranges = range.trim().replace(/\s{2,}/g, " ").split(" ");
      for (const r of ranges) {
        if (!_checkRange(parsedVersion, r, allParsedRanges, options)) {
          return false;
        }
      }
      return true;
    }
    return _checkRange(parsedVersion, range, allParsedRanges, options);
  }
  function _checkRange(parsedVersion, range, allParsedRanges, options) {
    range = _normalizeRange(range, options);
    if (range.includes(" ")) {
      return _doSatisfies(parsedVersion, range, allParsedRanges, options);
    } else {
      const parsedRange = _parseRange(range);
      allParsedRanges.push(parsedRange);
      return _satisfies(parsedVersion, parsedRange);
    }
  }
  function _satisfies(parsedVersion, parsedRange) {
    if (parsedRange.invalid) {
      return false;
    }
    if (!parsedRange.version || _isWildcard(parsedRange.version)) {
      return true;
    }
    let comparisonResult = _compareVersionSegments(parsedVersion.versionSegments || [], parsedRange.versionSegments || []);
    if (comparisonResult === 0) {
      const versionPrereleaseSegments = parsedVersion.prereleaseSegments || [];
      const rangePrereleaseSegments = parsedRange.prereleaseSegments || [];
      if (!versionPrereleaseSegments.length && !rangePrereleaseSegments.length) {
        comparisonResult = 0;
      } else if (!versionPrereleaseSegments.length && rangePrereleaseSegments.length) {
        comparisonResult = 1;
      } else if (versionPrereleaseSegments.length && !rangePrereleaseSegments.length) {
        comparisonResult = -1;
      } else {
        comparisonResult = _compareVersionSegments(versionPrereleaseSegments, rangePrereleaseSegments);
      }
    }
    return operatorResMap[parsedRange.op]?.includes(comparisonResult);
  }
  function _doPreleaseCheck(parsedVersion, allParsedRanges) {
    if (parsedVersion.prerelease) {
      return allParsedRanges.some((r) => r.prerelease && r.version === parsedVersion.version);
    }
    return true;
  }
  function _normalizeRange(range, options) {
    range = range.trim();
    range = replaceCaret(range, options);
    range = replaceTilde(range);
    range = replaceXRange(range, options);
    range = range.trim();
    return range;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function _parseVersion(versionString) {
    const match2 = versionString.match(VERSION_REGEXP);
    if (!match2) {
      api_1.diag.error(`Invalid version: ${versionString}`);
      return;
    }
    const version = match2.groups.version;
    const prerelease = match2.groups.prerelease;
    const build = match2.groups.build;
    const versionSegments = version.split(".");
    const prereleaseSegments = prerelease?.split(".");
    return {
      op: undefined,
      version,
      versionSegments,
      versionSegmentCount: versionSegments.length,
      prerelease,
      prereleaseSegments,
      prereleaseSegmentCount: prereleaseSegments ? prereleaseSegments.length : 0,
      build
    };
  }
  function _parseRange(rangeString) {
    if (!rangeString) {
      return {};
    }
    const match2 = rangeString.match(RANGE_REGEXP);
    if (!match2) {
      api_1.diag.error(`Invalid range: ${rangeString}`);
      return {
        invalid: true
      };
    }
    let op = match2.groups.op;
    const version = match2.groups.version;
    const prerelease = match2.groups.prerelease;
    const build = match2.groups.build;
    const versionSegments = version.split(".");
    const prereleaseSegments = prerelease?.split(".");
    if (op === "==") {
      op = "=";
    }
    return {
      op: op || "=",
      version,
      versionSegments,
      versionSegmentCount: versionSegments.length,
      prerelease,
      prereleaseSegments,
      prereleaseSegmentCount: prereleaseSegments ? prereleaseSegments.length : 0,
      build
    };
  }
  function _isWildcard(s) {
    return s === "*" || s === "x" || s === "X";
  }
  function _parseVersionString(v) {
    const n = parseInt(v, 10);
    return isNaN(n) ? v : n;
  }
  function _normalizeVersionType(a, b) {
    if (typeof a === typeof b) {
      if (typeof a === "number") {
        return [a, b];
      } else if (typeof a === "string") {
        return [a, b];
      } else {
        throw new Error("Version segments can only be strings or numbers");
      }
    } else {
      return [String(a), String(b)];
    }
  }
  function _compareVersionStrings(v1, v2) {
    if (_isWildcard(v1) || _isWildcard(v2)) {
      return 0;
    }
    const [parsedV1, parsedV2] = _normalizeVersionType(_parseVersionString(v1), _parseVersionString(v2));
    if (parsedV1 > parsedV2) {
      return 1;
    } else if (parsedV1 < parsedV2) {
      return -1;
    }
    return 0;
  }
  function _compareVersionSegments(v1, v2) {
    for (let i = 0;i < Math.max(v1.length, v2.length); i++) {
      const res = _compareVersionStrings(v1[i] || "0", v2[i] || "0");
      if (res !== 0) {
        return res;
      }
    }
    return 0;
  }
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var NUMERICIDENTIFIER = "0|[1-9]\\d*";
  var NONNUMERICIDENTIFIER = `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`;
  var GTLT = "((?:<|>)?=?)";
  var PRERELEASEIDENTIFIER = `(?:${NUMERICIDENTIFIER}|${NONNUMERICIDENTIFIER})`;
  var PRERELEASE = `(?:-(${PRERELEASEIDENTIFIER}(?:\\.${PRERELEASEIDENTIFIER})*))`;
  var BUILDIDENTIFIER = `${LETTERDASHNUMBER}+`;
  var BUILD = `(?:\\+(${BUILDIDENTIFIER}(?:\\.${BUILDIDENTIFIER})*))`;
  var XRANGEIDENTIFIER = `${NUMERICIDENTIFIER}|x|X|\\*`;
  var XRANGEPLAIN = `[v=\\s]*(${XRANGEIDENTIFIER})` + `(?:\\.(${XRANGEIDENTIFIER})` + `(?:\\.(${XRANGEIDENTIFIER})` + `(?:${PRERELEASE})?${BUILD}?` + `)?)?`;
  var XRANGE = `^${GTLT}\\s*${XRANGEPLAIN}$`;
  var XRANGE_REGEXP = new RegExp(XRANGE);
  var HYPHENRANGE = `^\\s*(${XRANGEPLAIN})` + `\\s+-\\s+` + `(${XRANGEPLAIN})` + `\\s*$`;
  var HYPHENRANGE_REGEXP = new RegExp(HYPHENRANGE);
  var LONETILDE = "(?:~>?)";
  var TILDE = `^${LONETILDE}${XRANGEPLAIN}$`;
  var TILDE_REGEXP = new RegExp(TILDE);
  var LONECARET = "(?:\\^)";
  var CARET = `^${LONECARET}${XRANGEPLAIN}$`;
  var CARET_REGEXP = new RegExp(CARET);
  function replaceTilde(comp) {
    const r = TILDE_REGEXP;
    return comp.replace(r, (_, M, m, p, pr) => {
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      return ret;
    });
  }
  function replaceCaret(comp, options) {
    const r = CARET_REGEXP;
    const z = options?.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      return ret;
    });
  }
  function replaceXRange(comp, options) {
    const r = XRANGE_REGEXP;
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options?.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      return ret;
    });
  }
  function replaceHyphen(comp, options) {
    const r = HYPHENRANGE_REGEXP;
    return comp.replace(r, (_, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${options?.includePrerelease ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${options?.includePrerelease ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${options?.includePrerelease ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (options?.includePrerelease) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    });
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/shimmer.js
var require_shimmer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.massUnwrap = exports.unwrap = exports.massWrap = exports.wrap = undefined;
  var logger30 = console.error.bind(console);
  function defineProperty(obj, name, value) {
    const enumerable = !!obj[name] && Object.prototype.propertyIsEnumerable.call(obj, name);
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable,
      writable: true,
      value
    });
  }
  var wrap = (nodule, name, wrapper) => {
    if (!nodule || !nodule[name]) {
      logger30("no original function " + String(name) + " to wrap");
      return;
    }
    if (!wrapper) {
      logger30("no wrapper function");
      logger30(new Error().stack);
      return;
    }
    const original = nodule[name];
    if (typeof original !== "function" || typeof wrapper !== "function") {
      logger30("original object and wrapper must be functions");
      return;
    }
    const wrapped = wrapper(original, name);
    defineProperty(wrapped, "__original", original);
    defineProperty(wrapped, "__unwrap", () => {
      if (nodule[name] === wrapped) {
        defineProperty(nodule, name, original);
      }
    });
    defineProperty(wrapped, "__wrapped", true);
    defineProperty(nodule, name, wrapped);
    return wrapped;
  };
  exports.wrap = wrap;
  var massWrap = (nodules, names, wrapper) => {
    if (!nodules) {
      logger30("must provide one or more modules to patch");
      logger30(new Error().stack);
      return;
    } else if (!Array.isArray(nodules)) {
      nodules = [nodules];
    }
    if (!(names && Array.isArray(names))) {
      logger30("must provide one or more functions to wrap on modules");
      return;
    }
    nodules.forEach((nodule) => {
      names.forEach((name) => {
        (0, exports.wrap)(nodule, name, wrapper);
      });
    });
  };
  exports.massWrap = massWrap;
  var unwrap = (nodule, name) => {
    if (!nodule || !nodule[name]) {
      logger30("no function to unwrap.");
      logger30(new Error().stack);
      return;
    }
    const wrapped = nodule[name];
    if (!wrapped.__unwrap) {
      logger30("no original to unwrap to -- has " + String(name) + " already been unwrapped?");
    } else {
      wrapped.__unwrap();
      return;
    }
  };
  exports.unwrap = unwrap;
  var massUnwrap = (nodules, names) => {
    if (!nodules) {
      logger30("must provide one or more modules to patch");
      logger30(new Error().stack);
      return;
    } else if (!Array.isArray(nodules)) {
      nodules = [nodules];
    }
    if (!(names && Array.isArray(names))) {
      logger30("must provide one or more functions to unwrap on modules");
      return;
    }
    nodules.forEach((nodule) => {
      names.forEach((name) => {
        (0, exports.unwrap)(nodule, name);
      });
    });
  };
  exports.massUnwrap = massUnwrap;
  function shimmer(options) {
    if (options && options.logger) {
      if (typeof options.logger !== "function") {
        logger30("new logger isn't a function, not replacing");
      } else {
        logger30 = options.logger;
      }
    }
  }
  exports.default = shimmer;
  shimmer.wrap = exports.wrap;
  shimmer.massWrap = exports.massWrap;
  shimmer.unwrap = exports.unwrap;
  shimmer.massUnwrap = exports.massUnwrap;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/instrumentation.js
var require_instrumentation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationAbstract = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src4();
  var shimmer = require_shimmer();

  class InstrumentationAbstract {
    instrumentationName;
    instrumentationVersion;
    _config = {};
    _tracer;
    _meter;
    _logger;
    _diag;
    constructor(instrumentationName, instrumentationVersion, config) {
      this.instrumentationName = instrumentationName;
      this.instrumentationVersion = instrumentationVersion;
      this.setConfig(config);
      this._diag = api_1.diag.createComponentLogger({
        namespace: instrumentationName
      });
      this._tracer = api_1.trace.getTracer(instrumentationName, instrumentationVersion);
      this._meter = api_1.metrics.getMeter(instrumentationName, instrumentationVersion);
      this._logger = api_logs_1.logs.getLogger(instrumentationName, instrumentationVersion);
      this._updateMetricInstruments();
    }
    _wrap = shimmer.wrap;
    _unwrap = shimmer.unwrap;
    _massWrap = shimmer.massWrap;
    _massUnwrap = shimmer.massUnwrap;
    get meter() {
      return this._meter;
    }
    setMeterProvider(meterProvider) {
      this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
      this._updateMetricInstruments();
    }
    get logger() {
      return this._logger;
    }
    setLoggerProvider(loggerProvider) {
      this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    }
    getModuleDefinitions() {
      const initResult = this.init() ?? [];
      if (!Array.isArray(initResult)) {
        return [initResult];
      }
      return initResult;
    }
    _updateMetricInstruments() {
      return;
    }
    getConfig() {
      return this._config;
    }
    setConfig(config) {
      this._config = {
        enabled: true,
        ...config
      };
    }
    setTracerProvider(tracerProvider) {
      this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    }
    get tracer() {
      return this._tracer;
    }
    _runSpanCustomizationHook(hookHandler, triggerName, span, info) {
      if (!hookHandler) {
        return;
      }
      try {
        hookHandler(span, info);
      } catch (e) {
        this._diag.error(`Error running span customization hook due to exception in handler`, { triggerName }, e);
      }
    }
  }
  exports.InstrumentationAbstract = InstrumentationAbstract;
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type = (match2[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format) => {
          if (match2 === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match2 = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self, args);
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match2) => {
      if (match2 === "%%") {
        return;
      }
      index++;
      if (match2 === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var flagForceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    flagForceColor = 1;
  }
  function envForceColor() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream, options = {}) {
    const level = supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
});

// ../../node_modules/debug/src/node.js
var require_node4 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/debug/src/index.js
var require_src5 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node4();
  }
});

// ../../node_modules/module-details-from-path/index.js
var require_module_details_from_path = __commonJS((exports, module) => {
  var sep = __require("path").sep;
  module.exports = function(file) {
    var segments = file.split(sep);
    var index = segments.lastIndexOf("node_modules");
    if (index === -1)
      return;
    if (!segments[index + 1])
      return;
    var scoped = segments[index + 1][0] === "@";
    var name = scoped ? segments[index + 1] + "/" + segments[index + 2] : segments[index + 1];
    var offset = scoped ? 3 : 2;
    var basedir = "";
    var lastBaseDirSegmentIndex = index + offset - 1;
    for (var i = 0;i <= lastBaseDirSegmentIndex; i++) {
      if (i === lastBaseDirSegmentIndex) {
        basedir += segments[i];
      } else {
        basedir += segments[i] + sep;
      }
    }
    var path7 = "";
    var lastSegmentIndex = segments.length - 1;
    for (var i2 = index + offset;i2 <= lastSegmentIndex; i2++) {
      if (i2 === lastSegmentIndex) {
        path7 += segments[i2];
      } else {
        path7 += segments[i2] + sep;
      }
    }
    return {
      name,
      basedir,
      path: path7
    };
  };
});

// ../../node_modules/require-in-the-middle/node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS((exports, module) => {
  var os = __require("os");
  module.exports = os.homedir || function homedir() {
    var home = process.env.HOME;
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
    if (process.platform === "win32") {
      return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
    }
    if (process.platform === "darwin") {
      return home || (user ? "/Users/" + user : null);
    }
    if (process.platform === "linux") {
      return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
    }
    return home || null;
  };
});

// ../../node_modules/require-in-the-middle/node_modules/resolve/lib/caller.js
var require_caller = __commonJS((exports, module) => {
  module.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// ../../node_modules/path-parse/index.js
var require_path_parse = __commonJS((exports, module) => {
  var isWindows = process.platform === "win32";
  var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
  var win32 = {};
  function win32SplitPath(filename) {
    return splitWindowsRe.exec(filename).slice(1);
  }
  win32.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
  var posix = {};
  function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  }
  posix.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  if (isWindows)
    module.exports = win32.parse;
  else
    module.exports = posix.parse;
  module.exports.posix = posix.parse;
  module.exports.win32 = win32.parse;
});

// ../../node_modules/require-in-the-middle/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS((exports, module) => {
  var path7 = __require("path");
  var parse = path7.parse || require_path_parse();
  var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
      return dirs.concat(modules.map(function(moduleDir) {
        return path7.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };
  module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    if (opts && typeof opts.paths === "function") {
      return opts.paths(request, start, function() {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// ../../node_modules/require-in-the-middle/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS((exports, module) => {
  module.exports = function(x, opts) {
    return opts || {};
  };
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = require_function_bind();
  module.exports = bind.call(call, $hasOwn);
});

// ../../node_modules/is-core-module/core.json
var require_core = __commonJS((exports, module) => {
  module.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// ../../node_modules/is-core-module/index.js
var require_is_core_module = __commonJS((exports, module) => {
  var hasOwn = require_hasown();
  function specifierIncluded(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0;i < 3; ++i) {
      var cur = parseInt(nodeParts[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      }
      if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  }
  function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0;i < specifiers.length; ++i) {
      if (!specifierIncluded(current, specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
    if (typeof current !== "string") {
      throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0;i < specifierValue.length; ++i) {
        if (matchesRange(current, specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(current, specifierValue);
  }
  var data = require_core();
  module.exports = function isCore(x, nodeVersion) {
    return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
  };
});

// ../../node_modules/require-in-the-middle/node_modules/resolve/lib/async.js
var require_async = __commonJS((exports, module) => {
  var fs6 = __require("fs");
  var getHomedir = require_homedir();
  var path7 = __require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var isCore = require_is_core_module();
  var realpathFS = process.platform !== "win32" && fs6.realpath && typeof fs6.realpath.native === "function" ? fs6.realpath.native : fs6.realpath;
  var homedir = getHomedir();
  var defaultPaths = function() {
    return [
      path7.join(homedir, ".node_modules"),
      path7.join(homedir, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file, cb) {
    fs6.stat(file, function(err, stat) {
      if (!err) {
        return cb(null, stat.isFile() || stat.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultIsDir = function isDirectory(dir, cb) {
    fs6.stat(dir, function(err, stat) {
      if (!err) {
        return cb(null, stat.isDirectory());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
      if (realpathErr && realpathErr.code !== "ENOENT")
        cb(realpathErr);
      else
        cb(null, realpathErr ? x : realPath);
    });
  };
  var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
      realpath(x, cb);
    } else {
      cb(null, x);
    }
  };
  var defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {
    readFile(pkgfile, function(readFileErr, body) {
      if (readFileErr)
        cb(readFileErr);
      else {
        try {
          var pkg = JSON.parse(body);
          cb(null, pkg);
        } catch (jsonErr) {
          cb(null);
        }
      }
    });
  };
  var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0;i < dirs.length; i++) {
      dirs[i] = path7.join(dirs[i], x);
    }
    return dirs;
  };
  module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof x !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb(err);
      });
    }
    opts = normalizeOptions(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs6.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
      var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
      return process.nextTick(function() {
        cb(conflictErr);
      });
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path7.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = path7.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
      if (err2)
        cb(err2);
      else
        init(realStart);
    });
    var res;
    function init(basedir2) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        res = path7.resolve(basedir2, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        if (/\/$/.test(x) && res === basedir2) {
          loadAsDirectory(res, opts.package, onfile);
        } else
          loadAsFile(res, opts.package, onfile);
      } else if (includeCoreModules && isCore(x)) {
        return cb(null, x);
      } else
        loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2)
            cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function onfile(err2, m, pkg) {
      if (err2)
        cb(err2);
      else if (m)
        cb(null, m, pkg);
      else
        loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3)
            cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function loadAsFile(x2, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb2 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb2 = loadAsFilePackage;
        loadAsFilePackage = undefined;
      }
      var exts = [""].concat(extensions);
      load(exts, x2, loadAsFilePackage);
      function load(exts2, x3, loadPackage) {
        if (exts2.length === 0)
          return cb2(null, undefined, loadPackage);
        var file = x3 + exts2[0];
        var pkg = loadPackage;
        if (pkg)
          onpkg(null, pkg);
        else
          loadpkg(path7.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg = pkg_;
          if (err2)
            return cb2(err2);
          if (dir && pkg && opts.pathFilter) {
            var rfile = path7.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r = opts.pathFilter(pkg, x3, rel);
            if (r)
              return load([""].concat(extensions.slice()), path7.resolve(dir, r), pkg);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb2(err2);
          if (ex)
            return cb2(null, file, pkg);
          load(exts2.slice(1), x3, pkg);
        }
      }
    }
    function loadpkg(dir, cb2) {
      if (dir === "" || dir === "/")
        return cb2(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb2(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb2(null);
      maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return loadpkg(path7.dirname(dir), cb2);
        var pkgfile = path7.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (!ex)
            return loadpkg(path7.dirname(dir), cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            cb2(null, pkg, dir);
          });
        });
      });
    }
    function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
      var cb2 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb2 = fpkg;
        fpkg = opts.package;
      }
      maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return cb2(unwrapErr);
        var pkgfile = path7.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (err2)
            return cb2(err2);
          if (!ex)
            return loadAsFile(path7.join(x2, "index"), fpkg, cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              return cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            if (pkg && pkg.main) {
              if (typeof pkg.main !== "string") {
                var mainError = new TypeError("package “" + pkg.name + "” `main` must be a string");
                mainError.code = "INVALID_PACKAGE_MAIN";
                return cb2(mainError);
              }
              if (pkg.main === "." || pkg.main === "./") {
                pkg.main = "index";
              }
              loadAsFile(path7.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                if (err4)
                  return cb2(err4);
                if (m)
                  return cb2(null, m, pkg2);
                if (!pkg2)
                  return loadAsFile(path7.join(x2, "index"), pkg2, cb2);
                var dir = path7.resolve(x2, pkg2.main);
                loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                  if (err5)
                    return cb2(err5);
                  if (n)
                    return cb2(null, n, pkg3);
                  loadAsFile(path7.join(x2, "index"), pkg3, cb2);
                });
              });
              return;
            }
            loadAsFile(path7.join(x2, "/index"), pkg, cb2);
          });
        });
      });
    }
    function processDirs(cb2, dirs) {
      if (dirs.length === 0)
        return cb2(null, undefined);
      var dir = dirs[0];
      isDirectory(path7.dirname(dir), isdir);
      function isdir(err2, isdir2) {
        if (err2)
          return cb2(err2);
        if (!isdir2)
          return processDirs(cb2, dirs.slice(1));
        loadAsFile(dir, opts.package, onfile2);
      }
      function onfile2(err2, m, pkg) {
        if (err2)
          return cb2(err2);
        if (m)
          return cb2(null, m, pkg);
        loadAsDirectory(dir, opts.package, ondir);
      }
      function ondir(err2, n, pkg) {
        if (err2)
          return cb2(err2);
        if (n)
          return cb2(null, n, pkg);
        processDirs(cb2, dirs.slice(1));
      }
    }
    function loadNodeModules(x2, start, cb2) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
    }
  };
});

// ../../node_modules/require-in-the-middle/node_modules/resolve/lib/core.json
var require_core2 = __commonJS((exports, module) => {
  module.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    "node:sea": [">= 20.12 && < 21", ">= 21.7"],
    smalloc: ">= 0.11.5 && < 3",
    "node:sqlite": ">= 23.4",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "test/mock_loader": ">= 22.3 && < 22.7",
    "node:test/mock_loader": ">= 22.3 && < 22.7",
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// ../../node_modules/require-in-the-middle/node_modules/resolve/lib/core.js
var require_core3 = __commonJS((exports, module) => {
  var isCoreModule = require_is_core_module();
  var data = require_core2();
  var core = {};
  for (mod in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
      core[mod] = isCoreModule(mod);
    }
  }
  var mod;
  module.exports = core;
});

// ../../node_modules/require-in-the-middle/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS((exports, module) => {
  var isCoreModule = require_is_core_module();
  module.exports = function isCore(x) {
    return isCoreModule(x);
  };
});

// ../../node_modules/require-in-the-middle/node_modules/resolve/lib/sync.js
var require_sync = __commonJS((exports, module) => {
  var isCore = require_is_core_module();
  var fs6 = __require("fs");
  var path7 = __require("path");
  var getHomedir = require_homedir();
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var realpathFS = process.platform !== "win32" && fs6.realpathSync && typeof fs6.realpathSync.native === "function" ? fs6.realpathSync.native : fs6.realpathSync;
  var homedir = getHomedir();
  var defaultPaths = function() {
    return [
      path7.join(homedir, ".node_modules"),
      path7.join(homedir, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file) {
    try {
      var stat = fs6.statSync(file, { throwIfNoEntry: false });
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return !!stat && (stat.isFile() || stat.isFIFO());
  };
  var defaultIsDir = function isDirectory(dir) {
    try {
      var stat = fs6.statSync(dir, { throwIfNoEntry: false });
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return !!stat && stat.isDirectory();
  };
  var defaultRealpathSync = function realpathSync(x) {
    try {
      return realpathFS(x);
    } catch (realpathErr) {
      if (realpathErr.code !== "ENOENT") {
        throw realpathErr;
      }
    }
    return x;
  };
  var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
      return realpathSync(x);
    }
    return x;
  };
  var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
      var pkg = JSON.parse(body);
      return pkg;
    } catch (jsonErr) {}
  };
  var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0;i < dirs.length; i++) {
      dirs[i] = path7.join(dirs[i], x);
    }
    return dirs;
  };
  module.exports = function resolveSync(x, options) {
    if (typeof x !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = normalizeOptions(x, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs6.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
      throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path7.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = maybeRealpathSync(realpathSync, path7.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path7.resolve(absoluteStart, x);
      if (x === "." || x === ".." || x.slice(-1) === "/")
        res += "/";
      var m = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m)
        return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x)) {
      return x;
    } else {
      var n = loadNodeModulesSync(x, absoluteStart);
      if (n)
        return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x2) {
      var pkg = loadpkg(path7.dirname(x2));
      if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
        var rfile = path7.relative(pkg.dir, x2);
        var r = opts.pathFilter(pkg.pkg, x2, rfile);
        if (r) {
          x2 = path7.resolve(pkg.dir, r);
        }
      }
      if (isFile(x2)) {
        return x2;
      }
      for (var i = 0;i < extensions.length; i++) {
        var file = x2 + extensions[i];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path7.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path7.dirname(dir));
      }
      var pkg = readPackageSync(readFileSync, pkgfile);
      if (pkg && opts.packageFilter) {
        pkg = opts.packageFilter(pkg, dir);
      }
      return { pkg, dir };
    }
    function loadAsDirectorySync(x2) {
      var pkgfile = path7.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
      if (isFile(pkgfile)) {
        try {
          var pkg = readPackageSync(readFileSync, pkgfile);
        } catch (e) {}
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, x2);
        }
        if (pkg && pkg.main) {
          if (typeof pkg.main !== "string") {
            var mainError = new TypeError("package “" + pkg.name + "” `main` must be a string");
            mainError.code = "INVALID_PACKAGE_MAIN";
            throw mainError;
          }
          if (pkg.main === "." || pkg.main === "./") {
            pkg.main = "index";
          }
          try {
            var m2 = loadAsFileSync(path7.resolve(x2, pkg.main));
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(path7.resolve(x2, pkg.main));
            if (n2)
              return n2;
          } catch (e) {}
        }
      }
      return loadAsFileSync(path7.join(x2, "/index"));
    }
    function loadNodeModulesSync(x2, start) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
      for (var i = 0;i < dirs.length; i++) {
        var dir = dirs[i];
        if (isDirectory(path7.dirname(dir))) {
          var m2 = loadAsFileSync(dir);
          if (m2)
            return m2;
          var n2 = loadAsDirectorySync(dir);
          if (n2)
            return n2;
        }
      }
    }
  };
});

// ../../node_modules/require-in-the-middle/node_modules/resolve/index.js
var require_resolve = __commonJS((exports, module) => {
  var async = require_async();
  async.core = require_core3();
  async.isCore = require_is_core();
  async.sync = require_sync();
  module.exports = async;
});

// ../../node_modules/require-in-the-middle/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "require-in-the-middle",
    version: "7.5.2",
    description: "Module to hook into the Node.js require function",
    main: "index.js",
    types: "types/index.d.ts",
    dependencies: {
      debug: "^4.3.5",
      "module-details-from-path": "^1.0.3",
      resolve: "^1.22.8"
    },
    devDependencies: {
      "@babel/core": "^7.9.0",
      "@babel/preset-env": "^7.9.5",
      "@babel/preset-typescript": "^7.9.0",
      "@babel/register": "^7.9.0",
      "ipp-printer": "^1.0.0",
      patterns: "^1.0.3",
      roundround: "^0.2.0",
      semver: "^6.3.0",
      standard: "^14.3.1",
      tape: "^4.11.0"
    },
    scripts: {
      test: "npm run test:lint && npm run test:tape && npm run test:babel",
      "test:lint": "standard",
      "test:tape": "tape test/*.js",
      "test:babel": "node test/babel/babel-register.js"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/nodejs/require-in-the-middle.git"
    },
    keywords: [
      "require",
      "hook",
      "shim",
      "shimmer",
      "shimming",
      "patch",
      "monkey",
      "monkeypatch",
      "module",
      "load"
    ],
    files: [
      "types"
    ],
    author: "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
    license: "MIT",
    bugs: {
      url: "https://github.com/nodejs/require-in-the-middle/issues"
    },
    homepage: "https://github.com/nodejs/require-in-the-middle#readme",
    engines: {
      node: ">=8.6.0"
    }
  };
});

// ../../node_modules/require-in-the-middle/index.js
var require_require_in_the_middle = __commonJS((exports, module) => {
  var path7 = __require("path");
  var Module = __require("module");
  var debug = require_src5()("require-in-the-middle");
  var moduleDetailsFromPath = require_module_details_from_path();
  module.exports = Hook;
  module.exports.Hook = Hook;
  var builtinModules;
  var isCore;
  if (Module.isBuiltin) {
    isCore = Module.isBuiltin;
  } else if (Module.builtinModules) {
    isCore = (moduleName) => {
      if (moduleName.startsWith("node:")) {
        return true;
      }
      if (builtinModules === undefined) {
        builtinModules = new Set(Module.builtinModules);
      }
      return builtinModules.has(moduleName);
    };
  } else {
    const _resolve2 = require_resolve();
    const [major, minor] = process.versions.node.split(".").map(Number);
    if (major === 8 && minor < 8) {
      isCore = (moduleName) => {
        if (moduleName === "http2") {
          return true;
        }
        return !!_resolve2.core[moduleName];
      };
    } else {
      isCore = (moduleName) => {
        return !!_resolve2.core[moduleName];
      };
    }
  }
  var _resolve;
  function resolve(moduleName, basedir) {
    if (!_resolve) {
      if (__require.resolve && __require.resolve.paths) {
        _resolve = function(moduleName2, basedir2) {
          return __require.resolve(moduleName2, { paths: [basedir2] });
        };
      } else {
        const resolve2 = require_resolve();
        _resolve = function(moduleName2, basedir2) {
          return resolve2.sync(moduleName2, { basedir: basedir2 });
        };
      }
    }
    return _resolve(moduleName, basedir);
  }
  var normalize = /([/\\]index)?(\.js)?$/;

  class ExportsCache {
    constructor() {
      this._localCache = new Map;
      this._kRitmExports = Symbol("RitmExports");
    }
    has(filename, isBuiltin) {
      if (this._localCache.has(filename)) {
        return true;
      } else if (!isBuiltin) {
        const mod = __require.cache[filename];
        return !!(mod && (this._kRitmExports in mod));
      } else {
        return false;
      }
    }
    get(filename, isBuiltin) {
      const cachedExports = this._localCache.get(filename);
      if (cachedExports !== undefined) {
        return cachedExports;
      } else if (!isBuiltin) {
        const mod = __require.cache[filename];
        return mod && mod[this._kRitmExports];
      }
    }
    set(filename, exports2, isBuiltin) {
      if (isBuiltin) {
        this._localCache.set(filename, exports2);
      } else if (filename in __require.cache) {
        __require.cache[filename][this._kRitmExports] = exports2;
      } else {
        debug('non-core module is unexpectedly not in require.cache: "%s"', filename);
        this._localCache.set(filename, exports2);
      }
    }
  }
  function Hook(modules, options, onrequire) {
    if (this instanceof Hook === false)
      return new Hook(modules, options, onrequire);
    if (typeof modules === "function") {
      onrequire = modules;
      modules = null;
      options = null;
    } else if (typeof options === "function") {
      onrequire = options;
      options = null;
    }
    if (typeof Module._resolveFilename !== "function") {
      console.error("Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!", typeof Module._resolveFilename);
      console.error("Please report this error as an issue related to Node.js %s at %s", process.version, require_package2().bugs.url);
      return;
    }
    this._cache = new ExportsCache;
    this._unhooked = false;
    this._origRequire = Module.prototype.require;
    const self = this;
    const patching = new Set;
    const internals = options ? options.internals === true : false;
    const hasWhitelist = Array.isArray(modules);
    debug("registering require hook");
    this._require = Module.prototype.require = function(id) {
      if (self._unhooked === true) {
        debug("ignoring require call - module is soft-unhooked");
        return self._origRequire.apply(this, arguments);
      }
      return patchedRequire.call(this, arguments, false);
    };
    if (typeof process.getBuiltinModule === "function") {
      this._origGetBuiltinModule = process.getBuiltinModule;
      this._getBuiltinModule = process.getBuiltinModule = function(id) {
        if (self._unhooked === true) {
          debug("ignoring process.getBuiltinModule call - module is soft-unhooked");
          return self._origGetBuiltinModule.apply(this, arguments);
        }
        return patchedRequire.call(this, arguments, true);
      };
    }
    function patchedRequire(args, coreOnly) {
      const id = args[0];
      const core = isCore(id);
      let filename;
      if (core) {
        filename = id;
        if (id.startsWith("node:")) {
          const idWithoutPrefix = id.slice(5);
          if (isCore(idWithoutPrefix)) {
            filename = idWithoutPrefix;
          }
        }
      } else if (coreOnly) {
        debug("call to process.getBuiltinModule with unknown built-in id");
        return self._origGetBuiltinModule.apply(this, args);
      } else {
        try {
          filename = Module._resolveFilename(id, this);
        } catch (resolveErr) {
          debug('Module._resolveFilename("%s") threw %j, calling original Module.require', id, resolveErr.message);
          return self._origRequire.apply(this, args);
        }
      }
      let moduleName, basedir;
      debug("processing %s module require('%s'): %s", core === true ? "core" : "non-core", id, filename);
      if (self._cache.has(filename, core) === true) {
        debug("returning already patched cached module: %s", filename);
        return self._cache.get(filename, core);
      }
      const isPatching = patching.has(filename);
      if (isPatching === false) {
        patching.add(filename);
      }
      const exports2 = coreOnly ? self._origGetBuiltinModule.apply(this, args) : self._origRequire.apply(this, args);
      if (isPatching === true) {
        debug("module is in the process of being patched already - ignoring: %s", filename);
        return exports2;
      }
      patching.delete(filename);
      if (core === true) {
        if (hasWhitelist === true && modules.includes(filename) === false) {
          debug("ignoring core module not on whitelist: %s", filename);
          return exports2;
        }
        moduleName = filename;
      } else if (hasWhitelist === true && modules.includes(filename)) {
        const parsedPath = path7.parse(filename);
        moduleName = parsedPath.name;
        basedir = parsedPath.dir;
      } else {
        const stat = moduleDetailsFromPath(filename);
        if (stat === undefined) {
          debug("could not parse filename: %s", filename);
          return exports2;
        }
        moduleName = stat.name;
        basedir = stat.basedir;
        const fullModuleName = resolveModuleName(stat);
        debug("resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)", moduleName, id, fullModuleName, basedir);
        let matchFound = false;
        if (hasWhitelist) {
          if (!id.startsWith(".") && modules.includes(id)) {
            moduleName = id;
            matchFound = true;
          }
          if (!modules.includes(moduleName) && !modules.includes(fullModuleName)) {
            return exports2;
          }
          if (modules.includes(fullModuleName) && fullModuleName !== moduleName) {
            moduleName = fullModuleName;
            matchFound = true;
          }
        }
        if (!matchFound) {
          let res;
          try {
            res = resolve(moduleName, basedir);
          } catch (e) {
            debug("could not resolve module: %s", moduleName);
            self._cache.set(filename, exports2, core);
            return exports2;
          }
          if (res !== filename) {
            if (internals === true) {
              moduleName = moduleName + path7.sep + path7.relative(basedir, filename);
              debug("preparing to process require of internal file: %s", moduleName);
            } else {
              debug("ignoring require of non-main module file: %s", res);
              self._cache.set(filename, exports2, core);
              return exports2;
            }
          }
        }
      }
      self._cache.set(filename, exports2, core);
      debug("calling require hook: %s", moduleName);
      const patchedExports = onrequire(exports2, moduleName, basedir);
      self._cache.set(filename, patchedExports, core);
      debug("returning module: %s", moduleName);
      return patchedExports;
    }
  }
  Hook.prototype.unhook = function() {
    this._unhooked = true;
    if (this._require === Module.prototype.require) {
      Module.prototype.require = this._origRequire;
      debug("require unhook successful");
    } else {
      debug("require unhook unsuccessful");
    }
    if (process.getBuiltinModule !== undefined) {
      if (this._getBuiltinModule === process.getBuiltinModule) {
        process.getBuiltinModule = this._origGetBuiltinModule;
        debug("process.getBuiltinModule unhook successful");
      } else {
        debug("process.getBuiltinModule unhook unsuccessful");
      }
    }
  };
  function resolveModuleName(stat) {
    const normalizedPath = path7.sep !== "/" ? stat.path.split(path7.sep).join("/") : stat.path;
    return path7.posix.join(stat.name, normalizedPath).replace(normalize, "");
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/node/ModuleNameTrie.js
var require_ModuleNameTrie = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ModuleNameTrie = exports.ModuleNameSeparator = undefined;
  exports.ModuleNameSeparator = "/";

  class ModuleNameTrieNode {
    hooks = [];
    children = new Map;
  }

  class ModuleNameTrie {
    _trie = new ModuleNameTrieNode;
    _counter = 0;
    insert(hook) {
      let trieNode = this._trie;
      for (const moduleNamePart of hook.moduleName.split(exports.ModuleNameSeparator)) {
        let nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          nextNode = new ModuleNameTrieNode;
          trieNode.children.set(moduleNamePart, nextNode);
        }
        trieNode = nextNode;
      }
      trieNode.hooks.push({ hook, insertedId: this._counter++ });
    }
    search(moduleName, { maintainInsertionOrder, fullOnly } = {}) {
      let trieNode = this._trie;
      const results = [];
      let foundFull = true;
      for (const moduleNamePart of moduleName.split(exports.ModuleNameSeparator)) {
        const nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          foundFull = false;
          break;
        }
        if (!fullOnly) {
          results.push(...nextNode.hooks);
        }
        trieNode = nextNode;
      }
      if (fullOnly && foundFull) {
        results.push(...trieNode.hooks);
      }
      if (results.length === 0) {
        return [];
      }
      if (results.length === 1) {
        return [results[0].hook];
      }
      if (maintainInsertionOrder) {
        results.sort((a, b) => a.insertedId - b.insertedId);
      }
      return results.map(({ hook }) => hook);
    }
  }
  exports.ModuleNameTrie = ModuleNameTrie;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/node/RequireInTheMiddleSingleton.js
var require_RequireInTheMiddleSingleton = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequireInTheMiddleSingleton = undefined;
  var require_in_the_middle_1 = require_require_in_the_middle();
  var path7 = __require("path");
  var ModuleNameTrie_1 = require_ModuleNameTrie();
  var isMocha = [
    "afterEach",
    "after",
    "beforeEach",
    "before",
    "describe",
    "it"
  ].every((fn) => {
    return typeof global[fn] === "function";
  });

  class RequireInTheMiddleSingleton {
    _moduleNameTrie = new ModuleNameTrie_1.ModuleNameTrie;
    static _instance;
    constructor() {
      this._initialize();
    }
    _initialize() {
      new require_in_the_middle_1.Hook(null, { internals: true }, (exports2, name, basedir) => {
        const normalizedModuleName = normalizePathSeparators(name);
        const matches = this._moduleNameTrie.search(normalizedModuleName, {
          maintainInsertionOrder: true,
          fullOnly: basedir === undefined
        });
        for (const { onRequire } of matches) {
          exports2 = onRequire(exports2, name, basedir);
        }
        return exports2;
      });
    }
    register(moduleName, onRequire) {
      const hooked = { moduleName, onRequire };
      this._moduleNameTrie.insert(hooked);
      return hooked;
    }
    static getInstance() {
      if (isMocha)
        return new RequireInTheMiddleSingleton;
      return this._instance = this._instance ?? new RequireInTheMiddleSingleton;
    }
  }
  exports.RequireInTheMiddleSingleton = RequireInTheMiddleSingleton;
  function normalizePathSeparators(moduleNameOrPath) {
    return path7.sep !== ModuleNameTrie_1.ModuleNameSeparator ? moduleNameOrPath.split(path7.sep).join(ModuleNameTrie_1.ModuleNameSeparator) : moduleNameOrPath;
  }
});

// ../../node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS((exports) => {
  var importHooks = [];
  var setters = new WeakMap;
  var getters = new WeakMap;
  var specifiers = new Map;
  var toHook = [];
  var proxyHandler = {
    set(target, name, value) {
      return setters.get(target)[name](value);
    },
    get(target, name) {
      if (name === Symbol.toStringTag) {
        return "Module";
      }
      const getter = getters.get(target)[name];
      if (typeof getter === "function") {
        return getter();
      }
    },
    defineProperty(target, property, descriptor) {
      if (!("value" in descriptor)) {
        throw new Error("Getters/setters are not supported for exports property descriptors.");
      }
      return setters.get(target)[property](descriptor.value);
    }
  };
  function register(name, namespace, set, get, specifier) {
    specifiers.set(name, specifier);
    setters.set(namespace, set);
    getters.set(namespace, get);
    const proxy = new Proxy(namespace, proxyHandler);
    importHooks.forEach((hook) => hook(name, proxy));
    toHook.push([name, proxy]);
  }
  var experimentalPatchInternals = false;
  function getExperimentalPatchInternals() {
    return experimentalPatchInternals;
  }
  function setExperimentalPatchInternals(value) {
    experimentalPatchInternals = value;
  }
  exports.register = register;
  exports.importHooks = importHooks;
  exports.specifiers = specifiers;
  exports.toHook = toHook;
  exports.getExperimentalPatchInternals = getExperimentalPatchInternals;
  exports.setExperimentalPatchInternals = setExperimentalPatchInternals;
});

// ../../node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS((exports, module) => {
  var path7 = __require("path");
  var parse = require_module_details_from_path();
  var { fileURLToPath: fileURLToPath2 } = __require("url");
  var { MessageChannel } = __require("worker_threads");
  var {
    importHooks,
    specifiers,
    toHook,
    getExperimentalPatchInternals
  } = require_register();
  function addHook(hook) {
    importHooks.push(hook);
    toHook.forEach(([name, namespace]) => hook(name, namespace));
  }
  function removeHook(hook) {
    const index = importHooks.indexOf(hook);
    if (index > -1) {
      importHooks.splice(index, 1);
    }
  }
  function callHookFn(hookFn, namespace, name, baseDir) {
    const newDefault = hookFn(namespace, name, baseDir);
    if (newDefault && newDefault !== namespace) {
      namespace.default = newDefault;
    }
  }
  var sendModulesToLoader;
  function createAddHookMessageChannel() {
    const { port1, port2 } = new MessageChannel;
    let pendingAckCount = 0;
    let resolveFn;
    sendModulesToLoader = (modules) => {
      pendingAckCount++;
      port1.postMessage(modules);
    };
    port1.on("message", () => {
      pendingAckCount--;
      if (resolveFn && pendingAckCount <= 0) {
        resolveFn();
      }
    }).unref();
    function waitForAllMessagesAcknowledged() {
      const timer = setInterval(() => {}, 1000);
      const promise = new Promise((resolve) => {
        resolveFn = resolve;
      }).then(() => {
        clearInterval(timer);
      });
      if (pendingAckCount === 0) {
        resolveFn();
      }
      return promise;
    }
    const addHookMessagePort = port2;
    const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] };
    return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged };
  }
  function Hook(modules, options, hookFn) {
    if (this instanceof Hook === false)
      return new Hook(modules, options, hookFn);
    if (typeof modules === "function") {
      hookFn = modules;
      modules = null;
      options = null;
    } else if (typeof options === "function") {
      hookFn = options;
      options = null;
    }
    const internals = options ? options.internals === true : false;
    if (sendModulesToLoader && Array.isArray(modules)) {
      sendModulesToLoader(modules);
    }
    this._iitmHook = (name, namespace) => {
      const filename = name;
      const isBuiltin = name.startsWith("node:");
      let baseDir;
      if (isBuiltin) {
        name = name.replace(/^node:/, "");
      } else {
        if (name.startsWith("file://")) {
          try {
            name = fileURLToPath2(name);
          } catch (e) {}
        }
        const details = parse(name);
        if (details) {
          name = details.name;
          baseDir = details.basedir;
        }
      }
      if (modules) {
        for (const moduleName of modules) {
          if (moduleName === name) {
            if (baseDir) {
              if (internals) {
                name = name + path7.sep + path7.relative(baseDir, fileURLToPath2(filename));
              } else {
                if (!getExperimentalPatchInternals() && !baseDir.endsWith(specifiers.get(filename)))
                  continue;
              }
            }
            callHookFn(hookFn, namespace, name, baseDir);
          }
        }
      } else {
        callHookFn(hookFn, namespace, name, baseDir);
      }
    };
    addHook(this._iitmHook);
  }
  Hook.prototype.unhook = function() {
    removeHook(this._iitmHook);
  };
  module.exports = Hook;
  module.exports.Hook = Hook;
  module.exports.addHook = addHook;
  module.exports.removeHook = removeHook;
  module.exports.createAddHookMessageChannel = createAddHookMessageChannel;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/utils.js
var require_utils5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isWrapped = exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = undefined;
  function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
      result = execute();
    } catch (e) {
      error = e;
    } finally {
      onFinish(error, result);
      if (error && !preventThrowingError) {
        throw error;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddle = safeExecuteInTheMiddle;
  async function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
      result = await execute();
    } catch (e) {
      error = e;
    } finally {
      onFinish(error, result);
      if (error && !preventThrowingError) {
        throw error;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddleAsync = safeExecuteInTheMiddleAsync;
  function isWrapped(func) {
    return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
  }
  exports.isWrapped = isWrapped;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/node/instrumentation.js
var require_instrumentation2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationBase = undefined;
  var path7 = __require("path");
  var util_1 = __require("util");
  var semver_1 = require_semver2();
  var shimmer_1 = require_shimmer();
  var instrumentation_1 = require_instrumentation();
  var RequireInTheMiddleSingleton_1 = require_RequireInTheMiddleSingleton();
  var import_in_the_middle_1 = require_import_in_the_middle();
  var api_1 = require_src();
  var require_in_the_middle_1 = require_require_in_the_middle();
  var fs_1 = __require("fs");
  var utils_1 = require_utils5();

  class InstrumentationBase extends instrumentation_1.InstrumentationAbstract {
    _modules;
    _hooks = [];
    _requireInTheMiddleSingleton = RequireInTheMiddleSingleton_1.RequireInTheMiddleSingleton.getInstance();
    _enabled = false;
    constructor(instrumentationName, instrumentationVersion, config) {
      super(instrumentationName, instrumentationVersion, config);
      let modules = this.init();
      if (modules && !Array.isArray(modules)) {
        modules = [modules];
      }
      this._modules = modules || [];
      if (this._config.enabled) {
        this.enable();
      }
    }
    _wrap = (moduleExports, name, wrapper) => {
      if ((0, utils_1.isWrapped)(moduleExports[name])) {
        this._unwrap(moduleExports, name);
      }
      if (!util_1.types.isProxy(moduleExports)) {
        return (0, shimmer_1.wrap)(moduleExports, name, wrapper);
      } else {
        const wrapped = (0, shimmer_1.wrap)(Object.assign({}, moduleExports), name, wrapper);
        Object.defineProperty(moduleExports, name, {
          value: wrapped
        });
        return wrapped;
      }
    };
    _unwrap = (moduleExports, name) => {
      if (!util_1.types.isProxy(moduleExports)) {
        return (0, shimmer_1.unwrap)(moduleExports, name);
      } else {
        return Object.defineProperty(moduleExports, name, {
          value: moduleExports[name]
        });
      }
    };
    _massWrap = (moduleExportsArray, names, wrapper) => {
      if (!moduleExportsArray) {
        api_1.diag.error("must provide one or more modules to patch");
        return;
      } else if (!Array.isArray(moduleExportsArray)) {
        moduleExportsArray = [moduleExportsArray];
      }
      if (!(names && Array.isArray(names))) {
        api_1.diag.error("must provide one or more functions to wrap on modules");
        return;
      }
      moduleExportsArray.forEach((moduleExports) => {
        names.forEach((name) => {
          this._wrap(moduleExports, name, wrapper);
        });
      });
    };
    _massUnwrap = (moduleExportsArray, names) => {
      if (!moduleExportsArray) {
        api_1.diag.error("must provide one or more modules to patch");
        return;
      } else if (!Array.isArray(moduleExportsArray)) {
        moduleExportsArray = [moduleExportsArray];
      }
      if (!(names && Array.isArray(names))) {
        api_1.diag.error("must provide one or more functions to wrap on modules");
        return;
      }
      moduleExportsArray.forEach((moduleExports) => {
        names.forEach((name) => {
          this._unwrap(moduleExports, name);
        });
      });
    };
    _warnOnPreloadedModules() {
      this._modules.forEach((module2) => {
        const { name } = module2;
        try {
          const resolvedModule = __require.resolve(name);
          if (__require.cache[resolvedModule]) {
            this._diag.warn(`Module ${name} has been loaded before ${this.instrumentationName} so it might not work, please initialize it before requiring ${name}`);
          }
        } catch {}
      });
    }
    _extractPackageVersion(baseDir) {
      try {
        const json = (0, fs_1.readFileSync)(path7.join(baseDir, "package.json"), {
          encoding: "utf8"
        });
        const version = JSON.parse(json).version;
        return typeof version === "string" ? version : undefined;
      } catch {
        api_1.diag.warn("Failed extracting version", baseDir);
      }
      return;
    }
    _onRequire(module2, exports2, name, baseDir) {
      if (!baseDir) {
        if (typeof module2.patch === "function") {
          module2.moduleExports = exports2;
          if (this._enabled) {
            this._diag.debug("Applying instrumentation patch for nodejs core module on require hook", {
              module: module2.name
            });
            return module2.patch(exports2);
          }
        }
        return exports2;
      }
      const version = this._extractPackageVersion(baseDir);
      module2.moduleVersion = version;
      if (module2.name === name) {
        if (isSupported(module2.supportedVersions, version, module2.includePrerelease)) {
          if (typeof module2.patch === "function") {
            module2.moduleExports = exports2;
            if (this._enabled) {
              this._diag.debug("Applying instrumentation patch for module on require hook", {
                module: module2.name,
                version: module2.moduleVersion,
                baseDir
              });
              return module2.patch(exports2, module2.moduleVersion);
            }
          }
        }
        return exports2;
      }
      const files = module2.files ?? [];
      const normalizedName = path7.normalize(name);
      const supportedFileInstrumentations = files.filter((f) => f.name === normalizedName).filter((f) => isSupported(f.supportedVersions, version, module2.includePrerelease));
      return supportedFileInstrumentations.reduce((patchedExports, file) => {
        file.moduleExports = patchedExports;
        if (this._enabled) {
          this._diag.debug("Applying instrumentation patch for nodejs module file on require hook", {
            module: module2.name,
            version: module2.moduleVersion,
            fileName: file.name,
            baseDir
          });
          return file.patch(patchedExports, module2.moduleVersion);
        }
        return patchedExports;
      }, exports2);
    }
    enable() {
      if (this._enabled) {
        return;
      }
      this._enabled = true;
      if (this._hooks.length > 0) {
        for (const module2 of this._modules) {
          if (typeof module2.patch === "function" && module2.moduleExports) {
            this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled", {
              module: module2.name,
              version: module2.moduleVersion
            });
            module2.patch(module2.moduleExports, module2.moduleVersion);
          }
          for (const file of module2.files) {
            if (file.moduleExports) {
              this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled", {
                module: module2.name,
                version: module2.moduleVersion,
                fileName: file.name
              });
              file.patch(file.moduleExports, module2.moduleVersion);
            }
          }
        }
        return;
      }
      this._warnOnPreloadedModules();
      for (const module2 of this._modules) {
        const hookFn = (exports2, name, baseDir) => {
          if (!baseDir && path7.isAbsolute(name)) {
            const parsedPath = path7.parse(name);
            name = parsedPath.name;
            baseDir = parsedPath.dir;
          }
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const onRequire = (exports2, name, baseDir) => {
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const hook = path7.isAbsolute(module2.name) ? new require_in_the_middle_1.Hook([module2.name], { internals: true }, onRequire) : this._requireInTheMiddleSingleton.register(module2.name, onRequire);
        this._hooks.push(hook);
        const esmHook = new import_in_the_middle_1.Hook([module2.name], { internals: false }, hookFn);
        this._hooks.push(esmHook);
      }
    }
    disable() {
      if (!this._enabled) {
        return;
      }
      this._enabled = false;
      for (const module2 of this._modules) {
        if (typeof module2.unpatch === "function" && module2.moduleExports) {
          this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled", {
            module: module2.name,
            version: module2.moduleVersion
          });
          module2.unpatch(module2.moduleExports, module2.moduleVersion);
        }
        for (const file of module2.files) {
          if (file.moduleExports) {
            this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled", {
              module: module2.name,
              version: module2.moduleVersion,
              fileName: file.name
            });
            file.unpatch(file.moduleExports, module2.moduleVersion);
          }
        }
      }
    }
    isEnabled() {
      return this._enabled;
    }
  }
  exports.InstrumentationBase = InstrumentationBase;
  function isSupported(supportedVersions, version, includePrerelease) {
    if (typeof version === "undefined") {
      return supportedVersions.includes("*");
    }
    return supportedVersions.some((supportedVersion) => {
      return (0, semver_1.satisfies)(version, supportedVersion, { includePrerelease });
    });
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/node/normalize.js
var require_normalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = undefined;
  var path_1 = __require("path");
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return path_1.normalize;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/node/index.js
var require_node5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var instrumentation_1 = require_instrumentation2();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return instrumentation_1.InstrumentationBase;
  } });
  var normalize_1 = require_normalize();
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return normalize_1.normalize;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/index.js
var require_platform4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var node_1 = require_node5();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return node_1.InstrumentationBase;
  } });
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return node_1.normalize;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleDefinition.js
var require_instrumentationNodeModuleDefinition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleDefinition = undefined;

  class InstrumentationNodeModuleDefinition {
    name;
    supportedVersions;
    patch;
    unpatch;
    files;
    constructor(name, supportedVersions, patch, unpatch, files) {
      this.name = name;
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.files = files || [];
    }
  }
  exports.InstrumentationNodeModuleDefinition = InstrumentationNodeModuleDefinition;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleFile.js
var require_instrumentationNodeModuleFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleFile = undefined;
  var index_1 = require_platform4();

  class InstrumentationNodeModuleFile {
    supportedVersions;
    patch;
    unpatch;
    name;
    constructor(name, supportedVersions, patch, unpatch) {
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.name = (0, index_1.normalize)(name);
    }
  }
  exports.InstrumentationNodeModuleFile = InstrumentationNodeModuleFile;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/semconvStability.js
var require_semconvStability = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.semconvStabilityFromStr = exports.SemconvStability = undefined;
  var SemconvStability;
  (function(SemconvStability2) {
    SemconvStability2[SemconvStability2["STABLE"] = 1] = "STABLE";
    SemconvStability2[SemconvStability2["OLD"] = 2] = "OLD";
    SemconvStability2[SemconvStability2["DUPLICATE"] = 3] = "DUPLICATE";
  })(SemconvStability = exports.SemconvStability || (exports.SemconvStability = {}));
  function semconvStabilityFromStr(namespace, str) {
    let semconvStability = SemconvStability.OLD;
    const entries = str?.split(",").map((v) => v.trim()).filter((s) => s !== "");
    for (const entry of entries ?? []) {
      if (entry.toLowerCase() === namespace + "/dup") {
        semconvStability = SemconvStability.DUPLICATE;
        break;
      } else if (entry.toLowerCase() === namespace) {
        semconvStability = SemconvStability.STABLE;
      }
    }
    return semconvStability;
  }
  exports.semconvStabilityFromStr = semconvStabilityFromStr;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/index.js
var require_src6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.semconvStabilityFromStr = exports.SemconvStability = exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = exports.isWrapped = exports.InstrumentationNodeModuleFile = exports.InstrumentationNodeModuleDefinition = exports.InstrumentationBase = exports.registerInstrumentations = undefined;
  var autoLoader_1 = require_autoLoader();
  Object.defineProperty(exports, "registerInstrumentations", { enumerable: true, get: function() {
    return autoLoader_1.registerInstrumentations;
  } });
  var index_1 = require_platform4();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return index_1.InstrumentationBase;
  } });
  var instrumentationNodeModuleDefinition_1 = require_instrumentationNodeModuleDefinition();
  Object.defineProperty(exports, "InstrumentationNodeModuleDefinition", { enumerable: true, get: function() {
    return instrumentationNodeModuleDefinition_1.InstrumentationNodeModuleDefinition;
  } });
  var instrumentationNodeModuleFile_1 = require_instrumentationNodeModuleFile();
  Object.defineProperty(exports, "InstrumentationNodeModuleFile", { enumerable: true, get: function() {
    return instrumentationNodeModuleFile_1.InstrumentationNodeModuleFile;
  } });
  var utils_1 = require_utils5();
  Object.defineProperty(exports, "isWrapped", { enumerable: true, get: function() {
    return utils_1.isWrapped;
  } });
  Object.defineProperty(exports, "safeExecuteInTheMiddle", { enumerable: true, get: function() {
    return utils_1.safeExecuteInTheMiddle;
  } });
  Object.defineProperty(exports, "safeExecuteInTheMiddleAsync", { enumerable: true, get: function() {
    return utils_1.safeExecuteInTheMiddleAsync;
  } });
  var semconvStability_1 = require_semconvStability();
  Object.defineProperty(exports, "SemconvStability", { enumerable: true, get: function() {
    return semconvStability_1.SemconvStability;
  } });
  Object.defineProperty(exports, "semconvStabilityFromStr", { enumerable: true, get: function() {
    return semconvStability_1.semconvStabilityFromStr;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/semconv.js
var require_semconv2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTTP_FLAVOR_VALUE_HTTP_1_1 = exports.NET_TRANSPORT_VALUE_IP_UDP = exports.NET_TRANSPORT_VALUE_IP_TCP = exports.ATTR_NET_TRANSPORT = exports.ATTR_NET_PEER_PORT = exports.ATTR_NET_PEER_NAME = exports.ATTR_NET_PEER_IP = exports.ATTR_NET_HOST_PORT = exports.ATTR_NET_HOST_NAME = exports.ATTR_NET_HOST_IP = exports.ATTR_HTTP_USER_AGENT = exports.ATTR_HTTP_URL = exports.ATTR_HTTP_TARGET = exports.ATTR_HTTP_STATUS_CODE = exports.ATTR_HTTP_SERVER_NAME = exports.ATTR_HTTP_SCHEME = exports.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.ATTR_HTTP_RESPONSE_CONTENT_LENGTH = exports.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.ATTR_HTTP_REQUEST_CONTENT_LENGTH = exports.ATTR_HTTP_METHOD = exports.ATTR_HTTP_HOST = exports.ATTR_HTTP_FLAVOR = exports.ATTR_HTTP_CLIENT_IP = exports.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST = exports.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT = exports.ATTR_USER_AGENT_SYNTHETIC_TYPE = undefined;
  exports.ATTR_USER_AGENT_SYNTHETIC_TYPE = "user_agent.synthetic.type";
  exports.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT = "bot";
  exports.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST = "test";
  exports.ATTR_HTTP_CLIENT_IP = "http.client_ip";
  exports.ATTR_HTTP_FLAVOR = "http.flavor";
  exports.ATTR_HTTP_HOST = "http.host";
  exports.ATTR_HTTP_METHOD = "http.method";
  exports.ATTR_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
  exports.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
  exports.ATTR_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
  exports.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
  exports.ATTR_HTTP_SCHEME = "http.scheme";
  exports.ATTR_HTTP_SERVER_NAME = "http.server_name";
  exports.ATTR_HTTP_STATUS_CODE = "http.status_code";
  exports.ATTR_HTTP_TARGET = "http.target";
  exports.ATTR_HTTP_URL = "http.url";
  exports.ATTR_HTTP_USER_AGENT = "http.user_agent";
  exports.ATTR_NET_HOST_IP = "net.host.ip";
  exports.ATTR_NET_HOST_NAME = "net.host.name";
  exports.ATTR_NET_HOST_PORT = "net.host.port";
  exports.ATTR_NET_PEER_IP = "net.peer.ip";
  exports.ATTR_NET_PEER_NAME = "net.peer.name";
  exports.ATTR_NET_PEER_PORT = "net.peer.port";
  exports.ATTR_NET_TRANSPORT = "net.transport";
  exports.NET_TRANSPORT_VALUE_IP_TCP = "ip_tcp";
  exports.NET_TRANSPORT_VALUE_IP_UDP = "ip_udp";
  exports.HTTP_FLAVOR_VALUE_HTTP_1_1 = "1.1";
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js
var require_AttributeNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["HTTP_ERROR_NAME"] = "http.error_name";
    AttributeNames2["HTTP_ERROR_MESSAGE"] = "http.error_message";
    AttributeNames2["HTTP_STATUS_TEXT"] = "http.status_text";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/internal-types.js
var require_internal_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_QUERY_STRINGS_TO_REDACT = exports.STR_REDACTED = exports.SYNTHETIC_BOT_NAMES = exports.SYNTHETIC_TEST_NAMES = undefined;
  exports.SYNTHETIC_TEST_NAMES = ["alwayson"];
  exports.SYNTHETIC_BOT_NAMES = ["googlebot", "bingbot"];
  exports.STR_REDACTED = "REDACTED";
  exports.DEFAULT_QUERY_STRINGS_TO_REDACT = [
    "sig",
    "Signature",
    "AWSAccessKeyId",
    "X-Goog-Signature"
  ];
});

// ../../node_modules/forwarded-parse/lib/error.js
var require_error = __commonJS((exports, module) => {
  var util = __require("util");
  function ParseError(message, input) {
    Error.captureStackTrace(this, ParseError);
    this.name = this.constructor.name;
    this.message = message;
    this.input = input;
  }
  util.inherits(ParseError, Error);
  module.exports = ParseError;
});

// ../../node_modules/forwarded-parse/lib/ascii.js
var require_ascii = __commonJS((exports, module) => {
  function isDelimiter(code) {
    return code === 34 || code === 40 || code === 41 || code === 44 || code === 47 || code >= 58 && code <= 64 || code >= 91 && code <= 93 || code === 123 || code === 125;
  }
  function isTokenChar(code) {
    return code === 33 || code >= 35 && code <= 39 || code === 42 || code === 43 || code === 45 || code === 46 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 94 && code <= 122 || code === 124 || code === 126;
  }
  function isPrint(code) {
    return code >= 32 && code <= 126;
  }
  function isExtended(code) {
    return code >= 128 && code <= 255;
  }
  module.exports = {
    isDelimiter,
    isTokenChar,
    isExtended,
    isPrint
  };
});

// ../../node_modules/forwarded-parse/index.js
var require_forwarded_parse = __commonJS((exports, module) => {
  var util = __require("util");
  var ParseError = require_error();
  var ascii = require_ascii();
  var isDelimiter = ascii.isDelimiter;
  var isTokenChar = ascii.isTokenChar;
  var isExtended = ascii.isExtended;
  var isPrint = ascii.isPrint;
  function decode(str) {
    return str.replace(/\\(.)/g, "$1");
  }
  function unexpectedCharacterMessage(header, position) {
    return util.format("Unexpected character '%s' at index %d", header.charAt(position), position);
  }
  function parse(header) {
    var mustUnescape = false;
    var isEscaping = false;
    var inQuotes = false;
    var forwarded = {};
    var output = [];
    var start = -1;
    var end = -1;
    var parameter;
    var code;
    for (var i = 0;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (parameter === undefined) {
        if (i !== 0 && start === -1 && (code === 32 || code === 9)) {
          continue;
        }
        if (isTokenChar(code)) {
          if (start === -1)
            start = i;
        } else if (code === 61 && start !== -1) {
          parameter = header.slice(start, i).toLowerCase();
          start = -1;
        } else {
          throw new ParseError(unexpectedCharacterMessage(header, i), header);
        }
      } else {
        if (isEscaping && (code === 9 || isPrint(code) || isExtended(code))) {
          isEscaping = false;
        } else if (isTokenChar(code)) {
          if (end !== -1) {
            throw new ParseError(unexpectedCharacterMessage(header, i), header);
          }
          if (start === -1)
            start = i;
        } else if (isDelimiter(code) || isExtended(code)) {
          if (inQuotes) {
            if (code === 34) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              if (start === -1)
                start = i;
              isEscaping = mustUnescape = true;
            } else if (start === -1) {
              start = i;
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if ((code === 44 || code === 59) && (start !== -1 || end !== -1)) {
            if (start !== -1) {
              if (end === -1)
                end = i;
              forwarded[parameter] = mustUnescape ? decode(header.slice(start, end)) : header.slice(start, end);
            } else {
              forwarded[parameter] = "";
            }
            if (code === 44) {
              output.push(forwarded);
              forwarded = {};
            }
            parameter = undefined;
            start = end = -1;
          } else {
            throw new ParseError(unexpectedCharacterMessage(header, i), header);
          }
        } else if (code === 32 || code === 9) {
          if (end !== -1)
            continue;
          if (inQuotes) {
            if (start === -1)
              start = i;
          } else if (start !== -1) {
            end = i;
          } else {
            throw new ParseError(unexpectedCharacterMessage(header, i), header);
          }
        } else {
          throw new ParseError(unexpectedCharacterMessage(header, i), header);
        }
      }
    }
    if (parameter === undefined || inQuotes || start === -1 && end === -1 || code === 32 || code === 9) {
      throw new ParseError("Unexpected end of input", header);
    }
    if (start !== -1) {
      if (end === -1)
        end = i;
      forwarded[parameter] = mustUnescape ? decode(header.slice(start, end)) : header.slice(start, end);
    } else {
      forwarded[parameter] = "";
    }
    output.push(forwarded);
    return output;
  }
  module.exports = parse;
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/utils.js
var require_utils6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headerCapture = exports.getIncomingStableRequestMetricAttributesOnResponse = exports.getIncomingRequestMetricAttributesOnResponse = exports.getIncomingRequestAttributesOnResponse = exports.getIncomingRequestMetricAttributes = exports.getIncomingRequestAttributes = exports.getRemoteClientAddress = exports.getOutgoingStableRequestMetricAttributesOnResponse = exports.getOutgoingRequestMetricAttributesOnResponse = exports.getOutgoingRequestAttributesOnResponse = exports.setAttributesFromHttpKind = exports.getOutgoingRequestMetricAttributes = exports.getOutgoingRequestAttributes = exports.extractHostnameAndPort = exports.isValidOptionsType = exports.getRequestInfo = exports.isCompressed = exports.setResponseContentLengthAttribute = exports.setRequestContentLengthAttribute = exports.setSpanWithError = exports.satisfiesPattern = exports.parseResponseStatus = exports.getAbsoluteUrl = undefined;
  var api_1 = require_src();
  var semantic_conventions_1 = require_src2();
  var semconv_1 = require_semconv2();
  var core_1 = require_src3();
  var instrumentation_1 = require_src6();
  var url = __require("url");
  var AttributeNames_1 = require_AttributeNames();
  var internal_types_1 = require_internal_types();
  var internal_types_2 = require_internal_types();
  var forwardedParse = require_forwarded_parse();
  var getAbsoluteUrl = (requestUrl, headers, fallbackProtocol = "http:", redactedQueryParams = Array.from(internal_types_2.DEFAULT_QUERY_STRINGS_TO_REDACT)) => {
    const reqUrlObject = requestUrl || {};
    const protocol = reqUrlObject.protocol || fallbackProtocol;
    const port = (reqUrlObject.port || "").toString();
    let path7 = reqUrlObject.path || "/";
    let host = reqUrlObject.host || reqUrlObject.hostname || headers.host || "localhost";
    if (host.indexOf(":") === -1 && port && port !== "80" && port !== "443") {
      host += `:${port}`;
    }
    if (path7.includes("?")) {
      const parsedUrl = url.parse(path7);
      const pathname = parsedUrl.pathname || "";
      const query = parsedUrl.query || "";
      const searchParams = new URLSearchParams(query);
      const sensitiveParamsToRedact = redactedQueryParams || [];
      for (const sensitiveParam of sensitiveParamsToRedact) {
        if (searchParams.has(sensitiveParam) && searchParams.get(sensitiveParam) !== "") {
          searchParams.set(sensitiveParam, internal_types_2.STR_REDACTED);
        }
      }
      const redactedQuery = searchParams.toString();
      path7 = `${pathname}?${redactedQuery}`;
    }
    const authPart = reqUrlObject.auth ? `${internal_types_2.STR_REDACTED}:${internal_types_2.STR_REDACTED}@` : "";
    return `${protocol}//${authPart}${host}${path7}`;
  };
  exports.getAbsoluteUrl = getAbsoluteUrl;
  var parseResponseStatus = (kind, statusCode) => {
    const upperBound = kind === api_1.SpanKind.CLIENT ? 400 : 500;
    if (statusCode && statusCode >= 100 && statusCode < upperBound) {
      return api_1.SpanStatusCode.UNSET;
    }
    return api_1.SpanStatusCode.ERROR;
  };
  exports.parseResponseStatus = parseResponseStatus;
  var satisfiesPattern = (constant, pattern) => {
    if (typeof pattern === "string") {
      return pattern === constant;
    } else if (pattern instanceof RegExp) {
      return pattern.test(constant);
    } else if (typeof pattern === "function") {
      return pattern(constant);
    } else {
      throw new TypeError("Pattern is in unsupported datatype");
    }
  };
  exports.satisfiesPattern = satisfiesPattern;
  var setSpanWithError = (span, error, semconvStability) => {
    const message = error.message;
    if (semconvStability & instrumentation_1.SemconvStability.OLD) {
      span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_NAME, error.name);
      span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_MESSAGE, message);
    }
    if (semconvStability & instrumentation_1.SemconvStability.STABLE) {
      span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, error.name);
    }
    span.setStatus({ code: api_1.SpanStatusCode.ERROR, message });
    span.recordException(error);
  };
  exports.setSpanWithError = setSpanWithError;
  var setRequestContentLengthAttribute = (request, attributes) => {
    const length = getContentLength(request.headers);
    if (length === null)
      return;
    if ((0, exports.isCompressed)(request.headers)) {
      attributes[semconv_1.ATTR_HTTP_REQUEST_CONTENT_LENGTH] = length;
    } else {
      attributes[semconv_1.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = length;
    }
  };
  exports.setRequestContentLengthAttribute = setRequestContentLengthAttribute;
  var setResponseContentLengthAttribute = (response, attributes) => {
    const length = getContentLength(response.headers);
    if (length === null)
      return;
    if ((0, exports.isCompressed)(response.headers)) {
      attributes[semconv_1.ATTR_HTTP_RESPONSE_CONTENT_LENGTH] = length;
    } else {
      attributes[semconv_1.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = length;
    }
  };
  exports.setResponseContentLengthAttribute = setResponseContentLengthAttribute;
  function getContentLength(headers) {
    const contentLengthHeader = headers["content-length"];
    if (contentLengthHeader === undefined)
      return null;
    const contentLength = parseInt(contentLengthHeader, 10);
    if (isNaN(contentLength))
      return null;
    return contentLength;
  }
  var isCompressed = (headers) => {
    const encoding = headers["content-encoding"];
    return !!encoding && encoding !== "identity";
  };
  exports.isCompressed = isCompressed;
  function stringUrlToHttpOptions(stringUrl) {
    const { hostname, pathname, port, username, password, search, protocol, hash, href, origin, host } = new URL(stringUrl);
    const options = {
      protocol,
      hostname: hostname && hostname[0] === "[" ? hostname.slice(1, -1) : hostname,
      hash,
      search,
      pathname,
      path: `${pathname || ""}${search || ""}`,
      href,
      origin,
      host
    };
    if (port !== "") {
      options.port = Number(port);
    }
    if (username || password) {
      options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;
    }
    return options;
  }
  var getRequestInfo = (logger30, options, extraOptions) => {
    let pathname;
    let origin;
    let optionsParsed;
    let invalidUrl = false;
    if (typeof options === "string") {
      try {
        const convertedOptions = stringUrlToHttpOptions(options);
        optionsParsed = convertedOptions;
        pathname = convertedOptions.pathname || "/";
      } catch (e) {
        invalidUrl = true;
        logger30.verbose("Unable to parse URL provided to HTTP request, using fallback to determine path. Original error:", e);
        optionsParsed = {
          path: options
        };
        pathname = optionsParsed.path || "/";
      }
      origin = `${optionsParsed.protocol || "http:"}//${optionsParsed.host}`;
      if (extraOptions !== undefined) {
        Object.assign(optionsParsed, extraOptions);
      }
    } else if (options instanceof url.URL) {
      optionsParsed = {
        protocol: options.protocol,
        hostname: typeof options.hostname === "string" && options.hostname.startsWith("[") ? options.hostname.slice(1, -1) : options.hostname,
        path: `${options.pathname || ""}${options.search || ""}`
      };
      if (options.port !== "") {
        optionsParsed.port = Number(options.port);
      }
      if (options.username || options.password) {
        optionsParsed.auth = `${options.username}:${options.password}`;
      }
      pathname = options.pathname;
      origin = options.origin;
      if (extraOptions !== undefined) {
        Object.assign(optionsParsed, extraOptions);
      }
    } else {
      optionsParsed = Object.assign({ protocol: options.host ? "http:" : undefined }, options);
      const hostname = optionsParsed.host || (optionsParsed.port != null ? `${optionsParsed.hostname}${optionsParsed.port}` : optionsParsed.hostname);
      origin = `${optionsParsed.protocol || "http:"}//${hostname}`;
      pathname = options.pathname;
      if (!pathname && optionsParsed.path) {
        try {
          const parsedUrl = new URL(optionsParsed.path, origin);
          pathname = parsedUrl.pathname || "/";
        } catch {
          pathname = "/";
        }
      }
    }
    const method = optionsParsed.method ? optionsParsed.method.toUpperCase() : "GET";
    return { origin, pathname, method, optionsParsed, invalidUrl };
  };
  exports.getRequestInfo = getRequestInfo;
  var isValidOptionsType = (options) => {
    if (!options) {
      return false;
    }
    const type = typeof options;
    return type === "string" || type === "object" && !Array.isArray(options);
  };
  exports.isValidOptionsType = isValidOptionsType;
  var extractHostnameAndPort = (requestOptions) => {
    if (requestOptions.hostname && requestOptions.port) {
      return { hostname: requestOptions.hostname, port: requestOptions.port };
    }
    const matches = requestOptions.host?.match(/^([^:/ ]+)(:\d{1,5})?/) || null;
    const hostname = requestOptions.hostname || (matches === null ? "localhost" : matches[1]);
    let port = requestOptions.port;
    if (!port) {
      if (matches && matches[2]) {
        port = matches[2].substring(1);
      } else {
        port = requestOptions.protocol === "https:" ? "443" : "80";
      }
    }
    return { hostname, port };
  };
  exports.extractHostnameAndPort = extractHostnameAndPort;
  var getOutgoingRequestAttributes = (requestOptions, options, semconvStability, enableSyntheticSourceDetection) => {
    const hostname = options.hostname;
    const port = options.port;
    const method = requestOptions.method ?? "GET";
    const normalizedMethod = normalizeMethod(method);
    const headers = requestOptions.headers || {};
    const userAgent = headers["user-agent"];
    const urlFull = (0, exports.getAbsoluteUrl)(requestOptions, headers, `${options.component}:`, options.redactedQueryParams);
    const oldAttributes = {
      [semconv_1.ATTR_HTTP_URL]: urlFull,
      [semconv_1.ATTR_HTTP_METHOD]: method,
      [semconv_1.ATTR_HTTP_TARGET]: requestOptions.path || "/",
      [semconv_1.ATTR_NET_PEER_NAME]: hostname,
      [semconv_1.ATTR_HTTP_HOST]: headers.host ?? `${hostname}:${port}`
    };
    const newAttributes = {
      [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,
      [semantic_conventions_1.ATTR_SERVER_ADDRESS]: hostname,
      [semantic_conventions_1.ATTR_SERVER_PORT]: Number(port),
      [semantic_conventions_1.ATTR_URL_FULL]: urlFull,
      [semantic_conventions_1.ATTR_USER_AGENT_ORIGINAL]: userAgent
    };
    if (method !== normalizedMethod) {
      newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;
    }
    if (enableSyntheticSourceDetection && userAgent) {
      newAttributes[semconv_1.ATTR_USER_AGENT_SYNTHETIC_TYPE] = getSyntheticType(userAgent);
    }
    if (userAgent !== undefined) {
      oldAttributes[semconv_1.ATTR_HTTP_USER_AGENT] = userAgent;
    }
    switch (semconvStability) {
      case instrumentation_1.SemconvStability.STABLE:
        return Object.assign(newAttributes, options.hookAttributes);
      case instrumentation_1.SemconvStability.OLD:
        return Object.assign(oldAttributes, options.hookAttributes);
    }
    return Object.assign(oldAttributes, newAttributes, options.hookAttributes);
  };
  exports.getOutgoingRequestAttributes = getOutgoingRequestAttributes;
  var getOutgoingRequestMetricAttributes = (spanAttributes) => {
    const metricAttributes = {};
    metricAttributes[semconv_1.ATTR_HTTP_METHOD] = spanAttributes[semconv_1.ATTR_HTTP_METHOD];
    metricAttributes[semconv_1.ATTR_NET_PEER_NAME] = spanAttributes[semconv_1.ATTR_NET_PEER_NAME];
    return metricAttributes;
  };
  exports.getOutgoingRequestMetricAttributes = getOutgoingRequestMetricAttributes;
  var setAttributesFromHttpKind = (kind, attributes) => {
    if (kind) {
      attributes[semconv_1.ATTR_HTTP_FLAVOR] = kind;
      if (kind.toUpperCase() !== "QUIC") {
        attributes[semconv_1.ATTR_NET_TRANSPORT] = semconv_1.NET_TRANSPORT_VALUE_IP_TCP;
      } else {
        attributes[semconv_1.ATTR_NET_TRANSPORT] = semconv_1.NET_TRANSPORT_VALUE_IP_UDP;
      }
    }
  };
  exports.setAttributesFromHttpKind = setAttributesFromHttpKind;
  var getSyntheticType = (userAgent) => {
    const userAgentString = String(userAgent).toLowerCase();
    for (const name of internal_types_1.SYNTHETIC_TEST_NAMES) {
      if (userAgentString.includes(name)) {
        return semconv_1.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST;
      }
    }
    for (const name of internal_types_1.SYNTHETIC_BOT_NAMES) {
      if (userAgentString.includes(name)) {
        return semconv_1.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT;
      }
    }
    return;
  };
  var getOutgoingRequestAttributesOnResponse = (response, semconvStability) => {
    const { statusCode, statusMessage, httpVersion, socket } = response;
    const oldAttributes = {};
    const stableAttributes = {};
    if (statusCode != null) {
      stableAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = statusCode;
    }
    if (socket) {
      const { remoteAddress, remotePort } = socket;
      oldAttributes[semconv_1.ATTR_NET_PEER_IP] = remoteAddress;
      oldAttributes[semconv_1.ATTR_NET_PEER_PORT] = remotePort;
      stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS] = remoteAddress;
      stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_PORT] = remotePort;
      stableAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = response.httpVersion;
    }
    (0, exports.setResponseContentLengthAttribute)(response, oldAttributes);
    if (statusCode) {
      oldAttributes[semconv_1.ATTR_HTTP_STATUS_CODE] = statusCode;
      oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || "").toUpperCase();
    }
    (0, exports.setAttributesFromHttpKind)(httpVersion, oldAttributes);
    switch (semconvStability) {
      case instrumentation_1.SemconvStability.STABLE:
        return stableAttributes;
      case instrumentation_1.SemconvStability.OLD:
        return oldAttributes;
    }
    return Object.assign(oldAttributes, stableAttributes);
  };
  exports.getOutgoingRequestAttributesOnResponse = getOutgoingRequestAttributesOnResponse;
  var getOutgoingRequestMetricAttributesOnResponse = (spanAttributes) => {
    const metricAttributes = {};
    metricAttributes[semconv_1.ATTR_NET_PEER_PORT] = spanAttributes[semconv_1.ATTR_NET_PEER_PORT];
    metricAttributes[semconv_1.ATTR_HTTP_STATUS_CODE] = spanAttributes[semconv_1.ATTR_HTTP_STATUS_CODE];
    metricAttributes[semconv_1.ATTR_HTTP_FLAVOR] = spanAttributes[semconv_1.ATTR_HTTP_FLAVOR];
    return metricAttributes;
  };
  exports.getOutgoingRequestMetricAttributesOnResponse = getOutgoingRequestMetricAttributesOnResponse;
  var getOutgoingStableRequestMetricAttributesOnResponse = (spanAttributes) => {
    const metricAttributes = {};
    if (spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {
      metricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];
    }
    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {
      metricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];
    }
    return metricAttributes;
  };
  exports.getOutgoingStableRequestMetricAttributesOnResponse = getOutgoingStableRequestMetricAttributesOnResponse;
  function parseHostHeader(hostHeader, proto) {
    const parts = hostHeader.split(":");
    if (parts.length === 1) {
      if (proto === "http") {
        return { host: parts[0], port: "80" };
      }
      if (proto === "https") {
        return { host: parts[0], port: "443" };
      }
      return { host: parts[0] };
    }
    if (parts.length === 2) {
      return {
        host: parts[0],
        port: parts[1]
      };
    }
    if (parts[0].startsWith("[")) {
      if (parts[parts.length - 1].endsWith("]")) {
        if (proto === "http") {
          return { host: hostHeader, port: "80" };
        }
        if (proto === "https") {
          return { host: hostHeader, port: "443" };
        }
      } else if (parts[parts.length - 2].endsWith("]")) {
        return {
          host: parts.slice(0, -1).join(":"),
          port: parts[parts.length - 1]
        };
      }
    }
    return { host: hostHeader };
  }
  function getServerAddress(request, component) {
    const forwardedHeader = request.headers["forwarded"];
    if (forwardedHeader) {
      for (const entry of parseForwardedHeader(forwardedHeader)) {
        if (entry.host) {
          return parseHostHeader(entry.host, entry.proto);
        }
      }
    }
    const xForwardedHost = request.headers["x-forwarded-host"];
    if (typeof xForwardedHost === "string") {
      if (typeof request.headers["x-forwarded-proto"] === "string") {
        return parseHostHeader(xForwardedHost, request.headers["x-forwarded-proto"]);
      }
      if (Array.isArray(request.headers["x-forwarded-proto"])) {
        return parseHostHeader(xForwardedHost, request.headers["x-forwarded-proto"][0]);
      }
      return parseHostHeader(xForwardedHost);
    } else if (Array.isArray(xForwardedHost) && typeof xForwardedHost[0] === "string" && xForwardedHost[0].length > 0) {
      if (typeof request.headers["x-forwarded-proto"] === "string") {
        return parseHostHeader(xForwardedHost[0], request.headers["x-forwarded-proto"]);
      }
      if (Array.isArray(request.headers["x-forwarded-proto"])) {
        return parseHostHeader(xForwardedHost[0], request.headers["x-forwarded-proto"][0]);
      }
      return parseHostHeader(xForwardedHost[0]);
    }
    const host = request.headers["host"];
    if (typeof host === "string" && host.length > 0) {
      return parseHostHeader(host, component);
    }
    return null;
  }
  function getRemoteClientAddress(request) {
    const forwardedHeader = request.headers["forwarded"];
    if (forwardedHeader) {
      for (const entry of parseForwardedHeader(forwardedHeader)) {
        if (entry.for) {
          return entry.for;
        }
      }
    }
    const xForwardedFor = request.headers["x-forwarded-for"];
    if (typeof xForwardedFor === "string") {
      return xForwardedFor;
    } else if (Array.isArray(xForwardedFor)) {
      return xForwardedFor[0];
    }
    const remote = request.socket.remoteAddress;
    if (remote) {
      return remote;
    }
    return null;
  }
  exports.getRemoteClientAddress = getRemoteClientAddress;
  function getInfoFromIncomingMessage(component, request, logger30) {
    try {
      if (request.headers.host) {
        return new URL(request.url ?? "/", `${component}://${request.headers.host}`);
      } else {
        const unsafeParsedUrl = new URL(request.url ?? "/", `${component}://localhost`);
        return {
          pathname: unsafeParsedUrl.pathname,
          search: unsafeParsedUrl.search,
          toString: function() {
            return unsafeParsedUrl.pathname + unsafeParsedUrl.search;
          }
        };
      }
    } catch (e) {
      logger30.verbose("Unable to get URL from request", e);
      return {};
    }
  }
  var getIncomingRequestAttributes = (request, options, logger30) => {
    const headers = request.headers;
    const userAgent = headers["user-agent"];
    const ips = headers["x-forwarded-for"];
    const httpVersion = request.httpVersion;
    const host = headers.host;
    const hostname = host?.replace(/^(.*)(:[0-9]{1,5})/, "$1") || "localhost";
    const method = request.method;
    const normalizedMethod = normalizeMethod(method);
    const serverAddress = getServerAddress(request, options.component);
    const serverName = options.serverName;
    const remoteClientAddress = getRemoteClientAddress(request);
    const newAttributes = {
      [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,
      [semantic_conventions_1.ATTR_URL_SCHEME]: options.component,
      [semantic_conventions_1.ATTR_SERVER_ADDRESS]: serverAddress?.host,
      [semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS]: request.socket.remoteAddress,
      [semantic_conventions_1.ATTR_NETWORK_PEER_PORT]: request.socket.remotePort,
      [semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]: request.httpVersion,
      [semantic_conventions_1.ATTR_USER_AGENT_ORIGINAL]: userAgent
    };
    const parsedUrl = getInfoFromIncomingMessage(options.component, request, logger30);
    if (parsedUrl?.pathname != null) {
      newAttributes[semantic_conventions_1.ATTR_URL_PATH] = parsedUrl.pathname;
    }
    if (parsedUrl.search) {
      newAttributes[semantic_conventions_1.ATTR_URL_QUERY] = parsedUrl.search.slice(1);
    }
    if (remoteClientAddress != null) {
      newAttributes[semantic_conventions_1.ATTR_CLIENT_ADDRESS] = remoteClientAddress.split(",")[0];
    }
    if (serverAddress?.port != null) {
      newAttributes[semantic_conventions_1.ATTR_SERVER_PORT] = Number(serverAddress.port);
    }
    if (method !== normalizedMethod) {
      newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;
    }
    if (options.enableSyntheticSourceDetection && userAgent) {
      newAttributes[semconv_1.ATTR_USER_AGENT_SYNTHETIC_TYPE] = getSyntheticType(userAgent);
    }
    const oldAttributes = {
      [semconv_1.ATTR_HTTP_URL]: parsedUrl.toString(),
      [semconv_1.ATTR_HTTP_HOST]: host,
      [semconv_1.ATTR_NET_HOST_NAME]: hostname,
      [semconv_1.ATTR_HTTP_METHOD]: method,
      [semconv_1.ATTR_HTTP_SCHEME]: options.component
    };
    if (typeof ips === "string") {
      oldAttributes[semconv_1.ATTR_HTTP_CLIENT_IP] = ips.split(",")[0];
    }
    if (typeof serverName === "string") {
      oldAttributes[semconv_1.ATTR_HTTP_SERVER_NAME] = serverName;
    }
    if (parsedUrl?.pathname) {
      oldAttributes[semconv_1.ATTR_HTTP_TARGET] = parsedUrl?.pathname + parsedUrl?.search || "/";
    }
    if (userAgent !== undefined) {
      oldAttributes[semconv_1.ATTR_HTTP_USER_AGENT] = userAgent;
    }
    (0, exports.setRequestContentLengthAttribute)(request, oldAttributes);
    (0, exports.setAttributesFromHttpKind)(httpVersion, oldAttributes);
    switch (options.semconvStability) {
      case instrumentation_1.SemconvStability.STABLE:
        return Object.assign(newAttributes, options.hookAttributes);
      case instrumentation_1.SemconvStability.OLD:
        return Object.assign(oldAttributes, options.hookAttributes);
    }
    return Object.assign(oldAttributes, newAttributes, options.hookAttributes);
  };
  exports.getIncomingRequestAttributes = getIncomingRequestAttributes;
  var getIncomingRequestMetricAttributes = (spanAttributes) => {
    const metricAttributes = {};
    metricAttributes[semconv_1.ATTR_HTTP_SCHEME] = spanAttributes[semconv_1.ATTR_HTTP_SCHEME];
    metricAttributes[semconv_1.ATTR_HTTP_METHOD] = spanAttributes[semconv_1.ATTR_HTTP_METHOD];
    metricAttributes[semconv_1.ATTR_NET_HOST_NAME] = spanAttributes[semconv_1.ATTR_NET_HOST_NAME];
    metricAttributes[semconv_1.ATTR_HTTP_FLAVOR] = spanAttributes[semconv_1.ATTR_HTTP_FLAVOR];
    return metricAttributes;
  };
  exports.getIncomingRequestMetricAttributes = getIncomingRequestMetricAttributes;
  var getIncomingRequestAttributesOnResponse = (request, response, semconvStability) => {
    const { socket } = request;
    const { statusCode, statusMessage } = response;
    const newAttributes = {
      [semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]: statusCode
    };
    const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
    const oldAttributes = {};
    if (socket) {
      const { localAddress, localPort, remoteAddress, remotePort } = socket;
      oldAttributes[semconv_1.ATTR_NET_HOST_IP] = localAddress;
      oldAttributes[semconv_1.ATTR_NET_HOST_PORT] = localPort;
      oldAttributes[semconv_1.ATTR_NET_PEER_IP] = remoteAddress;
      oldAttributes[semconv_1.ATTR_NET_PEER_PORT] = remotePort;
    }
    oldAttributes[semconv_1.ATTR_HTTP_STATUS_CODE] = statusCode;
    oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || "").toUpperCase();
    if (rpcMetadata?.type === core_1.RPCType.HTTP && rpcMetadata.route !== undefined) {
      oldAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = rpcMetadata.route;
      newAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = rpcMetadata.route;
    }
    switch (semconvStability) {
      case instrumentation_1.SemconvStability.STABLE:
        return newAttributes;
      case instrumentation_1.SemconvStability.OLD:
        return oldAttributes;
    }
    return Object.assign(oldAttributes, newAttributes);
  };
  exports.getIncomingRequestAttributesOnResponse = getIncomingRequestAttributesOnResponse;
  var getIncomingRequestMetricAttributesOnResponse = (spanAttributes) => {
    const metricAttributes = {};
    metricAttributes[semconv_1.ATTR_HTTP_STATUS_CODE] = spanAttributes[semconv_1.ATTR_HTTP_STATUS_CODE];
    metricAttributes[semconv_1.ATTR_NET_HOST_PORT] = spanAttributes[semconv_1.ATTR_NET_HOST_PORT];
    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] !== undefined) {
      metricAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE];
    }
    return metricAttributes;
  };
  exports.getIncomingRequestMetricAttributesOnResponse = getIncomingRequestMetricAttributesOnResponse;
  var getIncomingStableRequestMetricAttributesOnResponse = (spanAttributes) => {
    const metricAttributes = {};
    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] !== undefined) {
      metricAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE];
    }
    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {
      metricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];
    }
    return metricAttributes;
  };
  exports.getIncomingStableRequestMetricAttributesOnResponse = getIncomingStableRequestMetricAttributesOnResponse;
  function headerCapture(type, headers) {
    const normalizedHeaders = new Map;
    for (let i = 0, len = headers.length;i < len; i++) {
      const capturedHeader = headers[i].toLowerCase();
      normalizedHeaders.set(capturedHeader, capturedHeader.replace(/-/g, "_"));
    }
    return (span, getHeader) => {
      for (const capturedHeader of normalizedHeaders.keys()) {
        const value = getHeader(capturedHeader);
        if (value === undefined) {
          continue;
        }
        const normalizedHeader = normalizedHeaders.get(capturedHeader);
        const key = `http.${type}.header.${normalizedHeader}`;
        if (typeof value === "string") {
          span.setAttribute(key, [value]);
        } else if (Array.isArray(value)) {
          span.setAttribute(key, value);
        } else {
          span.setAttribute(key, [value]);
        }
      }
    };
  }
  exports.headerCapture = headerCapture;
  var KNOWN_METHODS = new Set([
    "GET",
    "HEAD",
    "POST",
    "PUT",
    "DELETE",
    "CONNECT",
    "OPTIONS",
    "TRACE",
    "PATCH"
  ]);
  function normalizeMethod(method) {
    if (method == null) {
      return "GET";
    }
    const upper = method.toUpperCase();
    if (KNOWN_METHODS.has(upper)) {
      return upper;
    }
    return "_OTHER";
  }
  function parseForwardedHeader(header) {
    try {
      return forwardedParse(header);
    } catch {
      return [];
    }
  }
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/http.js
var require_http = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpInstrumentation = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var url = __require("url");
  var version_1 = require_version3();
  var instrumentation_1 = require_src6();
  var events_1 = __require("events");
  var semantic_conventions_1 = require_src2();
  var utils_1 = require_utils6();

  class HttpInstrumentation extends instrumentation_1.InstrumentationBase {
    _spanNotEnded = new WeakSet;
    _headerCapture;
    _semconvStability = instrumentation_1.SemconvStability.OLD;
    constructor(config = {}) {
      super("@opentelemetry/instrumentation-http", version_1.VERSION, config);
      this._headerCapture = this._createHeaderCapture();
      this._semconvStability = (0, instrumentation_1.semconvStabilityFromStr)("http", process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
    }
    _updateMetricInstruments() {
      this._oldHttpServerDurationHistogram = this.meter.createHistogram("http.server.duration", {
        description: "Measures the duration of inbound HTTP requests.",
        unit: "ms",
        valueType: api_1.ValueType.DOUBLE
      });
      this._oldHttpClientDurationHistogram = this.meter.createHistogram("http.client.duration", {
        description: "Measures the duration of outbound HTTP requests.",
        unit: "ms",
        valueType: api_1.ValueType.DOUBLE
      });
      this._stableHttpServerDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_SERVER_REQUEST_DURATION, {
        description: "Duration of HTTP server requests.",
        unit: "s",
        valueType: api_1.ValueType.DOUBLE,
        advice: {
          explicitBucketBoundaries: [
            0.005,
            0.01,
            0.025,
            0.05,
            0.075,
            0.1,
            0.25,
            0.5,
            0.75,
            1,
            2.5,
            5,
            7.5,
            10
          ]
        }
      });
      this._stableHttpClientDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_CLIENT_REQUEST_DURATION, {
        description: "Duration of HTTP client requests.",
        unit: "s",
        valueType: api_1.ValueType.DOUBLE,
        advice: {
          explicitBucketBoundaries: [
            0.005,
            0.01,
            0.025,
            0.05,
            0.075,
            0.1,
            0.25,
            0.5,
            0.75,
            1,
            2.5,
            5,
            7.5,
            10
          ]
        }
      });
    }
    _recordServerDuration(durationMs, oldAttributes, stableAttributes) {
      if (this._semconvStability & instrumentation_1.SemconvStability.OLD) {
        this._oldHttpServerDurationHistogram.record(durationMs, oldAttributes);
      }
      if (this._semconvStability & instrumentation_1.SemconvStability.STABLE) {
        this._stableHttpServerDurationHistogram.record(durationMs / 1000, stableAttributes);
      }
    }
    _recordClientDuration(durationMs, oldAttributes, stableAttributes) {
      if (this._semconvStability & instrumentation_1.SemconvStability.OLD) {
        this._oldHttpClientDurationHistogram.record(durationMs, oldAttributes);
      }
      if (this._semconvStability & instrumentation_1.SemconvStability.STABLE) {
        this._stableHttpClientDurationHistogram.record(durationMs / 1000, stableAttributes);
      }
    }
    setConfig(config = {}) {
      super.setConfig(config);
      this._headerCapture = this._createHeaderCapture();
    }
    init() {
      return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];
    }
    _getHttpInstrumentation() {
      return new instrumentation_1.InstrumentationNodeModuleDefinition("http", ["*"], (moduleExports) => {
        const isESM = moduleExports[Symbol.toStringTag] === "Module";
        if (!this.getConfig().disableOutgoingRequestInstrumentation) {
          const patchedRequest = this._wrap(moduleExports, "request", this._getPatchOutgoingRequestFunction("http"));
          const patchedGet = this._wrap(moduleExports, "get", this._getPatchOutgoingGetFunction(patchedRequest));
          if (isESM) {
            moduleExports.default.request = patchedRequest;
            moduleExports.default.get = patchedGet;
          }
        }
        if (!this.getConfig().disableIncomingRequestInstrumentation) {
          this._wrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction("http"));
        }
        return moduleExports;
      }, (moduleExports) => {
        if (moduleExports === undefined)
          return;
        if (!this.getConfig().disableOutgoingRequestInstrumentation) {
          this._unwrap(moduleExports, "request");
          this._unwrap(moduleExports, "get");
        }
        if (!this.getConfig().disableIncomingRequestInstrumentation) {
          this._unwrap(moduleExports.Server.prototype, "emit");
        }
      });
    }
    _getHttpsInstrumentation() {
      return new instrumentation_1.InstrumentationNodeModuleDefinition("https", ["*"], (moduleExports) => {
        const isESM = moduleExports[Symbol.toStringTag] === "Module";
        if (!this.getConfig().disableOutgoingRequestInstrumentation) {
          const patchedRequest = this._wrap(moduleExports, "request", this._getPatchHttpsOutgoingRequestFunction("https"));
          const patchedGet = this._wrap(moduleExports, "get", this._getPatchHttpsOutgoingGetFunction(patchedRequest));
          if (isESM) {
            moduleExports.default.request = patchedRequest;
            moduleExports.default.get = patchedGet;
          }
        }
        if (!this.getConfig().disableIncomingRequestInstrumentation) {
          this._wrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction("https"));
        }
        return moduleExports;
      }, (moduleExports) => {
        if (moduleExports === undefined)
          return;
        if (!this.getConfig().disableOutgoingRequestInstrumentation) {
          this._unwrap(moduleExports, "request");
          this._unwrap(moduleExports, "get");
        }
        if (!this.getConfig().disableIncomingRequestInstrumentation) {
          this._unwrap(moduleExports.Server.prototype, "emit");
        }
      });
    }
    _getPatchIncomingRequestFunction(component) {
      return (original) => {
        return this._incomingRequestFunction(component, original);
      };
    }
    _getPatchOutgoingRequestFunction(component) {
      return (original) => {
        return this._outgoingRequestFunction(component, original);
      };
    }
    _getPatchOutgoingGetFunction(clientRequest) {
      return (_original) => {
        return function outgoingGetRequest(options, ...args) {
          const req = clientRequest(options, ...args);
          req.end();
          return req;
        };
      };
    }
    _getPatchHttpsOutgoingRequestFunction(component) {
      return (original) => {
        const instrumentation = this;
        return function httpsOutgoingRequest(options, ...args) {
          if (component === "https" && typeof options === "object" && options?.constructor?.name !== "URL") {
            options = Object.assign({}, options);
            instrumentation._setDefaultOptions(options);
          }
          return instrumentation._getPatchOutgoingRequestFunction(component)(original)(options, ...args);
        };
      };
    }
    _setDefaultOptions(options) {
      options.protocol = options.protocol || "https:";
      options.port = options.port || 443;
    }
    _getPatchHttpsOutgoingGetFunction(clientRequest) {
      return (original) => {
        const instrumentation = this;
        return function httpsOutgoingRequest(options, ...args) {
          return instrumentation._getPatchOutgoingGetFunction(clientRequest)(original)(options, ...args);
        };
      };
    }
    _traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes) {
      if (this.getConfig().requestHook) {
        this._callRequestHook(span, request);
      }
      let responseFinished = false;
      request.prependListener("response", (response) => {
        this._diag.debug("outgoingRequest on response()");
        if (request.listenerCount("response") <= 1) {
          response.resume();
        }
        const responseAttributes = (0, utils_1.getOutgoingRequestAttributesOnResponse)(response, this._semconvStability);
        span.setAttributes(responseAttributes);
        oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getOutgoingRequestMetricAttributesOnResponse)(responseAttributes));
        stableMetricAttributes = Object.assign(stableMetricAttributes, (0, utils_1.getOutgoingStableRequestMetricAttributesOnResponse)(responseAttributes));
        if (this.getConfig().responseHook) {
          this._callResponseHook(span, response);
        }
        this._headerCapture.client.captureRequestHeaders(span, (header) => request.getHeader(header));
        this._headerCapture.client.captureResponseHeaders(span, (header) => response.headers[header]);
        api_1.context.bind(api_1.context.active(), response);
        const endHandler = () => {
          this._diag.debug("outgoingRequest on end()");
          if (responseFinished) {
            return;
          }
          responseFinished = true;
          let status;
          if (response.aborted && !response.complete) {
            status = { code: api_1.SpanStatusCode.ERROR };
          } else {
            status = {
              code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.CLIENT, response.statusCode)
            };
          }
          span.setStatus(status);
          if (this.getConfig().applyCustomAttributesOnSpan) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(span, request, response), () => {}, true);
          }
          this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);
        };
        response.on("end", endHandler);
        response.on(events_1.errorMonitor, (error) => {
          this._diag.debug("outgoingRequest on error()", error);
          if (responseFinished) {
            return;
          }
          responseFinished = true;
          this._onOutgoingRequestError(span, oldMetricAttributes, stableMetricAttributes, startTime, error);
        });
      });
      request.on("close", () => {
        this._diag.debug("outgoingRequest on request close()");
        if (request.aborted || responseFinished) {
          return;
        }
        responseFinished = true;
        this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);
      });
      request.on(events_1.errorMonitor, (error) => {
        this._diag.debug("outgoingRequest on request error()", error);
        if (responseFinished) {
          return;
        }
        responseFinished = true;
        this._onOutgoingRequestError(span, oldMetricAttributes, stableMetricAttributes, startTime, error);
      });
      this._diag.debug("http.ClientRequest return request");
      return request;
    }
    _incomingRequestFunction(component, original) {
      const instrumentation = this;
      return function incomingRequest(event, ...args) {
        if (event !== "request") {
          return original.apply(this, [event, ...args]);
        }
        const request = args[0];
        const response = args[1];
        const method = request.method || "GET";
        instrumentation._diag.debug(`${component} instrumentation incomingRequest`);
        if ((0, instrumentation_1.safeExecuteInTheMiddle)(() => instrumentation.getConfig().ignoreIncomingRequestHook?.(request), (e) => {
          if (e != null) {
            instrumentation._diag.error("caught ignoreIncomingRequestHook error: ", e);
          }
        }, true)) {
          return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
            api_1.context.bind(api_1.context.active(), request);
            api_1.context.bind(api_1.context.active(), response);
            return original.apply(this, [event, ...args]);
          });
        }
        const headers = request.headers;
        const spanAttributes = (0, utils_1.getIncomingRequestAttributes)(request, {
          component,
          serverName: instrumentation.getConfig().serverName,
          hookAttributes: instrumentation._callStartSpanHook(request, instrumentation.getConfig().startIncomingSpanHook),
          semconvStability: instrumentation._semconvStability,
          enableSyntheticSourceDetection: instrumentation.getConfig().enableSyntheticSourceDetection || false
        }, instrumentation._diag);
        const spanOptions = {
          kind: api_1.SpanKind.SERVER,
          attributes: spanAttributes
        };
        const startTime = (0, core_1.hrTime)();
        const oldMetricAttributes = (0, utils_1.getIncomingRequestMetricAttributes)(spanAttributes);
        const stableMetricAttributes = {
          [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: spanAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],
          [semantic_conventions_1.ATTR_URL_SCHEME]: spanAttributes[semantic_conventions_1.ATTR_URL_SCHEME]
        };
        if (spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {
          stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];
        }
        const ctx = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);
        const span = instrumentation._startHttpSpan(method, spanOptions, ctx);
        const rpcMetadata = {
          type: core_1.RPCType.HTTP,
          span
        };
        return api_1.context.with((0, core_1.setRPCMetadata)(api_1.trace.setSpan(ctx, span), rpcMetadata), () => {
          api_1.context.bind(api_1.context.active(), request);
          api_1.context.bind(api_1.context.active(), response);
          if (instrumentation.getConfig().requestHook) {
            instrumentation._callRequestHook(span, request);
          }
          if (instrumentation.getConfig().responseHook) {
            instrumentation._callResponseHook(span, response);
          }
          instrumentation._headerCapture.server.captureRequestHeaders(span, (header) => request.headers[header]);
          let hasError = false;
          response.on("close", () => {
            if (hasError) {
              return;
            }
            instrumentation._onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime);
          });
          response.on(events_1.errorMonitor, (err) => {
            hasError = true;
            instrumentation._onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, err);
          });
          return (0, instrumentation_1.safeExecuteInTheMiddle)(() => original.apply(this, [event, ...args]), (error) => {
            if (error) {
              instrumentation._onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, error);
              throw error;
            }
          });
        });
      };
    }
    _outgoingRequestFunction(component, original) {
      const instrumentation = this;
      return function outgoingRequest(options, ...args) {
        if (!(0, utils_1.isValidOptionsType)(options)) {
          return original.apply(this, [options, ...args]);
        }
        const extraOptions = typeof args[0] === "object" && (typeof options === "string" || options instanceof url.URL) ? args.shift() : undefined;
        const { method, invalidUrl, optionsParsed } = (0, utils_1.getRequestInfo)(instrumentation._diag, options, extraOptions);
        if ((0, instrumentation_1.safeExecuteInTheMiddle)(() => instrumentation.getConfig().ignoreOutgoingRequestHook?.(optionsParsed), (e) => {
          if (e != null) {
            instrumentation._diag.error("caught ignoreOutgoingRequestHook error: ", e);
          }
        }, true)) {
          return original.apply(this, [optionsParsed, ...args]);
        }
        const { hostname, port } = (0, utils_1.extractHostnameAndPort)(optionsParsed);
        const attributes = (0, utils_1.getOutgoingRequestAttributes)(optionsParsed, {
          component,
          port,
          hostname,
          hookAttributes: instrumentation._callStartSpanHook(optionsParsed, instrumentation.getConfig().startOutgoingSpanHook),
          redactedQueryParams: instrumentation.getConfig().redactedQueryParams
        }, instrumentation._semconvStability, instrumentation.getConfig().enableSyntheticSourceDetection || false);
        const startTime = (0, core_1.hrTime)();
        const oldMetricAttributes = (0, utils_1.getOutgoingRequestMetricAttributes)(attributes);
        const stableMetricAttributes = {
          [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: attributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],
          [semantic_conventions_1.ATTR_SERVER_ADDRESS]: attributes[semantic_conventions_1.ATTR_SERVER_ADDRESS],
          [semantic_conventions_1.ATTR_SERVER_PORT]: attributes[semantic_conventions_1.ATTR_SERVER_PORT]
        };
        if (attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {
          stableMetricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];
        }
        if (attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {
          stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];
        }
        const spanOptions = {
          kind: api_1.SpanKind.CLIENT,
          attributes
        };
        const span = instrumentation._startHttpSpan(method, spanOptions);
        const parentContext = api_1.context.active();
        const requestContext = api_1.trace.setSpan(parentContext, span);
        if (!optionsParsed.headers) {
          optionsParsed.headers = {};
        } else {
          optionsParsed.headers = Object.assign({}, optionsParsed.headers);
        }
        api_1.propagation.inject(requestContext, optionsParsed.headers);
        return api_1.context.with(requestContext, () => {
          const cb = args[args.length - 1];
          if (typeof cb === "function") {
            args[args.length - 1] = api_1.context.bind(parentContext, cb);
          }
          const request = (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            if (invalidUrl) {
              return original.apply(this, [options, ...args]);
            } else {
              return original.apply(this, [optionsParsed, ...args]);
            }
          }, (error) => {
            if (error) {
              instrumentation._onOutgoingRequestError(span, oldMetricAttributes, stableMetricAttributes, startTime, error);
              throw error;
            }
          });
          instrumentation._diag.debug(`${component} instrumentation outgoingRequest`);
          api_1.context.bind(parentContext, request);
          return instrumentation._traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes);
        });
      };
    }
    _onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime) {
      const attributes = (0, utils_1.getIncomingRequestAttributesOnResponse)(request, response, this._semconvStability);
      oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getIncomingRequestMetricAttributesOnResponse)(attributes));
      stableMetricAttributes = Object.assign(stableMetricAttributes, (0, utils_1.getIncomingStableRequestMetricAttributesOnResponse)(attributes));
      this._headerCapture.server.captureResponseHeaders(span, (header) => response.getHeader(header));
      span.setAttributes(attributes).setStatus({
        code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.SERVER, response.statusCode)
      });
      const route = attributes[semantic_conventions_1.ATTR_HTTP_ROUTE];
      if (route) {
        span.updateName(`${request.method || "GET"} ${route}`);
      }
      if (this.getConfig().applyCustomAttributesOnSpan) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(span, request, response), () => {}, true);
      }
      this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);
    }
    _onOutgoingRequestError(span, oldMetricAttributes, stableMetricAttributes, startTime, error) {
      (0, utils_1.setSpanWithError)(span, error, this._semconvStability);
      stableMetricAttributes[semantic_conventions_1.ATTR_ERROR_TYPE] = error.name;
      this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);
    }
    _onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, error) {
      (0, utils_1.setSpanWithError)(span, error, this._semconvStability);
      stableMetricAttributes[semantic_conventions_1.ATTR_ERROR_TYPE] = error.name;
      this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);
    }
    _startHttpSpan(name, options, ctx = api_1.context.active()) {
      const requireParent = options.kind === api_1.SpanKind.CLIENT ? this.getConfig().requireParentforOutgoingSpans : this.getConfig().requireParentforIncomingSpans;
      let span;
      const currentSpan = api_1.trace.getSpan(ctx);
      if (requireParent === true && currentSpan === undefined) {
        span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);
      } else if (requireParent === true && currentSpan?.spanContext().isRemote) {
        span = currentSpan;
      } else {
        span = this.tracer.startSpan(name, options, ctx);
      }
      this._spanNotEnded.add(span);
      return span;
    }
    _closeHttpSpan(span, spanKind, startTime, oldMetricAttributes, stableMetricAttributes) {
      if (!this._spanNotEnded.has(span)) {
        return;
      }
      span.end();
      this._spanNotEnded.delete(span);
      const duration = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)()));
      if (spanKind === api_1.SpanKind.SERVER) {
        this._recordServerDuration(duration, oldMetricAttributes, stableMetricAttributes);
      } else if (spanKind === api_1.SpanKind.CLIENT) {
        this._recordClientDuration(duration, oldMetricAttributes, stableMetricAttributes);
      }
    }
    _callResponseHook(span, response) {
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().responseHook(span, response), () => {}, true);
    }
    _callRequestHook(span, request) {
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().requestHook(span, request), () => {}, true);
    }
    _callStartSpanHook(request, hookFunc) {
      if (typeof hookFunc === "function") {
        return (0, instrumentation_1.safeExecuteInTheMiddle)(() => hookFunc(request), () => {}, true);
      }
    }
    _createHeaderCapture() {
      const config = this.getConfig();
      return {
        client: {
          captureRequestHeaders: (0, utils_1.headerCapture)("request", config.headersToSpanAttributes?.client?.requestHeaders ?? []),
          captureResponseHeaders: (0, utils_1.headerCapture)("response", config.headersToSpanAttributes?.client?.responseHeaders ?? [])
        },
        server: {
          captureRequestHeaders: (0, utils_1.headerCapture)("request", config.headersToSpanAttributes?.server?.requestHeaders ?? []),
          captureResponseHeaders: (0, utils_1.headerCapture)("response", config.headersToSpanAttributes?.server?.responseHeaders ?? [])
        }
      };
    }
  }
  exports.HttpInstrumentation = HttpInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/index.js
var require_src7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpInstrumentation = undefined;
  var http_1 = require_http();
  Object.defineProperty(exports, "HttpInstrumentation", { enumerable: true, get: function() {
    return http_1.HttpInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = undefined;
  function defaultServiceName() {
    return `unknown_service:${process.argv0}`;
  }
  exports.defaultServiceName = defaultServiceName;
});

// ../../node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = undefined;
  var default_service_name_1 = require_default_service_name();
  Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
    return default_service_name_1.defaultServiceName;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = undefined;
  var node_1 = require_node6();
  Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
    return node_1.defaultServiceName;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.identity = exports.isPromiseLike = undefined;
  var isPromiseLike = (val) => {
    return val !== null && typeof val === "object" && typeof val.then === "function";
  };
  exports.isPromiseLike = isPromiseLike;
  function identity(_) {
    return _;
  }
  exports.identity = identity;
});

// ../../node_modules/@opentelemetry/resources/build/src/ResourceImpl.js
var require_ResourceImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultResource = exports.emptyResource = exports.resourceFromDetectedResource = exports.resourceFromAttributes = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var semantic_conventions_1 = require_src2();
  var platform_1 = require_platform5();
  var utils_1 = require_utils7();

  class ResourceImpl {
    _rawAttributes;
    _asyncAttributesPending = false;
    _schemaUrl;
    _memoizedAttributes;
    static FromAttributeList(attributes, options) {
      const res = new ResourceImpl({}, options);
      res._rawAttributes = guardedRawAttributes(attributes);
      res._asyncAttributesPending = attributes.filter(([_, val]) => (0, utils_1.isPromiseLike)(val)).length > 0;
      return res;
    }
    constructor(resource, options) {
      const attributes = resource.attributes ?? {};
      this._rawAttributes = Object.entries(attributes).map(([k, v]) => {
        if ((0, utils_1.isPromiseLike)(v)) {
          this._asyncAttributesPending = true;
        }
        return [k, v];
      });
      this._rawAttributes = guardedRawAttributes(this._rawAttributes);
      this._schemaUrl = validateSchemaUrl(options?.schemaUrl);
    }
    get asyncAttributesPending() {
      return this._asyncAttributesPending;
    }
    async waitForAsyncAttributes() {
      if (!this.asyncAttributesPending) {
        return;
      }
      for (let i = 0;i < this._rawAttributes.length; i++) {
        const [k, v] = this._rawAttributes[i];
        this._rawAttributes[i] = [k, (0, utils_1.isPromiseLike)(v) ? await v : v];
      }
      this._asyncAttributesPending = false;
    }
    get attributes() {
      if (this.asyncAttributesPending) {
        api_1.diag.error("Accessing resource attributes before async attributes settled");
      }
      if (this._memoizedAttributes) {
        return this._memoizedAttributes;
      }
      const attrs = {};
      for (const [k, v] of this._rawAttributes) {
        if ((0, utils_1.isPromiseLike)(v)) {
          api_1.diag.debug(`Unsettled resource attribute ${k} skipped`);
          continue;
        }
        if (v != null) {
          attrs[k] ??= v;
        }
      }
      if (!this._asyncAttributesPending) {
        this._memoizedAttributes = attrs;
      }
      return attrs;
    }
    getRawAttributes() {
      return this._rawAttributes;
    }
    get schemaUrl() {
      return this._schemaUrl;
    }
    merge(resource) {
      if (resource == null)
        return this;
      const mergedSchemaUrl = mergeSchemaUrl(this, resource);
      const mergedOptions = mergedSchemaUrl ? { schemaUrl: mergedSchemaUrl } : undefined;
      return ResourceImpl.FromAttributeList([...resource.getRawAttributes(), ...this.getRawAttributes()], mergedOptions);
    }
  }
  function resourceFromAttributes(attributes, options) {
    return ResourceImpl.FromAttributeList(Object.entries(attributes), options);
  }
  exports.resourceFromAttributes = resourceFromAttributes;
  function resourceFromDetectedResource(detectedResource, options) {
    return new ResourceImpl(detectedResource, options);
  }
  exports.resourceFromDetectedResource = resourceFromDetectedResource;
  function emptyResource() {
    return resourceFromAttributes({});
  }
  exports.emptyResource = emptyResource;
  function defaultResource() {
    return resourceFromAttributes({
      [semantic_conventions_1.ATTR_SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
      [semantic_conventions_1.ATTR_TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.ATTR_TELEMETRY_SDK_LANGUAGE],
      [semantic_conventions_1.ATTR_TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.ATTR_TELEMETRY_SDK_NAME],
      [semantic_conventions_1.ATTR_TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.ATTR_TELEMETRY_SDK_VERSION]
    });
  }
  exports.defaultResource = defaultResource;
  function guardedRawAttributes(attributes) {
    return attributes.map(([k, v]) => {
      if ((0, utils_1.isPromiseLike)(v)) {
        return [
          k,
          v.catch((err) => {
            api_1.diag.debug("promise rejection for resource attribute: %s - %s", k, err);
            return;
          })
        ];
      }
      return [k, v];
    });
  }
  function validateSchemaUrl(schemaUrl) {
    if (typeof schemaUrl === "string" || schemaUrl === undefined) {
      return schemaUrl;
    }
    api_1.diag.warn("Schema URL must be string or undefined, got %s. Schema URL will be ignored.", schemaUrl);
    return;
  }
  function mergeSchemaUrl(old, updating) {
    const oldSchemaUrl = old?.schemaUrl;
    const updatingSchemaUrl = updating?.schemaUrl;
    const isOldEmpty = oldSchemaUrl === undefined || oldSchemaUrl === "";
    const isUpdatingEmpty = updatingSchemaUrl === undefined || updatingSchemaUrl === "";
    if (isOldEmpty) {
      return updatingSchemaUrl;
    }
    if (isUpdatingEmpty) {
      return oldSchemaUrl;
    }
    if (oldSchemaUrl === updatingSchemaUrl) {
      return oldSchemaUrl;
    }
    api_1.diag.warn('Schema URL merge conflict: old resource has "%s", updating resource has "%s". Resulting resource will have undefined Schema URL.', oldSchemaUrl, updatingSchemaUrl);
    return;
  }
});

// ../../node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.detectResources = undefined;
  var api_1 = require_src();
  var ResourceImpl_1 = require_ResourceImpl();
  var detectResources = (config = {}) => {
    const resources = (config.detectors || []).map((d) => {
      try {
        const resource = (0, ResourceImpl_1.resourceFromDetectedResource)(d.detect(config));
        api_1.diag.debug(`${d.constructor.name} found resource.`, resource);
        return resource;
      } catch (e) {
        api_1.diag.debug(`${d.constructor.name} failed: ${e.message}`);
        return (0, ResourceImpl_1.emptyResource)();
      }
    });
    return resources.reduce((acc, resource) => acc.merge(resource), (0, ResourceImpl_1.emptyResource)());
  };
  exports.detectResources = detectResources;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.envDetector = undefined;
  var api_1 = require_src();
  var semantic_conventions_1 = require_src2();
  var core_1 = require_src3();

  class EnvDetector {
    _MAX_LENGTH = 255;
    _COMMA_SEPARATOR = ",";
    _LABEL_KEY_VALUE_SPLITTER = "=";
    _ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.";
    _ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
    detect(_config) {
      const attributes = {};
      const rawAttributes = (0, core_1.getStringFromEnv)("OTEL_RESOURCE_ATTRIBUTES");
      const serviceName = (0, core_1.getStringFromEnv)("OTEL_SERVICE_NAME");
      if (rawAttributes) {
        try {
          const parsedAttributes = this._parseResourceAttributes(rawAttributes);
          Object.assign(attributes, parsedAttributes);
        } catch (e) {
          api_1.diag.debug(`EnvDetector failed: ${e.message}`);
        }
      }
      if (serviceName) {
        attributes[semantic_conventions_1.ATTR_SERVICE_NAME] = serviceName;
      }
      return { attributes };
    }
    _parseResourceAttributes(rawEnvAttributes) {
      if (!rawEnvAttributes)
        return {};
      const attributes = {};
      const rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
      for (const rawAttribute of rawAttributes) {
        const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
        if (keyValuePair.length !== 2) {
          continue;
        }
        let [key, value] = keyValuePair;
        key = key.trim();
        value = value.trim().split(/^"|"$/).join("");
        if (!this._isValidAndNotEmpty(key)) {
          throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
        }
        if (!this._isValid(value)) {
          throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
        }
        attributes[key] = decodeURIComponent(value);
      }
      return attributes;
    }
    _isValid(name) {
      return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
    }
    _isBaggageOctetString(str) {
      for (let i = 0;i < str.length; i++) {
        const ch = str.charCodeAt(i);
        if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126) {
          return false;
        }
      }
      return true;
    }
    _isValidAndNotEmpty(str) {
      return str.length > 0 && this._isValid(str);
    }
  }
  exports.envDetector = new EnvDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/semconv.js
var require_semconv3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ATTR_WEBENGINE_VERSION = exports.ATTR_WEBENGINE_NAME = exports.ATTR_WEBENGINE_DESCRIPTION = exports.ATTR_SERVICE_NAMESPACE = exports.ATTR_SERVICE_INSTANCE_ID = exports.ATTR_PROCESS_RUNTIME_VERSION = exports.ATTR_PROCESS_RUNTIME_NAME = exports.ATTR_PROCESS_RUNTIME_DESCRIPTION = exports.ATTR_PROCESS_PID = exports.ATTR_PROCESS_OWNER = exports.ATTR_PROCESS_EXECUTABLE_PATH = exports.ATTR_PROCESS_EXECUTABLE_NAME = exports.ATTR_PROCESS_COMMAND_ARGS = exports.ATTR_PROCESS_COMMAND = exports.ATTR_OS_VERSION = exports.ATTR_OS_TYPE = exports.ATTR_K8S_POD_NAME = exports.ATTR_K8S_NAMESPACE_NAME = exports.ATTR_K8S_DEPLOYMENT_NAME = exports.ATTR_K8S_CLUSTER_NAME = exports.ATTR_HOST_TYPE = exports.ATTR_HOST_NAME = exports.ATTR_HOST_IMAGE_VERSION = exports.ATTR_HOST_IMAGE_NAME = exports.ATTR_HOST_IMAGE_ID = exports.ATTR_HOST_ID = exports.ATTR_HOST_ARCH = exports.ATTR_CONTAINER_NAME = exports.ATTR_CONTAINER_IMAGE_TAGS = exports.ATTR_CONTAINER_IMAGE_NAME = exports.ATTR_CONTAINER_ID = exports.ATTR_CLOUD_REGION = exports.ATTR_CLOUD_PROVIDER = exports.ATTR_CLOUD_AVAILABILITY_ZONE = exports.ATTR_CLOUD_ACCOUNT_ID = undefined;
  exports.ATTR_CLOUD_ACCOUNT_ID = "cloud.account.id";
  exports.ATTR_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
  exports.ATTR_CLOUD_PROVIDER = "cloud.provider";
  exports.ATTR_CLOUD_REGION = "cloud.region";
  exports.ATTR_CONTAINER_ID = "container.id";
  exports.ATTR_CONTAINER_IMAGE_NAME = "container.image.name";
  exports.ATTR_CONTAINER_IMAGE_TAGS = "container.image.tags";
  exports.ATTR_CONTAINER_NAME = "container.name";
  exports.ATTR_HOST_ARCH = "host.arch";
  exports.ATTR_HOST_ID = "host.id";
  exports.ATTR_HOST_IMAGE_ID = "host.image.id";
  exports.ATTR_HOST_IMAGE_NAME = "host.image.name";
  exports.ATTR_HOST_IMAGE_VERSION = "host.image.version";
  exports.ATTR_HOST_NAME = "host.name";
  exports.ATTR_HOST_TYPE = "host.type";
  exports.ATTR_K8S_CLUSTER_NAME = "k8s.cluster.name";
  exports.ATTR_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
  exports.ATTR_K8S_NAMESPACE_NAME = "k8s.namespace.name";
  exports.ATTR_K8S_POD_NAME = "k8s.pod.name";
  exports.ATTR_OS_TYPE = "os.type";
  exports.ATTR_OS_VERSION = "os.version";
  exports.ATTR_PROCESS_COMMAND = "process.command";
  exports.ATTR_PROCESS_COMMAND_ARGS = "process.command_args";
  exports.ATTR_PROCESS_EXECUTABLE_NAME = "process.executable.name";
  exports.ATTR_PROCESS_EXECUTABLE_PATH = "process.executable.path";
  exports.ATTR_PROCESS_OWNER = "process.owner";
  exports.ATTR_PROCESS_PID = "process.pid";
  exports.ATTR_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
  exports.ATTR_PROCESS_RUNTIME_NAME = "process.runtime.name";
  exports.ATTR_PROCESS_RUNTIME_VERSION = "process.runtime.version";
  exports.ATTR_SERVICE_INSTANCE_ID = "service.instance.id";
  exports.ATTR_SERVICE_NAMESPACE = "service.namespace";
  exports.ATTR_WEBENGINE_DESCRIPTION = "webengine.description";
  exports.ATTR_WEBENGINE_NAME = "webengine.name";
  exports.ATTR_WEBENGINE_VERSION = "webengine.version";
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js
var require_execAsync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.execAsync = undefined;
  var child_process = __require("child_process");
  var util = __require("util");
  exports.execAsync = util.promisify(child_process.exec);
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var execAsync_1 = require_execAsync();
  var api_1 = require_src();
  async function getMachineId() {
    try {
      const result = await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"');
      const idLine = result.stdout.split(`
`).find((line) => line.includes("IOPlatformUUID"));
      if (!idLine) {
        return;
      }
      const parts = idLine.split('" = "');
      if (parts.length === 2) {
        return parts[1].slice(0, -1);
      }
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    return;
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var fs_1 = __require("fs");
  var api_1 = require_src();
  async function getMachineId() {
    const paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
    for (const path7 of paths) {
      try {
        const result = await fs_1.promises.readFile(path7, { encoding: "utf8" });
        return result.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
    }
    return;
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var fs_1 = __require("fs");
  var execAsync_1 = require_execAsync();
  var api_1 = require_src();
  async function getMachineId() {
    try {
      const result = await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" });
      return result.trim();
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    try {
      const result = await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid");
      return result.stdout.trim();
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    return;
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var process2 = __require("process");
  var execAsync_1 = require_execAsync();
  var api_1 = require_src();
  async function getMachineId() {
    const args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid";
    let command = "%windir%\\System32\\REG.exe";
    if (process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env) {
      command = "%windir%\\sysnative\\cmd.exe /c " + command;
    }
    try {
      const result = await (0, execAsync_1.execAsync)(`${command} ${args}`);
      const parts = result.stdout.split("REG_SZ");
      if (parts.length === 2) {
        return parts[1].trim();
      }
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    return;
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var api_1 = require_src();
  async function getMachineId() {
    api_1.diag.debug("could not read machine-id: unsupported platform");
    return;
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js
var require_getMachineId = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var process2 = __require("process");
  var getMachineIdImpl;
  async function getMachineId() {
    if (!getMachineIdImpl) {
      switch (process2.platform) {
        case "darwin":
          getMachineIdImpl = (await Promise.resolve().then(() => __toESM(require_getMachineId_darwin(), 1))).getMachineId;
          break;
        case "linux":
          getMachineIdImpl = (await Promise.resolve().then(() => __toESM(require_getMachineId_linux(), 1))).getMachineId;
          break;
        case "freebsd":
          getMachineIdImpl = (await Promise.resolve().then(() => __toESM(require_getMachineId_bsd(), 1))).getMachineId;
          break;
        case "win32":
          getMachineIdImpl = (await Promise.resolve().then(() => __toESM(require_getMachineId_win(), 1))).getMachineId;
          break;
        default:
          getMachineIdImpl = (await Promise.resolve().then(() => __toESM(require_getMachineId_unsupported(), 1))).getMachineId;
          break;
      }
    }
    return getMachineIdImpl();
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js
var require_utils8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalizeType = exports.normalizeArch = undefined;
  var normalizeArch = (nodeArchString) => {
    switch (nodeArchString) {
      case "arm":
        return "arm32";
      case "ppc":
        return "ppc32";
      case "x64":
        return "amd64";
      default:
        return nodeArchString;
    }
  };
  exports.normalizeArch = normalizeArch;
  var normalizeType = (nodePlatform) => {
    switch (nodePlatform) {
      case "sunos":
        return "solaris";
      case "win32":
        return "windows";
      default:
        return nodePlatform;
    }
  };
  exports.normalizeType = normalizeType;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js
var require_HostDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hostDetector = undefined;
  var semconv_1 = require_semconv3();
  var os_1 = __require("os");
  var getMachineId_1 = require_getMachineId();
  var utils_1 = require_utils8();

  class HostDetector {
    detect(_config) {
      const attributes = {
        [semconv_1.ATTR_HOST_NAME]: (0, os_1.hostname)(),
        [semconv_1.ATTR_HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)()),
        [semconv_1.ATTR_HOST_ID]: (0, getMachineId_1.getMachineId)()
      };
      return { attributes };
    }
  }
  exports.hostDetector = new HostDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js
var require_OSDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.osDetector = undefined;
  var semconv_1 = require_semconv3();
  var os_1 = __require("os");
  var utils_1 = require_utils8();

  class OSDetector {
    detect(_config) {
      const attributes = {
        [semconv_1.ATTR_OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
        [semconv_1.ATTR_OS_VERSION]: (0, os_1.release)()
      };
      return { attributes };
    }
  }
  exports.osDetector = new OSDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js
var require_ProcessDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.processDetector = undefined;
  var api_1 = require_src();
  var semconv_1 = require_semconv3();
  var os = __require("os");

  class ProcessDetector {
    detect(_config) {
      const attributes = {
        [semconv_1.ATTR_PROCESS_PID]: process.pid,
        [semconv_1.ATTR_PROCESS_EXECUTABLE_NAME]: process.title,
        [semconv_1.ATTR_PROCESS_EXECUTABLE_PATH]: process.execPath,
        [semconv_1.ATTR_PROCESS_COMMAND_ARGS]: [
          process.argv[0],
          ...process.execArgv,
          ...process.argv.slice(1)
        ],
        [semconv_1.ATTR_PROCESS_RUNTIME_VERSION]: process.versions.node,
        [semconv_1.ATTR_PROCESS_RUNTIME_NAME]: "nodejs",
        [semconv_1.ATTR_PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
      };
      if (process.argv.length > 1) {
        attributes[semconv_1.ATTR_PROCESS_COMMAND] = process.argv[1];
      }
      try {
        const userInfo = os.userInfo();
        attributes[semconv_1.ATTR_PROCESS_OWNER] = userInfo.username;
      } catch (e) {
        api_1.diag.debug(`error obtaining process owner: ${e}`);
      }
      return { attributes };
    }
  }
  exports.processDetector = new ProcessDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetector.js
var require_ServiceInstanceIdDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serviceInstanceIdDetector = undefined;
  var semconv_1 = require_semconv3();
  var crypto_1 = __require("crypto");

  class ServiceInstanceIdDetector {
    detect(_config) {
      return {
        attributes: {
          [semconv_1.ATTR_SERVICE_INSTANCE_ID]: (0, crypto_1.randomUUID)()
        }
      };
    }
  }
  exports.serviceInstanceIdDetector = new ServiceInstanceIdDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js
var require_node7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serviceInstanceIdDetector = exports.processDetector = exports.osDetector = exports.hostDetector = undefined;
  var HostDetector_1 = require_HostDetector();
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return HostDetector_1.hostDetector;
  } });
  var OSDetector_1 = require_OSDetector();
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return OSDetector_1.osDetector;
  } });
  var ProcessDetector_1 = require_ProcessDetector();
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return ProcessDetector_1.processDetector;
  } });
  var ServiceInstanceIdDetector_1 = require_ServiceInstanceIdDetector();
  Object.defineProperty(exports, "serviceInstanceIdDetector", { enumerable: true, get: function() {
    return ServiceInstanceIdDetector_1.serviceInstanceIdDetector;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js
var require_platform6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serviceInstanceIdDetector = exports.processDetector = exports.osDetector = exports.hostDetector = undefined;
  var node_1 = require_node7();
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return node_1.hostDetector;
  } });
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return node_1.osDetector;
  } });
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return node_1.processDetector;
  } });
  Object.defineProperty(exports, "serviceInstanceIdDetector", { enumerable: true, get: function() {
    return node_1.serviceInstanceIdDetector;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/NoopDetector.js
var require_NoopDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noopDetector = exports.NoopDetector = undefined;

  class NoopDetector {
    detect() {
      return {
        attributes: {}
      };
    }
  }
  exports.NoopDetector = NoopDetector;
  exports.noopDetector = new NoopDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noopDetector = exports.serviceInstanceIdDetector = exports.processDetector = exports.osDetector = exports.hostDetector = exports.envDetector = undefined;
  var EnvDetector_1 = require_EnvDetector();
  Object.defineProperty(exports, "envDetector", { enumerable: true, get: function() {
    return EnvDetector_1.envDetector;
  } });
  var platform_1 = require_platform6();
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return platform_1.hostDetector;
  } });
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return platform_1.osDetector;
  } });
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return platform_1.processDetector;
  } });
  Object.defineProperty(exports, "serviceInstanceIdDetector", { enumerable: true, get: function() {
    return platform_1.serviceInstanceIdDetector;
  } });
  var NoopDetector_1 = require_NoopDetector();
  Object.defineProperty(exports, "noopDetector", { enumerable: true, get: function() {
    return NoopDetector_1.noopDetector;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/index.js
var require_src8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = exports.emptyResource = exports.defaultResource = exports.resourceFromAttributes = exports.serviceInstanceIdDetector = exports.processDetector = exports.osDetector = exports.hostDetector = exports.envDetector = exports.detectResources = undefined;
  var detect_resources_1 = require_detect_resources();
  Object.defineProperty(exports, "detectResources", { enumerable: true, get: function() {
    return detect_resources_1.detectResources;
  } });
  var detectors_1 = require_detectors();
  Object.defineProperty(exports, "envDetector", { enumerable: true, get: function() {
    return detectors_1.envDetector;
  } });
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return detectors_1.hostDetector;
  } });
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return detectors_1.osDetector;
  } });
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return detectors_1.processDetector;
  } });
  Object.defineProperty(exports, "serviceInstanceIdDetector", { enumerable: true, get: function() {
    return detectors_1.serviceInstanceIdDetector;
  } });
  var ResourceImpl_1 = require_ResourceImpl();
  Object.defineProperty(exports, "resourceFromAttributes", { enumerable: true, get: function() {
    return ResourceImpl_1.resourceFromAttributes;
  } });
  Object.defineProperty(exports, "defaultResource", { enumerable: true, get: function() {
    return ResourceImpl_1.defaultResource;
  } });
  Object.defineProperty(exports, "emptyResource", { enumerable: true, get: function() {
    return ResourceImpl_1.emptyResource;
  } });
  var platform_1 = require_platform5();
  Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
    return platform_1.defaultServiceName;
  } });
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/enums.js
var require_enums = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExceptionEventName = undefined;
  exports.ExceptionEventName = "exception";
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/Span.js
var require_Span = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanImpl = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var semantic_conventions_1 = require_src2();
  var enums_1 = require_enums();

  class SpanImpl {
    _spanContext;
    kind;
    parentSpanContext;
    attributes = {};
    links = [];
    events = [];
    startTime;
    resource;
    instrumentationScope;
    _droppedAttributesCount = 0;
    _droppedEventsCount = 0;
    _droppedLinksCount = 0;
    name;
    status = {
      code: api_1.SpanStatusCode.UNSET
    };
    endTime = [0, 0];
    _ended = false;
    _duration = [-1, -1];
    _spanProcessor;
    _spanLimits;
    _attributeValueLengthLimit;
    _performanceStartTime;
    _performanceOffset;
    _startTimeProvided;
    constructor(opts) {
      const now = Date.now();
      this._spanContext = opts.spanContext;
      this._performanceStartTime = core_1.otperformance.now();
      this._performanceOffset = now - (this._performanceStartTime + (0, core_1.getTimeOrigin)());
      this._startTimeProvided = opts.startTime != null;
      this._spanLimits = opts.spanLimits;
      this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
      this._spanProcessor = opts.spanProcessor;
      this.name = opts.name;
      this.parentSpanContext = opts.parentSpanContext;
      this.kind = opts.kind;
      this.links = opts.links || [];
      this.startTime = this._getTime(opts.startTime ?? now);
      this.resource = opts.resource;
      this.instrumentationScope = opts.scope;
      if (opts.attributes != null) {
        this.setAttributes(opts.attributes);
      }
      this._spanProcessor.onStart(this, opts.context);
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(key, value) {
      if (value == null || this._isSpanEnded())
        return this;
      if (key.length === 0) {
        api_1.diag.warn(`Invalid attribute key: ${key}`);
        return this;
      }
      if (!(0, core_1.isAttributeValue)(value)) {
        api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
        return this;
      }
      const { attributeCountLimit } = this._spanLimits;
      if (attributeCountLimit !== undefined && Object.keys(this.attributes).length >= attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
        this._droppedAttributesCount++;
        return this;
      }
      this.attributes[key] = this._truncateToSize(value);
      return this;
    }
    setAttributes(attributes) {
      for (const [k, v] of Object.entries(attributes)) {
        this.setAttribute(k, v);
      }
      return this;
    }
    addEvent(name, attributesOrStartTime, timeStamp) {
      if (this._isSpanEnded())
        return this;
      const { eventCountLimit } = this._spanLimits;
      if (eventCountLimit === 0) {
        api_1.diag.warn("No events allowed.");
        this._droppedEventsCount++;
        return this;
      }
      if (eventCountLimit !== undefined && this.events.length >= eventCountLimit) {
        if (this._droppedEventsCount === 0) {
          api_1.diag.debug("Dropping extra events.");
        }
        this.events.shift();
        this._droppedEventsCount++;
      }
      if ((0, core_1.isTimeInput)(attributesOrStartTime)) {
        if (!(0, core_1.isTimeInput)(timeStamp)) {
          timeStamp = attributesOrStartTime;
        }
        attributesOrStartTime = undefined;
      }
      const attributes = (0, core_1.sanitizeAttributes)(attributesOrStartTime);
      this.events.push({
        name,
        attributes,
        time: this._getTime(timeStamp),
        droppedAttributesCount: 0
      });
      return this;
    }
    addLink(link) {
      this.links.push(link);
      return this;
    }
    addLinks(links) {
      this.links.push(...links);
      return this;
    }
    setStatus(status) {
      if (this._isSpanEnded())
        return this;
      this.status = { ...status };
      if (this.status.message != null && typeof status.message !== "string") {
        api_1.diag.warn(`Dropping invalid status.message of type '${typeof status.message}', expected 'string'`);
        delete this.status.message;
      }
      return this;
    }
    updateName(name) {
      if (this._isSpanEnded())
        return this;
      this.name = name;
      return this;
    }
    end(endTime) {
      if (this._isSpanEnded()) {
        api_1.diag.error(`${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`);
        return;
      }
      this._ended = true;
      this.endTime = this._getTime(endTime);
      this._duration = (0, core_1.hrTimeDuration)(this.startTime, this.endTime);
      if (this._duration[0] < 0) {
        api_1.diag.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime);
        this.endTime = this.startTime.slice();
        this._duration = [0, 0];
      }
      if (this._droppedEventsCount > 0) {
        api_1.diag.warn(`Dropped ${this._droppedEventsCount} events because eventCountLimit reached`);
      }
      this._spanProcessor.onEnd(this);
    }
    _getTime(inp) {
      if (typeof inp === "number" && inp <= core_1.otperformance.now()) {
        return (0, core_1.hrTime)(inp + this._performanceOffset);
      }
      if (typeof inp === "number") {
        return (0, core_1.millisToHrTime)(inp);
      }
      if (inp instanceof Date) {
        return (0, core_1.millisToHrTime)(inp.getTime());
      }
      if ((0, core_1.isTimeInputHrTime)(inp)) {
        return inp;
      }
      if (this._startTimeProvided) {
        return (0, core_1.millisToHrTime)(Date.now());
      }
      const msDuration = core_1.otperformance.now() - this._performanceStartTime;
      return (0, core_1.addHrTimes)(this.startTime, (0, core_1.millisToHrTime)(msDuration));
    }
    isRecording() {
      return this._ended === false;
    }
    recordException(exception, time) {
      const attributes = {};
      if (typeof exception === "string") {
        attributes[semantic_conventions_1.ATTR_EXCEPTION_MESSAGE] = exception;
      } else if (exception) {
        if (exception.code) {
          attributes[semantic_conventions_1.ATTR_EXCEPTION_TYPE] = exception.code.toString();
        } else if (exception.name) {
          attributes[semantic_conventions_1.ATTR_EXCEPTION_TYPE] = exception.name;
        }
        if (exception.message) {
          attributes[semantic_conventions_1.ATTR_EXCEPTION_MESSAGE] = exception.message;
        }
        if (exception.stack) {
          attributes[semantic_conventions_1.ATTR_EXCEPTION_STACKTRACE] = exception.stack;
        }
      }
      if (attributes[semantic_conventions_1.ATTR_EXCEPTION_TYPE] || attributes[semantic_conventions_1.ATTR_EXCEPTION_MESSAGE]) {
        this.addEvent(enums_1.ExceptionEventName, attributes, time);
      } else {
        api_1.diag.warn(`Failed to record an exception ${exception}`);
      }
    }
    get duration() {
      return this._duration;
    }
    get ended() {
      return this._ended;
    }
    get droppedAttributesCount() {
      return this._droppedAttributesCount;
    }
    get droppedEventsCount() {
      return this._droppedEventsCount;
    }
    get droppedLinksCount() {
      return this._droppedLinksCount;
    }
    _isSpanEnded() {
      if (this._ended) {
        const error2 = new Error(`Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`);
        api_1.diag.warn(`Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`, error2);
      }
      return this._ended;
    }
    _truncateToLimitUtil(value, limit) {
      if (value.length <= limit) {
        return value;
      }
      return value.substring(0, limit);
    }
    _truncateToSize(value) {
      const limit = this._attributeValueLengthLimit;
      if (limit <= 0) {
        api_1.diag.warn(`Attribute value limit must be positive, got ${limit}`);
        return value;
      }
      if (typeof value === "string") {
        return this._truncateToLimitUtil(value, limit);
      }
      if (Array.isArray(value)) {
        return value.map((val) => typeof val === "string" ? this._truncateToLimitUtil(val, limit) : val);
      }
      return value;
    }
  }
  exports.SpanImpl = SpanImpl;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/Sampler.js
var require_Sampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlwaysOffSampler = undefined;
  var Sampler_1 = require_Sampler();

  class AlwaysOffSampler {
    shouldSample() {
      return {
        decision: Sampler_1.SamplingDecision.NOT_RECORD
      };
    }
    toString() {
      return "AlwaysOffSampler";
    }
  }
  exports.AlwaysOffSampler = AlwaysOffSampler;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlwaysOnSampler = undefined;
  var Sampler_1 = require_Sampler();

  class AlwaysOnSampler {
    shouldSample() {
      return {
        decision: Sampler_1.SamplingDecision.RECORD_AND_SAMPLED
      };
    }
    toString() {
      return "AlwaysOnSampler";
    }
  }
  exports.AlwaysOnSampler = AlwaysOnSampler;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ParentBasedSampler = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var AlwaysOffSampler_1 = require_AlwaysOffSampler();
  var AlwaysOnSampler_1 = require_AlwaysOnSampler();

  class ParentBasedSampler {
    _root;
    _remoteParentSampled;
    _remoteParentNotSampled;
    _localParentSampled;
    _localParentNotSampled;
    constructor(config) {
      this._root = config.root;
      if (!this._root) {
        (0, core_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
        this._root = new AlwaysOnSampler_1.AlwaysOnSampler;
      }
      this._remoteParentSampled = config.remoteParentSampled ?? new AlwaysOnSampler_1.AlwaysOnSampler;
      this._remoteParentNotSampled = config.remoteParentNotSampled ?? new AlwaysOffSampler_1.AlwaysOffSampler;
      this._localParentSampled = config.localParentSampled ?? new AlwaysOnSampler_1.AlwaysOnSampler;
      this._localParentNotSampled = config.localParentNotSampled ?? new AlwaysOffSampler_1.AlwaysOffSampler;
    }
    shouldSample(context2, traceId, spanName, spanKind, attributes, links) {
      const parentContext = api_1.trace.getSpanContext(context2);
      if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
        return this._root.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.isRemote) {
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._remoteParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        return this._remoteParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
        return this._localParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      return this._localParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
    }
    toString() {
      return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
    }
  }
  exports.ParentBasedSampler = ParentBasedSampler;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceIdRatioBasedSampler = undefined;
  var api_1 = require_src();
  var Sampler_1 = require_Sampler();

  class TraceIdRatioBasedSampler {
    _ratio;
    _upperBound;
    constructor(_ratio = 0) {
      this._ratio = _ratio;
      this._ratio = this._normalize(_ratio);
      this._upperBound = Math.floor(this._ratio * 4294967295);
    }
    shouldSample(context2, traceId) {
      return {
        decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? Sampler_1.SamplingDecision.RECORD_AND_SAMPLED : Sampler_1.SamplingDecision.NOT_RECORD
      };
    }
    toString() {
      return `TraceIdRatioBased{${this._ratio}}`;
    }
    _normalize(ratio) {
      if (typeof ratio !== "number" || isNaN(ratio))
        return 0;
      return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    }
    _accumulate(traceId) {
      let accumulation = 0;
      for (let i = 0;i < traceId.length / 8; i++) {
        const pos = i * 8;
        const part = parseInt(traceId.slice(pos, pos + 8), 16);
        accumulation = (accumulation ^ part) >>> 0;
      }
      return accumulation;
    }
  }
  exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildSamplerFromEnv = exports.loadDefaultConfig = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var AlwaysOffSampler_1 = require_AlwaysOffSampler();
  var AlwaysOnSampler_1 = require_AlwaysOnSampler();
  var ParentBasedSampler_1 = require_ParentBasedSampler();
  var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler();
  var TracesSamplerValues;
  (function(TracesSamplerValues2) {
    TracesSamplerValues2["AlwaysOff"] = "always_off";
    TracesSamplerValues2["AlwaysOn"] = "always_on";
    TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
  })(TracesSamplerValues || (TracesSamplerValues = {}));
  var DEFAULT_RATIO = 1;
  function loadDefaultConfig() {
    return {
      sampler: buildSamplerFromEnv(),
      forceFlushTimeoutMillis: 30000,
      generalLimits: {
        attributeValueLengthLimit: (0, core_1.getNumberFromEnv)("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? Infinity,
        attributeCountLimit: (0, core_1.getNumberFromEnv)("OTEL_ATTRIBUTE_COUNT_LIMIT") ?? 128
      },
      spanLimits: {
        attributeValueLengthLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? Infinity,
        attributeCountLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT") ?? 128,
        linkCountLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_LINK_COUNT_LIMIT") ?? 128,
        eventCountLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_EVENT_COUNT_LIMIT") ?? 128,
        attributePerEventCountLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT") ?? 128,
        attributePerLinkCountLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT") ?? 128
      }
    };
  }
  exports.loadDefaultConfig = loadDefaultConfig;
  function buildSamplerFromEnv() {
    const sampler = (0, core_1.getStringFromEnv)("OTEL_TRACES_SAMPLER") ?? TracesSamplerValues.ParentBasedAlwaysOn;
    switch (sampler) {
      case TracesSamplerValues.AlwaysOn:
        return new AlwaysOnSampler_1.AlwaysOnSampler;
      case TracesSamplerValues.AlwaysOff:
        return new AlwaysOffSampler_1.AlwaysOffSampler;
      case TracesSamplerValues.ParentBasedAlwaysOn:
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new AlwaysOnSampler_1.AlwaysOnSampler
        });
      case TracesSamplerValues.ParentBasedAlwaysOff:
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new AlwaysOffSampler_1.AlwaysOffSampler
        });
      case TracesSamplerValues.TraceIdRatio:
        return new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv());
      case TracesSamplerValues.ParentBasedTraceIdRatio:
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv())
        });
      default:
        api_1.diag.error(`OTEL_TRACES_SAMPLER value "${sampler}" invalid, defaulting to "${TracesSamplerValues.ParentBasedAlwaysOn}".`);
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new AlwaysOnSampler_1.AlwaysOnSampler
        });
    }
  }
  exports.buildSamplerFromEnv = buildSamplerFromEnv;
  function getSamplerProbabilityFromEnv() {
    const probability = (0, core_1.getNumberFromEnv)("OTEL_TRACES_SAMPLER_ARG");
    if (probability == null) {
      api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`);
      return DEFAULT_RATIO;
    }
    if (probability < 0 || probability > 1) {
      api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${probability} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`);
      return DEFAULT_RATIO;
    }
    return probability;
  }
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/utility.js
var require_utility = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reconfigureLimits = exports.mergeConfig = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = undefined;
  var config_1 = require_config();
  var core_1 = require_src3();
  exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
  exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
  function mergeConfig(userConfig) {
    const perInstanceDefaults = {
      sampler: (0, config_1.buildSamplerFromEnv)()
    };
    const DEFAULT_CONFIG = (0, config_1.loadDefaultConfig)();
    const target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
    target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
    target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
    return target;
  }
  exports.mergeConfig = mergeConfig;
  function reconfigureLimits(userConfig) {
    const spanLimits = Object.assign({}, userConfig.spanLimits);
    spanLimits.attributeCountLimit = userConfig.spanLimits?.attributeCountLimit ?? userConfig.generalLimits?.attributeCountLimit ?? (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT") ?? (0, core_1.getNumberFromEnv)("OTEL_ATTRIBUTE_COUNT_LIMIT") ?? exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
    spanLimits.attributeValueLengthLimit = userConfig.spanLimits?.attributeValueLengthLimit ?? userConfig.generalLimits?.attributeValueLengthLimit ?? (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? (0, core_1.getNumberFromEnv)("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
    return Object.assign({}, userConfig, { spanLimits });
  }
  exports.reconfigureLimits = reconfigureLimits;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/export/BatchSpanProcessorBase.js
var require_BatchSpanProcessorBase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchSpanProcessorBase = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();

  class BatchSpanProcessorBase {
    _exporter;
    _maxExportBatchSize;
    _maxQueueSize;
    _scheduledDelayMillis;
    _exportTimeoutMillis;
    _isExporting = false;
    _finishedSpans = [];
    _timer;
    _shutdownOnce;
    _droppedSpansCount = 0;
    constructor(_exporter, config) {
      this._exporter = _exporter;
      this._maxExportBatchSize = typeof config?.maxExportBatchSize === "number" ? config.maxExportBatchSize : (0, core_1.getNumberFromEnv)("OTEL_BSP_MAX_EXPORT_BATCH_SIZE") ?? 512;
      this._maxQueueSize = typeof config?.maxQueueSize === "number" ? config.maxQueueSize : (0, core_1.getNumberFromEnv)("OTEL_BSP_MAX_QUEUE_SIZE") ?? 2048;
      this._scheduledDelayMillis = typeof config?.scheduledDelayMillis === "number" ? config.scheduledDelayMillis : (0, core_1.getNumberFromEnv)("OTEL_BSP_SCHEDULE_DELAY") ?? 5000;
      this._exportTimeoutMillis = typeof config?.exportTimeoutMillis === "number" ? config.exportTimeoutMillis : (0, core_1.getNumberFromEnv)("OTEL_BSP_EXPORT_TIMEOUT") ?? 30000;
      this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
      if (this._maxExportBatchSize > this._maxQueueSize) {
        api_1.diag.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
        this._maxExportBatchSize = this._maxQueueSize;
      }
    }
    forceFlush() {
      if (this._shutdownOnce.isCalled) {
        return this._shutdownOnce.promise;
      }
      return this._flushAll();
    }
    onStart(_span, _parentContext) {}
    onEnd(span) {
      if (this._shutdownOnce.isCalled) {
        return;
      }
      if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
        return;
      }
      this._addToBuffer(span);
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return Promise.resolve().then(() => {
        return this.onShutdown();
      }).then(() => {
        return this._flushAll();
      }).then(() => {
        return this._exporter.shutdown();
      });
    }
    _addToBuffer(span) {
      if (this._finishedSpans.length >= this._maxQueueSize) {
        if (this._droppedSpansCount === 0) {
          api_1.diag.debug("maxQueueSize reached, dropping spans");
        }
        this._droppedSpansCount++;
        return;
      }
      if (this._droppedSpansCount > 0) {
        api_1.diag.warn(`Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`);
        this._droppedSpansCount = 0;
      }
      this._finishedSpans.push(span);
      this._maybeStartTimer();
    }
    _flushAll() {
      return new Promise((resolve2, reject) => {
        const promises = [];
        const count = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);
        for (let i = 0, j = count;i < j; i++) {
          promises.push(this._flushOneBatch());
        }
        Promise.all(promises).then(() => {
          resolve2();
        }).catch(reject);
      });
    }
    _flushOneBatch() {
      this._clearTimer();
      if (this._finishedSpans.length === 0) {
        return Promise.resolve();
      }
      return new Promise((resolve2, reject) => {
        const timer = setTimeout(() => {
          reject(new Error("Timeout"));
        }, this._exportTimeoutMillis);
        api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
          let spans;
          if (this._finishedSpans.length <= this._maxExportBatchSize) {
            spans = this._finishedSpans;
            this._finishedSpans = [];
          } else {
            spans = this._finishedSpans.splice(0, this._maxExportBatchSize);
          }
          const doExport = () => this._exporter.export(spans, (result) => {
            clearTimeout(timer);
            if (result.code === core_1.ExportResultCode.SUCCESS) {
              resolve2();
            } else {
              reject(result.error ?? new Error("BatchSpanProcessor: span export failed"));
            }
          });
          let pendingResources = null;
          for (let i = 0, len = spans.length;i < len; i++) {
            const span = spans[i];
            if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {
              pendingResources ??= [];
              pendingResources.push(span.resource.waitForAsyncAttributes());
            }
          }
          if (pendingResources === null) {
            doExport();
          } else {
            Promise.all(pendingResources).then(doExport, (err) => {
              (0, core_1.globalErrorHandler)(err);
              reject(err);
            });
          }
        });
      });
    }
    _maybeStartTimer() {
      if (this._isExporting)
        return;
      const flush2 = () => {
        this._isExporting = true;
        this._flushOneBatch().finally(() => {
          this._isExporting = false;
          if (this._finishedSpans.length > 0) {
            this._clearTimer();
            this._maybeStartTimer();
          }
        }).catch((e) => {
          this._isExporting = false;
          (0, core_1.globalErrorHandler)(e);
        });
      };
      if (this._finishedSpans.length >= this._maxExportBatchSize) {
        return flush2();
      }
      if (this._timer !== undefined)
        return;
      this._timer = setTimeout(() => flush2(), this._scheduledDelayMillis);
      (0, core_1.unrefTimer)(this._timer);
    }
    _clearTimer() {
      if (this._timer !== undefined) {
        clearTimeout(this._timer);
        this._timer = undefined;
      }
    }
  }
  exports.BatchSpanProcessorBase = BatchSpanProcessorBase;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/export/BatchSpanProcessor.js
var require_BatchSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchSpanProcessor = undefined;
  var BatchSpanProcessorBase_1 = require_BatchSpanProcessorBase();

  class BatchSpanProcessor extends BatchSpanProcessorBase_1.BatchSpanProcessorBase {
    onShutdown() {}
  }
  exports.BatchSpanProcessor = BatchSpanProcessor;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = undefined;
  var SPAN_ID_BYTES = 8;
  var TRACE_ID_BYTES = 16;

  class RandomIdGenerator {
    generateTraceId = getIdGenerator(TRACE_ID_BYTES);
    generateSpanId = getIdGenerator(SPAN_ID_BYTES);
  }
  exports.RandomIdGenerator = RandomIdGenerator;
  var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
  function getIdGenerator(bytes) {
    return function generateId() {
      for (let i = 0;i < bytes / 4; i++) {
        SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
      }
      for (let i = 0;i < bytes; i++) {
        if (SHARED_BUFFER[i] > 0) {
          break;
        } else if (i === bytes - 1) {
          SHARED_BUFFER[bytes - 1] = 1;
        }
      }
      return SHARED_BUFFER.toString("hex", 0, bytes);
    };
  }
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/index.js
var require_node8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = exports.BatchSpanProcessor = undefined;
  var BatchSpanProcessor_1 = require_BatchSpanProcessor();
  Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
    return BatchSpanProcessor_1.BatchSpanProcessor;
  } });
  var RandomIdGenerator_1 = require_RandomIdGenerator();
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return RandomIdGenerator_1.RandomIdGenerator;
  } });
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/platform/index.js
var require_platform7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = exports.BatchSpanProcessor = undefined;
  var node_1 = require_node8();
  Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
    return node_1.BatchSpanProcessor;
  } });
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return node_1.RandomIdGenerator;
  } });
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/Tracer.js
var require_Tracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tracer = undefined;
  var api = require_src();
  var core_1 = require_src3();
  var Span_1 = require_Span();
  var utility_1 = require_utility();
  var platform_1 = require_platform7();

  class Tracer {
    _sampler;
    _generalLimits;
    _spanLimits;
    _idGenerator;
    instrumentationScope;
    _resource;
    _spanProcessor;
    constructor(instrumentationScope, config, resource, spanProcessor) {
      const localConfig = (0, utility_1.mergeConfig)(config);
      this._sampler = localConfig.sampler;
      this._generalLimits = localConfig.generalLimits;
      this._spanLimits = localConfig.spanLimits;
      this._idGenerator = config.idGenerator || new platform_1.RandomIdGenerator;
      this._resource = resource;
      this._spanProcessor = spanProcessor;
      this.instrumentationScope = instrumentationScope;
    }
    startSpan(name, options = {}, context2 = api.context.active()) {
      if (options.root) {
        context2 = api.trace.deleteSpan(context2);
      }
      const parentSpan = api.trace.getSpan(context2);
      if ((0, core_1.isTracingSuppressed)(context2)) {
        api.diag.debug("Instrumentation suppressed, returning Noop Span");
        const nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);
        return nonRecordingSpan;
      }
      const parentSpanContext = parentSpan?.spanContext();
      const spanId = this._idGenerator.generateSpanId();
      let validParentSpanContext;
      let traceId;
      let traceState;
      if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {
        traceId = this._idGenerator.generateTraceId();
      } else {
        traceId = parentSpanContext.traceId;
        traceState = parentSpanContext.traceState;
        validParentSpanContext = parentSpanContext;
      }
      const spanKind = options.kind ?? api.SpanKind.INTERNAL;
      const links = (options.links ?? []).map((link) => {
        return {
          context: link.context,
          attributes: (0, core_1.sanitizeAttributes)(link.attributes)
        };
      });
      const attributes = (0, core_1.sanitizeAttributes)(options.attributes);
      const samplingResult = this._sampler.shouldSample(context2, traceId, name, spanKind, attributes, links);
      traceState = samplingResult.traceState ?? traceState;
      const traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;
      const spanContext = { traceId, spanId, traceFlags, traceState };
      if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {
        api.diag.debug("Recording is off, propagating context in a non-recording span");
        const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);
        return nonRecordingSpan;
      }
      const initAttributes = (0, core_1.sanitizeAttributes)(Object.assign(attributes, samplingResult.attributes));
      const span = new Span_1.SpanImpl({
        resource: this._resource,
        scope: this.instrumentationScope,
        context: context2,
        spanContext,
        name,
        kind: spanKind,
        links,
        parentSpanContext: validParentSpanContext,
        attributes: initAttributes,
        startTime: options.startTime,
        spanProcessor: this._spanProcessor,
        spanLimits: this._spanLimits
      });
      return span;
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx ?? api.context.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = api.trace.setSpan(parentContext, span);
      return api.context.with(contextWithSpanSet, fn, undefined, span);
    }
    getGeneralLimits() {
      return this._generalLimits;
    }
    getSpanLimits() {
      return this._spanLimits;
    }
  }
  exports.Tracer = Tracer;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/MultiSpanProcessor.js
var require_MultiSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MultiSpanProcessor = undefined;
  var core_1 = require_src3();

  class MultiSpanProcessor {
    _spanProcessors;
    constructor(_spanProcessors) {
      this._spanProcessors = _spanProcessors;
    }
    forceFlush() {
      const promises = [];
      for (const spanProcessor of this._spanProcessors) {
        promises.push(spanProcessor.forceFlush());
      }
      return new Promise((resolve2) => {
        Promise.all(promises).then(() => {
          resolve2();
        }).catch((error2) => {
          (0, core_1.globalErrorHandler)(error2 || new Error("MultiSpanProcessor: forceFlush failed"));
          resolve2();
        });
      });
    }
    onStart(span, context2) {
      for (const spanProcessor of this._spanProcessors) {
        spanProcessor.onStart(span, context2);
      }
    }
    onEnd(span) {
      for (const spanProcessor of this._spanProcessors) {
        spanProcessor.onEnd(span);
      }
    }
    shutdown() {
      const promises = [];
      for (const spanProcessor of this._spanProcessors) {
        promises.push(spanProcessor.shutdown());
      }
      return new Promise((resolve2, reject) => {
        Promise.all(promises).then(() => {
          resolve2();
        }, reject);
      });
    }
  }
  exports.MultiSpanProcessor = MultiSpanProcessor;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/BasicTracerProvider.js
var require_BasicTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BasicTracerProvider = exports.ForceFlushState = undefined;
  var core_1 = require_src3();
  var resources_1 = require_src8();
  var Tracer_1 = require_Tracer();
  var config_1 = require_config();
  var MultiSpanProcessor_1 = require_MultiSpanProcessor();
  var utility_1 = require_utility();
  var ForceFlushState;
  (function(ForceFlushState2) {
    ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
    ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
    ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
    ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
  })(ForceFlushState = exports.ForceFlushState || (exports.ForceFlushState = {}));

  class BasicTracerProvider {
    _config;
    _tracers = new Map;
    _resource;
    _activeSpanProcessor;
    constructor(config = {}) {
      const mergedConfig = (0, core_1.merge)({}, (0, config_1.loadDefaultConfig)(), (0, utility_1.reconfigureLimits)(config));
      this._resource = mergedConfig.resource ?? (0, resources_1.defaultResource)();
      this._config = Object.assign({}, mergedConfig, {
        resource: this._resource
      });
      const spanProcessors = [];
      if (config.spanProcessors?.length) {
        spanProcessors.push(...config.spanProcessors);
      }
      this._activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(spanProcessors);
    }
    getTracer(name, version, options) {
      const key = `${name}@${version || ""}:${options?.schemaUrl || ""}`;
      if (!this._tracers.has(key)) {
        this._tracers.set(key, new Tracer_1.Tracer({ name, version, schemaUrl: options?.schemaUrl }, this._config, this._resource, this._activeSpanProcessor));
      }
      return this._tracers.get(key);
    }
    forceFlush() {
      const timeout = this._config.forceFlushTimeoutMillis;
      const promises = this._activeSpanProcessor["_spanProcessors"].map((spanProcessor) => {
        return new Promise((resolve2) => {
          let state;
          const timeoutInterval = setTimeout(() => {
            resolve2(new Error(`Span processor did not completed within timeout period of ${timeout} ms`));
            state = ForceFlushState.timeout;
          }, timeout);
          spanProcessor.forceFlush().then(() => {
            clearTimeout(timeoutInterval);
            if (state !== ForceFlushState.timeout) {
              state = ForceFlushState.resolved;
              resolve2(state);
            }
          }).catch((error2) => {
            clearTimeout(timeoutInterval);
            state = ForceFlushState.error;
            resolve2(error2);
          });
        });
      });
      return new Promise((resolve2, reject) => {
        Promise.all(promises).then((results) => {
          const errors = results.filter((result) => result !== ForceFlushState.resolved);
          if (errors.length > 0) {
            reject(errors);
          } else {
            resolve2();
          }
        }).catch((error2) => reject([error2]));
      });
    }
    shutdown() {
      return this._activeSpanProcessor.shutdown();
    }
  }
  exports.BasicTracerProvider = BasicTracerProvider;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/export/ConsoleSpanExporter.js
var require_ConsoleSpanExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConsoleSpanExporter = undefined;
  var core_1 = require_src3();

  class ConsoleSpanExporter {
    export(spans, resultCallback) {
      return this._sendSpans(spans, resultCallback);
    }
    shutdown() {
      this._sendSpans([]);
      return this.forceFlush();
    }
    forceFlush() {
      return Promise.resolve();
    }
    _exportInfo(span) {
      return {
        resource: {
          attributes: span.resource.attributes
        },
        instrumentationScope: span.instrumentationScope,
        traceId: span.spanContext().traceId,
        parentSpanContext: span.parentSpanContext,
        traceState: span.spanContext().traceState?.serialize(),
        name: span.name,
        id: span.spanContext().spanId,
        kind: span.kind,
        timestamp: (0, core_1.hrTimeToMicroseconds)(span.startTime),
        duration: (0, core_1.hrTimeToMicroseconds)(span.duration),
        attributes: span.attributes,
        status: span.status,
        events: span.events,
        links: span.links
      };
    }
    _sendSpans(spans, done) {
      for (const span of spans) {
        console.dir(this._exportInfo(span), { depth: 3 });
      }
      if (done) {
        return done({ code: core_1.ExportResultCode.SUCCESS });
      }
    }
  }
  exports.ConsoleSpanExporter = ConsoleSpanExporter;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/export/InMemorySpanExporter.js
var require_InMemorySpanExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InMemorySpanExporter = undefined;
  var core_1 = require_src3();

  class InMemorySpanExporter {
    _finishedSpans = [];
    _stopped = false;
    export(spans, resultCallback) {
      if (this._stopped)
        return resultCallback({
          code: core_1.ExportResultCode.FAILED,
          error: new Error("Exporter has been stopped")
        });
      this._finishedSpans.push(...spans);
      setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
    }
    shutdown() {
      this._stopped = true;
      this._finishedSpans = [];
      return this.forceFlush();
    }
    forceFlush() {
      return Promise.resolve();
    }
    reset() {
      this._finishedSpans = [];
    }
    getFinishedSpans() {
      return this._finishedSpans;
    }
  }
  exports.InMemorySpanExporter = InMemorySpanExporter;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/export/SimpleSpanProcessor.js
var require_SimpleSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SimpleSpanProcessor = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();

  class SimpleSpanProcessor {
    _exporter;
    _shutdownOnce;
    _pendingExports;
    constructor(_exporter) {
      this._exporter = _exporter;
      this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
      this._pendingExports = new Set;
    }
    async forceFlush() {
      await Promise.all(Array.from(this._pendingExports));
      if (this._exporter.forceFlush) {
        await this._exporter.forceFlush();
      }
    }
    onStart(_span, _parentContext) {}
    onEnd(span) {
      if (this._shutdownOnce.isCalled) {
        return;
      }
      if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
        return;
      }
      const pendingExport = this._doExport(span).catch((err) => (0, core_1.globalErrorHandler)(err));
      this._pendingExports.add(pendingExport);
      pendingExport.finally(() => this._pendingExports.delete(pendingExport));
    }
    async _doExport(span) {
      if (span.resource.asyncAttributesPending) {
        await span.resource.waitForAsyncAttributes?.();
      }
      const result = await core_1.internal._export(this._exporter, [span]);
      if (result.code !== core_1.ExportResultCode.SUCCESS) {
        throw result.error ?? new Error(`SimpleSpanProcessor: span export failed (status ${result})`);
      }
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return this._exporter.shutdown();
    }
  }
  exports.SimpleSpanProcessor = SimpleSpanProcessor;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/export/NoopSpanProcessor.js
var require_NoopSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopSpanProcessor = undefined;

  class NoopSpanProcessor {
    onStart(_span, _context) {}
    onEnd(_span) {}
    shutdown() {
      return Promise.resolve();
    }
    forceFlush() {
      return Promise.resolve();
    }
  }
  exports.NoopSpanProcessor = NoopSpanProcessor;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/index.js
var require_src9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = exports.TraceIdRatioBasedSampler = exports.ParentBasedSampler = exports.AlwaysOnSampler = exports.AlwaysOffSampler = exports.NoopSpanProcessor = exports.SimpleSpanProcessor = exports.InMemorySpanExporter = exports.ConsoleSpanExporter = exports.RandomIdGenerator = exports.BatchSpanProcessor = exports.BasicTracerProvider = undefined;
  var BasicTracerProvider_1 = require_BasicTracerProvider();
  Object.defineProperty(exports, "BasicTracerProvider", { enumerable: true, get: function() {
    return BasicTracerProvider_1.BasicTracerProvider;
  } });
  var platform_1 = require_platform7();
  Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
    return platform_1.BatchSpanProcessor;
  } });
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return platform_1.RandomIdGenerator;
  } });
  var ConsoleSpanExporter_1 = require_ConsoleSpanExporter();
  Object.defineProperty(exports, "ConsoleSpanExporter", { enumerable: true, get: function() {
    return ConsoleSpanExporter_1.ConsoleSpanExporter;
  } });
  var InMemorySpanExporter_1 = require_InMemorySpanExporter();
  Object.defineProperty(exports, "InMemorySpanExporter", { enumerable: true, get: function() {
    return InMemorySpanExporter_1.InMemorySpanExporter;
  } });
  var SimpleSpanProcessor_1 = require_SimpleSpanProcessor();
  Object.defineProperty(exports, "SimpleSpanProcessor", { enumerable: true, get: function() {
    return SimpleSpanProcessor_1.SimpleSpanProcessor;
  } });
  var NoopSpanProcessor_1 = require_NoopSpanProcessor();
  Object.defineProperty(exports, "NoopSpanProcessor", { enumerable: true, get: function() {
    return NoopSpanProcessor_1.NoopSpanProcessor;
  } });
  var AlwaysOffSampler_1 = require_AlwaysOffSampler();
  Object.defineProperty(exports, "AlwaysOffSampler", { enumerable: true, get: function() {
    return AlwaysOffSampler_1.AlwaysOffSampler;
  } });
  var AlwaysOnSampler_1 = require_AlwaysOnSampler();
  Object.defineProperty(exports, "AlwaysOnSampler", { enumerable: true, get: function() {
    return AlwaysOnSampler_1.AlwaysOnSampler;
  } });
  var ParentBasedSampler_1 = require_ParentBasedSampler();
  Object.defineProperty(exports, "ParentBasedSampler", { enumerable: true, get: function() {
    return ParentBasedSampler_1.ParentBasedSampler;
  } });
  var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler();
  Object.defineProperty(exports, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
    return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
  } });
  var Sampler_1 = require_Sampler();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return Sampler_1.SamplingDecision;
  } });
});

// ../../node_modules/@opentelemetry/context-async-hooks/build/src/AbstractAsyncHooksContextManager.js
var require_AbstractAsyncHooksContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractAsyncHooksContextManager = undefined;
  var events_1 = __require("events");
  var ADD_LISTENER_METHODS = [
    "addListener",
    "on",
    "once",
    "prependListener",
    "prependOnceListener"
  ];

  class AbstractAsyncHooksContextManager {
    bind(context6, target) {
      if (target instanceof events_1.EventEmitter) {
        return this._bindEventEmitter(context6, target);
      }
      if (typeof target === "function") {
        return this._bindFunction(context6, target);
      }
      return target;
    }
    _bindFunction(context6, target) {
      const manager = this;
      const contextWrapper = function(...args) {
        return manager.with(context6, () => target.apply(this, args));
      };
      Object.defineProperty(contextWrapper, "length", {
        enumerable: false,
        configurable: true,
        writable: false,
        value: target.length
      });
      return contextWrapper;
    }
    _bindEventEmitter(context6, ee) {
      const map = this._getPatchMap(ee);
      if (map !== undefined)
        return ee;
      this._createPatchMap(ee);
      ADD_LISTENER_METHODS.forEach((methodName) => {
        if (ee[methodName] === undefined)
          return;
        ee[methodName] = this._patchAddListener(ee, ee[methodName], context6);
      });
      if (typeof ee.removeListener === "function") {
        ee.removeListener = this._patchRemoveListener(ee, ee.removeListener);
      }
      if (typeof ee.off === "function") {
        ee.off = this._patchRemoveListener(ee, ee.off);
      }
      if (typeof ee.removeAllListeners === "function") {
        ee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners);
      }
      return ee;
    }
    _patchRemoveListener(ee, original) {
      const contextManager = this;
      return function(event, listener) {
        const events = contextManager._getPatchMap(ee)?.[event];
        if (events === undefined) {
          return original.call(this, event, listener);
        }
        const patchedListener = events.get(listener);
        return original.call(this, event, patchedListener || listener);
      };
    }
    _patchRemoveAllListeners(ee, original) {
      const contextManager = this;
      return function(event) {
        const map = contextManager._getPatchMap(ee);
        if (map !== undefined) {
          if (arguments.length === 0) {
            contextManager._createPatchMap(ee);
          } else if (map[event] !== undefined) {
            delete map[event];
          }
        }
        return original.apply(this, arguments);
      };
    }
    _patchAddListener(ee, original, context6) {
      const contextManager = this;
      return function(event, listener) {
        if (contextManager._wrapped) {
          return original.call(this, event, listener);
        }
        let map = contextManager._getPatchMap(ee);
        if (map === undefined) {
          map = contextManager._createPatchMap(ee);
        }
        let listeners = map[event];
        if (listeners === undefined) {
          listeners = new WeakMap;
          map[event] = listeners;
        }
        const patchedListener = contextManager.bind(context6, listener);
        listeners.set(listener, patchedListener);
        contextManager._wrapped = true;
        try {
          return original.call(this, event, patchedListener);
        } finally {
          contextManager._wrapped = false;
        }
      };
    }
    _createPatchMap(ee) {
      const map = Object.create(null);
      ee[this._kOtListeners] = map;
      return map;
    }
    _getPatchMap(ee) {
      return ee[this._kOtListeners];
    }
    _kOtListeners = Symbol("OtListeners");
    _wrapped = false;
  }
  exports.AbstractAsyncHooksContextManager = AbstractAsyncHooksContextManager;
});

// ../../node_modules/@opentelemetry/context-async-hooks/build/src/AsyncHooksContextManager.js
var require_AsyncHooksContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncHooksContextManager = undefined;
  var api_1 = require_src();
  var asyncHooks = __require("async_hooks");
  var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();

  class AsyncHooksContextManager extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
    _asyncHook;
    _contexts = new Map;
    _stack = [];
    constructor() {
      super();
      this._asyncHook = asyncHooks.createHook({
        init: this._init.bind(this),
        before: this._before.bind(this),
        after: this._after.bind(this),
        destroy: this._destroy.bind(this),
        promiseResolve: this._destroy.bind(this)
      });
    }
    active() {
      return this._stack[this._stack.length - 1] ?? api_1.ROOT_CONTEXT;
    }
    with(context6, fn, thisArg, ...args) {
      this._enterContext(context6);
      try {
        return fn.call(thisArg, ...args);
      } finally {
        this._exitContext();
      }
    }
    enable() {
      this._asyncHook.enable();
      return this;
    }
    disable() {
      this._asyncHook.disable();
      this._contexts.clear();
      this._stack = [];
      return this;
    }
    _init(uid, type) {
      if (type === "TIMERWRAP")
        return;
      const context6 = this._stack[this._stack.length - 1];
      if (context6 !== undefined) {
        this._contexts.set(uid, context6);
      }
    }
    _destroy(uid) {
      this._contexts.delete(uid);
    }
    _before(uid) {
      const context6 = this._contexts.get(uid);
      if (context6 !== undefined) {
        this._enterContext(context6);
      }
    }
    _after() {
      this._exitContext();
    }
    _enterContext(context6) {
      this._stack.push(context6);
    }
    _exitContext() {
      this._stack.pop();
    }
  }
  exports.AsyncHooksContextManager = AsyncHooksContextManager;
});

// ../../node_modules/@opentelemetry/context-async-hooks/build/src/AsyncLocalStorageContextManager.js
var require_AsyncLocalStorageContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncLocalStorageContextManager = undefined;
  var api_1 = require_src();
  var async_hooks_1 = __require("async_hooks");
  var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();

  class AsyncLocalStorageContextManager extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
    _asyncLocalStorage;
    constructor() {
      super();
      this._asyncLocalStorage = new async_hooks_1.AsyncLocalStorage;
    }
    active() {
      return this._asyncLocalStorage.getStore() ?? api_1.ROOT_CONTEXT;
    }
    with(context6, fn, thisArg, ...args) {
      const cb = thisArg == null ? fn : fn.bind(thisArg);
      return this._asyncLocalStorage.run(context6, cb, ...args);
    }
    enable() {
      return this;
    }
    disable() {
      this._asyncLocalStorage.disable();
      return this;
    }
  }
  exports.AsyncLocalStorageContextManager = AsyncLocalStorageContextManager;
});

// ../../node_modules/@opentelemetry/context-async-hooks/build/src/index.js
var require_src10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncLocalStorageContextManager = exports.AsyncHooksContextManager = undefined;
  var AsyncHooksContextManager_1 = require_AsyncHooksContextManager();
  Object.defineProperty(exports, "AsyncHooksContextManager", { enumerable: true, get: function() {
    return AsyncHooksContextManager_1.AsyncHooksContextManager;
  } });
  var AsyncLocalStorageContextManager_1 = require_AsyncLocalStorageContextManager();
  Object.defineProperty(exports, "AsyncLocalStorageContextManager", { enumerable: true, get: function() {
    return AsyncLocalStorageContextManager_1.AsyncLocalStorageContextManager;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-undici/build/src/version.js
var require_version4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.15.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-undici";
});

// ../../node_modules/@opentelemetry/instrumentation-undici/build/src/enums/SemanticAttributes.js
var require_SemanticAttributes2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SemanticAttributes = undefined;
  exports.SemanticAttributes = {
    HTTP_CONNECTION_STATE: "http.connection.state",
    ERROR_TYPE: "error.type",
    HTTP_REQUEST_BODY_SIZE: "http.request.body.size",
    HTTP_REQUEST_METHOD: "http.request.method",
    HTTP_REQUEST_METHOD_ORIGINAL: "http.request.method_original",
    HTTP_REQUEST_RESEND_COUNT: "http.request.resend_count",
    HTTP_RESPONSE_BODY_SIZE: "http.response.body.size",
    HTTP_RESPONSE_STATUS_CODE: "http.response.status_code",
    HTTP_ROUTE: "http.route",
    NETWORK_PEER_ADDRESS: "network.peer.address",
    NETWORK_PEER_PORT: "network.peer.port",
    NETWORK_PROTOCOL_NAME: "network.protocol.name",
    NETWORK_PROTOCOL_VERSION: "network.protocol.version",
    SERVER_ADDRESS: "server.address",
    SERVER_PORT: "server.port",
    URL_FULL: "url.full",
    URL_PATH: "url.path",
    URL_QUERY: "url.query",
    URL_SCHEME: "url.scheme",
    USER_AGENT_ORIGINAL: "user_agent.original"
  };
});

// ../../node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js
var require_undici = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UndiciInstrumentation = undefined;
  var diagch2 = __require("diagnostics_channel");
  var url_1 = __require("url");
  var instrumentation_1 = require_src6();
  var api_1 = require_src();
  var version_1 = require_version4();
  var SemanticAttributes_1 = require_SemanticAttributes2();
  var core_1 = require_src3();

  class UndiciInstrumentation extends instrumentation_1.InstrumentationBase {
    _recordFromReq = new WeakMap;
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return;
    }
    disable() {
      super.disable();
      this._channelSubs.forEach((sub) => sub.unsubscribe());
      this._channelSubs.length = 0;
    }
    enable() {
      super.enable();
      this._channelSubs = this._channelSubs || [];
      if (this._channelSubs.length > 0) {
        return;
      }
      this.subscribeToChannel("undici:request:create", this.onRequestCreated.bind(this));
      this.subscribeToChannel("undici:client:sendHeaders", this.onRequestHeaders.bind(this));
      this.subscribeToChannel("undici:request:headers", this.onResponseHeaders.bind(this));
      this.subscribeToChannel("undici:request:trailers", this.onDone.bind(this));
      this.subscribeToChannel("undici:request:error", this.onError.bind(this));
    }
    _updateMetricInstruments() {
      this._httpClientDurationHistogram = this.meter.createHistogram("http.client.request.duration", {
        description: "Measures the duration of outbound HTTP requests.",
        unit: "s",
        valueType: api_1.ValueType.DOUBLE,
        advice: {
          explicitBucketBoundaries: [
            0.005,
            0.01,
            0.025,
            0.05,
            0.075,
            0.1,
            0.25,
            0.5,
            0.75,
            1,
            2.5,
            5,
            7.5,
            10
          ]
        }
      });
    }
    subscribeToChannel(diagnosticChannel, onMessage) {
      const [major, minor] = process.version.replace("v", "").split(".").map((n) => Number(n));
      const useNewSubscribe = major > 18 || major === 18 && minor >= 19;
      let unsubscribe3;
      if (useNewSubscribe) {
        diagch2.subscribe?.(diagnosticChannel, onMessage);
        unsubscribe3 = () => diagch2.unsubscribe?.(diagnosticChannel, onMessage);
      } else {
        const channel3 = diagch2.channel(diagnosticChannel);
        channel3.subscribe(onMessage);
        unsubscribe3 = () => channel3.unsubscribe(onMessage);
      }
      this._channelSubs.push({
        name: diagnosticChannel,
        unsubscribe: unsubscribe3
      });
    }
    parseRequestHeaders(request2) {
      const result = new Map;
      if (Array.isArray(request2.headers)) {
        for (let i = 0;i < request2.headers.length; i += 2) {
          const key = request2.headers[i];
          const value = request2.headers[i + 1];
          if (typeof key === "string") {
            result.set(key.toLowerCase(), value);
          }
        }
      } else if (typeof request2.headers === "string") {
        const headers = request2.headers.split(`\r
`);
        for (const line of headers) {
          if (!line) {
            continue;
          }
          const colonIndex = line.indexOf(":");
          if (colonIndex === -1) {
            continue;
          }
          const key = line.substring(0, colonIndex).toLowerCase();
          const value = line.substring(colonIndex + 1).trim();
          const allValues = result.get(key);
          if (allValues && Array.isArray(allValues)) {
            allValues.push(value);
          } else if (allValues) {
            result.set(key, [allValues, value]);
          } else {
            result.set(key, value);
          }
        }
      }
      return result;
    }
    onRequestCreated({ request: request2 }) {
      const config = this.getConfig();
      const enabled = config.enabled !== false;
      const shouldIgnoreReq = (0, instrumentation_1.safeExecuteInTheMiddle)(() => !enabled || request2.method === "CONNECT" || config.ignoreRequestHook?.(request2), (e) => e && this._diag.error("caught ignoreRequestHook error: ", e), true);
      if (shouldIgnoreReq) {
        return;
      }
      const startTime = (0, core_1.hrTime)();
      let requestUrl;
      try {
        requestUrl = new url_1.URL(request2.path, request2.origin);
      } catch (err) {
        this._diag.warn("could not determine url.full:", err);
        return;
      }
      const urlScheme = requestUrl.protocol.replace(":", "");
      const requestMethod = this.getRequestMethod(request2.method);
      const attributes = {
        [SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD]: requestMethod,
        [SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD_ORIGINAL]: request2.method,
        [SemanticAttributes_1.SemanticAttributes.URL_FULL]: requestUrl.toString(),
        [SemanticAttributes_1.SemanticAttributes.URL_PATH]: requestUrl.pathname,
        [SemanticAttributes_1.SemanticAttributes.URL_QUERY]: requestUrl.search,
        [SemanticAttributes_1.SemanticAttributes.URL_SCHEME]: urlScheme
      };
      const schemePorts = { https: "443", http: "80" };
      const serverAddress = requestUrl.hostname;
      const serverPort = requestUrl.port || schemePorts[urlScheme];
      attributes[SemanticAttributes_1.SemanticAttributes.SERVER_ADDRESS] = serverAddress;
      if (serverPort && !isNaN(Number(serverPort))) {
        attributes[SemanticAttributes_1.SemanticAttributes.SERVER_PORT] = Number(serverPort);
      }
      const headersMap = this.parseRequestHeaders(request2);
      const userAgentValues = headersMap.get("user-agent");
      if (userAgentValues) {
        const userAgent = Array.isArray(userAgentValues) ? userAgentValues[userAgentValues.length - 1] : userAgentValues;
        attributes[SemanticAttributes_1.SemanticAttributes.USER_AGENT_ORIGINAL] = userAgent;
      }
      const hookAttributes = (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.startSpanHook?.(request2), (e) => e && this._diag.error("caught startSpanHook error: ", e), true);
      if (hookAttributes) {
        Object.entries(hookAttributes).forEach(([key, val]) => {
          attributes[key] = val;
        });
      }
      const activeCtx = api_1.context.active();
      const currentSpan = api_1.trace.getSpan(activeCtx);
      let span;
      if (config.requireParentforSpans && (!currentSpan || !api_1.trace.isSpanContextValid(currentSpan.spanContext()))) {
        span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);
      } else {
        span = this.tracer.startSpan(requestMethod === "_OTHER" ? "HTTP" : requestMethod, {
          kind: api_1.SpanKind.CLIENT,
          attributes
        }, activeCtx);
      }
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.requestHook?.(span, request2), (e) => e && this._diag.error("caught requestHook error: ", e), true);
      const requestContext = api_1.trace.setSpan(api_1.context.active(), span);
      const addedHeaders = {};
      api_1.propagation.inject(requestContext, addedHeaders);
      const headerEntries = Object.entries(addedHeaders);
      for (let i = 0;i < headerEntries.length; i++) {
        const [k, v] = headerEntries[i];
        if (typeof request2.addHeader === "function") {
          request2.addHeader(k, v);
        } else if (typeof request2.headers === "string") {
          request2.headers += `${k}: ${v}\r
`;
        } else if (Array.isArray(request2.headers)) {
          request2.headers.push(k, v);
        }
      }
      this._recordFromReq.set(request2, { span, attributes, startTime });
    }
    onRequestHeaders({ request: request2, socket }) {
      const record = this._recordFromReq.get(request2);
      if (!record) {
        return;
      }
      const config = this.getConfig();
      const { span } = record;
      const { remoteAddress, remotePort } = socket;
      const spanAttributes = {
        [SemanticAttributes_1.SemanticAttributes.NETWORK_PEER_ADDRESS]: remoteAddress,
        [SemanticAttributes_1.SemanticAttributes.NETWORK_PEER_PORT]: remotePort
      };
      if (config.headersToSpanAttributes?.requestHeaders) {
        const headersToAttribs = new Set(config.headersToSpanAttributes.requestHeaders.map((n) => n.toLowerCase()));
        const headersMap = this.parseRequestHeaders(request2);
        for (const [name, value] of headersMap.entries()) {
          if (headersToAttribs.has(name)) {
            const attrValue = Array.isArray(value) ? value.join(", ") : value;
            spanAttributes[`http.request.header.${name}`] = attrValue;
          }
        }
      }
      span.setAttributes(spanAttributes);
    }
    onResponseHeaders({ request: request2, response }) {
      const record = this._recordFromReq.get(request2);
      if (!record) {
        return;
      }
      const { span, attributes } = record;
      const spanAttributes = {
        [SemanticAttributes_1.SemanticAttributes.HTTP_RESPONSE_STATUS_CODE]: response.statusCode
      };
      const config = this.getConfig();
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.responseHook?.(span, { request: request2, response }), (e) => e && this._diag.error("caught responseHook error: ", e), true);
      const headersToAttribs = new Set;
      if (config.headersToSpanAttributes?.responseHeaders) {
        config.headersToSpanAttributes?.responseHeaders.forEach((name) => headersToAttribs.add(name.toLowerCase()));
      }
      for (let idx = 0;idx < response.headers.length; idx = idx + 2) {
        const name = response.headers[idx].toString().toLowerCase();
        const value = response.headers[idx + 1];
        if (headersToAttribs.has(name)) {
          spanAttributes[`http.response.header.${name}`] = value.toString();
        }
        if (name === "content-length") {
          const contentLength = Number(value.toString());
          if (!isNaN(contentLength)) {
            spanAttributes["http.response.header.content-length"] = contentLength;
          }
        }
      }
      span.setAttributes(spanAttributes);
      span.setStatus({
        code: response.statusCode >= 400 ? api_1.SpanStatusCode.ERROR : api_1.SpanStatusCode.UNSET
      });
      record.attributes = Object.assign(attributes, spanAttributes);
    }
    onDone({ request: request2 }) {
      const record = this._recordFromReq.get(request2);
      if (!record) {
        return;
      }
      const { span, attributes, startTime } = record;
      span.end();
      this._recordFromReq.delete(request2);
      this.recordRequestDuration(attributes, startTime);
    }
    onError({ request: request2, error: error2 }) {
      const record = this._recordFromReq.get(request2);
      if (!record) {
        return;
      }
      const { span, attributes, startTime } = record;
      span.recordException(error2);
      span.setStatus({
        code: api_1.SpanStatusCode.ERROR,
        message: error2.message
      });
      span.end();
      this._recordFromReq.delete(request2);
      attributes[SemanticAttributes_1.SemanticAttributes.ERROR_TYPE] = error2.message;
      this.recordRequestDuration(attributes, startTime);
    }
    recordRequestDuration(attributes, startTime) {
      const metricsAttributes = {};
      const keysToCopy = [
        SemanticAttributes_1.SemanticAttributes.HTTP_RESPONSE_STATUS_CODE,
        SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD,
        SemanticAttributes_1.SemanticAttributes.SERVER_ADDRESS,
        SemanticAttributes_1.SemanticAttributes.SERVER_PORT,
        SemanticAttributes_1.SemanticAttributes.URL_SCHEME,
        SemanticAttributes_1.SemanticAttributes.ERROR_TYPE
      ];
      keysToCopy.forEach((key) => {
        if (key in attributes) {
          metricsAttributes[key] = attributes[key];
        }
      });
      const durationSeconds = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)())) / 1000;
      this._httpClientDurationHistogram.record(durationSeconds, metricsAttributes);
    }
    getRequestMethod(original) {
      const knownMethods = {
        CONNECT: true,
        OPTIONS: true,
        HEAD: true,
        GET: true,
        POST: true,
        PUT: true,
        PATCH: true,
        DELETE: true,
        TRACE: true
      };
      if (original.toUpperCase() in knownMethods) {
        return original.toUpperCase();
      }
      return "_OTHER";
    }
  }
  exports.UndiciInstrumentation = UndiciInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-undici/build/src/index.js
var require_src11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UndiciInstrumentation = undefined;
  var undici_1 = require_undici();
  Object.defineProperty(exports, "UndiciInstrumentation", { enumerable: true, get: function() {
    return undici_1.UndiciInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/enums/ExpressLayerType.js
var require_ExpressLayerType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExpressLayerType = undefined;
  var ExpressLayerType;
  (function(ExpressLayerType2) {
    ExpressLayerType2["ROUTER"] = "router";
    ExpressLayerType2["MIDDLEWARE"] = "middleware";
    ExpressLayerType2["REQUEST_HANDLER"] = "request_handler";
  })(ExpressLayerType = exports.ExpressLayerType || (exports.ExpressLayerType = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/enums/AttributeNames.js
var require_AttributeNames2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames;
  (function(AttributeNames2) {
    AttributeNames2["EXPRESS_TYPE"] = "express.type";
    AttributeNames2["EXPRESS_NAME"] = "express.name";
  })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/internal-types.js
var require_internal_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._LAYERS_STORE_PROPERTY = exports.kLayerPatched = undefined;
  exports.kLayerPatched = Symbol("express-layer-patched");
  exports._LAYERS_STORE_PROPERTY = "__ot_middlewares";
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/utils.js
var require_utils9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getActualMatchedRoute = exports.getConstructedRoute = exports.getLayerPath = exports.asErrorAndMessage = exports.isLayerIgnored = exports.getLayerMetadata = exports.getRouterPath = exports.storeLayerPath = undefined;
  var ExpressLayerType_1 = require_ExpressLayerType();
  var AttributeNames_1 = require_AttributeNames2();
  var internal_types_1 = require_internal_types2();
  var storeLayerPath = (request2, value) => {
    if (Array.isArray(request2[internal_types_1._LAYERS_STORE_PROPERTY]) === false) {
      Object.defineProperty(request2, internal_types_1._LAYERS_STORE_PROPERTY, {
        enumerable: false,
        value: []
      });
    }
    if (value === undefined)
      return { isLayerPathStored: false };
    request2[internal_types_1._LAYERS_STORE_PROPERTY].push(value);
    return { isLayerPathStored: true };
  };
  exports.storeLayerPath = storeLayerPath;
  var getRouterPath = (path7, layer) => {
    const stackLayer = layer.handle?.stack?.[0];
    if (stackLayer?.route?.path) {
      return `${path7}${stackLayer.route.path}`;
    }
    if (stackLayer?.handle?.stack) {
      return (0, exports.getRouterPath)(path7, stackLayer);
    }
    return path7;
  };
  exports.getRouterPath = getRouterPath;
  var getLayerMetadata = (route, layer, layerPath) => {
    if (layer.name === "router") {
      const maybeRouterPath = (0, exports.getRouterPath)("", layer);
      const extractedRouterPath = maybeRouterPath ? maybeRouterPath : layerPath || route || "/";
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.EXPRESS_NAME]: extractedRouterPath,
          [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.ROUTER
        },
        name: `router - ${extractedRouterPath}`
      };
    } else if (layer.name === "bound dispatch" || layer.name === "handle") {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.EXPRESS_NAME]: (route || layerPath) ?? "request handler",
          [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.REQUEST_HANDLER
        },
        name: `request handler${layer.path ? ` - ${route || layerPath}` : ""}`
      };
    } else {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.EXPRESS_NAME]: layer.name,
          [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.MIDDLEWARE
        },
        name: `middleware - ${layer.name}`
      };
    }
  };
  exports.getLayerMetadata = getLayerMetadata;
  var satisfiesPattern = (constant, pattern) => {
    if (typeof pattern === "string") {
      return pattern === constant;
    } else if (pattern instanceof RegExp) {
      return pattern.test(constant);
    } else if (typeof pattern === "function") {
      return pattern(constant);
    } else {
      throw new TypeError("Pattern is in unsupported datatype");
    }
  };
  var isLayerIgnored = (name, type, config) => {
    if (Array.isArray(config?.ignoreLayersType) && config?.ignoreLayersType?.includes(type)) {
      return true;
    }
    if (Array.isArray(config?.ignoreLayers) === false)
      return false;
    try {
      for (const pattern of config.ignoreLayers) {
        if (satisfiesPattern(name, pattern)) {
          return true;
        }
      }
    } catch (e) {}
    return false;
  };
  exports.isLayerIgnored = isLayerIgnored;
  var asErrorAndMessage = (error2) => error2 instanceof Error ? [error2, error2.message] : [String(error2), String(error2)];
  exports.asErrorAndMessage = asErrorAndMessage;
  var getLayerPath = (args) => {
    const firstArg = args[0];
    if (Array.isArray(firstArg)) {
      return firstArg.map((arg) => extractLayerPathSegment(arg) || "").join(",");
    }
    return extractLayerPathSegment(firstArg);
  };
  exports.getLayerPath = getLayerPath;
  var extractLayerPathSegment = (arg) => {
    if (typeof arg === "string") {
      return arg;
    }
    if (arg instanceof RegExp || typeof arg === "number") {
      return arg.toString();
    }
    return;
  };
  function getConstructedRoute(req) {
    const layersStore = Array.isArray(req[internal_types_1._LAYERS_STORE_PROPERTY]) ? req[internal_types_1._LAYERS_STORE_PROPERTY] : [];
    const meaningfulPaths = layersStore.filter((path7) => path7 !== "/" && path7 !== "/*");
    if (meaningfulPaths.length === 1 && meaningfulPaths[0] === "*") {
      return "*";
    }
    return meaningfulPaths.join("").replace(/\/{2,}/g, "/");
  }
  exports.getConstructedRoute = getConstructedRoute;
  function getActualMatchedRoute(req) {
    const layersStore = Array.isArray(req[internal_types_1._LAYERS_STORE_PROPERTY]) ? req[internal_types_1._LAYERS_STORE_PROPERTY] : [];
    if (layersStore.length === 0) {
      return;
    }
    if (layersStore.every((path7) => path7 === "/")) {
      return req.originalUrl === "/" ? "/" : undefined;
    }
    const constructedRoute = getConstructedRoute(req);
    if (constructedRoute === "*") {
      return constructedRoute;
    }
    if (constructedRoute.includes("/") && (constructedRoute.includes(",") || constructedRoute.includes("\\") || constructedRoute.includes("*") || constructedRoute.includes("["))) {
      return constructedRoute;
    }
    const normalizedRoute = constructedRoute.startsWith("/") ? constructedRoute : `/${constructedRoute}`;
    const isValidRoute = normalizedRoute.length > 0 && (req.originalUrl === normalizedRoute || req.originalUrl.startsWith(normalizedRoute) || isRoutePattern(normalizedRoute));
    return isValidRoute ? normalizedRoute : undefined;
  }
  exports.getActualMatchedRoute = getActualMatchedRoute;
  function isRoutePattern(route) {
    return route.includes(":") || route.includes("*");
  }
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/version.js
var require_version5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.53.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-express";
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/instrumentation.js
var require_instrumentation3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExpressInstrumentation = undefined;
  var core_1 = require_src3();
  var api_1 = require_src();
  var ExpressLayerType_1 = require_ExpressLayerType();
  var AttributeNames_1 = require_AttributeNames2();
  var utils_1 = require_utils9();
  var version_1 = require_version5();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var internal_types_1 = require_internal_types2();

  class ExpressInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("express", [">=4.0.0 <6"], (moduleExports) => {
          const isExpressWithRouterPrototype = typeof moduleExports?.Router?.prototype?.route === "function";
          const routerProto = isExpressWithRouterPrototype ? moduleExports.Router.prototype : moduleExports.Router;
          if ((0, instrumentation_1.isWrapped)(routerProto.route)) {
            this._unwrap(routerProto, "route");
          }
          this._wrap(routerProto, "route", this._getRoutePatch());
          if ((0, instrumentation_1.isWrapped)(routerProto.use)) {
            this._unwrap(routerProto, "use");
          }
          this._wrap(routerProto, "use", this._getRouterUsePatch());
          if ((0, instrumentation_1.isWrapped)(moduleExports.application.use)) {
            this._unwrap(moduleExports.application, "use");
          }
          this._wrap(moduleExports.application, "use", this._getAppUsePatch(isExpressWithRouterPrototype));
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === undefined)
            return;
          const isExpressWithRouterPrototype = typeof moduleExports?.Router?.prototype?.route === "function";
          const routerProto = isExpressWithRouterPrototype ? moduleExports.Router.prototype : moduleExports.Router;
          this._unwrap(routerProto, "route");
          this._unwrap(routerProto, "use");
          this._unwrap(moduleExports.application, "use");
        })
      ];
    }
    _getRoutePatch() {
      const instrumentation = this;
      return function(original) {
        return function route_trace(...args) {
          const route = original.apply(this, args);
          const layer = this.stack[this.stack.length - 1];
          instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
          return route;
        };
      };
    }
    _getRouterUsePatch() {
      const instrumentation = this;
      return function(original) {
        return function use(...args) {
          const route = original.apply(this, args);
          const layer = this.stack[this.stack.length - 1];
          instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
          return route;
        };
      };
    }
    _getAppUsePatch(isExpressWithRouterPrototype) {
      const instrumentation = this;
      return function(original) {
        return function use(...args) {
          const router = isExpressWithRouterPrototype ? this.router : this._router;
          const route = original.apply(this, args);
          if (router) {
            const layer = router.stack[router.stack.length - 1];
            instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
          }
          return route;
        };
      };
    }
    _applyPatch(layer, layerPath) {
      const instrumentation = this;
      if (layer[internal_types_1.kLayerPatched] === true)
        return;
      layer[internal_types_1.kLayerPatched] = true;
      this._wrap(layer, "handle", (original) => {
        if (original.length === 4)
          return original;
        const patched = function(req, res) {
          const { isLayerPathStored } = (0, utils_1.storeLayerPath)(req, layerPath);
          const constructedRoute = (0, utils_1.getConstructedRoute)(req);
          const actualMatchedRoute = (0, utils_1.getActualMatchedRoute)(req);
          const attributes = {
            [semantic_conventions_1.ATTR_HTTP_ROUTE]: actualMatchedRoute
          };
          const metadata = (0, utils_1.getLayerMetadata)(constructedRoute, layer, layerPath);
          const type = metadata.attributes[AttributeNames_1.AttributeNames.EXPRESS_TYPE];
          const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
          if (rpcMetadata?.type === core_1.RPCType.HTTP) {
            rpcMetadata.route = actualMatchedRoute;
          }
          if ((0, utils_1.isLayerIgnored)(metadata.name, type, instrumentation.getConfig())) {
            if (type === ExpressLayerType_1.ExpressLayerType.MIDDLEWARE) {
              req[internal_types_1._LAYERS_STORE_PROPERTY].pop();
            }
            return original.apply(this, arguments);
          }
          if (api_1.trace.getSpan(api_1.context.active()) === undefined) {
            return original.apply(this, arguments);
          }
          const spanName = instrumentation._getSpanName({
            request: req,
            layerType: type,
            route: constructedRoute
          }, metadata.name);
          const span = instrumentation.tracer.startSpan(spanName, {
            attributes: Object.assign(attributes, metadata.attributes)
          });
          const parentContext = api_1.context.active();
          let currentContext = api_1.trace.setSpan(parentContext, span);
          const { requestHook } = instrumentation.getConfig();
          if (requestHook) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => requestHook(span, {
              request: req,
              layerType: type,
              route: constructedRoute
            }), (e) => {
              if (e) {
                api_1.diag.error("express instrumentation: request hook failed", e);
              }
            }, true);
          }
          let spanHasEnded = false;
          if (metadata.attributes[AttributeNames_1.AttributeNames.EXPRESS_TYPE] === ExpressLayerType_1.ExpressLayerType.ROUTER) {
            span.end();
            spanHasEnded = true;
            currentContext = parentContext;
          }
          const onResponseFinish = () => {
            if (spanHasEnded === false) {
              spanHasEnded = true;
              span.end();
            }
          };
          const args = Array.from(arguments);
          const callbackIdx = args.findIndex((arg) => typeof arg === "function");
          if (callbackIdx >= 0) {
            arguments[callbackIdx] = function() {
              const maybeError = arguments[0];
              const isError2 = ![undefined, null, "route", "router"].includes(maybeError);
              if (!spanHasEnded && isError2) {
                const [error2, message] = (0, utils_1.asErrorAndMessage)(maybeError);
                span.recordException(error2);
                span.setStatus({
                  code: api_1.SpanStatusCode.ERROR,
                  message
                });
              }
              if (spanHasEnded === false) {
                spanHasEnded = true;
                req.res?.removeListener("finish", onResponseFinish);
                span.end();
              }
              if (!(req.route && isError2) && isLayerPathStored) {
                req[internal_types_1._LAYERS_STORE_PROPERTY].pop();
              }
              const callback = args[callbackIdx];
              return api_1.context.bind(parentContext, callback).apply(this, arguments);
            };
          }
          try {
            return api_1.context.bind(currentContext, original).apply(this, arguments);
          } catch (anyError) {
            const [error2, message] = (0, utils_1.asErrorAndMessage)(anyError);
            span.recordException(error2);
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message
            });
            throw anyError;
          } finally {
            if (!spanHasEnded) {
              res.once("finish", onResponseFinish);
            }
          }
        };
        for (const key in original) {
          Object.defineProperty(patched, key, {
            get() {
              return original[key];
            },
            set(value) {
              original[key] = value;
            }
          });
        }
        return patched;
      });
    }
    _getSpanName(info, defaultName) {
      const { spanNameHook } = this.getConfig();
      if (!(spanNameHook instanceof Function)) {
        return defaultName;
      }
      try {
        return spanNameHook(info, defaultName) ?? defaultName;
      } catch (err) {
        api_1.diag.error("express instrumentation: error calling span name rewrite hook", err);
        return defaultName;
      }
    }
  }
  exports.ExpressInstrumentation = ExpressInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/index.js
var require_src12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = exports.ExpressLayerType = exports.ExpressInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation3();
  Object.defineProperty(exports, "ExpressInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.ExpressInstrumentation;
  } });
  var ExpressLayerType_1 = require_ExpressLayerType();
  Object.defineProperty(exports, "ExpressLayerType", { enumerable: true, get: function() {
    return ExpressLayerType_1.ExpressLayerType;
  } });
  var AttributeNames_1 = require_AttributeNames2();
  Object.defineProperty(exports, "AttributeNames", { enumerable: true, get: function() {
    return AttributeNames_1.AttributeNames;
  } });
});

// ../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports, module) => {
  module.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// ../../node_modules/@sentry/node/node_modules/minimatch/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports, module) => {
  var balanced = require_balanced_match();
  module.exports = expandTop;
  var escSlash = "\x00SLASH" + Math.random() + "\x00";
  var escOpen = "\x00OPEN" + Math.random() + "\x00";
  var escClose = "\x00CLOSE" + Math.random() + "\x00";
  var escComma = "\x00COMMA" + Math.random() + "\x00";
  var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m)
      return [str];
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    if (/\$$/.test(m.pre)) {
      for (var k = 0;k < post.length; k++) {
        var expansion = pre + "{" + m.body + "}" + post[k];
        expansions.push(expansion);
      }
    } else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,(?!,).*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x;test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = [];
        for (var j = 0;j < n.length; j++) {
          N.push.apply(N, expand(n[j], false));
        }
      }
      for (var j = 0;j < N.length; j++) {
        for (var k = 0;k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    }
    return expansions;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/enum.js
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanNames = exports.TokenKind = exports.AllowedOperationTypes = undefined;
  var AllowedOperationTypes;
  (function(AllowedOperationTypes2) {
    AllowedOperationTypes2["QUERY"] = "query";
    AllowedOperationTypes2["MUTATION"] = "mutation";
    AllowedOperationTypes2["SUBSCRIPTION"] = "subscription";
  })(AllowedOperationTypes = exports.AllowedOperationTypes || (exports.AllowedOperationTypes = {}));
  var TokenKind;
  (function(TokenKind2) {
    TokenKind2["SOF"] = "<SOF>";
    TokenKind2["EOF"] = "<EOF>";
    TokenKind2["BANG"] = "!";
    TokenKind2["DOLLAR"] = "$";
    TokenKind2["AMP"] = "&";
    TokenKind2["PAREN_L"] = "(";
    TokenKind2["PAREN_R"] = ")";
    TokenKind2["SPREAD"] = "...";
    TokenKind2["COLON"] = ":";
    TokenKind2["EQUALS"] = "=";
    TokenKind2["AT"] = "@";
    TokenKind2["BRACKET_L"] = "[";
    TokenKind2["BRACKET_R"] = "]";
    TokenKind2["BRACE_L"] = "{";
    TokenKind2["PIPE"] = "|";
    TokenKind2["BRACE_R"] = "}";
    TokenKind2["NAME"] = "Name";
    TokenKind2["INT"] = "Int";
    TokenKind2["FLOAT"] = "Float";
    TokenKind2["STRING"] = "String";
    TokenKind2["BLOCK_STRING"] = "BlockString";
    TokenKind2["COMMENT"] = "Comment";
  })(TokenKind = exports.TokenKind || (exports.TokenKind = {}));
  var SpanNames;
  (function(SpanNames2) {
    SpanNames2["EXECUTE"] = "graphql.execute";
    SpanNames2["PARSE"] = "graphql.parse";
    SpanNames2["RESOLVE"] = "graphql.resolve";
    SpanNames2["VALIDATE"] = "graphql.validate";
    SpanNames2["SCHEMA_VALIDATE"] = "graphql.validateSchema";
    SpanNames2["SCHEMA_PARSE"] = "graphql.parseSchema";
  })(SpanNames = exports.SpanNames || (exports.SpanNames = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/enums/AttributeNames.js
var require_AttributeNames3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames2;
  (function(AttributeNames3) {
    AttributeNames3["SOURCE"] = "graphql.source";
    AttributeNames3["FIELD_NAME"] = "graphql.field.name";
    AttributeNames3["FIELD_PATH"] = "graphql.field.path";
    AttributeNames3["FIELD_TYPE"] = "graphql.field.type";
    AttributeNames3["OPERATION_TYPE"] = "graphql.operation.type";
    AttributeNames3["OPERATION_NAME"] = "graphql.operation.name";
    AttributeNames3["VARIABLES"] = "graphql.variables.";
    AttributeNames3["ERROR_VALIDATION_NAME"] = "graphql.validation.error";
  })(AttributeNames2 = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/symbols.js
var require_symbols = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTEL_GRAPHQL_DATA_SYMBOL = exports.OTEL_PATCHED_SYMBOL = undefined;
  exports.OTEL_PATCHED_SYMBOL = Symbol.for("opentelemetry.patched");
  exports.OTEL_GRAPHQL_DATA_SYMBOL = Symbol.for("opentelemetry.graphql_data");
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/internal-types.js
var require_internal_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OPERATION_NOT_SUPPORTED = undefined;
  var symbols_1 = require_symbols();
  exports.OPERATION_NOT_SUPPORTED = "Operation$operationName$not" + " supported";
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/utils.js
var require_utils10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapFieldResolver = exports.wrapFields = exports.getSourceFromLocation = exports.getOperation = exports.endSpan = exports.addSpanSource = exports.addInputVariableAttributes = exports.isPromise = undefined;
  var api2 = require_src();
  var enum_1 = require_enum();
  var AttributeNames_1 = require_AttributeNames3();
  var symbols_1 = require_symbols();
  var OPERATION_VALUES = Object.values(enum_1.AllowedOperationTypes);
  var isPromise2 = (value) => {
    return typeof value?.then === "function";
  };
  exports.isPromise = isPromise2;
  var isObjectLike = (value) => {
    return typeof value == "object" && value !== null;
  };
  function addInputVariableAttribute(span, key, variable) {
    if (Array.isArray(variable)) {
      variable.forEach((value, idx) => {
        addInputVariableAttribute(span, `${key}.${idx}`, value);
      });
    } else if (variable instanceof Object) {
      Object.entries(variable).forEach(([nestedKey, value]) => {
        addInputVariableAttribute(span, `${key}.${nestedKey}`, value);
      });
    } else {
      span.setAttribute(`${AttributeNames_1.AttributeNames.VARIABLES}${String(key)}`, variable);
    }
  }
  function addInputVariableAttributes(span, variableValues) {
    Object.entries(variableValues).forEach(([key, value]) => {
      addInputVariableAttribute(span, key, value);
    });
  }
  exports.addInputVariableAttributes = addInputVariableAttributes;
  function addSpanSource(span, loc, allowValues, start, end) {
    const source = getSourceFromLocation(loc, allowValues, start, end);
    span.setAttribute(AttributeNames_1.AttributeNames.SOURCE, source);
  }
  exports.addSpanSource = addSpanSource;
  function createFieldIfNotExists(tracer, getConfig, contextValue, info, path8) {
    let field = getField(contextValue, path8);
    let spanAdded = false;
    if (!field) {
      spanAdded = true;
      const parent = getParentField(contextValue, path8);
      field = {
        parent,
        span: createResolverSpan(tracer, getConfig, contextValue, info, path8, parent.span),
        error: null
      };
      addField(contextValue, path8, field);
    }
    return { spanAdded, field };
  }
  function createResolverSpan(tracer, getConfig, contextValue, info, path8, parentSpan) {
    const attributes = {
      [AttributeNames_1.AttributeNames.FIELD_NAME]: info.fieldName,
      [AttributeNames_1.AttributeNames.FIELD_PATH]: path8.join("."),
      [AttributeNames_1.AttributeNames.FIELD_TYPE]: info.returnType.toString()
    };
    const span = tracer.startSpan(`${enum_1.SpanNames.RESOLVE} ${attributes[AttributeNames_1.AttributeNames.FIELD_PATH]}`, {
      attributes
    }, parentSpan ? api2.trace.setSpan(api2.context.active(), parentSpan) : undefined);
    const document2 = contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].source;
    const fieldNode = info.fieldNodes.find((fieldNode2) => fieldNode2.kind === "Field");
    if (fieldNode) {
      addSpanSource(span, document2.loc, getConfig().allowValues, fieldNode.loc?.start, fieldNode.loc?.end);
    }
    return span;
  }
  function endSpan2(span, error2) {
    if (error2) {
      span.recordException(error2);
    }
    span.end();
  }
  exports.endSpan = endSpan2;
  function getOperation(document2, operationName) {
    if (!document2 || !Array.isArray(document2.definitions)) {
      return;
    }
    if (operationName) {
      return document2.definitions.filter((definition) => OPERATION_VALUES.indexOf(definition?.operation) !== -1).find((definition) => operationName === definition?.name?.value);
    } else {
      return document2.definitions.find((definition) => OPERATION_VALUES.indexOf(definition?.operation) !== -1);
    }
  }
  exports.getOperation = getOperation;
  function addField(contextValue, path8, field) {
    return contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].fields[path8.join(".")] = field;
  }
  function getField(contextValue, path8) {
    return contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].fields[path8.join(".")];
  }
  function getParentField(contextValue, path8) {
    for (let i = path8.length - 1;i > 0; i--) {
      const field = getField(contextValue, path8.slice(0, i));
      if (field) {
        return field;
      }
    }
    return {
      span: contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].span
    };
  }
  function pathToArray(mergeItems, path8) {
    const flattened = [];
    let curr = path8;
    while (curr) {
      let key = curr.key;
      if (mergeItems && typeof key === "number") {
        key = "*";
      }
      flattened.push(String(key));
      curr = curr.prev;
    }
    return flattened.reverse();
  }
  function repeatBreak(i) {
    return repeatChar(`
`, i);
  }
  function repeatSpace(i) {
    return repeatChar(" ", i);
  }
  function repeatChar(char, to) {
    let text = "";
    for (let i = 0;i < to; i++) {
      text += char;
    }
    return text;
  }
  var KindsToBeRemoved = [
    enum_1.TokenKind.FLOAT,
    enum_1.TokenKind.STRING,
    enum_1.TokenKind.INT,
    enum_1.TokenKind.BLOCK_STRING
  ];
  function getSourceFromLocation(loc, allowValues = false, inputStart, inputEnd) {
    let source = "";
    if (loc?.startToken) {
      const start = typeof inputStart === "number" ? inputStart : loc.start;
      const end = typeof inputEnd === "number" ? inputEnd : loc.end;
      let next = loc.startToken.next;
      let previousLine = 1;
      while (next) {
        if (next.start < start) {
          next = next.next;
          previousLine = next?.line;
          continue;
        }
        if (next.end > end) {
          next = next.next;
          previousLine = next?.line;
          continue;
        }
        let value = next.value || next.kind;
        let space = "";
        if (!allowValues && KindsToBeRemoved.indexOf(next.kind) >= 0) {
          value = "*";
        }
        if (next.kind === enum_1.TokenKind.STRING) {
          value = `"${value}"`;
        }
        if (next.kind === enum_1.TokenKind.EOF) {
          value = "";
        }
        if (next.line > previousLine) {
          source += repeatBreak(next.line - previousLine);
          previousLine = next.line;
          space = repeatSpace(next.column - 1);
        } else {
          if (next.line === next.prev?.line) {
            space = repeatSpace(next.start - (next.prev?.end || 0));
          }
        }
        source += space + value;
        if (next) {
          next = next.next;
        }
      }
    }
    return source;
  }
  exports.getSourceFromLocation = getSourceFromLocation;
  function wrapFields(type, tracer, getConfig) {
    if (!type || typeof type.getFields !== "function" || type[symbols_1.OTEL_PATCHED_SYMBOL]) {
      return;
    }
    const fields = type.getFields();
    type[symbols_1.OTEL_PATCHED_SYMBOL] = true;
    Object.keys(fields).forEach((key) => {
      const field = fields[key];
      if (!field) {
        return;
      }
      if (field.resolve) {
        field.resolve = wrapFieldResolver(tracer, getConfig, field.resolve);
      }
      if (field.type) {
        let unwrappedType = field.type;
        while (unwrappedType.ofType) {
          unwrappedType = unwrappedType.ofType;
        }
        wrapFields(unwrappedType, tracer, getConfig);
      }
    });
  }
  exports.wrapFields = wrapFields;
  var handleResolveSpanError = (resolveSpan, err, shouldEndSpan) => {
    if (!shouldEndSpan) {
      return;
    }
    resolveSpan.recordException(err);
    resolveSpan.setStatus({
      code: api2.SpanStatusCode.ERROR,
      message: err.message
    });
    resolveSpan.end();
  };
  var handleResolveSpanSuccess = (resolveSpan, shouldEndSpan) => {
    if (!shouldEndSpan) {
      return;
    }
    resolveSpan.end();
  };
  function wrapFieldResolver(tracer, getConfig, fieldResolver, isDefaultResolver = false) {
    if (wrappedFieldResolver[symbols_1.OTEL_PATCHED_SYMBOL] || typeof fieldResolver !== "function") {
      return fieldResolver;
    }
    function wrappedFieldResolver(source, args, contextValue, info) {
      if (!fieldResolver) {
        return;
      }
      const config = getConfig();
      if (config.ignoreTrivialResolveSpans && isDefaultResolver && (isObjectLike(source) || typeof source === "function")) {
        const property = source[info.fieldName];
        if (typeof property !== "function") {
          return fieldResolver.call(this, source, args, contextValue, info);
        }
      }
      if (!contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL]) {
        return fieldResolver.call(this, source, args, contextValue, info);
      }
      const path8 = pathToArray(config.mergeItems, info && info.path);
      const depth = path8.filter((item) => typeof item === "string").length;
      let field;
      let shouldEndSpan = false;
      if (config.depth >= 0 && config.depth < depth) {
        field = getParentField(contextValue, path8);
      } else {
        const newField = createFieldIfNotExists(tracer, getConfig, contextValue, info, path8);
        field = newField.field;
        shouldEndSpan = newField.spanAdded;
      }
      return api2.context.with(api2.trace.setSpan(api2.context.active(), field.span), () => {
        try {
          const res = fieldResolver.call(this, source, args, contextValue, info);
          if ((0, exports.isPromise)(res)) {
            return res.then((r) => {
              handleResolveSpanSuccess(field.span, shouldEndSpan);
              return r;
            }, (err) => {
              handleResolveSpanError(field.span, err, shouldEndSpan);
              throw err;
            });
          } else {
            handleResolveSpanSuccess(field.span, shouldEndSpan);
            return res;
          }
        } catch (err) {
          handleResolveSpanError(field.span, err, shouldEndSpan);
          throw err;
        }
      });
    }
    wrappedFieldResolver[symbols_1.OTEL_PATCHED_SYMBOL] = true;
    return wrappedFieldResolver;
  }
  exports.wrapFieldResolver = wrapFieldResolver;
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/version.js
var require_version6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.52.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-graphql";
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/instrumentation.js
var require_instrumentation4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GraphQLInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var enum_1 = require_enum();
  var AttributeNames_1 = require_AttributeNames3();
  var symbols_1 = require_symbols();
  var internal_types_1 = require_internal_types3();
  var utils_1 = require_utils10();
  var version_1 = require_version6();
  var DEFAULT_CONFIG = {
    mergeItems: false,
    depth: -1,
    allowValues: false,
    ignoreResolveSpans: false
  };
  var supportedVersions = [">=14.0.0 <17"];

  class GraphQLInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, { ...DEFAULT_CONFIG, ...config });
    }
    setConfig(config = {}) {
      super.setConfig({ ...DEFAULT_CONFIG, ...config });
    }
    init() {
      const module2 = new instrumentation_1.InstrumentationNodeModuleDefinition("graphql", supportedVersions);
      module2.files.push(this._addPatchingExecute());
      module2.files.push(this._addPatchingParser());
      module2.files.push(this._addPatchingValidate());
      return module2;
    }
    _addPatchingExecute() {
      return new instrumentation_1.InstrumentationNodeModuleFile("graphql/execution/execute.js", supportedVersions, (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports.execute)) {
          this._unwrap(moduleExports, "execute");
        }
        this._wrap(moduleExports, "execute", this._patchExecute(moduleExports.defaultFieldResolver));
        return moduleExports;
      }, (moduleExports) => {
        if (moduleExports) {
          this._unwrap(moduleExports, "execute");
        }
      });
    }
    _addPatchingParser() {
      return new instrumentation_1.InstrumentationNodeModuleFile("graphql/language/parser.js", supportedVersions, (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports.parse)) {
          this._unwrap(moduleExports, "parse");
        }
        this._wrap(moduleExports, "parse", this._patchParse());
        return moduleExports;
      }, (moduleExports) => {
        if (moduleExports) {
          this._unwrap(moduleExports, "parse");
        }
      });
    }
    _addPatchingValidate() {
      return new instrumentation_1.InstrumentationNodeModuleFile("graphql/validation/validate.js", supportedVersions, (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports.validate)) {
          this._unwrap(moduleExports, "validate");
        }
        this._wrap(moduleExports, "validate", this._patchValidate());
        return moduleExports;
      }, (moduleExports) => {
        if (moduleExports) {
          this._unwrap(moduleExports, "validate");
        }
      });
    }
    _patchExecute(defaultFieldResolved) {
      const instrumentation = this;
      return function execute(original) {
        return function patchExecute() {
          let processedArgs;
          if (arguments.length >= 2) {
            const args = arguments;
            processedArgs = instrumentation._wrapExecuteArgs(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], defaultFieldResolved);
          } else {
            const args = arguments[0];
            processedArgs = instrumentation._wrapExecuteArgs(args.schema, args.document, args.rootValue, args.contextValue, args.variableValues, args.operationName, args.fieldResolver, args.typeResolver, defaultFieldResolved);
          }
          const operation = (0, utils_1.getOperation)(processedArgs.document, processedArgs.operationName);
          const span = instrumentation._createExecuteSpan(operation, processedArgs);
          processedArgs.contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] = {
            source: processedArgs.document ? processedArgs.document || processedArgs.document[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] : undefined,
            span,
            fields: {}
          };
          return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
              return original.apply(this, [
                processedArgs
              ]);
            }, (err, result) => {
              instrumentation._handleExecutionResult(span, err, result);
            });
          });
        };
      };
    }
    _handleExecutionResult(span, err, result) {
      const config = this.getConfig();
      if (result === undefined || err) {
        (0, utils_1.endSpan)(span, err);
        return;
      }
      if ((0, utils_1.isPromise)(result)) {
        result.then((resultData) => {
          if (typeof config.responseHook !== "function") {
            (0, utils_1.endSpan)(span);
            return;
          }
          this._executeResponseHook(span, resultData);
        }, (error2) => {
          (0, utils_1.endSpan)(span, error2);
        });
      } else {
        if (typeof config.responseHook !== "function") {
          (0, utils_1.endSpan)(span);
          return;
        }
        this._executeResponseHook(span, result);
      }
    }
    _executeResponseHook(span, result) {
      const { responseHook } = this.getConfig();
      if (!responseHook) {
        return;
      }
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
        responseHook(span, result);
      }, (err) => {
        if (err) {
          this._diag.error("Error running response hook", err);
        }
        (0, utils_1.endSpan)(span, undefined);
      }, true);
    }
    _patchParse() {
      const instrumentation = this;
      return function parse(original) {
        return function patchParse(source, options) {
          return instrumentation._parse(this, original, source, options);
        };
      };
    }
    _patchValidate() {
      const instrumentation = this;
      return function validate(original) {
        return function patchValidate(schema, documentAST, rules, options, typeInfo) {
          return instrumentation._validate(this, original, schema, documentAST, rules, typeInfo, options);
        };
      };
    }
    _parse(obj, original, source, options) {
      const config = this.getConfig();
      const span = this.tracer.startSpan(enum_1.SpanNames.PARSE);
      return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
        return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          return original.call(obj, source, options);
        }, (err, result) => {
          if (result) {
            const operation = (0, utils_1.getOperation)(result);
            if (!operation) {
              span.updateName(enum_1.SpanNames.SCHEMA_PARSE);
            } else if (result.loc) {
              (0, utils_1.addSpanSource)(span, result.loc, config.allowValues);
            }
          }
          (0, utils_1.endSpan)(span, err);
        });
      });
    }
    _validate(obj, original, schema, documentAST, rules, typeInfo, options) {
      const span = this.tracer.startSpan(enum_1.SpanNames.VALIDATE, {});
      return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
        return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          return original.call(obj, schema, documentAST, rules, options, typeInfo);
        }, (err, errors) => {
          if (!documentAST.loc) {
            span.updateName(enum_1.SpanNames.SCHEMA_VALIDATE);
          }
          if (errors && errors.length) {
            span.recordException({
              name: AttributeNames_1.AttributeNames.ERROR_VALIDATION_NAME,
              message: JSON.stringify(errors)
            });
          }
          (0, utils_1.endSpan)(span, err);
        });
      });
    }
    _createExecuteSpan(operation, processedArgs) {
      const config = this.getConfig();
      const span = this.tracer.startSpan(enum_1.SpanNames.EXECUTE, {});
      if (operation) {
        const { operation: operationType, name: nameNode } = operation;
        span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_TYPE, operationType);
        const operationName = nameNode?.value;
        if (operationName) {
          span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_NAME, operationName);
          span.updateName(`${operationType} ${operationName}`);
        } else {
          span.updateName(operationType);
        }
      } else {
        let operationName = " ";
        if (processedArgs.operationName) {
          operationName = ` "${processedArgs.operationName}" `;
        }
        operationName = internal_types_1.OPERATION_NOT_SUPPORTED.replace("$operationName$", operationName);
        span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_NAME, operationName);
      }
      if (processedArgs.document?.loc) {
        (0, utils_1.addSpanSource)(span, processedArgs.document.loc, config.allowValues);
      }
      if (processedArgs.variableValues && config.allowValues) {
        (0, utils_1.addInputVariableAttributes)(span, processedArgs.variableValues);
      }
      return span;
    }
    _wrapExecuteArgs(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver, defaultFieldResolved) {
      if (!contextValue) {
        contextValue = {};
      }
      if (contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] || this.getConfig().ignoreResolveSpans) {
        return {
          schema,
          document: document2,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        };
      }
      const isUsingDefaultResolver = fieldResolver == null;
      const fieldResolverForExecute = fieldResolver ?? defaultFieldResolved;
      fieldResolver = (0, utils_1.wrapFieldResolver)(this.tracer, () => this.getConfig(), fieldResolverForExecute, isUsingDefaultResolver);
      if (schema) {
        (0, utils_1.wrapFields)(schema.getQueryType(), this.tracer, () => this.getConfig());
        (0, utils_1.wrapFields)(schema.getMutationType(), this.tracer, () => this.getConfig());
      }
      return {
        schema,
        document: document2,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      };
    }
  }
  exports.GraphQLInstrumentation = GraphQLInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/index.js
var require_src13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GraphQLInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation4();
  Object.defineProperty(exports, "GraphQLInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.GraphQLInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/internal-types.js
var require_internal_types4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EVENT_LISTENERS_SET = undefined;
  exports.EVENT_LISTENERS_SET = Symbol("opentelemetry.instrumentation.kafkajs.eventListenersSet");
});

// ../../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js
var require_propagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferTextMapGetter = undefined;
  exports.bufferTextMapGetter = {
    get(carrier, key) {
      if (!carrier) {
        return;
      }
      const keys = Object.keys(carrier);
      for (const carrierKey of keys) {
        if (carrierKey === key || carrierKey.toLowerCase() === key) {
          return carrier[carrierKey]?.toString();
        }
      }
      return;
    },
    keys(carrier) {
      return carrier ? Object.keys(carrier) : [];
    }
  };
});

// ../../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/semconv.js
var require_semconv4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.METRIC_MESSAGING_PROCESS_DURATION = exports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = exports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = exports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = exports.MESSAGING_SYSTEM_VALUE_KAFKA = exports.MESSAGING_OPERATION_TYPE_VALUE_SEND = exports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = exports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = exports.ATTR_MESSAGING_SYSTEM = exports.ATTR_MESSAGING_OPERATION_TYPE = exports.ATTR_MESSAGING_OPERATION_NAME = exports.ATTR_MESSAGING_KAFKA_OFFSET = exports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = exports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = exports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = exports.ATTR_MESSAGING_DESTINATION_NAME = exports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = undefined;
  exports.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = "messaging.batch.message_count";
  exports.ATTR_MESSAGING_DESTINATION_NAME = "messaging.destination.name";
  exports.ATTR_MESSAGING_DESTINATION_PARTITION_ID = "messaging.destination.partition.id";
  exports.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message.key";
  exports.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = "messaging.kafka.message.tombstone";
  exports.ATTR_MESSAGING_KAFKA_OFFSET = "messaging.kafka.offset";
  exports.ATTR_MESSAGING_OPERATION_NAME = "messaging.operation.name";
  exports.ATTR_MESSAGING_OPERATION_TYPE = "messaging.operation.type";
  exports.ATTR_MESSAGING_SYSTEM = "messaging.system";
  exports.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = "process";
  exports.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = "receive";
  exports.MESSAGING_OPERATION_TYPE_VALUE_SEND = "send";
  exports.MESSAGING_SYSTEM_VALUE_KAFKA = "kafka";
  exports.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = "messaging.client.consumed.messages";
  exports.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = "messaging.client.operation.duration";
  exports.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = "messaging.client.sent.messages";
  exports.METRIC_MESSAGING_PROCESS_DURATION = "messaging.process.duration";
});

// ../../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js
var require_version7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.14.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-kafkajs";
});

// ../../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js
var require_instrumentation5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KafkaJsInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var internal_types_1 = require_internal_types4();
  var propagator_1 = require_propagator();
  var semconv_1 = require_semconv4();
  var version_1 = require_version7();
  function prepareCounter(meter, value, attributes) {
    return (errorType) => {
      meter.add(value, {
        ...attributes,
        ...errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}
      });
    };
  }
  function prepareDurationHistogram(meter, value, attributes) {
    return (errorType) => {
      meter.record((Date.now() - value) / 1000, {
        ...attributes,
        ...errorType ? { [semantic_conventions_1.ATTR_ERROR_TYPE]: errorType } : {}
      });
    };
  }
  var HISTOGRAM_BUCKET_BOUNDARIES = [
    0.005,
    0.01,
    0.025,
    0.05,
    0.075,
    0.1,
    0.25,
    0.5,
    0.75,
    1,
    2.5,
    5,
    7.5,
    10
  ];

  class KafkaJsInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    _updateMetricInstruments() {
      this._clientDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_CLIENT_OPERATION_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });
      this._sentMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_SENT_MESSAGES);
      this._consumedMessages = this.meter.createCounter(semconv_1.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES);
      this._processDuration = this.meter.createHistogram(semconv_1.METRIC_MESSAGING_PROCESS_DURATION, { advice: { explicitBucketBoundaries: HISTOGRAM_BUCKET_BOUNDARIES } });
    }
    init() {
      const unpatch = (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.producer)) {
          this._unwrap(moduleExports.Kafka.prototype, "producer");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports?.Kafka?.prototype.consumer)) {
          this._unwrap(moduleExports.Kafka.prototype, "consumer");
        }
      };
      const module2 = new instrumentation_1.InstrumentationNodeModuleDefinition("kafkajs", [">=0.3.0 <3"], (moduleExports) => {
        unpatch(moduleExports);
        this._wrap(moduleExports?.Kafka?.prototype, "producer", this._getProducerPatch());
        this._wrap(moduleExports?.Kafka?.prototype, "consumer", this._getConsumerPatch());
        return moduleExports;
      }, unpatch);
      return module2;
    }
    _getConsumerPatch() {
      const instrumentation = this;
      return (original) => {
        return function consumer(...args) {
          const newConsumer = original.apply(this, args);
          if ((0, instrumentation_1.isWrapped)(newConsumer.run)) {
            instrumentation._unwrap(newConsumer, "run");
          }
          instrumentation._wrap(newConsumer, "run", instrumentation._getConsumerRunPatch());
          instrumentation._setKafkaEventListeners(newConsumer);
          return newConsumer;
        };
      };
    }
    _setKafkaEventListeners(kafkaObj) {
      if (kafkaObj[internal_types_1.EVENT_LISTENERS_SET])
        return;
      if (kafkaObj.events?.REQUEST) {
        kafkaObj.on(kafkaObj.events.REQUEST, this._recordClientDurationMetric.bind(this));
      }
      kafkaObj[internal_types_1.EVENT_LISTENERS_SET] = true;
    }
    _recordClientDurationMetric(event) {
      const [address, port] = event.payload.broker.split(":");
      this._clientDuration.record(event.payload.duration / 1000, {
        [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,
        [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: `${event.payload.apiName}`,
        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: address,
        [semantic_conventions_1.ATTR_SERVER_PORT]: Number.parseInt(port, 10)
      });
    }
    _getProducerPatch() {
      const instrumentation = this;
      return (original) => {
        return function consumer(...args) {
          const newProducer = original.apply(this, args);
          if ((0, instrumentation_1.isWrapped)(newProducer.sendBatch)) {
            instrumentation._unwrap(newProducer, "sendBatch");
          }
          instrumentation._wrap(newProducer, "sendBatch", instrumentation._getSendBatchPatch());
          if ((0, instrumentation_1.isWrapped)(newProducer.send)) {
            instrumentation._unwrap(newProducer, "send");
          }
          instrumentation._wrap(newProducer, "send", instrumentation._getSendPatch());
          if ((0, instrumentation_1.isWrapped)(newProducer.transaction)) {
            instrumentation._unwrap(newProducer, "transaction");
          }
          instrumentation._wrap(newProducer, "transaction", instrumentation._getProducerTransactionPatch());
          instrumentation._setKafkaEventListeners(newProducer);
          return newProducer;
        };
      };
    }
    _getConsumerRunPatch() {
      const instrumentation = this;
      return (original) => {
        return function run(...args) {
          const config = args[0];
          if (config?.eachMessage) {
            if ((0, instrumentation_1.isWrapped)(config.eachMessage)) {
              instrumentation._unwrap(config, "eachMessage");
            }
            instrumentation._wrap(config, "eachMessage", instrumentation._getConsumerEachMessagePatch());
          }
          if (config?.eachBatch) {
            if ((0, instrumentation_1.isWrapped)(config.eachBatch)) {
              instrumentation._unwrap(config, "eachBatch");
            }
            instrumentation._wrap(config, "eachBatch", instrumentation._getConsumerEachBatchPatch());
          }
          return original.call(this, config);
        };
      };
    }
    _getConsumerEachMessagePatch() {
      const instrumentation = this;
      return (original) => {
        return function eachMessage(...args) {
          const payload = args[0];
          const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, payload.message.headers, propagator_1.bufferTextMapGetter);
          const span = instrumentation._startConsumerSpan({
            topic: payload.topic,
            message: payload.message,
            operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,
            ctx: propagatedContext,
            attributes: {
              [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition)
            }
          });
          const pendingMetrics = [
            prepareDurationHistogram(instrumentation._processDuration, Date.now(), {
              [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,
              [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: "process",
              [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,
              [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition)
            }),
            prepareCounter(instrumentation._consumedMessages, 1, {
              [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,
              [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: "process",
              [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.topic,
              [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.partition)
            })
          ];
          const eachMessagePromise = api_1.context.with(api_1.trace.setSpan(propagatedContext, span), () => {
            return original.apply(this, args);
          });
          return instrumentation._endSpansOnPromise([span], pendingMetrics, eachMessagePromise);
        };
      };
    }
    _getConsumerEachBatchPatch() {
      return (original) => {
        const instrumentation = this;
        return function eachBatch(...args) {
          const payload = args[0];
          const receivingSpan = instrumentation._startConsumerSpan({
            topic: payload.batch.topic,
            message: undefined,
            operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE,
            ctx: api_1.ROOT_CONTEXT,
            attributes: {
              [semconv_1.ATTR_MESSAGING_BATCH_MESSAGE_COUNT]: payload.batch.messages.length,
              [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition)
            }
          });
          return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), receivingSpan), () => {
            const startTime = Date.now();
            const spans = [];
            const pendingMetrics = [
              prepareCounter(instrumentation._consumedMessages, payload.batch.messages.length, {
                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,
                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: "process",
                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,
                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition)
              })
            ];
            payload.batch.messages.forEach((message) => {
              const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, message.headers, propagator_1.bufferTextMapGetter);
              const spanContext = api_1.trace.getSpan(propagatedContext)?.spanContext();
              let origSpanLink;
              if (spanContext) {
                origSpanLink = {
                  context: spanContext
                };
              }
              spans.push(instrumentation._startConsumerSpan({
                topic: payload.batch.topic,
                message,
                operationType: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,
                link: origSpanLink,
                attributes: {
                  [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition)
                }
              }));
              pendingMetrics.push(prepareDurationHistogram(instrumentation._processDuration, startTime, {
                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,
                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: "process",
                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: payload.batch.topic,
                [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(payload.batch.partition)
              }));
            });
            const batchMessagePromise = original.apply(this, args);
            spans.unshift(receivingSpan);
            return instrumentation._endSpansOnPromise(spans, pendingMetrics, batchMessagePromise);
          });
        };
      };
    }
    _getProducerTransactionPatch() {
      const instrumentation = this;
      return (original) => {
        return function transaction(...args) {
          const transactionSpan = instrumentation.tracer.startSpan("transaction");
          const transactionPromise = original.apply(this, args);
          transactionPromise.then((transaction) => {
            const originalSend = transaction.send;
            transaction.send = function send(...args2) {
              return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {
                const patched = instrumentation._getSendPatch()(originalSend);
                return patched.apply(this, args2).catch((err) => {
                  transactionSpan.setStatus({
                    code: api_1.SpanStatusCode.ERROR,
                    message: err?.message
                  });
                  transactionSpan.recordException(err);
                  throw err;
                });
              });
            };
            const originalSendBatch = transaction.sendBatch;
            transaction.sendBatch = function sendBatch(...args2) {
              return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), transactionSpan), () => {
                const patched = instrumentation._getSendBatchPatch()(originalSendBatch);
                return patched.apply(this, args2).catch((err) => {
                  transactionSpan.setStatus({
                    code: api_1.SpanStatusCode.ERROR,
                    message: err?.message
                  });
                  transactionSpan.recordException(err);
                  throw err;
                });
              });
            };
            const originalCommit = transaction.commit;
            transaction.commit = function commit(...args2) {
              const originCommitPromise = originalCommit.apply(this, args2).then(() => {
                transactionSpan.setStatus({ code: api_1.SpanStatusCode.OK });
              });
              return instrumentation._endSpansOnPromise([transactionSpan], [], originCommitPromise);
            };
            const originalAbort = transaction.abort;
            transaction.abort = function abort(...args2) {
              const originAbortPromise = originalAbort.apply(this, args2);
              return instrumentation._endSpansOnPromise([transactionSpan], [], originAbortPromise);
            };
          }).catch((err) => {
            transactionSpan.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: err?.message
            });
            transactionSpan.recordException(err);
            transactionSpan.end();
          });
          return transactionPromise;
        };
      };
    }
    _getSendBatchPatch() {
      const instrumentation = this;
      return (original) => {
        return function sendBatch(...args) {
          const batch = args[0];
          const messages = batch.topicMessages || [];
          const spans = [];
          const pendingMetrics = [];
          messages.forEach((topicMessage) => {
            topicMessage.messages.forEach((message) => {
              spans.push(instrumentation._startProducerSpan(topicMessage.topic, message));
              pendingMetrics.push(prepareCounter(instrumentation._sentMessages, 1, {
                [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,
                [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: "send",
                [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topicMessage.topic,
                ...message.partition !== undefined ? {
                  [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(message.partition)
                } : {}
              }));
            });
          });
          const origSendResult = original.apply(this, args);
          return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);
        };
      };
    }
    _getSendPatch() {
      const instrumentation = this;
      return (original) => {
        return function send(...args) {
          const record = args[0];
          const spans = record.messages.map((message) => {
            return instrumentation._startProducerSpan(record.topic, message);
          });
          const pendingMetrics = record.messages.map((m) => prepareCounter(instrumentation._sentMessages, 1, {
            [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,
            [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: "send",
            [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: record.topic,
            ...m.partition !== undefined ? {
              [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(m.partition)
            } : {}
          }));
          const origSendResult = original.apply(this, args);
          return instrumentation._endSpansOnPromise(spans, pendingMetrics, origSendResult);
        };
      };
    }
    _endSpansOnPromise(spans, pendingMetrics, sendPromise) {
      return Promise.resolve(sendPromise).then((result) => {
        pendingMetrics.forEach((m) => m());
        return result;
      }).catch((reason) => {
        let errorMessage;
        let errorType = semantic_conventions_1.ERROR_TYPE_VALUE_OTHER;
        if (typeof reason === "string" || reason === undefined) {
          errorMessage = reason;
        } else if (typeof reason === "object" && Object.prototype.hasOwnProperty.call(reason, "message")) {
          errorMessage = reason.message;
          errorType = reason.constructor.name;
        }
        pendingMetrics.forEach((m) => m(errorType));
        spans.forEach((span) => {
          span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, errorType);
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: errorMessage
          });
        });
        throw reason;
      }).finally(() => {
        spans.forEach((span) => span.end());
      });
    }
    _startConsumerSpan({ topic, message, operationType, ctx, link, attributes }) {
      const operationName = operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE ? "poll" : operationType;
      const span = this.tracer.startSpan(`${operationName} ${topic}`, {
        kind: operationType === semconv_1.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE ? api_1.SpanKind.CLIENT : api_1.SpanKind.CONSUMER,
        attributes: {
          ...attributes,
          [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,
          [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,
          [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: operationType,
          [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: operationName,
          [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message?.key ? String(message.key) : undefined,
          [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message?.key && message.value === null ? true : undefined,
          [semconv_1.ATTR_MESSAGING_KAFKA_OFFSET]: message?.offset
        },
        links: link ? [link] : []
      }, ctx);
      const { consumerHook } = this.getConfig();
      if (consumerHook && message) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumerHook(span, { topic, message }), (e) => {
          if (e)
            this._diag.error("consumerHook error", e);
        }, true);
      }
      return span;
    }
    _startProducerSpan(topic, message) {
      const span = this.tracer.startSpan(`send ${topic}`, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
          [semconv_1.ATTR_MESSAGING_SYSTEM]: semconv_1.MESSAGING_SYSTEM_VALUE_KAFKA,
          [semconv_1.ATTR_MESSAGING_DESTINATION_NAME]: topic,
          [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: message.key ? String(message.key) : undefined,
          [semconv_1.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: message.key && message.value === null ? true : undefined,
          [semconv_1.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: message.partition !== undefined ? String(message.partition) : undefined,
          [semconv_1.ATTR_MESSAGING_OPERATION_NAME]: "send",
          [semconv_1.ATTR_MESSAGING_OPERATION_TYPE]: semconv_1.MESSAGING_OPERATION_TYPE_VALUE_SEND
        }
      });
      message.headers = message.headers ?? {};
      api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), message.headers);
      const { producerHook } = this.getConfig();
      if (producerHook) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => producerHook(span, { topic, message }), (e) => {
          if (e)
            this._diag.error("producerHook error", e);
        }, true);
      }
      return span;
    }
  }
  exports.KafkaJsInstrumentation = KafkaJsInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js
var require_src14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KafkaJsInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation5();
  Object.defineProperty(exports, "KafkaJsInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.KafkaJsInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-lru-memoizer/build/src/version.js
var require_version8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.49.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-lru-memoizer";
});

// ../../node_modules/@opentelemetry/instrumentation-lru-memoizer/build/src/instrumentation.js
var require_instrumentation6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LruMemoizerInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var version_1 = require_version8();

  class LruMemoizerInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("lru-memoizer", [">=1.3 <3"], (moduleExports) => {
          const asyncMemoizer = function() {
            const origMemoizer = moduleExports.apply(this, arguments);
            return function() {
              const modifiedArguments = [...arguments];
              const origCallback = modifiedArguments.pop();
              const callbackWithContext = typeof origCallback === "function" ? api_1.context.bind(api_1.context.active(), origCallback) : origCallback;
              modifiedArguments.push(callbackWithContext);
              return origMemoizer.apply(this, modifiedArguments);
            };
          };
          asyncMemoizer.sync = moduleExports.sync;
          return asyncMemoizer;
        }, undefined)
      ];
    }
  }
  exports.LruMemoizerInstrumentation = LruMemoizerInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-lru-memoizer/build/src/index.js
var require_src15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LruMemoizerInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation6();
  Object.defineProperty(exports, "LruMemoizerInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.LruMemoizerInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/internal-types.js
var require_internal_types5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongodbCommandType = undefined;
  var MongodbCommandType;
  (function(MongodbCommandType2) {
    MongodbCommandType2["CREATE_INDEXES"] = "createIndexes";
    MongodbCommandType2["FIND_AND_MODIFY"] = "findAndModify";
    MongodbCommandType2["IS_MASTER"] = "isMaster";
    MongodbCommandType2["COUNT"] = "count";
    MongodbCommandType2["AGGREGATE"] = "aggregate";
    MongodbCommandType2["UNKNOWN"] = "unknown";
  })(MongodbCommandType = exports.MongodbCommandType || (exports.MongodbCommandType = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/version.js
var require_version9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.57.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mongodb";
});

// ../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/instrumentation.js
var require_instrumentation7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDBInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var internal_types_1 = require_internal_types5();
  var version_1 = require_version9();
  var DEFAULT_CONFIG = {
    requireParentSpan: true
  };

  class MongoDBInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, { ...DEFAULT_CONFIG, ...config });
    }
    setConfig(config = {}) {
      super.setConfig({ ...DEFAULT_CONFIG, ...config });
    }
    _updateMetricInstruments() {
      this._connectionsUsage = this.meter.createUpDownCounter("db.client.connections.usage", {
        description: "The number of connections that are currently in state described by the state attribute.",
        unit: "{connection}"
      });
    }
    init() {
      const { v3PatchConnection, v3UnpatchConnection } = this._getV3ConnectionPatches();
      const { v4PatchConnect, v4UnpatchConnect } = this._getV4ConnectPatches();
      const { v4PatchConnectionCallback, v4PatchConnectionPromise, v4UnpatchConnection } = this._getV4ConnectionPatches();
      const { v4PatchConnectionPool, v4UnpatchConnectionPool } = this._getV4ConnectionPoolPatches();
      const { v4PatchSessions, v4UnpatchSessions } = this._getV4SessionsPatches();
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("mongodb", [">=3.3.0 <4"], undefined, undefined, [
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/core/wireprotocol/index.js", [">=3.3.0 <4"], v3PatchConnection, v3UnpatchConnection)
        ]),
        new instrumentation_1.InstrumentationNodeModuleDefinition("mongodb", [">=4.0.0 <7"], undefined, undefined, [
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection.js", [">=4.0.0 <6.4"], v4PatchConnectionCallback, v4UnpatchConnection),
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection.js", [">=6.4.0 <7"], v4PatchConnectionPromise, v4UnpatchConnection),
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection_pool.js", [">=4.0.0 <6.4"], v4PatchConnectionPool, v4UnpatchConnectionPool),
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connect.js", [">=4.0.0 <7"], v4PatchConnect, v4UnpatchConnect),
          new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/sessions.js", [">=4.0.0 <7"], v4PatchSessions, v4UnpatchSessions)
        ])
      ];
    }
    _getV3ConnectionPatches() {
      return {
        v3PatchConnection: (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.insert)) {
            this._unwrap(moduleExports, "insert");
          }
          this._wrap(moduleExports, "insert", this._getV3PatchOperation("insert"));
          if ((0, instrumentation_1.isWrapped)(moduleExports.remove)) {
            this._unwrap(moduleExports, "remove");
          }
          this._wrap(moduleExports, "remove", this._getV3PatchOperation("remove"));
          if ((0, instrumentation_1.isWrapped)(moduleExports.update)) {
            this._unwrap(moduleExports, "update");
          }
          this._wrap(moduleExports, "update", this._getV3PatchOperation("update"));
          if ((0, instrumentation_1.isWrapped)(moduleExports.command)) {
            this._unwrap(moduleExports, "command");
          }
          this._wrap(moduleExports, "command", this._getV3PatchCommand());
          if ((0, instrumentation_1.isWrapped)(moduleExports.query)) {
            this._unwrap(moduleExports, "query");
          }
          this._wrap(moduleExports, "query", this._getV3PatchFind());
          if ((0, instrumentation_1.isWrapped)(moduleExports.getMore)) {
            this._unwrap(moduleExports, "getMore");
          }
          this._wrap(moduleExports, "getMore", this._getV3PatchCursor());
          return moduleExports;
        },
        v3UnpatchConnection: (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports, "insert");
          this._unwrap(moduleExports, "remove");
          this._unwrap(moduleExports, "update");
          this._unwrap(moduleExports, "command");
          this._unwrap(moduleExports, "query");
          this._unwrap(moduleExports, "getMore");
        }
      };
    }
    _getV4SessionsPatches() {
      return {
        v4PatchSessions: (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.acquire)) {
            this._unwrap(moduleExports, "acquire");
          }
          this._wrap(moduleExports.ServerSessionPool.prototype, "acquire", this._getV4AcquireCommand());
          if ((0, instrumentation_1.isWrapped)(moduleExports.release)) {
            this._unwrap(moduleExports, "release");
          }
          this._wrap(moduleExports.ServerSessionPool.prototype, "release", this._getV4ReleaseCommand());
          return moduleExports;
        },
        v4UnpatchSessions: (moduleExports) => {
          if (moduleExports === undefined)
            return;
          if ((0, instrumentation_1.isWrapped)(moduleExports.acquire)) {
            this._unwrap(moduleExports, "acquire");
          }
          if ((0, instrumentation_1.isWrapped)(moduleExports.release)) {
            this._unwrap(moduleExports, "release");
          }
        }
      };
    }
    _getV4AcquireCommand() {
      const instrumentation = this;
      return (original) => {
        return function patchAcquire() {
          const nSessionsBeforeAcquire = this.sessions.length;
          const session = original.call(this);
          const nSessionsAfterAcquire = this.sessions.length;
          if (nSessionsBeforeAcquire === nSessionsAfterAcquire) {
            instrumentation._connectionsUsage.add(1, {
              state: "used",
              "pool.name": instrumentation._poolName
            });
          } else if (nSessionsBeforeAcquire - 1 === nSessionsAfterAcquire) {
            instrumentation._connectionsUsage.add(-1, {
              state: "idle",
              "pool.name": instrumentation._poolName
            });
            instrumentation._connectionsUsage.add(1, {
              state: "used",
              "pool.name": instrumentation._poolName
            });
          }
          return session;
        };
      };
    }
    _getV4ReleaseCommand() {
      const instrumentation = this;
      return (original) => {
        return function patchRelease(session) {
          const cmdPromise = original.call(this, session);
          instrumentation._connectionsUsage.add(-1, {
            state: "used",
            "pool.name": instrumentation._poolName
          });
          instrumentation._connectionsUsage.add(1, {
            state: "idle",
            "pool.name": instrumentation._poolName
          });
          return cmdPromise;
        };
      };
    }
    _getV4ConnectionPoolPatches() {
      return {
        v4PatchConnectionPool: (moduleExports) => {
          const poolPrototype = moduleExports.ConnectionPool.prototype;
          if ((0, instrumentation_1.isWrapped)(poolPrototype.checkOut)) {
            this._unwrap(poolPrototype, "checkOut");
          }
          this._wrap(poolPrototype, "checkOut", this._getV4ConnectionPoolCheckOut());
          return moduleExports;
        },
        v4UnpatchConnectionPool: (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports.ConnectionPool.prototype, "checkOut");
        }
      };
    }
    _getV4ConnectPatches() {
      return {
        v4PatchConnect: (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {
            this._unwrap(moduleExports, "connect");
          }
          this._wrap(moduleExports, "connect", this._getV4ConnectCommand());
          return moduleExports;
        },
        v4UnpatchConnect: (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports, "connect");
        }
      };
    }
    _getV4ConnectionPoolCheckOut() {
      return (original) => {
        return function patchedCheckout(callback) {
          const patchedCallback = api_1.context.bind(api_1.context.active(), callback);
          return original.call(this, patchedCallback);
        };
      };
    }
    _getV4ConnectCommand() {
      const instrumentation = this;
      return (original) => {
        return function patchedConnect(options, callback) {
          if (original.length === 1) {
            const result = original.call(this, options);
            if (result && typeof result.then === "function") {
              result.then(() => instrumentation.setPoolName(options), () => {
                return;
              });
            }
            return result;
          }
          const patchedCallback = function(err, conn) {
            if (err || !conn) {
              callback(err, conn);
              return;
            }
            instrumentation.setPoolName(options);
            callback(err, conn);
          };
          return original.call(this, options, patchedCallback);
        };
      };
    }
    _getV4ConnectionPatches() {
      return {
        v4PatchConnectionCallback: (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.Connection.prototype.command)) {
            this._unwrap(moduleExports.Connection.prototype, "command");
          }
          this._wrap(moduleExports.Connection.prototype, "command", this._getV4PatchCommandCallback());
          return moduleExports;
        },
        v4PatchConnectionPromise: (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.Connection.prototype.command)) {
            this._unwrap(moduleExports.Connection.prototype, "command");
          }
          this._wrap(moduleExports.Connection.prototype, "command", this._getV4PatchCommandPromise());
          return moduleExports;
        },
        v4UnpatchConnection: (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports.Connection.prototype, "command");
        }
      };
    }
    _getV3PatchOperation(operationName) {
      const instrumentation = this;
      return (original) => {
        return function patchedServerCommand(server, ns, ops, options, callback) {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
          const resultHandler = typeof options === "function" ? options : callback;
          if (skipInstrumentation || typeof resultHandler !== "function" || typeof ops !== "object") {
            if (typeof options === "function") {
              return original.call(this, server, ns, ops, options);
            } else {
              return original.call(this, server, ns, ops, options, callback);
            }
          }
          const span = instrumentation.tracer.startSpan(`mongodb.${operationName}`, {
            kind: api_1.SpanKind.CLIENT
          });
          instrumentation._populateV3Attributes(span, ns, server, ops[0], operationName);
          const patchedCallback = instrumentation._patchEnd(span, resultHandler);
          if (typeof options === "function") {
            return original.call(this, server, ns, ops, patchedCallback);
          } else {
            return original.call(this, server, ns, ops, options, patchedCallback);
          }
        };
      };
    }
    _getV3PatchCommand() {
      const instrumentation = this;
      return (original) => {
        return function patchedServerCommand(server, ns, cmd, options, callback) {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
          const resultHandler = typeof options === "function" ? options : callback;
          if (skipInstrumentation || typeof resultHandler !== "function" || typeof cmd !== "object") {
            if (typeof options === "function") {
              return original.call(this, server, ns, cmd, options);
            } else {
              return original.call(this, server, ns, cmd, options, callback);
            }
          }
          const commandType = MongoDBInstrumentation._getCommandType(cmd);
          const type = commandType === internal_types_1.MongodbCommandType.UNKNOWN ? "command" : commandType;
          const span = instrumentation.tracer.startSpan(`mongodb.${type}`, {
            kind: api_1.SpanKind.CLIENT
          });
          const operation = commandType === internal_types_1.MongodbCommandType.UNKNOWN ? undefined : commandType;
          instrumentation._populateV3Attributes(span, ns, server, cmd, operation);
          const patchedCallback = instrumentation._patchEnd(span, resultHandler);
          if (typeof options === "function") {
            return original.call(this, server, ns, cmd, patchedCallback);
          } else {
            return original.call(this, server, ns, cmd, options, patchedCallback);
          }
        };
      };
    }
    _getV4PatchCommandCallback() {
      const instrumentation = this;
      return (original) => {
        return function patchedV4ServerCommand(ns, cmd, options, callback) {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
          const resultHandler = callback;
          const commandType = Object.keys(cmd)[0];
          if (typeof cmd !== "object" || cmd.ismaster || cmd.hello) {
            return original.call(this, ns, cmd, options, callback);
          }
          let span = undefined;
          if (!skipInstrumentation) {
            span = instrumentation.tracer.startSpan(`mongodb.${commandType}`, {
              kind: api_1.SpanKind.CLIENT
            });
            instrumentation._populateV4Attributes(span, this, ns, cmd, commandType);
          }
          const patchedCallback = instrumentation._patchEnd(span, resultHandler, this.id, commandType);
          return original.call(this, ns, cmd, options, patchedCallback);
        };
      };
    }
    _getV4PatchCommandPromise() {
      const instrumentation = this;
      return (original) => {
        return function patchedV4ServerCommand(...args) {
          const [ns, cmd] = args;
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
          const commandType = Object.keys(cmd)[0];
          const resultHandler = () => {
            return;
          };
          if (typeof cmd !== "object" || cmd.ismaster || cmd.hello) {
            return original.apply(this, args);
          }
          let span = undefined;
          if (!skipInstrumentation) {
            span = instrumentation.tracer.startSpan(`mongodb.${commandType}`, {
              kind: api_1.SpanKind.CLIENT
            });
            instrumentation._populateV4Attributes(span, this, ns, cmd, commandType);
          }
          const patchedCallback = instrumentation._patchEnd(span, resultHandler, this.id, commandType);
          const result = original.apply(this, args);
          result.then((res) => patchedCallback(null, res), (err) => patchedCallback(err));
          return result;
        };
      };
    }
    _getV3PatchFind() {
      const instrumentation = this;
      return (original) => {
        return function patchedServerCommand(server, ns, cmd, cursorState, options, callback) {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
          const resultHandler = typeof options === "function" ? options : callback;
          if (skipInstrumentation || typeof resultHandler !== "function" || typeof cmd !== "object") {
            if (typeof options === "function") {
              return original.call(this, server, ns, cmd, cursorState, options);
            } else {
              return original.call(this, server, ns, cmd, cursorState, options, callback);
            }
          }
          const span = instrumentation.tracer.startSpan("mongodb.find", {
            kind: api_1.SpanKind.CLIENT
          });
          instrumentation._populateV3Attributes(span, ns, server, cmd, "find");
          const patchedCallback = instrumentation._patchEnd(span, resultHandler);
          if (typeof options === "function") {
            return original.call(this, server, ns, cmd, cursorState, patchedCallback);
          } else {
            return original.call(this, server, ns, cmd, cursorState, options, patchedCallback);
          }
        };
      };
    }
    _getV3PatchCursor() {
      const instrumentation = this;
      return (original) => {
        return function patchedServerCommand(server, ns, cursorState, batchSize, options, callback) {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
          const resultHandler = typeof options === "function" ? options : callback;
          if (skipInstrumentation || typeof resultHandler !== "function") {
            if (typeof options === "function") {
              return original.call(this, server, ns, cursorState, batchSize, options);
            } else {
              return original.call(this, server, ns, cursorState, batchSize, options, callback);
            }
          }
          const span = instrumentation.tracer.startSpan("mongodb.getMore", {
            kind: api_1.SpanKind.CLIENT
          });
          instrumentation._populateV3Attributes(span, ns, server, cursorState.cmd, "getMore");
          const patchedCallback = instrumentation._patchEnd(span, resultHandler);
          if (typeof options === "function") {
            return original.call(this, server, ns, cursorState, batchSize, patchedCallback);
          } else {
            return original.call(this, server, ns, cursorState, batchSize, options, patchedCallback);
          }
        };
      };
    }
    static _getCommandType(command) {
      if (command.createIndexes !== undefined) {
        return internal_types_1.MongodbCommandType.CREATE_INDEXES;
      } else if (command.findandmodify !== undefined) {
        return internal_types_1.MongodbCommandType.FIND_AND_MODIFY;
      } else if (command.ismaster !== undefined) {
        return internal_types_1.MongodbCommandType.IS_MASTER;
      } else if (command.count !== undefined) {
        return internal_types_1.MongodbCommandType.COUNT;
      } else if (command.aggregate !== undefined) {
        return internal_types_1.MongodbCommandType.AGGREGATE;
      } else {
        return internal_types_1.MongodbCommandType.UNKNOWN;
      }
    }
    _populateV4Attributes(span, connectionCtx, ns, command, operation) {
      let host, port;
      if (connectionCtx) {
        const hostParts = typeof connectionCtx.address === "string" ? connectionCtx.address.split(":") : "";
        if (hostParts.length === 2) {
          host = hostParts[0];
          port = hostParts[1];
        }
      }
      let commandObj;
      if (command?.documents && command.documents[0]) {
        commandObj = command.documents[0];
      } else if (command?.cursors) {
        commandObj = command.cursors;
      } else {
        commandObj = command;
      }
      this._addAllSpanAttributes(span, ns.db, ns.collection, host, port, commandObj, operation);
    }
    _populateV3Attributes(span, ns, topology, command, operation) {
      let host;
      let port;
      if (topology && topology.s) {
        host = topology.s.options?.host ?? topology.s.host;
        port = (topology.s.options?.port ?? topology.s.port)?.toString();
        if (host == null || port == null) {
          const address = topology.description?.address;
          if (address) {
            const addressSegments = address.split(":");
            host = addressSegments[0];
            port = addressSegments[1];
          }
        }
      }
      const [dbName, dbCollection] = ns.toString().split(".");
      const commandObj = command?.query ?? command?.q ?? command;
      this._addAllSpanAttributes(span, dbName, dbCollection, host, port, commandObj, operation);
    }
    _addAllSpanAttributes(span, dbName, dbCollection, host, port, commandObj, operation) {
      span.setAttributes({
        [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MONGODB,
        [semantic_conventions_1.SEMATTRS_DB_NAME]: dbName,
        [semantic_conventions_1.SEMATTRS_DB_MONGODB_COLLECTION]: dbCollection,
        [semantic_conventions_1.SEMATTRS_DB_OPERATION]: operation,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `mongodb://${host}:${port}/${dbName}`
      });
      if (host && port) {
        span.setAttribute(semantic_conventions_1.SEMATTRS_NET_PEER_NAME, host);
        const portNumber = parseInt(port, 10);
        if (!isNaN(portNumber)) {
          span.setAttribute(semantic_conventions_1.SEMATTRS_NET_PEER_PORT, portNumber);
        }
      }
      if (!commandObj)
        return;
      const { dbStatementSerializer: configDbStatementSerializer } = this.getConfig();
      const dbStatementSerializer = typeof configDbStatementSerializer === "function" ? configDbStatementSerializer : this._defaultDbStatementSerializer.bind(this);
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
        const query = dbStatementSerializer(commandObj);
        span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, query);
      }, (err) => {
        if (err) {
          this._diag.error("Error running dbStatementSerializer hook", err);
        }
      }, true);
    }
    _defaultDbStatementSerializer(commandObj) {
      const { enhancedDatabaseReporting } = this.getConfig();
      const resultObj = enhancedDatabaseReporting ? commandObj : this._scrubStatement(commandObj);
      return JSON.stringify(resultObj);
    }
    _scrubStatement(value) {
      if (Array.isArray(value)) {
        return value.map((element) => this._scrubStatement(element));
      }
      if (typeof value === "object" && value !== null) {
        return Object.fromEntries(Object.entries(value).map(([key, element]) => [
          key,
          this._scrubStatement(element)
        ]));
      }
      return "?";
    }
    _handleExecutionResult(span, result) {
      const { responseHook } = this.getConfig();
      if (typeof responseHook === "function") {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          responseHook(span, { data: result });
        }, (err) => {
          if (err) {
            this._diag.error("Error running response hook", err);
          }
        }, true);
      }
    }
    _patchEnd(span, resultHandler, connectionId, commandType) {
      const activeContext = api_1.context.active();
      const instrumentation = this;
      return function patchedEnd(...args) {
        const error2 = args[0];
        if (span) {
          if (error2 instanceof Error) {
            span?.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: error2.message
            });
          } else {
            const result = args[1];
            instrumentation._handleExecutionResult(span, result);
          }
          span.end();
        }
        return api_1.context.with(activeContext, () => {
          if (commandType === "endSessions") {
            instrumentation._connectionsUsage.add(-1, {
              state: "idle",
              "pool.name": instrumentation._poolName
            });
          }
          return resultHandler.apply(this, args);
        });
      };
    }
    setPoolName(options) {
      const host = options.hostAddress?.host;
      const port = options.hostAddress?.port;
      const database = options.dbName;
      const poolName = `mongodb://${host}:${port}/${database}`;
      this._poolName = poolName;
    }
    _checkSkipInstrumentation(currentSpan) {
      const requireParentSpan = this.getConfig().requireParentSpan;
      const hasNoParentSpan = currentSpan === undefined;
      return requireParentSpan === true && hasNoParentSpan;
    }
  }
  exports.MongoDBInstrumentation = MongoDBInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongodbCommandType = undefined;
  var MongodbCommandType;
  (function(MongodbCommandType2) {
    MongodbCommandType2["CREATE_INDEXES"] = "createIndexes";
    MongodbCommandType2["FIND_AND_MODIFY"] = "findAndModify";
    MongodbCommandType2["IS_MASTER"] = "isMaster";
    MongodbCommandType2["COUNT"] = "count";
    MongodbCommandType2["UNKNOWN"] = "unknown";
  })(MongodbCommandType = exports.MongodbCommandType || (exports.MongodbCommandType = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/index.js
var require_src16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongodbCommandType = exports.MongoDBInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation7();
  Object.defineProperty(exports, "MongoDBInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.MongoDBInstrumentation;
  } });
  var types_1 = require_types2();
  Object.defineProperty(exports, "MongodbCommandType", { enumerable: true, get: function() {
    return types_1.MongodbCommandType;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/utils.js
var require_utils11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.handleCallbackResponse = exports.handlePromiseResponse = exports.getAttributesFromCollection = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  function getAttributesFromCollection(collection) {
    return {
      [semantic_conventions_1.SEMATTRS_DB_MONGODB_COLLECTION]: collection.name,
      [semantic_conventions_1.SEMATTRS_DB_NAME]: collection.conn.name,
      [semantic_conventions_1.SEMATTRS_DB_USER]: collection.conn.user,
      [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: collection.conn.host,
      [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: collection.conn.port
    };
  }
  exports.getAttributesFromCollection = getAttributesFromCollection;
  function setErrorStatus(span, error2 = {}) {
    span.recordException(error2);
    span.setStatus({
      code: api_1.SpanStatusCode.ERROR,
      message: `${error2.message} ${error2.code ? `
Mongoose Error Code: ${error2.code}` : ""}`
    });
  }
  function applyResponseHook(span, response, responseHook, moduleVersion = undefined) {
    if (!responseHook) {
      return;
    }
    (0, instrumentation_1.safeExecuteInTheMiddle)(() => responseHook(span, { moduleVersion, response }), (e) => {
      if (e) {
        api_1.diag.error("mongoose instrumentation: responseHook error", e);
      }
    }, true);
  }
  function handlePromiseResponse(execResponse, span, responseHook, moduleVersion = undefined) {
    if (!(execResponse instanceof Promise)) {
      applyResponseHook(span, execResponse, responseHook, moduleVersion);
      span.end();
      return execResponse;
    }
    return execResponse.then((response) => {
      applyResponseHook(span, response, responseHook, moduleVersion);
      return response;
    }).catch((err) => {
      setErrorStatus(span, err);
      throw err;
    }).finally(() => span.end());
  }
  exports.handlePromiseResponse = handlePromiseResponse;
  function handleCallbackResponse(callback, exec, originalThis, span, args, responseHook, moduleVersion = undefined) {
    let callbackArgumentIndex = 0;
    if (args.length === 2) {
      callbackArgumentIndex = 1;
    } else if (args.length === 3) {
      callbackArgumentIndex = 2;
    }
    args[callbackArgumentIndex] = (err, response) => {
      err ? setErrorStatus(span, err) : applyResponseHook(span, response, responseHook, moduleVersion);
      span.end();
      return callback(err, response);
    };
    return exec.apply(originalThis, args);
  }
  exports.handleCallbackResponse = handleCallbackResponse;
});

// ../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/version.js
var require_version10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.51.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mongoose";
});

// ../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/mongoose.js
var require_mongoose = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongooseInstrumentation = exports._STORED_PARENT_SPAN = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var utils_1 = require_utils11();
  var instrumentation_1 = require_src6();
  var version_1 = require_version10();
  var semantic_conventions_1 = require_src2();
  var contextCaptureFunctionsCommon = [
    "deleteOne",
    "deleteMany",
    "find",
    "findOne",
    "estimatedDocumentCount",
    "countDocuments",
    "distinct",
    "where",
    "$where",
    "findOneAndUpdate",
    "findOneAndDelete",
    "findOneAndReplace"
  ];
  var contextCaptureFunctions6 = [
    "remove",
    "count",
    "findOneAndRemove",
    ...contextCaptureFunctionsCommon
  ];
  var contextCaptureFunctions7 = [
    "count",
    "findOneAndRemove",
    ...contextCaptureFunctionsCommon
  ];
  var contextCaptureFunctions8 = [...contextCaptureFunctionsCommon];
  function getContextCaptureFunctions(moduleVersion) {
    if (!moduleVersion) {
      return contextCaptureFunctionsCommon;
    } else if (moduleVersion.startsWith("6.") || moduleVersion.startsWith("5.")) {
      return contextCaptureFunctions6;
    } else if (moduleVersion.startsWith("7.")) {
      return contextCaptureFunctions7;
    } else {
      return contextCaptureFunctions8;
    }
  }
  function instrumentRemove(moduleVersion) {
    return moduleVersion && (moduleVersion.startsWith("5.") || moduleVersion.startsWith("6.")) || false;
  }
  exports._STORED_PARENT_SPAN = Symbol("stored-parent-span");

  class MongooseInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      const module2 = new instrumentation_1.InstrumentationNodeModuleDefinition("mongoose", [">=5.9.7 <9"], this.patch.bind(this), this.unpatch.bind(this));
      return module2;
    }
    patch(module2, moduleVersion) {
      const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
      this._wrap(moduleExports.Model.prototype, "save", this.patchOnModelMethods("save", moduleVersion));
      moduleExports.Model.prototype.$save = moduleExports.Model.prototype.save;
      if (instrumentRemove(moduleVersion)) {
        this._wrap(moduleExports.Model.prototype, "remove", this.patchOnModelMethods("remove", moduleVersion));
      }
      this._wrap(moduleExports.Query.prototype, "exec", this.patchQueryExec(moduleVersion));
      this._wrap(moduleExports.Aggregate.prototype, "exec", this.patchAggregateExec(moduleVersion));
      const contextCaptureFunctions = getContextCaptureFunctions(moduleVersion);
      contextCaptureFunctions.forEach((funcName) => {
        this._wrap(moduleExports.Query.prototype, funcName, this.patchAndCaptureSpanContext(funcName));
      });
      this._wrap(moduleExports.Model, "aggregate", this.patchModelAggregate());
      this._wrap(moduleExports.Model, "insertMany", this.patchModelStatic("insertMany", moduleVersion));
      this._wrap(moduleExports.Model, "bulkWrite", this.patchModelStatic("bulkWrite", moduleVersion));
      return moduleExports;
    }
    unpatch(module2, moduleVersion) {
      const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
      const contextCaptureFunctions = getContextCaptureFunctions(moduleVersion);
      this._unwrap(moduleExports.Model.prototype, "save");
      moduleExports.Model.prototype.$save = moduleExports.Model.prototype.save;
      if (instrumentRemove(moduleVersion)) {
        this._unwrap(moduleExports.Model.prototype, "remove");
      }
      this._unwrap(moduleExports.Query.prototype, "exec");
      this._unwrap(moduleExports.Aggregate.prototype, "exec");
      contextCaptureFunctions.forEach((funcName) => {
        this._unwrap(moduleExports.Query.prototype, funcName);
      });
      this._unwrap(moduleExports.Model, "aggregate");
      this._unwrap(moduleExports.Model, "insertMany");
      this._unwrap(moduleExports.Model, "bulkWrite");
    }
    patchAggregateExec(moduleVersion) {
      const self = this;
      return (originalAggregate) => {
        return function exec(callback) {
          if (self.getConfig().requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === undefined) {
            return originalAggregate.apply(this, arguments);
          }
          const parentSpan = this[exports._STORED_PARENT_SPAN];
          const attributes = {};
          const { dbStatementSerializer } = self.getConfig();
          if (dbStatementSerializer) {
            attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatementSerializer("aggregate", {
              options: this.options,
              aggregatePipeline: this._pipeline
            });
          }
          const span = self._startSpan(this._model.collection, this._model?.modelName, "aggregate", attributes, parentSpan);
          return self._handleResponse(span, originalAggregate, this, arguments, callback, moduleVersion);
        };
      };
    }
    patchQueryExec(moduleVersion) {
      const self = this;
      return (originalExec) => {
        return function exec(callback) {
          if (self.getConfig().requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === undefined) {
            return originalExec.apply(this, arguments);
          }
          const parentSpan = this[exports._STORED_PARENT_SPAN];
          const attributes = {};
          const { dbStatementSerializer } = self.getConfig();
          if (dbStatementSerializer) {
            attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatementSerializer(this.op, {
              condition: this._conditions,
              updates: this._update,
              options: this.options,
              fields: this._fields
            });
          }
          const span = self._startSpan(this.mongooseCollection, this.model.modelName, this.op, attributes, parentSpan);
          return self._handleResponse(span, originalExec, this, arguments, callback, moduleVersion);
        };
      };
    }
    patchOnModelMethods(op, moduleVersion) {
      const self = this;
      return (originalOnModelFunction) => {
        return function method(options, callback) {
          if (self.getConfig().requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === undefined) {
            return originalOnModelFunction.apply(this, arguments);
          }
          const serializePayload = { document: this };
          if (options && !(options instanceof Function)) {
            serializePayload.options = options;
          }
          const attributes = {};
          const { dbStatementSerializer } = self.getConfig();
          if (dbStatementSerializer) {
            attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatementSerializer(op, serializePayload);
          }
          const span = self._startSpan(this.constructor.collection, this.constructor.modelName, op, attributes);
          if (options instanceof Function) {
            callback = options;
            options = undefined;
          }
          return self._handleResponse(span, originalOnModelFunction, this, arguments, callback, moduleVersion);
        };
      };
    }
    patchModelStatic(op, moduleVersion) {
      const self = this;
      return (original) => {
        return function patchedStatic(docsOrOps, options, callback) {
          if (self.getConfig().requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === undefined) {
            return original.apply(this, arguments);
          }
          if (typeof options === "function") {
            callback = options;
            options = undefined;
          }
          const serializePayload = {};
          switch (op) {
            case "insertMany":
              serializePayload.documents = docsOrOps;
              break;
            case "bulkWrite":
              serializePayload.operations = docsOrOps;
              break;
            default:
              serializePayload.document = docsOrOps;
              break;
          }
          if (options !== undefined) {
            serializePayload.options = options;
          }
          const attributes = {};
          const { dbStatementSerializer } = self.getConfig();
          if (dbStatementSerializer) {
            attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatementSerializer(op, serializePayload);
          }
          const span = self._startSpan(this.collection, this.modelName, op, attributes);
          return self._handleResponse(span, original, this, arguments, callback, moduleVersion);
        };
      };
    }
    patchModelAggregate() {
      const self = this;
      return (original) => {
        return function captureSpanContext() {
          const currentSpan = api_1.trace.getSpan(api_1.context.active());
          const aggregate = self._callOriginalFunction(() => original.apply(this, arguments));
          if (aggregate)
            aggregate[exports._STORED_PARENT_SPAN] = currentSpan;
          return aggregate;
        };
      };
    }
    patchAndCaptureSpanContext(funcName) {
      const self = this;
      return (original) => {
        return function captureSpanContext() {
          this[exports._STORED_PARENT_SPAN] = api_1.trace.getSpan(api_1.context.active());
          return self._callOriginalFunction(() => original.apply(this, arguments));
        };
      };
    }
    _startSpan(collection, modelName, operation, attributes, parentSpan) {
      return this.tracer.startSpan(`mongoose.${modelName}.${operation}`, {
        kind: api_1.SpanKind.CLIENT,
        attributes: {
          ...attributes,
          ...(0, utils_1.getAttributesFromCollection)(collection),
          [semantic_conventions_1.SEMATTRS_DB_OPERATION]: operation,
          [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: "mongoose"
        }
      }, parentSpan ? api_1.trace.setSpan(api_1.context.active(), parentSpan) : undefined);
    }
    _handleResponse(span, exec, originalThis, args, callback, moduleVersion = undefined) {
      const self = this;
      if (callback instanceof Function) {
        return self._callOriginalFunction(() => (0, utils_1.handleCallbackResponse)(callback, exec, originalThis, span, args, self.getConfig().responseHook, moduleVersion));
      } else {
        const response = self._callOriginalFunction(() => exec.apply(originalThis, args));
        return (0, utils_1.handlePromiseResponse)(response, span, self.getConfig().responseHook, moduleVersion);
      }
    }
    _callOriginalFunction(originalFunction) {
      if (this.getConfig().suppressInternalInstrumentation) {
        return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), originalFunction);
      } else {
        return originalFunction();
      }
    }
  }
  exports.MongooseInstrumentation = MongooseInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/index.js
var require_src17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongooseInstrumentation = undefined;
  var mongoose_1 = require_mongoose();
  Object.defineProperty(exports, "MongooseInstrumentation", { enumerable: true, get: function() {
    return mongoose_1.MongooseInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/AttributeNames.js
var require_AttributeNames4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames2;
  (function(AttributeNames3) {
    AttributeNames3["MYSQL_VALUES"] = "db.mysql.values";
  })(AttributeNames2 = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/utils.js
var require_utils12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getPoolName = exports.arrayStringifyHelper = exports.getSpanName = exports.getDbValues = exports.getDbStatement = exports.getConnectionAttributes = undefined;
  var semantic_conventions_1 = require_src2();
  function getConnectionAttributes(config) {
    const { host, port, database, user } = getConfig(config);
    const portNumber = parseInt(port, 10);
    if (!isNaN(portNumber)) {
      return {
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: portNumber,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
        [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
        [semantic_conventions_1.SEMATTRS_DB_USER]: user
      };
    }
    return {
      [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
      [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
      [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
      [semantic_conventions_1.SEMATTRS_DB_USER]: user
    };
  }
  exports.getConnectionAttributes = getConnectionAttributes;
  function getConfig(config) {
    const { host, port, database, user } = config && config.connectionConfig || config || {};
    return { host, port, database, user };
  }
  function getJDBCString(host, port, database) {
    let jdbcString = `jdbc:mysql://${host || "localhost"}`;
    if (typeof port === "number") {
      jdbcString += `:${port}`;
    }
    if (typeof database === "string") {
      jdbcString += `/${database}`;
    }
    return jdbcString;
  }
  function getDbStatement(query) {
    if (typeof query === "string") {
      return query;
    } else {
      return query.sql;
    }
  }
  exports.getDbStatement = getDbStatement;
  function getDbValues(query, values) {
    if (typeof query === "string") {
      return arrayStringifyHelper(values);
    } else {
      return arrayStringifyHelper(values || query.values);
    }
  }
  exports.getDbValues = getDbValues;
  function getSpanName(query) {
    const rawQuery = typeof query === "object" ? query.sql : query;
    const firstSpace = rawQuery?.indexOf(" ");
    if (typeof firstSpace === "number" && firstSpace !== -1) {
      return rawQuery?.substring(0, firstSpace);
    }
    return rawQuery;
  }
  exports.getSpanName = getSpanName;
  function arrayStringifyHelper(arr) {
    if (arr)
      return `[${arr.toString()}]`;
    return "";
  }
  exports.arrayStringifyHelper = arrayStringifyHelper;
  function getPoolName(pool) {
    const c = pool.config.connectionConfig;
    let poolName = "";
    poolName += c.host ? `host: '${c.host}', ` : "";
    poolName += c.port ? `port: ${c.port}, ` : "";
    poolName += c.database ? `database: '${c.database}', ` : "";
    poolName += c.user ? `user: '${c.user}'` : "";
    if (!c.user) {
      poolName = poolName.substring(0, poolName.length - 2);
    }
    return poolName.trim();
  }
  exports.getPoolName = getPoolName;
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/version.js
var require_version11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.50.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mysql";
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/instrumentation.js
var require_instrumentation8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MySQLInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var AttributeNames_1 = require_AttributeNames4();
  var utils_1 = require_utils12();
  var version_1 = require_version11();

  class MySQLInstrumentation extends instrumentation_1.InstrumentationBase {
    static COMMON_ATTRIBUTES = {
      [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MYSQL
    };
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    _updateMetricInstruments() {
      this._connectionsUsage = this.meter.createUpDownCounter("db.client.connections.usage", {
        description: "The number of connections that are currently in state described by the state attribute.",
        unit: "{connection}"
      });
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("mysql", [">=2.0.0 <3"], (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.createConnection)) {
            this._unwrap(moduleExports, "createConnection");
          }
          this._wrap(moduleExports, "createConnection", this._patchCreateConnection());
          if ((0, instrumentation_1.isWrapped)(moduleExports.createPool)) {
            this._unwrap(moduleExports, "createPool");
          }
          this._wrap(moduleExports, "createPool", this._patchCreatePool());
          if ((0, instrumentation_1.isWrapped)(moduleExports.createPoolCluster)) {
            this._unwrap(moduleExports, "createPoolCluster");
          }
          this._wrap(moduleExports, "createPoolCluster", this._patchCreatePoolCluster());
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports, "createConnection");
          this._unwrap(moduleExports, "createPool");
          this._unwrap(moduleExports, "createPoolCluster");
        })
      ];
    }
    _patchCreateConnection() {
      return (originalCreateConnection) => {
        const thisPlugin = this;
        return function createConnection(_connectionUri) {
          const originalResult = originalCreateConnection(...arguments);
          thisPlugin._wrap(originalResult, "query", thisPlugin._patchQuery(originalResult));
          return originalResult;
        };
      };
    }
    _patchCreatePool() {
      return (originalCreatePool) => {
        const thisPlugin = this;
        return function createPool(_config) {
          const pool = originalCreatePool(...arguments);
          thisPlugin._wrap(pool, "query", thisPlugin._patchQuery(pool));
          thisPlugin._wrap(pool, "getConnection", thisPlugin._patchGetConnection(pool));
          thisPlugin._wrap(pool, "end", thisPlugin._patchPoolEnd(pool));
          thisPlugin._setPoolcallbacks(pool, thisPlugin, "");
          return pool;
        };
      };
    }
    _patchPoolEnd(pool) {
      return (originalPoolEnd) => {
        const thisPlugin = this;
        return function end(callback) {
          const nAll = pool._allConnections.length;
          const nFree = pool._freeConnections.length;
          const nUsed = nAll - nFree;
          const poolName = (0, utils_1.getPoolName)(pool);
          thisPlugin._connectionsUsage.add(-nUsed, {
            state: "used",
            name: poolName
          });
          thisPlugin._connectionsUsage.add(-nFree, {
            state: "idle",
            name: poolName
          });
          originalPoolEnd.apply(pool, arguments);
        };
      };
    }
    _patchCreatePoolCluster() {
      return (originalCreatePoolCluster) => {
        const thisPlugin = this;
        return function createPool(_config) {
          const cluster = originalCreatePoolCluster(...arguments);
          thisPlugin._wrap(cluster, "getConnection", thisPlugin._patchGetConnection(cluster));
          thisPlugin._wrap(cluster, "add", thisPlugin._patchAdd(cluster));
          return cluster;
        };
      };
    }
    _patchAdd(cluster) {
      return (originalAdd) => {
        const thisPlugin = this;
        return function add(id, config) {
          if (!thisPlugin["_enabled"]) {
            thisPlugin._unwrap(cluster, "add");
            return originalAdd.apply(cluster, arguments);
          }
          originalAdd.apply(cluster, arguments);
          const nodes = cluster["_nodes"];
          if (nodes) {
            const nodeId = typeof id === "object" ? "CLUSTER::" + cluster._lastId : String(id);
            const pool = nodes[nodeId].pool;
            thisPlugin._setPoolcallbacks(pool, thisPlugin, id);
          }
        };
      };
    }
    _patchGetConnection(pool) {
      return (originalGetConnection) => {
        const thisPlugin = this;
        return function getConnection(arg1, arg2, arg3) {
          if (!thisPlugin["_enabled"]) {
            thisPlugin._unwrap(pool, "getConnection");
            return originalGetConnection.apply(pool, arguments);
          }
          if (arguments.length === 1 && typeof arg1 === "function") {
            const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg1);
            return originalGetConnection.call(pool, patchFn);
          }
          if (arguments.length === 2 && typeof arg2 === "function") {
            const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg2);
            return originalGetConnection.call(pool, arg1, patchFn);
          }
          if (arguments.length === 3 && typeof arg3 === "function") {
            const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg3);
            return originalGetConnection.call(pool, arg1, arg2, patchFn);
          }
          return originalGetConnection.apply(pool, arguments);
        };
      };
    }
    _getConnectionCallbackPatchFn(cb) {
      const thisPlugin = this;
      const activeContext = api_1.context.active();
      return function(err, connection) {
        if (connection) {
          if (!(0, instrumentation_1.isWrapped)(connection.query)) {
            thisPlugin._wrap(connection, "query", thisPlugin._patchQuery(connection));
          }
        }
        if (typeof cb === "function") {
          api_1.context.with(activeContext, cb, this, err, connection);
        }
      };
    }
    _patchQuery(connection) {
      return (originalQuery) => {
        const thisPlugin = this;
        return function query(query, _valuesOrCallback, _callback) {
          if (!thisPlugin["_enabled"]) {
            thisPlugin._unwrap(connection, "query");
            return originalQuery.apply(connection, arguments);
          }
          const span = thisPlugin.tracer.startSpan((0, utils_1.getSpanName)(query), {
            kind: api_1.SpanKind.CLIENT,
            attributes: {
              ...MySQLInstrumentation.COMMON_ATTRIBUTES,
              ...(0, utils_1.getConnectionAttributes)(connection.config)
            }
          });
          span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, (0, utils_1.getDbStatement)(query));
          if (thisPlugin.getConfig().enhancedDatabaseReporting) {
            let values;
            if (Array.isArray(_valuesOrCallback)) {
              values = _valuesOrCallback;
            } else if (arguments[2]) {
              values = [_valuesOrCallback];
            }
            span.setAttribute(AttributeNames_1.AttributeNames.MYSQL_VALUES, (0, utils_1.getDbValues)(query, values));
          }
          const cbIndex = Array.from(arguments).findIndex((arg) => typeof arg === "function");
          const parentContext = api_1.context.active();
          if (cbIndex === -1) {
            const streamableQuery = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return originalQuery.apply(connection, arguments);
            });
            api_1.context.bind(parentContext, streamableQuery);
            return streamableQuery.on("error", (err) => span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: err.message
            })).on("end", () => {
              span.end();
            });
          } else {
            thisPlugin._wrap(arguments, cbIndex, thisPlugin._patchCallbackQuery(span, parentContext));
            return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return originalQuery.apply(connection, arguments);
            });
          }
        };
      };
    }
    _patchCallbackQuery(span, parentContext) {
      return (originalCallback) => {
        return function(err, results, fields) {
          if (err) {
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: err.message
            });
          }
          span.end();
          return api_1.context.with(parentContext, () => originalCallback(...arguments));
        };
      };
    }
    _setPoolcallbacks(pool, thisPlugin, id) {
      const poolName = id || (0, utils_1.getPoolName)(pool);
      pool.on("connection", (connection) => {
        thisPlugin._connectionsUsage.add(1, {
          state: "idle",
          name: poolName
        });
      });
      pool.on("acquire", (connection) => {
        thisPlugin._connectionsUsage.add(-1, {
          state: "idle",
          name: poolName
        });
        thisPlugin._connectionsUsage.add(1, {
          state: "used",
          name: poolName
        });
      });
      pool.on("release", (connection) => {
        thisPlugin._connectionsUsage.add(-1, {
          state: "used",
          name: poolName
        });
        thisPlugin._connectionsUsage.add(1, {
          state: "idle",
          name: poolName
        });
      });
    }
  }
  exports.MySQLInstrumentation = MySQLInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/index.js
var require_src18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MySQLInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation8();
  Object.defineProperty(exports, "MySQLInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.MySQLInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/sql-common/build/src/index.js
var require_src19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addSqlCommenterComment = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  function hasValidSqlComment(query) {
    const indexOpeningDashDashComment = query.indexOf("--");
    if (indexOpeningDashDashComment >= 0) {
      return true;
    }
    const indexOpeningSlashComment = query.indexOf("/*");
    if (indexOpeningSlashComment < 0) {
      return false;
    }
    const indexClosingSlashComment = query.indexOf("*/");
    return indexOpeningDashDashComment < indexClosingSlashComment;
  }
  function fixedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
  }
  function addSqlCommenterComment(span, query) {
    if (typeof query !== "string" || query.length === 0) {
      return query;
    }
    if (hasValidSqlComment(query)) {
      return query;
    }
    const propagator = new core_1.W3CTraceContextPropagator;
    const headers = {};
    propagator.inject(api_1.trace.setSpan(api_1.ROOT_CONTEXT, span), headers, api_1.defaultTextMapSetter);
    const sortedKeys = Object.keys(headers).sort();
    if (sortedKeys.length === 0) {
      return query;
    }
    const commentString = sortedKeys.map((key) => {
      const encodedValue = fixedEncodeURIComponent(headers[key]);
      return `${key}='${encodedValue}'`;
    }).join(",");
    return `${query} /*${commentString}*/`;
  }
  exports.addSqlCommenterComment = addSqlCommenterComment;
});

// ../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/utils.js
var require_utils13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getConnectionPrototypeToInstrument = exports.once = exports.getSpanName = exports.getDbStatement = exports.getConnectionAttributes = undefined;
  var semantic_conventions_1 = require_src2();
  function getConnectionAttributes(config) {
    const { host, port, database, user } = getConfig(config);
    const portNumber = parseInt(port, 10);
    if (!isNaN(portNumber)) {
      return {
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: portNumber,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
        [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
        [semantic_conventions_1.SEMATTRS_DB_USER]: user
      };
    }
    return {
      [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
      [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
      [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
      [semantic_conventions_1.SEMATTRS_DB_USER]: user
    };
  }
  exports.getConnectionAttributes = getConnectionAttributes;
  function getConfig(config) {
    const { host, port, database, user } = config && config.connectionConfig || config || {};
    return { host, port, database, user };
  }
  function getJDBCString(host, port, database) {
    let jdbcString = `jdbc:mysql://${host || "localhost"}`;
    if (typeof port === "number") {
      jdbcString += `:${port}`;
    }
    if (typeof database === "string") {
      jdbcString += `/${database}`;
    }
    return jdbcString;
  }
  function getDbStatement(query, format, values, maskStatement = false, maskStatementHook = defaultMaskingHook) {
    const [querySql, queryValues] = typeof query === "string" ? [query, values] : [query.sql, hasValues(query) ? values || query.values : values];
    try {
      if (maskStatement) {
        return maskStatementHook(querySql);
      } else if (format && queryValues) {
        return format(querySql, queryValues);
      } else {
        return querySql;
      }
    } catch (e) {
      return "Could not determine the query due to an error in masking or formatting";
    }
  }
  exports.getDbStatement = getDbStatement;
  function defaultMaskingHook(query) {
    return query.replace(/\b\d+\b/g, "?").replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, "?");
  }
  function hasValues(obj) {
    return "values" in obj;
  }
  function getSpanName(query) {
    const rawQuery = typeof query === "object" ? query.sql : query;
    const firstSpace = rawQuery?.indexOf(" ");
    if (typeof firstSpace === "number" && firstSpace !== -1) {
      return rawQuery?.substring(0, firstSpace);
    }
    return rawQuery;
  }
  exports.getSpanName = getSpanName;
  var once = (fn) => {
    let called = false;
    return (...args) => {
      if (called)
        return;
      called = true;
      return fn(...args);
    };
  };
  exports.once = once;
  function getConnectionPrototypeToInstrument(connection) {
    const connectionPrototype = connection.prototype;
    const basePrototype = Object.getPrototypeOf(connectionPrototype);
    if (typeof basePrototype?.query === "function" && typeof basePrototype?.execute === "function") {
      return basePrototype;
    }
    return connectionPrototype;
  }
  exports.getConnectionPrototypeToInstrument = getConnectionPrototypeToInstrument;
});

// ../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/version.js
var require_version12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.51.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mysql2";
});

// ../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/instrumentation.js
var require_instrumentation9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MySQL2Instrumentation = undefined;
  var api2 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var sql_common_1 = require_src19();
  var utils_1 = require_utils13();
  var version_1 = require_version12();
  var supportedVersions = [">=1.4.2 <4"];

  class MySQL2Instrumentation extends instrumentation_1.InstrumentationBase {
    static COMMON_ATTRIBUTES = {
      [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MYSQL
    };
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      let format;
      function setFormatFunction(moduleExports) {
        if (!format && moduleExports.format) {
          format = moduleExports.format;
        }
      }
      const patch = (ConnectionPrototype) => {
        if ((0, instrumentation_1.isWrapped)(ConnectionPrototype.query)) {
          this._unwrap(ConnectionPrototype, "query");
        }
        this._wrap(ConnectionPrototype, "query", this._patchQuery(format, false));
        if ((0, instrumentation_1.isWrapped)(ConnectionPrototype.execute)) {
          this._unwrap(ConnectionPrototype, "execute");
        }
        this._wrap(ConnectionPrototype, "execute", this._patchQuery(format, true));
      };
      const unpatch = (ConnectionPrototype) => {
        this._unwrap(ConnectionPrototype, "query");
        this._unwrap(ConnectionPrototype, "execute");
      };
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("mysql2", supportedVersions, (moduleExports) => {
          setFormatFunction(moduleExports);
          return moduleExports;
        }, () => {}, [
          new instrumentation_1.InstrumentationNodeModuleFile("mysql2/promise.js", supportedVersions, (moduleExports) => {
            setFormatFunction(moduleExports);
            return moduleExports;
          }, () => {}),
          new instrumentation_1.InstrumentationNodeModuleFile("mysql2/lib/connection.js", supportedVersions, (moduleExports) => {
            const ConnectionPrototype = (0, utils_1.getConnectionPrototypeToInstrument)(moduleExports);
            patch(ConnectionPrototype);
            return moduleExports;
          }, (moduleExports) => {
            if (moduleExports === undefined)
              return;
            const ConnectionPrototype = (0, utils_1.getConnectionPrototypeToInstrument)(moduleExports);
            unpatch(ConnectionPrototype);
          })
        ])
      ];
    }
    _patchQuery(format, isPrepared) {
      return (originalQuery) => {
        const thisPlugin = this;
        return function query(query, _valuesOrCallback, _callback) {
          let values;
          if (Array.isArray(_valuesOrCallback)) {
            values = _valuesOrCallback;
          } else if (arguments[2]) {
            values = [_valuesOrCallback];
          }
          const { maskStatement, maskStatementHook, responseHook } = thisPlugin.getConfig();
          const span = thisPlugin.tracer.startSpan((0, utils_1.getSpanName)(query), {
            kind: api2.SpanKind.CLIENT,
            attributes: {
              ...MySQL2Instrumentation.COMMON_ATTRIBUTES,
              ...(0, utils_1.getConnectionAttributes)(this.config),
              [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: (0, utils_1.getDbStatement)(query, format, values, maskStatement, maskStatementHook)
            }
          });
          if (!isPrepared && thisPlugin.getConfig().addSqlCommenterCommentToQueries) {
            arguments[0] = query = typeof query === "string" ? (0, sql_common_1.addSqlCommenterComment)(span, query) : Object.assign(query, {
              sql: (0, sql_common_1.addSqlCommenterComment)(span, query.sql)
            });
          }
          const endSpan2 = (0, utils_1.once)((err, results) => {
            if (err) {
              span.setStatus({
                code: api2.SpanStatusCode.ERROR,
                message: err.message
              });
            } else {
              if (typeof responseHook === "function") {
                (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
                  responseHook(span, {
                    queryResults: results
                  });
                }, (err2) => {
                  if (err2) {
                    thisPlugin._diag.warn("Failed executing responseHook", err2);
                  }
                }, true);
              }
            }
            span.end();
          });
          if (arguments.length === 1) {
            if (typeof query.onResult === "function") {
              thisPlugin._wrap(query, "onResult", thisPlugin._patchCallbackQuery(endSpan2));
            }
            const streamableQuery = originalQuery.apply(this, arguments);
            streamableQuery.once("error", (err) => {
              endSpan2(err);
            }).once("result", (results) => {
              endSpan2(undefined, results);
            });
            return streamableQuery;
          }
          if (typeof arguments[1] === "function") {
            thisPlugin._wrap(arguments, 1, thisPlugin._patchCallbackQuery(endSpan2));
          } else if (typeof arguments[2] === "function") {
            thisPlugin._wrap(arguments, 2, thisPlugin._patchCallbackQuery(endSpan2));
          }
          return originalQuery.apply(this, arguments);
        };
      };
    }
    _patchCallbackQuery(endSpan2) {
      return (originalCallback) => {
        return function(err, results, fields) {
          endSpan2(err, results);
          return originalCallback(...arguments);
        };
      };
    }
  }
  exports.MySQL2Instrumentation = MySQL2Instrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/index.js
var require_src20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MySQL2Instrumentation = undefined;
  var instrumentation_1 = require_instrumentation9();
  Object.defineProperty(exports, "MySQL2Instrumentation", { enumerable: true, get: function() {
    return instrumentation_1.MySQL2Instrumentation;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/utils.js
var require_utils14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.endSpan = undefined;
  var api_1 = require_src();
  var endSpan2 = (span, err) => {
    if (err) {
      span.recordException(err);
      span.setStatus({
        code: api_1.SpanStatusCode.ERROR,
        message: err.message
      });
    }
    span.end();
  };
  exports.endSpan = endSpan2;
});

// ../../node_modules/@opentelemetry/redis-common/build/src/index.js
var require_src21 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultDbStatementSerializer = undefined;
  var serializationSubsets = [
    {
      regex: /^ECHO/i,
      args: 0
    },
    {
      regex: /^(LPUSH|MSET|PFA|PUBLISH|RPUSH|SADD|SET|SPUBLISH|XADD|ZADD)/i,
      args: 1
    },
    {
      regex: /^(HSET|HMSET|LSET|LINSERT)/i,
      args: 2
    },
    {
      regex: /^(ACL|BIT|B[LRZ]|CLIENT|CLUSTER|CONFIG|COMMAND|DECR|DEL|EVAL|EX|FUNCTION|GEO|GET|HINCR|HMGET|HSCAN|INCR|L[TRLM]|MEMORY|P[EFISTU]|RPOP|S[CDIMORSU]|XACK|X[CDGILPRT]|Z[CDILMPRS])/i,
      args: -1
    }
  ];
  var defaultDbStatementSerializer = (cmdName, cmdArgs) => {
    if (Array.isArray(cmdArgs) && cmdArgs.length) {
      const nArgsToSerialize = serializationSubsets.find(({ regex }) => {
        return regex.test(cmdName);
      })?.args ?? 0;
      const argsToSerialize = nArgsToSerialize >= 0 ? cmdArgs.slice(0, nArgsToSerialize) : cmdArgs;
      if (cmdArgs.length > argsToSerialize.length) {
        argsToSerialize.push(`[${cmdArgs.length - nArgsToSerialize} other arguments]`);
      }
      return `${cmdName} ${argsToSerialize.join(" ")}`;
    }
    return cmdName;
  };
  exports.defaultDbStatementSerializer = defaultDbStatementSerializer;
});

// ../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/version.js
var require_version13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.52.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-ioredis";
});

// ../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/instrumentation.js
var require_instrumentation10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IORedisInstrumentation = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var instrumentation_2 = require_src6();
  var utils_1 = require_utils14();
  var redis_common_1 = require_src21();
  var version_1 = require_version13();
  var DEFAULT_CONFIG = {
    requireParentSpan: true
  };

  class IORedisInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, { ...DEFAULT_CONFIG, ...config });
    }
    setConfig(config = {}) {
      super.setConfig({ ...DEFAULT_CONFIG, ...config });
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("ioredis", [">=2.0.0 <6"], (module2, moduleVersion) => {
          const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.sendCommand)) {
            this._unwrap(moduleExports.prototype, "sendCommand");
          }
          this._wrap(moduleExports.prototype, "sendCommand", this._patchSendCommand(moduleVersion));
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
            this._unwrap(moduleExports.prototype, "connect");
          }
          this._wrap(moduleExports.prototype, "connect", this._patchConnection());
          return module2;
        }, (module2) => {
          if (module2 === undefined)
            return;
          const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
          this._unwrap(moduleExports.prototype, "sendCommand");
          this._unwrap(moduleExports.prototype, "connect");
        })
      ];
    }
    _patchSendCommand(moduleVersion) {
      return (original) => {
        return this._traceSendCommand(original, moduleVersion);
      };
    }
    _patchConnection() {
      return (original) => {
        return this._traceConnection(original);
      };
    }
    _traceSendCommand(original, moduleVersion) {
      const instrumentation = this;
      return function(cmd) {
        if (arguments.length < 1 || typeof cmd !== "object") {
          return original.apply(this, arguments);
        }
        const config = instrumentation.getConfig();
        const dbStatementSerializer = config.dbStatementSerializer || redis_common_1.defaultDbStatementSerializer;
        const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === undefined;
        if (config.requireParentSpan === true && hasNoParentSpan) {
          return original.apply(this, arguments);
        }
        const span = instrumentation.tracer.startSpan(cmd.name, {
          kind: api_1.SpanKind.CLIENT,
          attributes: {
            [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
            [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: dbStatementSerializer(cmd.name, cmd.args)
          }
        });
        const { requestHook: requestHook2 } = config;
        if (requestHook2) {
          (0, instrumentation_2.safeExecuteInTheMiddle)(() => requestHook2(span, {
            moduleVersion,
            cmdName: cmd.name,
            cmdArgs: cmd.args
          }), (e) => {
            if (e) {
              api_1.diag.error("ioredis instrumentation: request hook failed", e);
            }
          }, true);
        }
        const { host, port } = this.options;
        span.setAttributes({
          [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
          [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: port,
          [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `redis://${host}:${port}`
        });
        try {
          const result = original.apply(this, arguments);
          const origResolve = cmd.resolve;
          cmd.resolve = function(result2) {
            (0, instrumentation_2.safeExecuteInTheMiddle)(() => config.responseHook?.(span, cmd.name, cmd.args, result2), (e) => {
              if (e) {
                api_1.diag.error("ioredis instrumentation: response hook failed", e);
              }
            }, true);
            (0, utils_1.endSpan)(span, null);
            origResolve(result2);
          };
          const origReject = cmd.reject;
          cmd.reject = function(err) {
            (0, utils_1.endSpan)(span, err);
            origReject(err);
          };
          return result;
        } catch (error2) {
          (0, utils_1.endSpan)(span, error2);
          throw error2;
        }
      };
    }
    _traceConnection(original) {
      const instrumentation = this;
      return function() {
        const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === undefined;
        if (instrumentation.getConfig().requireParentSpan === true && hasNoParentSpan) {
          return original.apply(this, arguments);
        }
        const span = instrumentation.tracer.startSpan("connect", {
          kind: api_1.SpanKind.CLIENT,
          attributes: {
            [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
            [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: "connect"
          }
        });
        const { host, port } = this.options;
        span.setAttributes({
          [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
          [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: port,
          [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `redis://${host}:${port}`
        });
        try {
          const client = original.apply(this, arguments);
          (0, utils_1.endSpan)(span, null);
          return client;
        } catch (error2) {
          (0, utils_1.endSpan)(span, error2);
          throw error2;
        }
      };
    }
  }
  exports.IORedisInstrumentation = IORedisInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/index.js
var require_src22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IORedisInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation10();
  Object.defineProperty(exports, "IORedisInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.IORedisInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-redis/build/src/version.js
var require_version14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.53.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-redis";
});

// ../../node_modules/@opentelemetry/instrumentation-redis/build/src/v2-v3/utils.js
var require_utils15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getTracedCreateStreamTrace = exports.getTracedCreateClient = exports.endSpan = undefined;
  var api_1 = require_src();
  var endSpan2 = (span, err) => {
    if (err) {
      span.setStatus({
        code: api_1.SpanStatusCode.ERROR,
        message: err.message
      });
    }
    span.end();
  };
  exports.endSpan = endSpan2;
  var getTracedCreateClient = (original) => {
    return function createClientTrace() {
      const client = original.apply(this, arguments);
      return api_1.context.bind(api_1.context.active(), client);
    };
  };
  exports.getTracedCreateClient = getTracedCreateClient;
  var getTracedCreateStreamTrace = (original) => {
    return function create_stream_trace() {
      if (!Object.prototype.hasOwnProperty.call(this, "stream")) {
        Object.defineProperty(this, "stream", {
          get() {
            return this._patched_redis_stream;
          },
          set(val) {
            api_1.context.bind(api_1.context.active(), val);
            this._patched_redis_stream = val;
          }
        });
      }
      return original.apply(this, arguments);
    };
  };
  exports.getTracedCreateStreamTrace = getTracedCreateStreamTrace;
});

// ../../node_modules/@opentelemetry/instrumentation-redis/build/src/v2-v3/instrumentation.js
var require_instrumentation11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisInstrumentationV2_V3 = undefined;
  var instrumentation_1 = require_src6();
  var utils_1 = require_utils15();
  var version_1 = require_version14();
  var api_1 = require_src();
  var semantic_conventions_1 = require_src2();
  var redis_common_1 = require_src21();

  class RedisInstrumentationV2_V3 extends instrumentation_1.InstrumentationBase {
    static COMPONENT = "redis";
    _semconvStability;
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      this._semconvStability = config.semconvStability ? config.semconvStability : (0, instrumentation_1.semconvStabilityFromStr)("database", process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
    }
    setConfig(config = {}) {
      super.setConfig(config);
      this._semconvStability = config.semconvStability ? config.semconvStability : (0, instrumentation_1.semconvStabilityFromStr)("database", process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("redis", [">=2.6.0 <4"], (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.RedisClient.prototype["internal_send_command"])) {
            this._unwrap(moduleExports.RedisClient.prototype, "internal_send_command");
          }
          this._wrap(moduleExports.RedisClient.prototype, "internal_send_command", this._getPatchInternalSendCommand());
          if ((0, instrumentation_1.isWrapped)(moduleExports.RedisClient.prototype["create_stream"])) {
            this._unwrap(moduleExports.RedisClient.prototype, "create_stream");
          }
          this._wrap(moduleExports.RedisClient.prototype, "create_stream", this._getPatchCreateStream());
          if ((0, instrumentation_1.isWrapped)(moduleExports.createClient)) {
            this._unwrap(moduleExports, "createClient");
          }
          this._wrap(moduleExports, "createClient", this._getPatchCreateClient());
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === undefined)
            return;
          this._unwrap(moduleExports.RedisClient.prototype, "internal_send_command");
          this._unwrap(moduleExports.RedisClient.prototype, "create_stream");
          this._unwrap(moduleExports, "createClient");
        })
      ];
    }
    _getPatchInternalSendCommand() {
      const instrumentation = this;
      return function internal_send_command(original) {
        return function internal_send_command_trace(cmd) {
          if (arguments.length !== 1 || typeof cmd !== "object") {
            return original.apply(this, arguments);
          }
          const config = instrumentation.getConfig();
          const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === undefined;
          if (config.requireParentSpan === true && hasNoParentSpan) {
            return original.apply(this, arguments);
          }
          const dbStatementSerializer = config?.dbStatementSerializer || redis_common_1.defaultDbStatementSerializer;
          const attributes = {};
          if (instrumentation._semconvStability & instrumentation_1.SemconvStability.OLD) {
            Object.assign(attributes, {
              [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
              [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: dbStatementSerializer(cmd.command, cmd.args)
            });
          }
          if (instrumentation._semconvStability & instrumentation_1.SemconvStability.STABLE) {
            Object.assign(attributes, {
              [semantic_conventions_1.ATTR_DB_SYSTEM_NAME]: "redis",
              [semantic_conventions_1.ATTR_DB_OPERATION_NAME]: cmd.command,
              [semantic_conventions_1.ATTR_DB_QUERY_TEXT]: dbStatementSerializer(cmd.command, cmd.args)
            });
          }
          const span = instrumentation.tracer.startSpan(`${RedisInstrumentationV2_V3.COMPONENT}-${cmd.command}`, {
            kind: api_1.SpanKind.CLIENT,
            attributes
          });
          if (this.connection_options) {
            const connectionAttributes = {};
            if (instrumentation._semconvStability & instrumentation_1.SemconvStability.OLD) {
              Object.assign(connectionAttributes, {
                [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: this.connection_options.host,
                [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: this.connection_options.port
              });
            }
            if (instrumentation._semconvStability & instrumentation_1.SemconvStability.STABLE) {
              Object.assign(connectionAttributes, {
                [semantic_conventions_1.ATTR_SERVER_ADDRESS]: this.connection_options.host,
                [semantic_conventions_1.ATTR_SERVER_PORT]: this.connection_options.port
              });
            }
            span.setAttributes(connectionAttributes);
          }
          if (this.address && instrumentation._semconvStability & instrumentation_1.SemconvStability.OLD) {
            span.setAttribute(semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING, `redis://${this.address}`);
          }
          const originalCallback = arguments[0].callback;
          if (originalCallback) {
            const originalContext = api_1.context.active();
            arguments[0].callback = function callback(err, reply) {
              if (config?.responseHook) {
                const responseHook = config.responseHook;
                (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
                  responseHook(span, cmd.command, cmd.args, reply);
                }, (err2) => {
                  if (err2) {
                    instrumentation._diag.error("Error executing responseHook", err2);
                  }
                }, true);
              }
              (0, utils_1.endSpan)(span, err);
              return api_1.context.with(originalContext, originalCallback, this, ...arguments);
            };
          }
          try {
            return original.apply(this, arguments);
          } catch (rethrow) {
            (0, utils_1.endSpan)(span, rethrow);
            throw rethrow;
          }
        };
      };
    }
    _getPatchCreateClient() {
      return function createClient(original) {
        return (0, utils_1.getTracedCreateClient)(original);
      };
    }
    _getPatchCreateStream() {
      return function createReadStream(original) {
        return (0, utils_1.getTracedCreateStreamTrace)(original);
      };
    }
  }
  exports.RedisInstrumentationV2_V3 = RedisInstrumentationV2_V3;
});

// ../../node_modules/@opentelemetry/instrumentation-redis/build/src/v4-v5/utils.js
var require_utils16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getClientAttributes = undefined;
  var semantic_conventions_1 = require_src2();
  var instrumentation_1 = require_src6();
  function getClientAttributes(diag4, options, semconvStability) {
    const attributes = {};
    if (semconvStability & instrumentation_1.SemconvStability.OLD) {
      Object.assign(attributes, {
        [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: options?.socket?.host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: options?.socket?.port,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: removeCredentialsFromDBConnectionStringAttribute(diag4, options?.url)
      });
    }
    if (semconvStability & instrumentation_1.SemconvStability.STABLE) {
      Object.assign(attributes, {
        [semantic_conventions_1.ATTR_DB_SYSTEM_NAME]: "redis",
        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: options?.socket?.host,
        [semantic_conventions_1.ATTR_SERVER_PORT]: options?.socket?.port
      });
    }
    return attributes;
  }
  exports.getClientAttributes = getClientAttributes;
  function removeCredentialsFromDBConnectionStringAttribute(diag4, url) {
    if (typeof url !== "string" || !url) {
      return;
    }
    try {
      const u = new URL(url);
      u.searchParams.delete("user_pwd");
      u.username = "";
      u.password = "";
      return u.href;
    } catch (err) {
      diag4.error("failed to sanitize redis connection url", err);
    }
    return;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-redis/build/src/v4-v5/instrumentation.js
var require_instrumentation12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisInstrumentationV4_V5 = undefined;
  var api_1 = require_src();
  var instrumentation_1 = require_src6();
  var utils_1 = require_utils16();
  var redis_common_1 = require_src21();
  var version_1 = require_version14();
  var semantic_conventions_1 = require_src2();
  var OTEL_OPEN_SPANS = Symbol("opentelemetry.instrumentation.redis.open_spans");
  var MULTI_COMMAND_OPTIONS = Symbol("opentelemetry.instrumentation.redis.multi_command_options");

  class RedisInstrumentationV4_V5 extends instrumentation_1.InstrumentationBase {
    static COMPONENT = "redis";
    _semconvStability;
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      this._semconvStability = config.semconvStability ? config.semconvStability : (0, instrumentation_1.semconvStabilityFromStr)("database", process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
    }
    setConfig(config = {}) {
      super.setConfig(config);
      this._semconvStability = config.semconvStability ? config.semconvStability : (0, instrumentation_1.semconvStabilityFromStr)("database", process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
    }
    init() {
      return [
        this._getInstrumentationNodeModuleDefinition("@redis/client"),
        this._getInstrumentationNodeModuleDefinition("@node-redis/client")
      ];
    }
    _getInstrumentationNodeModuleDefinition(basePackageName) {
      const commanderModuleFile = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/commander.js`, ["^1.0.0"], (moduleExports, moduleVersion) => {
        const transformCommandArguments = moduleExports.transformCommandArguments;
        if (!transformCommandArguments) {
          this._diag.error("internal instrumentation error, missing transformCommandArguments function");
          return moduleExports;
        }
        const functionToPatch = moduleVersion?.startsWith("1.0.") ? "extendWithCommands" : "attachCommands";
        if ((0, instrumentation_1.isWrapped)(moduleExports?.[functionToPatch])) {
          this._unwrap(moduleExports, functionToPatch);
        }
        this._wrap(moduleExports, functionToPatch, this._getPatchExtendWithCommands(transformCommandArguments));
        return moduleExports;
      }, (moduleExports) => {
        if ((0, instrumentation_1.isWrapped)(moduleExports?.extendWithCommands)) {
          this._unwrap(moduleExports, "extendWithCommands");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports?.attachCommands)) {
          this._unwrap(moduleExports, "attachCommands");
        }
      });
      const multiCommanderModule = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/client/multi-command.js`, ["^1.0.0", "^5.0.0"], (moduleExports) => {
        const redisClientMultiCommandPrototype = moduleExports?.default?.prototype;
        if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype?.exec)) {
          this._unwrap(redisClientMultiCommandPrototype, "exec");
        }
        this._wrap(redisClientMultiCommandPrototype, "exec", this._getPatchMultiCommandsExec());
        if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype?.addCommand)) {
          this._unwrap(redisClientMultiCommandPrototype, "addCommand");
        }
        this._wrap(redisClientMultiCommandPrototype, "addCommand", this._getPatchMultiCommandsAddCommand());
        return moduleExports;
      }, (moduleExports) => {
        const redisClientMultiCommandPrototype = moduleExports?.default?.prototype;
        if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype?.exec)) {
          this._unwrap(redisClientMultiCommandPrototype, "exec");
        }
        if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype?.addCommand)) {
          this._unwrap(redisClientMultiCommandPrototype, "addCommand");
        }
      });
      const clientIndexModule = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/client/index.js`, ["^1.0.0", "^5.0.0"], (moduleExports) => {
        const redisClientPrototype = moduleExports?.default?.prototype;
        if (redisClientPrototype?.multi) {
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype?.multi)) {
            this._unwrap(redisClientPrototype, "multi");
          }
          this._wrap(redisClientPrototype, "multi", this._getPatchRedisClientMulti());
        }
        if (redisClientPrototype?.MULTI) {
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype?.MULTI)) {
            this._unwrap(redisClientPrototype, "MULTI");
          }
          this._wrap(redisClientPrototype, "MULTI", this._getPatchRedisClientMulti());
        }
        if ((0, instrumentation_1.isWrapped)(redisClientPrototype?.sendCommand)) {
          this._unwrap(redisClientPrototype, "sendCommand");
        }
        this._wrap(redisClientPrototype, "sendCommand", this._getPatchRedisClientSendCommand());
        this._wrap(redisClientPrototype, "connect", this._getPatchedClientConnect());
        return moduleExports;
      }, (moduleExports) => {
        const redisClientPrototype = moduleExports?.default?.prototype;
        if ((0, instrumentation_1.isWrapped)(redisClientPrototype?.multi)) {
          this._unwrap(redisClientPrototype, "multi");
        }
        if ((0, instrumentation_1.isWrapped)(redisClientPrototype?.MULTI)) {
          this._unwrap(redisClientPrototype, "MULTI");
        }
        if ((0, instrumentation_1.isWrapped)(redisClientPrototype?.sendCommand)) {
          this._unwrap(redisClientPrototype, "sendCommand");
        }
      });
      return new instrumentation_1.InstrumentationNodeModuleDefinition(basePackageName, ["^1.0.0", "^5.0.0"], (moduleExports) => {
        return moduleExports;
      }, () => {}, [commanderModuleFile, multiCommanderModule, clientIndexModule]);
    }
    _getPatchExtendWithCommands(transformCommandArguments) {
      const plugin = this;
      return function extendWithCommandsPatchWrapper(original) {
        return function extendWithCommandsPatch(config) {
          if (config?.BaseClass?.name !== "RedisClient") {
            return original.apply(this, arguments);
          }
          const origExecutor = config.executor;
          config.executor = function(command, args) {
            const redisCommandArguments = transformCommandArguments(command, args).args;
            return plugin._traceClientCommand(origExecutor, this, arguments, redisCommandArguments);
          };
          return original.apply(this, arguments);
        };
      };
    }
    _getPatchMultiCommandsExec() {
      const plugin = this;
      return function execPatchWrapper(original) {
        return function execPatch() {
          const execRes = original.apply(this, arguments);
          if (typeof execRes?.then !== "function") {
            plugin._diag.error("got non promise result when patching RedisClientMultiCommand.exec");
            return execRes;
          }
          return execRes.then((redisRes) => {
            const openSpans = this[OTEL_OPEN_SPANS];
            plugin._endSpansWithRedisReplies(openSpans, redisRes);
            return redisRes;
          }).catch((err) => {
            const openSpans = this[OTEL_OPEN_SPANS];
            if (!openSpans) {
              plugin._diag.error("cannot find open spans to end for redis multi command");
            } else {
              const replies = err.constructor.name === "MultiErrorReply" ? err.replies : new Array(openSpans.length).fill(err);
              plugin._endSpansWithRedisReplies(openSpans, replies);
            }
            return Promise.reject(err);
          });
        };
      };
    }
    _getPatchMultiCommandsAddCommand() {
      const plugin = this;
      return function addCommandWrapper(original) {
        return function addCommandPatch(args) {
          return plugin._traceClientCommand(original, this, arguments, args);
        };
      };
    }
    _getPatchRedisClientMulti() {
      return function multiPatchWrapper(original) {
        return function multiPatch() {
          const multiRes = original.apply(this, arguments);
          multiRes[MULTI_COMMAND_OPTIONS] = this.options;
          return multiRes;
        };
      };
    }
    _getPatchRedisClientSendCommand() {
      const plugin = this;
      return function sendCommandWrapper(original) {
        return function sendCommandPatch(args) {
          return plugin._traceClientCommand(original, this, arguments, args);
        };
      };
    }
    _getPatchedClientConnect() {
      const plugin = this;
      return function connectWrapper(original) {
        return function patchedConnect() {
          const options = this.options;
          const attributes = (0, utils_1.getClientAttributes)(plugin._diag, options, plugin._semconvStability);
          const span = plugin.tracer.startSpan(`${RedisInstrumentationV4_V5.COMPONENT}-connect`, {
            kind: api_1.SpanKind.CLIENT,
            attributes
          });
          const res = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            return original.apply(this);
          });
          return res.then((result) => {
            span.end();
            return result;
          }).catch((error2) => {
            span.recordException(error2);
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: error2.message
            });
            span.end();
            return Promise.reject(error2);
          });
        };
      };
    }
    _traceClientCommand(origFunction, origThis, origArguments, redisCommandArguments) {
      const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === undefined;
      if (hasNoParentSpan && this.getConfig().requireParentSpan) {
        return origFunction.apply(origThis, origArguments);
      }
      const clientOptions = origThis.options || origThis[MULTI_COMMAND_OPTIONS];
      const commandName = redisCommandArguments[0];
      const commandArgs = redisCommandArguments.slice(1);
      const dbStatementSerializer = this.getConfig().dbStatementSerializer || redis_common_1.defaultDbStatementSerializer;
      const attributes = (0, utils_1.getClientAttributes)(this._diag, clientOptions, this._semconvStability);
      if (this._semconvStability & instrumentation_1.SemconvStability.STABLE) {
        attributes[semantic_conventions_1.ATTR_DB_OPERATION_NAME] = commandName;
      }
      try {
        const dbStatement = dbStatementSerializer(commandName, commandArgs);
        if (dbStatement != null) {
          if (this._semconvStability & instrumentation_1.SemconvStability.OLD) {
            attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatement;
          }
          if (this._semconvStability & instrumentation_1.SemconvStability.STABLE) {
            attributes[semantic_conventions_1.ATTR_DB_QUERY_TEXT] = dbStatement;
          }
        }
      } catch (e) {
        this._diag.error("dbStatementSerializer throw an exception", e, {
          commandName
        });
      }
      const span = this.tracer.startSpan(`${RedisInstrumentationV4_V5.COMPONENT}-${commandName}`, {
        kind: api_1.SpanKind.CLIENT,
        attributes
      });
      const res = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
        return origFunction.apply(origThis, origArguments);
      });
      if (typeof res?.then === "function") {
        res.then((redisRes) => {
          this._endSpanWithResponse(span, commandName, commandArgs, redisRes, undefined);
        }, (err) => {
          this._endSpanWithResponse(span, commandName, commandArgs, null, err);
        });
      } else {
        const redisClientMultiCommand = res;
        redisClientMultiCommand[OTEL_OPEN_SPANS] = redisClientMultiCommand[OTEL_OPEN_SPANS] || [];
        redisClientMultiCommand[OTEL_OPEN_SPANS].push({
          span,
          commandName,
          commandArgs
        });
      }
      return res;
    }
    _endSpansWithRedisReplies(openSpans, replies) {
      if (!openSpans) {
        return this._diag.error("cannot find open spans to end for redis multi command");
      }
      if (replies.length !== openSpans.length) {
        return this._diag.error("number of multi command spans does not match response from redis");
      }
      for (let i = 0;i < openSpans.length; i++) {
        const { span, commandName, commandArgs } = openSpans[i];
        const currCommandRes = replies[i];
        const [res, err] = currCommandRes instanceof Error ? [null, currCommandRes] : [currCommandRes, undefined];
        this._endSpanWithResponse(span, commandName, commandArgs, res, err);
      }
    }
    _endSpanWithResponse(span, commandName, commandArgs, response, error2) {
      const { responseHook } = this.getConfig();
      if (!error2 && responseHook) {
        try {
          responseHook(span, commandName, commandArgs, response);
        } catch (err) {
          this._diag.error("responseHook throw an exception", err);
        }
      }
      if (error2) {
        span.recordException(error2);
        span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: error2?.message });
      }
      span.end();
    }
  }
  exports.RedisInstrumentationV4_V5 = RedisInstrumentationV4_V5;
});

// ../../node_modules/@opentelemetry/instrumentation-redis/build/src/redis.js
var require_redis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisInstrumentation = undefined;
  var instrumentation_1 = require_src6();
  var version_1 = require_version14();
  var instrumentation_2 = require_instrumentation11();
  var instrumentation_3 = require_instrumentation12();
  var DEFAULT_CONFIG = {
    requireParentSpan: false
  };

  class RedisInstrumentation extends instrumentation_1.InstrumentationBase {
    instrumentationV2_V3;
    instrumentationV4_V5;
    initialized = false;
    constructor(config = {}) {
      const resolvedConfig = { ...DEFAULT_CONFIG, ...config };
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, resolvedConfig);
      this.instrumentationV2_V3 = new instrumentation_2.RedisInstrumentationV2_V3(this.getConfig());
      this.instrumentationV4_V5 = new instrumentation_3.RedisInstrumentationV4_V5(this.getConfig());
      this.initialized = true;
    }
    setConfig(config = {}) {
      const newConfig = { ...DEFAULT_CONFIG, ...config };
      super.setConfig(newConfig);
      if (!this.initialized) {
        return;
      }
      this.instrumentationV2_V3.setConfig(newConfig);
      this.instrumentationV4_V5.setConfig(newConfig);
    }
    init() {}
    setTracerProvider(tracerProvider) {
      super.setTracerProvider(tracerProvider);
      if (!this.initialized) {
        return;
      }
      this.instrumentationV2_V3.setTracerProvider(tracerProvider);
      this.instrumentationV4_V5.setTracerProvider(tracerProvider);
    }
    enable() {
      super.enable();
      if (!this.initialized) {
        return;
      }
      this.instrumentationV2_V3.enable();
      this.instrumentationV4_V5.enable();
    }
    disable() {
      super.disable();
      if (!this.initialized) {
        return;
      }
      this.instrumentationV2_V3.disable();
      this.instrumentationV4_V5.disable();
    }
  }
  exports.RedisInstrumentation = RedisInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-redis/build/src/index.js
var require_src23 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisInstrumentation = undefined;
  var redis_1 = require_redis();
  Object.defineProperty(exports, "RedisInstrumentation", { enumerable: true, get: function() {
    return redis_1.RedisInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/internal-types.js
var require_internal_types6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EVENT_LISTENERS_SET = undefined;
  exports.EVENT_LISTENERS_SET = Symbol("opentelemetry.instrumentation.pg.eventListenersSet");
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/enums/AttributeNames.js
var require_AttributeNames5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames2;
  (function(AttributeNames3) {
    AttributeNames3["PG_VALUES"] = "db.postgresql.values";
    AttributeNames3["PG_PLAN"] = "db.postgresql.plan";
    AttributeNames3["IDLE_TIMEOUT_MILLIS"] = "db.postgresql.idle.timeout.millis";
    AttributeNames3["MAX_CLIENT"] = "db.postgresql.max.client";
  })(AttributeNames2 = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/semconv.js
var require_semconv5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS = exports.METRIC_DB_CLIENT_CONNECTION_COUNT = exports.DB_SYSTEM_VALUE_POSTGRESQL = exports.DB_CLIENT_CONNECTION_STATE_VALUE_USED = exports.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE = exports.ATTR_NET_PEER_PORT = exports.ATTR_NET_PEER_NAME = exports.ATTR_DB_USER = exports.ATTR_DB_SYSTEM = exports.ATTR_DB_STATEMENT = exports.ATTR_DB_NAME = exports.ATTR_DB_CONNECTION_STRING = exports.ATTR_DB_CLIENT_CONNECTION_STATE = exports.ATTR_DB_CLIENT_CONNECTION_POOL_NAME = undefined;
  exports.ATTR_DB_CLIENT_CONNECTION_POOL_NAME = "db.client.connection.pool.name";
  exports.ATTR_DB_CLIENT_CONNECTION_STATE = "db.client.connection.state";
  exports.ATTR_DB_CONNECTION_STRING = "db.connection_string";
  exports.ATTR_DB_NAME = "db.name";
  exports.ATTR_DB_STATEMENT = "db.statement";
  exports.ATTR_DB_SYSTEM = "db.system";
  exports.ATTR_DB_USER = "db.user";
  exports.ATTR_NET_PEER_NAME = "net.peer.name";
  exports.ATTR_NET_PEER_PORT = "net.peer.port";
  exports.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE = "idle";
  exports.DB_CLIENT_CONNECTION_STATE_VALUE_USED = "used";
  exports.DB_SYSTEM_VALUE_POSTGRESQL = "postgresql";
  exports.METRIC_DB_CLIENT_CONNECTION_COUNT = "db.client.connection.count";
  exports.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS = "db.client.connection.pending_requests";
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/enums/SpanNames.js
var require_SpanNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanNames = undefined;
  var SpanNames;
  (function(SpanNames2) {
    SpanNames2["QUERY_PREFIX"] = "pg.query";
    SpanNames2["CONNECT"] = "pg.connect";
    SpanNames2["POOL_CONNECT"] = "pg-pool.connect";
  })(SpanNames = exports.SpanNames || (exports.SpanNames = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/utils.js
var require_utils17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObjectWithTextString = exports.getErrorMessage = exports.patchClientConnectCallback = exports.patchCallbackPGPool = exports.updateCounter = exports.getPoolName = exports.patchCallback = exports.handleExecutionResult = exports.handleConfigQuery = exports.shouldSkipInstrumentation = exports.getSemanticAttributesFromPoolConnection = exports.getSemanticAttributesFromConnection = exports.getConnectionString = exports.parseAndMaskConnectionString = exports.parseNormalizedOperationName = exports.getQuerySpanName = undefined;
  var api_1 = require_src();
  var AttributeNames_1 = require_AttributeNames5();
  var semantic_conventions_1 = require_src2();
  var semconv_1 = require_semconv5();
  var instrumentation_1 = require_src6();
  var SpanNames_1 = require_SpanNames();
  function getQuerySpanName(dbName, queryConfig) {
    if (!queryConfig)
      return SpanNames_1.SpanNames.QUERY_PREFIX;
    const command = typeof queryConfig.name === "string" && queryConfig.name ? queryConfig.name : parseNormalizedOperationName(queryConfig.text);
    return `${SpanNames_1.SpanNames.QUERY_PREFIX}:${command}${dbName ? ` ${dbName}` : ""}`;
  }
  exports.getQuerySpanName = getQuerySpanName;
  function parseNormalizedOperationName(queryText) {
    const indexOfFirstSpace = queryText.indexOf(" ");
    let sqlCommand = indexOfFirstSpace === -1 ? queryText : queryText.slice(0, indexOfFirstSpace);
    sqlCommand = sqlCommand.toUpperCase();
    return sqlCommand.endsWith(";") ? sqlCommand.slice(0, -1) : sqlCommand;
  }
  exports.parseNormalizedOperationName = parseNormalizedOperationName;
  function parseAndMaskConnectionString(connectionString) {
    try {
      const url = new URL(connectionString);
      url.username = "";
      url.password = "";
      return url.toString();
    } catch (e) {
      return "postgresql://localhost:5432/";
    }
  }
  exports.parseAndMaskConnectionString = parseAndMaskConnectionString;
  function getConnectionString(params) {
    if ("connectionString" in params && params.connectionString) {
      return parseAndMaskConnectionString(params.connectionString);
    }
    const host = params.host || "localhost";
    const port = params.port || 5432;
    const database = params.database || "";
    return `postgresql://${host}:${port}/${database}`;
  }
  exports.getConnectionString = getConnectionString;
  function getPort(port) {
    if (Number.isInteger(port)) {
      return port;
    }
    return;
  }
  function getSemanticAttributesFromConnection(params, semconvStability) {
    let attributes = {};
    if (semconvStability & instrumentation_1.SemconvStability.OLD) {
      attributes = {
        ...attributes,
        [semconv_1.ATTR_DB_SYSTEM]: semconv_1.DB_SYSTEM_VALUE_POSTGRESQL,
        [semconv_1.ATTR_DB_NAME]: params.database,
        [semconv_1.ATTR_DB_CONNECTION_STRING]: getConnectionString(params),
        [semconv_1.ATTR_DB_USER]: params.user,
        [semconv_1.ATTR_NET_PEER_NAME]: params.host,
        [semconv_1.ATTR_NET_PEER_PORT]: getPort(params.port)
      };
    }
    if (semconvStability & instrumentation_1.SemconvStability.STABLE) {
      attributes = {
        ...attributes,
        [semantic_conventions_1.ATTR_DB_SYSTEM_NAME]: semantic_conventions_1.DB_SYSTEM_NAME_VALUE_POSTGRESQL,
        [semantic_conventions_1.ATTR_DB_NAMESPACE]: params.namespace,
        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: params.host,
        [semantic_conventions_1.ATTR_SERVER_PORT]: getPort(params.port)
      };
    }
    return attributes;
  }
  exports.getSemanticAttributesFromConnection = getSemanticAttributesFromConnection;
  function getSemanticAttributesFromPoolConnection(params, semconvStability) {
    let url;
    try {
      url = params.connectionString ? new URL(params.connectionString) : undefined;
    } catch (e) {
      url = undefined;
    }
    let attributes = {
      [AttributeNames_1.AttributeNames.IDLE_TIMEOUT_MILLIS]: params.idleTimeoutMillis,
      [AttributeNames_1.AttributeNames.MAX_CLIENT]: params.maxClient
    };
    if (semconvStability & instrumentation_1.SemconvStability.OLD) {
      attributes = {
        ...attributes,
        [semconv_1.ATTR_DB_SYSTEM]: semconv_1.DB_SYSTEM_VALUE_POSTGRESQL,
        [semconv_1.ATTR_DB_NAME]: url?.pathname.slice(1) ?? params.database,
        [semconv_1.ATTR_DB_CONNECTION_STRING]: getConnectionString(params),
        [semconv_1.ATTR_NET_PEER_NAME]: url?.hostname ?? params.host,
        [semconv_1.ATTR_NET_PEER_PORT]: Number(url?.port) || getPort(params.port),
        [semconv_1.ATTR_DB_USER]: url?.username ?? params.user
      };
    }
    if (semconvStability & instrumentation_1.SemconvStability.STABLE) {
      attributes = {
        ...attributes,
        [semantic_conventions_1.ATTR_DB_SYSTEM_NAME]: semantic_conventions_1.DB_SYSTEM_NAME_VALUE_POSTGRESQL,
        [semantic_conventions_1.ATTR_DB_NAMESPACE]: params.namespace,
        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: url?.hostname ?? params.host,
        [semantic_conventions_1.ATTR_SERVER_PORT]: Number(url?.port) || getPort(params.port)
      };
    }
    return attributes;
  }
  exports.getSemanticAttributesFromPoolConnection = getSemanticAttributesFromPoolConnection;
  function shouldSkipInstrumentation(instrumentationConfig) {
    return instrumentationConfig.requireParentSpan === true && api_1.trace.getSpan(api_1.context.active()) === undefined;
  }
  exports.shouldSkipInstrumentation = shouldSkipInstrumentation;
  function handleConfigQuery(tracer, instrumentationConfig, semconvStability, queryConfig) {
    const { connectionParameters } = this;
    const dbName = connectionParameters.database;
    const spanName = getQuerySpanName(dbName, queryConfig);
    const span = tracer.startSpan(spanName, {
      kind: api_1.SpanKind.CLIENT,
      attributes: getSemanticAttributesFromConnection(connectionParameters, semconvStability)
    });
    if (!queryConfig) {
      return span;
    }
    if (queryConfig.text) {
      if (semconvStability & instrumentation_1.SemconvStability.OLD) {
        span.setAttribute(semconv_1.ATTR_DB_STATEMENT, queryConfig.text);
      }
      if (semconvStability & instrumentation_1.SemconvStability.STABLE) {
        span.setAttribute(semantic_conventions_1.ATTR_DB_QUERY_TEXT, queryConfig.text);
      }
    }
    if (instrumentationConfig.enhancedDatabaseReporting && Array.isArray(queryConfig.values)) {
      try {
        const convertedValues = queryConfig.values.map((value) => {
          if (value == null) {
            return "null";
          } else if (value instanceof Buffer) {
            return value.toString();
          } else if (typeof value === "object") {
            if (typeof value.toPostgres === "function") {
              return value.toPostgres();
            }
            return JSON.stringify(value);
          } else {
            return value.toString();
          }
        });
        span.setAttribute(AttributeNames_1.AttributeNames.PG_VALUES, convertedValues);
      } catch (e) {
        api_1.diag.error("failed to stringify ", queryConfig.values, e);
      }
    }
    if (typeof queryConfig.name === "string") {
      span.setAttribute(AttributeNames_1.AttributeNames.PG_PLAN, queryConfig.name);
    }
    return span;
  }
  exports.handleConfigQuery = handleConfigQuery;
  function handleExecutionResult(config, span, pgResult) {
    if (typeof config.responseHook === "function") {
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
        config.responseHook(span, {
          data: pgResult
        });
      }, (err) => {
        if (err) {
          api_1.diag.error("Error running response hook", err);
        }
      }, true);
    }
  }
  exports.handleExecutionResult = handleExecutionResult;
  function patchCallback(instrumentationConfig, span, cb, attributes, recordDuration) {
    return function patchedCallback(err, res) {
      if (err) {
        if (Object.prototype.hasOwnProperty.call(err, "code")) {
          attributes[semantic_conventions_1.ATTR_ERROR_TYPE] = err["code"];
        }
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: err.message
        });
      } else {
        handleExecutionResult(instrumentationConfig, span, res);
      }
      recordDuration();
      span.end();
      cb.call(this, err, res);
    };
  }
  exports.patchCallback = patchCallback;
  function getPoolName(pool) {
    let poolName = "";
    poolName += (pool?.host ? `${pool.host}` : "unknown_host") + ":";
    poolName += (pool?.port ? `${pool.port}` : "unknown_port") + "/";
    poolName += pool?.database ? `${pool.database}` : "unknown_database";
    return poolName.trim();
  }
  exports.getPoolName = getPoolName;
  function updateCounter(poolName, pool, connectionCount, connectionPendingRequests, latestCounter) {
    const all = pool.totalCount;
    const pending = pool.waitingCount;
    const idle = pool.idleCount;
    const used = all - idle;
    connectionCount.add(used - latestCounter.used, {
      [semconv_1.ATTR_DB_CLIENT_CONNECTION_STATE]: semconv_1.DB_CLIENT_CONNECTION_STATE_VALUE_USED,
      [semconv_1.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: poolName
    });
    connectionCount.add(idle - latestCounter.idle, {
      [semconv_1.ATTR_DB_CLIENT_CONNECTION_STATE]: semconv_1.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE,
      [semconv_1.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: poolName
    });
    connectionPendingRequests.add(pending - latestCounter.pending, {
      [semconv_1.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: poolName
    });
    return { used, idle, pending };
  }
  exports.updateCounter = updateCounter;
  function patchCallbackPGPool(span, cb) {
    return function patchedCallback(err, res, done) {
      if (err) {
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: err.message
        });
      }
      span.end();
      cb.call(this, err, res, done);
    };
  }
  exports.patchCallbackPGPool = patchCallbackPGPool;
  function patchClientConnectCallback(span, cb) {
    return function patchedClientConnectCallback(err) {
      if (err) {
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: err.message
        });
      }
      span.end();
      cb.apply(this, arguments);
    };
  }
  exports.patchClientConnectCallback = patchClientConnectCallback;
  function getErrorMessage(e) {
    return typeof e === "object" && e !== null && "message" in e ? String(e.message) : undefined;
  }
  exports.getErrorMessage = getErrorMessage;
  function isObjectWithTextString(it) {
    return typeof it === "object" && typeof it?.text === "string";
  }
  exports.isObjectWithTextString = isObjectWithTextString;
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/version.js
var require_version15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.57.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-pg";
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/instrumentation.js
var require_instrumentation13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PgInstrumentation = undefined;
  var instrumentation_1 = require_src6();
  var api_1 = require_src();
  var internal_types_1 = require_internal_types6();
  var utils = require_utils17();
  var sql_common_1 = require_src19();
  var version_1 = require_version15();
  var SpanNames_1 = require_SpanNames();
  var core_1 = require_src3();
  var semantic_conventions_1 = require_src2();
  var semconv_1 = require_semconv5();
  function extractModuleExports(module2) {
    return module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
  }

  class PgInstrumentation extends instrumentation_1.InstrumentationBase {
    _connectionsCounter = {
      used: 0,
      idle: 0,
      pending: 0
    };
    _semconvStability;
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      this._semconvStability = (0, instrumentation_1.semconvStabilityFromStr)("database", process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
    }
    _updateMetricInstruments() {
      this._operationDuration = this.meter.createHistogram(semantic_conventions_1.METRIC_DB_CLIENT_OPERATION_DURATION, {
        description: "Duration of database client operations.",
        unit: "s",
        valueType: api_1.ValueType.DOUBLE,
        advice: {
          explicitBucketBoundaries: [
            0.001,
            0.005,
            0.01,
            0.05,
            0.1,
            0.5,
            1,
            5,
            10
          ]
        }
      });
      this._connectionsCounter = {
        idle: 0,
        pending: 0,
        used: 0
      };
      this._connectionsCount = this.meter.createUpDownCounter(semconv_1.METRIC_DB_CLIENT_CONNECTION_COUNT, {
        description: "The number of connections that are currently in state described by the state attribute.",
        unit: "{connection}"
      });
      this._connectionPendingRequests = this.meter.createUpDownCounter(semconv_1.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS, {
        description: "The number of current pending requests for an open connection.",
        unit: "{connection}"
      });
    }
    init() {
      const SUPPORTED_PG_VERSIONS = [">=8.0.3 <9"];
      const SUPPORTED_PG_POOL_VERSIONS = [">=2.0.0 <4"];
      const modulePgNativeClient = new instrumentation_1.InstrumentationNodeModuleFile("pg/lib/native/client.js", SUPPORTED_PG_VERSIONS, this._patchPgClient.bind(this), this._unpatchPgClient.bind(this));
      const modulePgClient = new instrumentation_1.InstrumentationNodeModuleFile("pg/lib/client.js", SUPPORTED_PG_VERSIONS, this._patchPgClient.bind(this), this._unpatchPgClient.bind(this));
      const modulePG = new instrumentation_1.InstrumentationNodeModuleDefinition("pg", SUPPORTED_PG_VERSIONS, (module2) => {
        const moduleExports = extractModuleExports(module2);
        this._patchPgClient(moduleExports.Client);
        return module2;
      }, (module2) => {
        const moduleExports = extractModuleExports(module2);
        this._unpatchPgClient(moduleExports.Client);
        return module2;
      }, [modulePgClient, modulePgNativeClient]);
      const modulePGPool = new instrumentation_1.InstrumentationNodeModuleDefinition("pg-pool", SUPPORTED_PG_POOL_VERSIONS, (module2) => {
        const moduleExports = extractModuleExports(module2);
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
          this._unwrap(moduleExports.prototype, "connect");
        }
        this._wrap(moduleExports.prototype, "connect", this._getPoolConnectPatch());
        return moduleExports;
      }, (module2) => {
        const moduleExports = extractModuleExports(module2);
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
          this._unwrap(moduleExports.prototype, "connect");
        }
      });
      return [modulePG, modulePGPool];
    }
    _patchPgClient(module2) {
      if (!module2) {
        return;
      }
      const moduleExports = extractModuleExports(module2);
      if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.query)) {
        this._unwrap(moduleExports.prototype, "query");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
        this._unwrap(moduleExports.prototype, "connect");
      }
      this._wrap(moduleExports.prototype, "query", this._getClientQueryPatch());
      this._wrap(moduleExports.prototype, "connect", this._getClientConnectPatch());
      return module2;
    }
    _unpatchPgClient(module2) {
      const moduleExports = extractModuleExports(module2);
      if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.query)) {
        this._unwrap(moduleExports.prototype, "query");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
        this._unwrap(moduleExports.prototype, "connect");
      }
      return module2;
    }
    _getClientConnectPatch() {
      const plugin = this;
      return (original) => {
        return function connect(callback) {
          if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
            return original.call(this, callback);
          }
          const span = plugin.tracer.startSpan(SpanNames_1.SpanNames.CONNECT, {
            kind: api_1.SpanKind.CLIENT,
            attributes: utils.getSemanticAttributesFromConnection(this, plugin._semconvStability)
          });
          if (callback) {
            const parentSpan = api_1.trace.getSpan(api_1.context.active());
            callback = utils.patchClientConnectCallback(span, callback);
            if (parentSpan) {
              callback = api_1.context.bind(api_1.context.active(), callback);
            }
          }
          const connectResult = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            return original.call(this, callback);
          });
          return handleConnectResult(span, connectResult);
        };
      };
    }
    recordOperationDuration(attributes, startTime) {
      const metricsAttributes = {};
      const keysToCopy = [
        semantic_conventions_1.ATTR_DB_NAMESPACE,
        semantic_conventions_1.ATTR_ERROR_TYPE,
        semantic_conventions_1.ATTR_SERVER_PORT,
        semantic_conventions_1.ATTR_SERVER_ADDRESS,
        semantic_conventions_1.ATTR_DB_OPERATION_NAME
      ];
      if (this._semconvStability & instrumentation_1.SemconvStability.OLD) {
        keysToCopy.push(semconv_1.ATTR_DB_SYSTEM);
      }
      if (this._semconvStability & instrumentation_1.SemconvStability.STABLE) {
        keysToCopy.push(semantic_conventions_1.ATTR_DB_SYSTEM_NAME);
      }
      keysToCopy.forEach((key) => {
        if (key in attributes) {
          metricsAttributes[key] = attributes[key];
        }
      });
      const durationSeconds = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)())) / 1000;
      this._operationDuration.record(durationSeconds, metricsAttributes);
    }
    _getClientQueryPatch() {
      const plugin = this;
      return (original) => {
        this._diag.debug("Patching pg.Client.prototype.query");
        return function query(...args) {
          if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
            return original.apply(this, args);
          }
          const startTime = (0, core_1.hrTime)();
          const arg0 = args[0];
          const firstArgIsString = typeof arg0 === "string";
          const firstArgIsQueryObjectWithText = utils.isObjectWithTextString(arg0);
          const queryConfig = firstArgIsString ? {
            text: arg0,
            values: Array.isArray(args[1]) ? args[1] : undefined
          } : firstArgIsQueryObjectWithText ? arg0 : undefined;
          const attributes = {
            [semconv_1.ATTR_DB_SYSTEM]: semconv_1.DB_SYSTEM_VALUE_POSTGRESQL,
            [semantic_conventions_1.ATTR_DB_NAMESPACE]: this.database,
            [semantic_conventions_1.ATTR_SERVER_PORT]: this.connectionParameters.port,
            [semantic_conventions_1.ATTR_SERVER_ADDRESS]: this.connectionParameters.host
          };
          if (queryConfig?.text) {
            attributes[semantic_conventions_1.ATTR_DB_OPERATION_NAME] = utils.parseNormalizedOperationName(queryConfig?.text);
          }
          const recordDuration = () => {
            plugin.recordOperationDuration(attributes, startTime);
          };
          const instrumentationConfig = plugin.getConfig();
          const span = utils.handleConfigQuery.call(this, plugin.tracer, instrumentationConfig, plugin._semconvStability, queryConfig);
          if (instrumentationConfig.addSqlCommenterCommentToQueries) {
            if (firstArgIsString) {
              args[0] = (0, sql_common_1.addSqlCommenterComment)(span, arg0);
            } else if (firstArgIsQueryObjectWithText && !("name" in arg0)) {
              args[0] = {
                ...arg0,
                text: (0, sql_common_1.addSqlCommenterComment)(span, arg0.text)
              };
            }
          }
          if (args.length > 0) {
            const parentSpan = api_1.trace.getSpan(api_1.context.active());
            if (typeof args[args.length - 1] === "function") {
              args[args.length - 1] = utils.patchCallback(instrumentationConfig, span, args[args.length - 1], attributes, recordDuration);
              if (parentSpan) {
                args[args.length - 1] = api_1.context.bind(api_1.context.active(), args[args.length - 1]);
              }
            } else if (typeof queryConfig?.callback === "function") {
              let callback = utils.patchCallback(plugin.getConfig(), span, queryConfig.callback, attributes, recordDuration);
              if (parentSpan) {
                callback = api_1.context.bind(api_1.context.active(), callback);
              }
              args[0].callback = callback;
            }
          }
          const { requestHook: requestHook2 } = instrumentationConfig;
          if (typeof requestHook2 === "function" && queryConfig) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
              const { database, host, port, user } = this.connectionParameters;
              const connection = { database, host, port, user };
              requestHook2(span, {
                connection,
                query: {
                  text: queryConfig.text,
                  values: queryConfig.values,
                  name: queryConfig.name
                }
              });
            }, (err) => {
              if (err) {
                plugin._diag.error("Error running query hook", err);
              }
            }, true);
          }
          let result;
          try {
            result = original.apply(this, args);
          } catch (e) {
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: utils.getErrorMessage(e)
            });
            span.end();
            throw e;
          }
          if (result instanceof Promise) {
            return result.then((result2) => {
              return new Promise((resolve2) => {
                utils.handleExecutionResult(plugin.getConfig(), span, result2);
                recordDuration();
                span.end();
                resolve2(result2);
              });
            }).catch((error2) => {
              return new Promise((_, reject) => {
                span.setStatus({
                  code: api_1.SpanStatusCode.ERROR,
                  message: error2.message
                });
                recordDuration();
                span.end();
                reject(error2);
              });
            });
          }
          return result;
        };
      };
    }
    _setPoolConnectEventListeners(pgPool) {
      if (pgPool[internal_types_1.EVENT_LISTENERS_SET])
        return;
      const poolName = utils.getPoolName(pgPool.options);
      pgPool.on("connect", () => {
        this._connectionsCounter = utils.updateCounter(poolName, pgPool, this._connectionsCount, this._connectionPendingRequests, this._connectionsCounter);
      });
      pgPool.on("acquire", () => {
        this._connectionsCounter = utils.updateCounter(poolName, pgPool, this._connectionsCount, this._connectionPendingRequests, this._connectionsCounter);
      });
      pgPool.on("remove", () => {
        this._connectionsCounter = utils.updateCounter(poolName, pgPool, this._connectionsCount, this._connectionPendingRequests, this._connectionsCounter);
      });
      pgPool.on("release", () => {
        this._connectionsCounter = utils.updateCounter(poolName, pgPool, this._connectionsCount, this._connectionPendingRequests, this._connectionsCounter);
      });
      pgPool[internal_types_1.EVENT_LISTENERS_SET] = true;
    }
    _getPoolConnectPatch() {
      const plugin = this;
      return (originalConnect) => {
        return function connect(callback) {
          if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
            return originalConnect.call(this, callback);
          }
          const span = plugin.tracer.startSpan(SpanNames_1.SpanNames.POOL_CONNECT, {
            kind: api_1.SpanKind.CLIENT,
            attributes: utils.getSemanticAttributesFromPoolConnection(this.options, plugin._semconvStability)
          });
          plugin._setPoolConnectEventListeners(this);
          if (callback) {
            const parentSpan = api_1.trace.getSpan(api_1.context.active());
            callback = utils.patchCallbackPGPool(span, callback);
            if (parentSpan) {
              callback = api_1.context.bind(api_1.context.active(), callback);
            }
          }
          const connectResult = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            return originalConnect.call(this, callback);
          });
          return handleConnectResult(span, connectResult);
        };
      };
    }
  }
  exports.PgInstrumentation = PgInstrumentation;
  function handleConnectResult(span, connectResult) {
    if (!(connectResult instanceof Promise)) {
      return connectResult;
    }
    const connectResultPromise = connectResult;
    return api_1.context.bind(api_1.context.active(), connectResultPromise.then((result) => {
      span.end();
      return result;
    }).catch((error2) => {
      span.setStatus({
        code: api_1.SpanStatusCode.ERROR,
        message: utils.getErrorMessage(error2)
      });
      span.end();
      return Promise.reject(error2);
    }));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/index.js
var require_src24 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = exports.PgInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation13();
  Object.defineProperty(exports, "PgInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.PgInstrumentation;
  } });
  var AttributeNames_1 = require_AttributeNames5();
  Object.defineProperty(exports, "AttributeNames", { enumerable: true, get: function() {
    return AttributeNames_1.AttributeNames;
  } });
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js
var require_LogRecord2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SeverityNumber = undefined;
  var SeverityNumber;
  (function(SeverityNumber2) {
    SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
    SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
    SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
    SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
    SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
    SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
    SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
    SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
    SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
    SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
    SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
    SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
    SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
    SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
    SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
    SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
    SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
    SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
    SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
    SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
    SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
    SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
    SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
    SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
  })(SeverityNumber = exports.SeverityNumber || (exports.SeverityNumber = {}));
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js
var require_NoopLogger2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER = exports.NoopLogger = undefined;

  class NoopLogger {
    emit(_logRecord) {}
  }
  exports.NoopLogger = NoopLogger;
  exports.NOOP_LOGGER = new NoopLogger;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js
var require_NoopLoggerProvider2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER_PROVIDER = exports.NoopLoggerProvider = undefined;
  var NoopLogger_1 = require_NoopLogger2();

  class NoopLoggerProvider {
    getLogger(_name, _version, _options) {
      return new NoopLogger_1.NoopLogger;
    }
  }
  exports.NoopLoggerProvider = NoopLoggerProvider;
  exports.NOOP_LOGGER_PROVIDER = new NoopLoggerProvider;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/ProxyLogger.js
var require_ProxyLogger2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyLogger = undefined;
  var NoopLogger_1 = require_NoopLogger2();

  class ProxyLogger {
    constructor(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    emit(logRecord) {
      this._getLogger().emit(logRecord);
    }
    _getLogger() {
      if (this._delegate) {
        return this._delegate;
      }
      const logger30 = this._provider.getDelegateLogger(this.name, this.version, this.options);
      if (!logger30) {
        return NoopLogger_1.NOOP_LOGGER;
      }
      this._delegate = logger30;
      return this._delegate;
    }
  }
  exports.ProxyLogger = ProxyLogger;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/ProxyLoggerProvider.js
var require_ProxyLoggerProvider2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyLoggerProvider = undefined;
  var NoopLoggerProvider_1 = require_NoopLoggerProvider2();
  var ProxyLogger_1 = require_ProxyLogger2();

  class ProxyLoggerProvider {
    getLogger(name, version, options) {
      var _a;
      return (_a = this.getDelegateLogger(name, version, options)) !== null && _a !== undefined ? _a : new ProxyLogger_1.ProxyLogger(this, name, version, options);
    }
    getDelegate() {
      var _a;
      return (_a = this._delegate) !== null && _a !== undefined ? _a : NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateLogger(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getLogger(name, version, options);
    }
  }
  exports.ProxyLoggerProvider = ProxyLoggerProvider;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js
var require_globalThis4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js
var require_node9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  var globalThis_1 = require_globalThis4();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return globalThis_1._globalThis;
  } });
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/platform/index.js
var require_platform8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  var node_1 = require_node9();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return node_1._globalThis;
  } });
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js
var require_global_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_LOGS_API_KEY = undefined;
  var platform_1 = require_platform8();
  exports.GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
  exports._global = platform_1._globalThis;
  function makeGetter(requiredVersion, instance, fallback) {
    return (version) => version === requiredVersion ? instance : fallback;
  }
  exports.makeGetter = makeGetter;
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = 1;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/api/logs.js
var require_logs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogsAPI = undefined;
  var global_utils_1 = require_global_utils3();
  var NoopLoggerProvider_1 = require_NoopLoggerProvider2();
  var ProxyLoggerProvider_1 = require_ProxyLoggerProvider2();

  class LogsAPI {
    constructor() {
      this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new LogsAPI;
      }
      return this._instance;
    }
    setGlobalLoggerProvider(provider) {
      if (global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) {
        return this.getLoggerProvider();
      }
      global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY] = (0, global_utils_1.makeGetter)(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER);
      this._proxyLoggerProvider.setDelegate(provider);
      return provider;
    }
    getLoggerProvider() {
      var _a, _b;
      return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) === null || _a === undefined ? undefined : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== undefined ? _b : this._proxyLoggerProvider;
    }
    getLogger(name, version, options) {
      return this.getLoggerProvider().getLogger(name, version, options);
    }
    disable() {
      delete global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY];
      this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider;
    }
  }
  exports.LogsAPI = LogsAPI;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/index.js
var require_src25 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logs = exports.ProxyLoggerProvider = exports.ProxyLogger = exports.NoopLoggerProvider = exports.NOOP_LOGGER_PROVIDER = exports.NoopLogger = exports.NOOP_LOGGER = exports.SeverityNumber = undefined;
  var LogRecord_1 = require_LogRecord2();
  Object.defineProperty(exports, "SeverityNumber", { enumerable: true, get: function() {
    return LogRecord_1.SeverityNumber;
  } });
  var NoopLogger_1 = require_NoopLogger2();
  Object.defineProperty(exports, "NOOP_LOGGER", { enumerable: true, get: function() {
    return NoopLogger_1.NOOP_LOGGER;
  } });
  Object.defineProperty(exports, "NoopLogger", { enumerable: true, get: function() {
    return NoopLogger_1.NoopLogger;
  } });
  var NoopLoggerProvider_1 = require_NoopLoggerProvider2();
  Object.defineProperty(exports, "NOOP_LOGGER_PROVIDER", { enumerable: true, get: function() {
    return NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
  } });
  Object.defineProperty(exports, "NoopLoggerProvider", { enumerable: true, get: function() {
    return NoopLoggerProvider_1.NoopLoggerProvider;
  } });
  var ProxyLogger_1 = require_ProxyLogger2();
  Object.defineProperty(exports, "ProxyLogger", { enumerable: true, get: function() {
    return ProxyLogger_1.ProxyLogger;
  } });
  var ProxyLoggerProvider_1 = require_ProxyLoggerProvider2();
  Object.defineProperty(exports, "ProxyLoggerProvider", { enumerable: true, get: function() {
    return ProxyLoggerProvider_1.ProxyLoggerProvider;
  } });
  var logs_1 = require_logs2();
  exports.logs = logs_1.LogsAPI.getInstance();
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/autoLoaderUtils.js
var require_autoLoaderUtils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.disableInstrumentations = exports.enableInstrumentations = undefined;
  function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
    for (let i = 0, j = instrumentations.length;i < j; i++) {
      const instrumentation = instrumentations[i];
      if (tracerProvider) {
        instrumentation.setTracerProvider(tracerProvider);
      }
      if (meterProvider) {
        instrumentation.setMeterProvider(meterProvider);
      }
      if (loggerProvider && instrumentation.setLoggerProvider) {
        instrumentation.setLoggerProvider(loggerProvider);
      }
      if (!instrumentation.getConfig().enabled) {
        instrumentation.enable();
      }
    }
  }
  exports.enableInstrumentations = enableInstrumentations;
  function disableInstrumentations(instrumentations) {
    instrumentations.forEach((instrumentation) => instrumentation.disable());
  }
  exports.disableInstrumentations = disableInstrumentations;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/autoLoader.js
var require_autoLoader2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.registerInstrumentations = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src25();
  var autoLoaderUtils_1 = require_autoLoaderUtils2();
  function registerInstrumentations3(options) {
    var _a, _b;
    const tracerProvider = options.tracerProvider || api_1.trace.getTracerProvider();
    const meterProvider = options.meterProvider || api_1.metrics.getMeterProvider();
    const loggerProvider = options.loggerProvider || api_logs_1.logs.getLoggerProvider();
    const instrumentations = (_b = (_a = options.instrumentations) === null || _a === undefined ? undefined : _a.flat()) !== null && _b !== undefined ? _b : [];
    (0, autoLoaderUtils_1.enableInstrumentations)(instrumentations, tracerProvider, meterProvider, loggerProvider);
    return () => {
      (0, autoLoaderUtils_1.disableInstrumentations)(instrumentations);
    };
  }
  exports.registerInstrumentations = registerInstrumentations3;
});

// ../../node_modules/semver/internal/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// ../../node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module.exports = debug2;
});

// ../../node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants2();
  var debug2 = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var safeSrc = exports.safeSrc = [];
  var t = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("COERCERTLFULL", src[t.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// ../../node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions2 = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions2;
});

// ../../node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// ../../node_modules/semver/classes/semver.js
var require_semver3 = __commonJS((exports, module) => {
  var debug2 = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
  var { safeRe: re, t } = require_re();
  var parseOptions2 = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions2(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug2("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug2("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug2("build compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release2, identifier, identifierBase) {
      if (release2.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match3 = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
          if (!match3 || match3[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release2) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release2}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// ../../node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var parse = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse;
});

// ../../node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse = require_parse();
  var valid = (version, options) => {
    const v = parse(version, options);
    return v ? v.version : null;
  };
  module.exports = valid;
});

// ../../node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse = require_parse();
  var clean = (version, options) => {
    const s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module.exports = clean;
});

// ../../node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var inc = (version, release2, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release2, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// ../../node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse = require_parse();
  var diff = (version1, version2) => {
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// ../../node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var major = (a, loose) => new SemVer(a, loose).major;
  module.exports = major;
});

// ../../node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module.exports = minor;
});

// ../../node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module.exports = patch;
});

// ../../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse = require_parse();
  var prerelease = (version, options) => {
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// ../../node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module.exports = compare;
});

// ../../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module.exports = rcompare;
});

// ../../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module.exports = compareLoose;
});

// ../../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// ../../node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module.exports = sort;
});

// ../../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module.exports = rsort;
});

// ../../node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module.exports = gt;
});

// ../../node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module.exports = lt;
});

// ../../node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module.exports = eq;
});

// ../../node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module.exports = neq;
});

// ../../node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module.exports = gte;
});

// ../../node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module.exports = lte;
});

// ../../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// ../../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var parse = require_parse();
  var { safeRe: re, t } = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match3 = null;
    if (!options.rtl) {
      match3 = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match3 || match3.index + match3[0].length !== version.length)) {
        if (!match3 || next.index + next[0].length !== match3.index + match3[0].length) {
          match3 = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match3 === null) {
      return null;
    }
    const major = match3[2];
    const minor = match3[3] || "0";
    const patch = match3[4] || "0";
    const prerelease = options.includePrerelease && match3[5] ? `-${match3[5]}` : "";
    const build = options.includePrerelease && match3[6] ? `+${match3[6]}` : "";
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce;
});

// ../../node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// ../../node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions2(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i = 0;i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0;k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache = new LRU;
  var parseOptions2 = require_parse_options();
  var Comparator = require_comparator();
  var debug2 = require_debug();
  var SemVer = require_semver3();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version, options) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug2(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// ../../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions2 = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug2 = require_debug();
  var SemVer = require_semver3();
  var Range = require_range();
});

// ../../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module.exports = satisfies;
});

// ../../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// ../../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// ../../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// ../../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// ../../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// ../../node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver3();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// ../../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module.exports = gtr;
});

// ../../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module.exports = ltr;
});

// ../../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// ../../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version of v) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// ../../node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module.exports = subset;
});

// ../../node_modules/semver/index.js
var require_semver4 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants2 = require_constants2();
  var SemVer = require_semver3();
  var identifiers = require_identifiers();
  var parse = require_parse();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants2.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// ../../node_modules/shimmer/index.js
var require_shimmer2 = __commonJS((exports, module) => {
  function isFunction(funktion) {
    return typeof funktion === "function";
  }
  var logger30 = console.error.bind(console);
  function defineProperty(obj, name, value) {
    var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable,
      writable: true,
      value
    });
  }
  function shimmer(options) {
    if (options && options.logger) {
      if (!isFunction(options.logger))
        logger30("new logger isn't a function, not replacing");
      else
        logger30 = options.logger;
    }
  }
  function wrap(nodule, name, wrapper) {
    if (!nodule || !nodule[name]) {
      logger30("no original function " + name + " to wrap");
      return;
    }
    if (!wrapper) {
      logger30("no wrapper function");
      logger30(new Error().stack);
      return;
    }
    if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
      logger30("original object and wrapper must be functions");
      return;
    }
    var original = nodule[name];
    var wrapped = wrapper(original, name);
    defineProperty(wrapped, "__original", original);
    defineProperty(wrapped, "__unwrap", function() {
      if (nodule[name] === wrapped)
        defineProperty(nodule, name, original);
    });
    defineProperty(wrapped, "__wrapped", true);
    defineProperty(nodule, name, wrapped);
    return wrapped;
  }
  function massWrap(nodules, names, wrapper) {
    if (!nodules) {
      logger30("must provide one or more modules to patch");
      logger30(new Error().stack);
      return;
    } else if (!Array.isArray(nodules)) {
      nodules = [nodules];
    }
    if (!(names && Array.isArray(names))) {
      logger30("must provide one or more functions to wrap on modules");
      return;
    }
    nodules.forEach(function(nodule) {
      names.forEach(function(name) {
        wrap(nodule, name, wrapper);
      });
    });
  }
  function unwrap(nodule, name) {
    if (!nodule || !nodule[name]) {
      logger30("no function to unwrap.");
      logger30(new Error().stack);
      return;
    }
    if (!nodule[name].__unwrap) {
      logger30("no original to unwrap to -- has " + name + " already been unwrapped?");
    } else {
      return nodule[name].__unwrap();
    }
  }
  function massUnwrap(nodules, names) {
    if (!nodules) {
      logger30("must provide one or more modules to patch");
      logger30(new Error().stack);
      return;
    } else if (!Array.isArray(nodules)) {
      nodules = [nodules];
    }
    if (!(names && Array.isArray(names))) {
      logger30("must provide one or more functions to unwrap on modules");
      return;
    }
    nodules.forEach(function(nodule) {
      names.forEach(function(name) {
        unwrap(nodule, name);
      });
    });
  }
  shimmer.wrap = wrap;
  shimmer.massWrap = massWrap;
  shimmer.unwrap = unwrap;
  shimmer.massUnwrap = massUnwrap;
  module.exports = shimmer;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/instrumentation.js
var require_instrumentation14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationAbstract = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src25();
  var shimmer = require_shimmer2();

  class InstrumentationAbstract {
    constructor(instrumentationName, instrumentationVersion, config) {
      this.instrumentationName = instrumentationName;
      this.instrumentationVersion = instrumentationVersion;
      this._config = {};
      this._wrap = shimmer.wrap;
      this._unwrap = shimmer.unwrap;
      this._massWrap = shimmer.massWrap;
      this._massUnwrap = shimmer.massUnwrap;
      this.setConfig(config);
      this._diag = api_1.diag.createComponentLogger({
        namespace: instrumentationName
      });
      this._tracer = api_1.trace.getTracer(instrumentationName, instrumentationVersion);
      this._meter = api_1.metrics.getMeter(instrumentationName, instrumentationVersion);
      this._logger = api_logs_1.logs.getLogger(instrumentationName, instrumentationVersion);
      this._updateMetricInstruments();
    }
    get meter() {
      return this._meter;
    }
    setMeterProvider(meterProvider) {
      this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
      this._updateMetricInstruments();
    }
    get logger() {
      return this._logger;
    }
    setLoggerProvider(loggerProvider) {
      this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    }
    getModuleDefinitions() {
      var _a;
      const initResult = (_a = this.init()) !== null && _a !== undefined ? _a : [];
      if (!Array.isArray(initResult)) {
        return [initResult];
      }
      return initResult;
    }
    _updateMetricInstruments() {
      return;
    }
    getConfig() {
      return this._config;
    }
    setConfig(config) {
      this._config = Object.assign({ enabled: true }, config);
    }
    setTracerProvider(tracerProvider) {
      this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    }
    get tracer() {
      return this._tracer;
    }
    _runSpanCustomizationHook(hookHandler, triggerName, span, info) {
      if (!hookHandler) {
        return;
      }
      try {
        hookHandler(span, info);
      } catch (e) {
        this._diag.error(`Error running span customization hook due to exception in handler`, { triggerName }, e);
      }
    }
  }
  exports.InstrumentationAbstract = InstrumentationAbstract;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/platform/node/ModuleNameTrie.js
var require_ModuleNameTrie2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ModuleNameTrie = exports.ModuleNameSeparator = undefined;
  exports.ModuleNameSeparator = "/";

  class ModuleNameTrieNode {
    constructor() {
      this.hooks = [];
      this.children = new Map;
    }
  }

  class ModuleNameTrie {
    constructor() {
      this._trie = new ModuleNameTrieNode;
      this._counter = 0;
    }
    insert(hook) {
      let trieNode = this._trie;
      for (const moduleNamePart of hook.moduleName.split(exports.ModuleNameSeparator)) {
        let nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          nextNode = new ModuleNameTrieNode;
          trieNode.children.set(moduleNamePart, nextNode);
        }
        trieNode = nextNode;
      }
      trieNode.hooks.push({ hook, insertedId: this._counter++ });
    }
    search(moduleName, { maintainInsertionOrder, fullOnly } = {}) {
      let trieNode = this._trie;
      const results = [];
      let foundFull = true;
      for (const moduleNamePart of moduleName.split(exports.ModuleNameSeparator)) {
        const nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          foundFull = false;
          break;
        }
        if (!fullOnly) {
          results.push(...nextNode.hooks);
        }
        trieNode = nextNode;
      }
      if (fullOnly && foundFull) {
        results.push(...trieNode.hooks);
      }
      if (results.length === 0) {
        return [];
      }
      if (results.length === 1) {
        return [results[0].hook];
      }
      if (maintainInsertionOrder) {
        results.sort((a, b) => a.insertedId - b.insertedId);
      }
      return results.map(({ hook }) => hook);
    }
  }
  exports.ModuleNameTrie = ModuleNameTrie;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/platform/node/RequireInTheMiddleSingleton.js
var require_RequireInTheMiddleSingleton2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequireInTheMiddleSingleton = undefined;
  var require_in_the_middle_1 = require_require_in_the_middle();
  var path8 = __require("path");
  var ModuleNameTrie_1 = require_ModuleNameTrie2();
  var isMocha = [
    "afterEach",
    "after",
    "beforeEach",
    "before",
    "describe",
    "it"
  ].every((fn) => {
    return typeof global[fn] === "function";
  });

  class RequireInTheMiddleSingleton {
    constructor() {
      this._moduleNameTrie = new ModuleNameTrie_1.ModuleNameTrie;
      this._initialize();
    }
    _initialize() {
      new require_in_the_middle_1.Hook(null, { internals: true }, (exports2, name, basedir) => {
        const normalizedModuleName = normalizePathSeparators(name);
        const matches = this._moduleNameTrie.search(normalizedModuleName, {
          maintainInsertionOrder: true,
          fullOnly: basedir === undefined
        });
        for (const { onRequire } of matches) {
          exports2 = onRequire(exports2, name, basedir);
        }
        return exports2;
      });
    }
    register(moduleName, onRequire) {
      const hooked = { moduleName, onRequire };
      this._moduleNameTrie.insert(hooked);
      return hooked;
    }
    static getInstance() {
      var _a;
      if (isMocha)
        return new RequireInTheMiddleSingleton;
      return this._instance = (_a = this._instance) !== null && _a !== undefined ? _a : new RequireInTheMiddleSingleton;
    }
  }
  exports.RequireInTheMiddleSingleton = RequireInTheMiddleSingleton;
  function normalizePathSeparators(moduleNameOrPath) {
    return path8.sep !== ModuleNameTrie_1.ModuleNameSeparator ? moduleNameOrPath.split(path8.sep).join(ModuleNameTrie_1.ModuleNameSeparator) : moduleNameOrPath;
  }
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/utils.js
var require_utils18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isWrapped = exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = undefined;
  function safeExecuteInTheMiddle3(execute, onFinish, preventThrowingError) {
    let error2;
    let result;
    try {
      result = execute();
    } catch (e) {
      error2 = e;
    } finally {
      onFinish(error2, result);
      if (error2 && !preventThrowingError) {
        throw error2;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddle = safeExecuteInTheMiddle3;
  async function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
    let error2;
    let result;
    try {
      result = await execute();
    } catch (e) {
      error2 = e;
    } finally {
      onFinish(error2, result);
      if (error2 && !preventThrowingError) {
        throw error2;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddleAsync = safeExecuteInTheMiddleAsync;
  function isWrapped(func) {
    return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
  }
  exports.isWrapped = isWrapped;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/platform/node/instrumentation.js
var require_instrumentation15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationBase = undefined;
  var path8 = __require("path");
  var util_1 = __require("util");
  var semver_1 = require_semver4();
  var shimmer_1 = require_shimmer2();
  var instrumentation_1 = require_instrumentation14();
  var RequireInTheMiddleSingleton_1 = require_RequireInTheMiddleSingleton2();
  var import_in_the_middle_1 = require_import_in_the_middle();
  var api_1 = require_src();
  var require_in_the_middle_1 = require_require_in_the_middle();
  var fs_1 = __require("fs");
  var utils_1 = require_utils18();

  class InstrumentationBase6 extends instrumentation_1.InstrumentationAbstract {
    constructor(instrumentationName, instrumentationVersion, config) {
      super(instrumentationName, instrumentationVersion, config);
      this._hooks = [];
      this._requireInTheMiddleSingleton = RequireInTheMiddleSingleton_1.RequireInTheMiddleSingleton.getInstance();
      this._enabled = false;
      this._wrap = (moduleExports, name, wrapper) => {
        if ((0, utils_1.isWrapped)(moduleExports[name])) {
          this._unwrap(moduleExports, name);
        }
        if (!util_1.types.isProxy(moduleExports)) {
          return (0, shimmer_1.wrap)(moduleExports, name, wrapper);
        } else {
          const wrapped = (0, shimmer_1.wrap)(Object.assign({}, moduleExports), name, wrapper);
          Object.defineProperty(moduleExports, name, {
            value: wrapped
          });
          return wrapped;
        }
      };
      this._unwrap = (moduleExports, name) => {
        if (!util_1.types.isProxy(moduleExports)) {
          return (0, shimmer_1.unwrap)(moduleExports, name);
        } else {
          return Object.defineProperty(moduleExports, name, {
            value: moduleExports[name]
          });
        }
      };
      this._massWrap = (moduleExportsArray, names, wrapper) => {
        if (!moduleExportsArray) {
          api_1.diag.error("must provide one or more modules to patch");
          return;
        } else if (!Array.isArray(moduleExportsArray)) {
          moduleExportsArray = [moduleExportsArray];
        }
        if (!(names && Array.isArray(names))) {
          api_1.diag.error("must provide one or more functions to wrap on modules");
          return;
        }
        moduleExportsArray.forEach((moduleExports) => {
          names.forEach((name) => {
            this._wrap(moduleExports, name, wrapper);
          });
        });
      };
      this._massUnwrap = (moduleExportsArray, names) => {
        if (!moduleExportsArray) {
          api_1.diag.error("must provide one or more modules to patch");
          return;
        } else if (!Array.isArray(moduleExportsArray)) {
          moduleExportsArray = [moduleExportsArray];
        }
        if (!(names && Array.isArray(names))) {
          api_1.diag.error("must provide one or more functions to wrap on modules");
          return;
        }
        moduleExportsArray.forEach((moduleExports) => {
          names.forEach((name) => {
            this._unwrap(moduleExports, name);
          });
        });
      };
      let modules = this.init();
      if (modules && !Array.isArray(modules)) {
        modules = [modules];
      }
      this._modules = modules || [];
      if (this._config.enabled) {
        this.enable();
      }
    }
    _warnOnPreloadedModules() {
      this._modules.forEach((module2) => {
        const { name } = module2;
        try {
          const resolvedModule = __require.resolve(name);
          if (__require.cache[resolvedModule]) {
            this._diag.warn(`Module ${name} has been loaded before ${this.instrumentationName} so it might not work, please initialize it before requiring ${name}`);
          }
        } catch (_a) {}
      });
    }
    _extractPackageVersion(baseDir) {
      try {
        const json = (0, fs_1.readFileSync)(path8.join(baseDir, "package.json"), {
          encoding: "utf8"
        });
        const version = JSON.parse(json).version;
        return typeof version === "string" ? version : undefined;
      } catch (error2) {
        api_1.diag.warn("Failed extracting version", baseDir);
      }
      return;
    }
    _onRequire(module2, exports2, name, baseDir) {
      var _a;
      if (!baseDir) {
        if (typeof module2.patch === "function") {
          module2.moduleExports = exports2;
          if (this._enabled) {
            this._diag.debug("Applying instrumentation patch for nodejs core module on require hook", {
              module: module2.name
            });
            return module2.patch(exports2);
          }
        }
        return exports2;
      }
      const version = this._extractPackageVersion(baseDir);
      module2.moduleVersion = version;
      if (module2.name === name) {
        if (isSupported(module2.supportedVersions, version, module2.includePrerelease)) {
          if (typeof module2.patch === "function") {
            module2.moduleExports = exports2;
            if (this._enabled) {
              this._diag.debug("Applying instrumentation patch for module on require hook", {
                module: module2.name,
                version: module2.moduleVersion,
                baseDir
              });
              return module2.patch(exports2, module2.moduleVersion);
            }
          }
        }
        return exports2;
      }
      const files = (_a = module2.files) !== null && _a !== undefined ? _a : [];
      const normalizedName = path8.normalize(name);
      const supportedFileInstrumentations = files.filter((f) => f.name === normalizedName).filter((f) => isSupported(f.supportedVersions, version, module2.includePrerelease));
      return supportedFileInstrumentations.reduce((patchedExports, file) => {
        file.moduleExports = patchedExports;
        if (this._enabled) {
          this._diag.debug("Applying instrumentation patch for nodejs module file on require hook", {
            module: module2.name,
            version: module2.moduleVersion,
            fileName: file.name,
            baseDir
          });
          return file.patch(patchedExports, module2.moduleVersion);
        }
        return patchedExports;
      }, exports2);
    }
    enable() {
      if (this._enabled) {
        return;
      }
      this._enabled = true;
      if (this._hooks.length > 0) {
        for (const module2 of this._modules) {
          if (typeof module2.patch === "function" && module2.moduleExports) {
            this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled", {
              module: module2.name,
              version: module2.moduleVersion
            });
            module2.patch(module2.moduleExports, module2.moduleVersion);
          }
          for (const file of module2.files) {
            if (file.moduleExports) {
              this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled", {
                module: module2.name,
                version: module2.moduleVersion,
                fileName: file.name
              });
              file.patch(file.moduleExports, module2.moduleVersion);
            }
          }
        }
        return;
      }
      this._warnOnPreloadedModules();
      for (const module2 of this._modules) {
        const hookFn = (exports2, name, baseDir) => {
          if (!baseDir && path8.isAbsolute(name)) {
            const parsedPath = path8.parse(name);
            name = parsedPath.name;
            baseDir = parsedPath.dir;
          }
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const onRequire = (exports2, name, baseDir) => {
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const hook = path8.isAbsolute(module2.name) ? new require_in_the_middle_1.Hook([module2.name], { internals: true }, onRequire) : this._requireInTheMiddleSingleton.register(module2.name, onRequire);
        this._hooks.push(hook);
        const esmHook = new import_in_the_middle_1.Hook([module2.name], { internals: false }, hookFn);
        this._hooks.push(esmHook);
      }
    }
    disable() {
      if (!this._enabled) {
        return;
      }
      this._enabled = false;
      for (const module2 of this._modules) {
        if (typeof module2.unpatch === "function" && module2.moduleExports) {
          this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled", {
            module: module2.name,
            version: module2.moduleVersion
          });
          module2.unpatch(module2.moduleExports, module2.moduleVersion);
        }
        for (const file of module2.files) {
          if (file.moduleExports) {
            this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled", {
              module: module2.name,
              version: module2.moduleVersion,
              fileName: file.name
            });
            file.unpatch(file.moduleExports, module2.moduleVersion);
          }
        }
      }
    }
    isEnabled() {
      return this._enabled;
    }
  }
  exports.InstrumentationBase = InstrumentationBase6;
  function isSupported(supportedVersions, version, includePrerelease) {
    if (typeof version === "undefined") {
      return supportedVersions.includes("*");
    }
    return supportedVersions.some((supportedVersion) => {
      return (0, semver_1.satisfies)(version, supportedVersion, { includePrerelease });
    });
  }
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/platform/node/normalize.js
var require_normalize2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = undefined;
  var path_1 = __require("path");
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return path_1.normalize;
  } });
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/platform/node/index.js
var require_node10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var instrumentation_1 = require_instrumentation15();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return instrumentation_1.InstrumentationBase;
  } });
  var normalize_1 = require_normalize2();
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return normalize_1.normalize;
  } });
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/platform/index.js
var require_platform9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var node_1 = require_node10();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return node_1.InstrumentationBase;
  } });
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return node_1.normalize;
  } });
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleDefinition.js
var require_instrumentationNodeModuleDefinition2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleDefinition = undefined;

  class InstrumentationNodeModuleDefinition4 {
    constructor(name, supportedVersions, patch, unpatch, files) {
      this.name = name;
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.files = files || [];
    }
  }
  exports.InstrumentationNodeModuleDefinition = InstrumentationNodeModuleDefinition4;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleFile.js
var require_instrumentationNodeModuleFile2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleFile = undefined;
  var index_1 = require_platform9();

  class InstrumentationNodeModuleFile2 {
    constructor(name, supportedVersions, patch, unpatch) {
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.name = (0, index_1.normalize)(name);
    }
  }
  exports.InstrumentationNodeModuleFile = InstrumentationNodeModuleFile2;
});

// ../../node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/src/index.js
var require_src26 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = exports.isWrapped = exports.InstrumentationNodeModuleFile = exports.InstrumentationNodeModuleDefinition = exports.InstrumentationBase = exports.registerInstrumentations = undefined;
  var autoLoader_1 = require_autoLoader2();
  Object.defineProperty(exports, "registerInstrumentations", { enumerable: true, get: function() {
    return autoLoader_1.registerInstrumentations;
  } });
  var index_1 = require_platform9();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return index_1.InstrumentationBase;
  } });
  var instrumentationNodeModuleDefinition_1 = require_instrumentationNodeModuleDefinition2();
  Object.defineProperty(exports, "InstrumentationNodeModuleDefinition", { enumerable: true, get: function() {
    return instrumentationNodeModuleDefinition_1.InstrumentationNodeModuleDefinition;
  } });
  var instrumentationNodeModuleFile_1 = require_instrumentationNodeModuleFile2();
  Object.defineProperty(exports, "InstrumentationNodeModuleFile", { enumerable: true, get: function() {
    return instrumentationNodeModuleFile_1.InstrumentationNodeModuleFile;
  } });
  var utils_1 = require_utils18();
  Object.defineProperty(exports, "isWrapped", { enumerable: true, get: function() {
    return utils_1.isWrapped;
  } });
  Object.defineProperty(exports, "safeExecuteInTheMiddle", { enumerable: true, get: function() {
    return utils_1.safeExecuteInTheMiddle;
  } });
  Object.defineProperty(exports, "safeExecuteInTheMiddleAsync", { enumerable: true, get: function() {
    return utils_1.safeExecuteInTheMiddleAsync;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/version.js
var require_version16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.51.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-hapi";
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/internal-types.js
var require_internal_types7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HapiLifecycleMethodNames = exports.HapiLayerType = exports.handlerPatched = exports.HapiComponentName = undefined;
  exports.HapiComponentName = "@hapi/hapi";
  exports.handlerPatched = Symbol("hapi-handler-patched");
  exports.HapiLayerType = {
    ROUTER: "router",
    PLUGIN: "plugin",
    EXT: "server.ext"
  };
  exports.HapiLifecycleMethodNames = new Set([
    "onPreAuth",
    "onCredentials",
    "onPostAuth",
    "onPreHandler",
    "onPostHandler",
    "onPreResponse",
    "onRequest"
  ]);
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/semconv.js
var require_semconv6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ATTR_HTTP_METHOD = undefined;
  exports.ATTR_HTTP_METHOD = "http.method";
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/enums/AttributeNames.js
var require_AttributeNames6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames2;
  (function(AttributeNames3) {
    AttributeNames3["HAPI_TYPE"] = "hapi.type";
    AttributeNames3["PLUGIN_NAME"] = "hapi.plugin.name";
    AttributeNames3["EXT_TYPE"] = "server.ext.type";
  })(AttributeNames2 = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/utils.js
var require_utils19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getPluginFromInput = exports.getExtMetadata = exports.getRouteMetadata = exports.isPatchableExtMethod = exports.isDirectExtInput = exports.isLifecycleExtEventObj = exports.isLifecycleExtType = exports.getPluginName = undefined;
  var semantic_conventions_1 = require_src2();
  var semconv_1 = require_semconv6();
  var internal_types_1 = require_internal_types7();
  var AttributeNames_1 = require_AttributeNames6();
  var instrumentation_1 = require_src6();
  function getPluginName(plugin) {
    if (plugin.name) {
      return plugin.name;
    } else {
      return plugin.pkg.name;
    }
  }
  exports.getPluginName = getPluginName;
  var isLifecycleExtType = (variableToCheck) => {
    return typeof variableToCheck === "string" && internal_types_1.HapiLifecycleMethodNames.has(variableToCheck);
  };
  exports.isLifecycleExtType = isLifecycleExtType;
  var isLifecycleExtEventObj = (variableToCheck) => {
    const event = variableToCheck?.type;
    return event !== undefined && (0, exports.isLifecycleExtType)(event);
  };
  exports.isLifecycleExtEventObj = isLifecycleExtEventObj;
  var isDirectExtInput = (variableToCheck) => {
    return Array.isArray(variableToCheck) && variableToCheck.length <= 3 && (0, exports.isLifecycleExtType)(variableToCheck[0]) && typeof variableToCheck[1] === "function";
  };
  exports.isDirectExtInput = isDirectExtInput;
  var isPatchableExtMethod = (variableToCheck) => {
    return !Array.isArray(variableToCheck);
  };
  exports.isPatchableExtMethod = isPatchableExtMethod;
  var getRouteMetadata = (route, semconvStability, pluginName) => {
    const attributes = {
      [semantic_conventions_1.ATTR_HTTP_ROUTE]: route.path
    };
    if (semconvStability & instrumentation_1.SemconvStability.OLD) {
      attributes[semconv_1.ATTR_HTTP_METHOD] = route.method;
    }
    if (semconvStability & instrumentation_1.SemconvStability.STABLE) {
      attributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD] = route.method;
    }
    let name;
    if (pluginName) {
      attributes[AttributeNames_1.AttributeNames.HAPI_TYPE] = internal_types_1.HapiLayerType.PLUGIN;
      attributes[AttributeNames_1.AttributeNames.PLUGIN_NAME] = pluginName;
      name = `${pluginName}: route - ${route.path}`;
    } else {
      attributes[AttributeNames_1.AttributeNames.HAPI_TYPE] = internal_types_1.HapiLayerType.ROUTER;
      name = `route - ${route.path}`;
    }
    return { attributes, name };
  };
  exports.getRouteMetadata = getRouteMetadata;
  var getExtMetadata = (extPoint, pluginName) => {
    if (pluginName) {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.EXT_TYPE]: extPoint,
          [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.EXT,
          [AttributeNames_1.AttributeNames.PLUGIN_NAME]: pluginName
        },
        name: `${pluginName}: ext - ${extPoint}`
      };
    }
    return {
      attributes: {
        [AttributeNames_1.AttributeNames.EXT_TYPE]: extPoint,
        [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.EXT
      },
      name: `ext - ${extPoint}`
    };
  };
  exports.getExtMetadata = getExtMetadata;
  var getPluginFromInput = (pluginObj) => {
    if ("plugin" in pluginObj) {
      if ("plugin" in pluginObj.plugin) {
        return pluginObj.plugin.plugin;
      }
      return pluginObj.plugin;
    }
    return pluginObj;
  };
  exports.getPluginFromInput = getPluginFromInput;
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/instrumentation.js
var require_instrumentation16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HapiInstrumentation = undefined;
  var api2 = require_src();
  var core_1 = require_src3();
  var instrumentation_1 = require_src6();
  var version_1 = require_version16();
  var internal_types_1 = require_internal_types7();
  var utils_1 = require_utils19();

  class HapiInstrumentation extends instrumentation_1.InstrumentationBase {
    _semconvStability;
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      this._semconvStability = (0, instrumentation_1.semconvStabilityFromStr)("http", process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
    }
    init() {
      return new instrumentation_1.InstrumentationNodeModuleDefinition(internal_types_1.HapiComponentName, [">=17.0.0 <22"], (module2) => {
        const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
        if (!(0, instrumentation_1.isWrapped)(moduleExports.server)) {
          this._wrap(moduleExports, "server", this._getServerPatch.bind(this));
        }
        if (!(0, instrumentation_1.isWrapped)(moduleExports.Server)) {
          this._wrap(moduleExports, "Server", this._getServerPatch.bind(this));
        }
        return moduleExports;
      }, (module2) => {
        const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
        this._massUnwrap([moduleExports], ["server", "Server"]);
      });
    }
    _getServerPatch(original) {
      const instrumentation = this;
      const self = this;
      return function server(opts) {
        const newServer = original.apply(this, [opts]);
        self._wrap(newServer, "route", (originalRouter) => {
          return instrumentation._getServerRoutePatch.bind(instrumentation)(originalRouter);
        });
        self._wrap(newServer, "ext", (originalExtHandler) => {
          return instrumentation._getServerExtPatch.bind(instrumentation)(originalExtHandler);
        });
        self._wrap(newServer, "register", instrumentation._getServerRegisterPatch.bind(instrumentation));
        return newServer;
      };
    }
    _getServerRegisterPatch(original) {
      const instrumentation = this;
      return function register(pluginInput, options) {
        if (Array.isArray(pluginInput)) {
          for (const pluginObj of pluginInput) {
            const plugin = (0, utils_1.getPluginFromInput)(pluginObj);
            instrumentation._wrapRegisterHandler(plugin);
          }
        } else {
          const plugin = (0, utils_1.getPluginFromInput)(pluginInput);
          instrumentation._wrapRegisterHandler(plugin);
        }
        return original.apply(this, [pluginInput, options]);
      };
    }
    _getServerExtPatch(original, pluginName) {
      const instrumentation = this;
      return function ext(...args) {
        if (Array.isArray(args[0])) {
          const eventsList = args[0];
          for (let i = 0;i < eventsList.length; i++) {
            const eventObj = eventsList[i];
            if ((0, utils_1.isLifecycleExtType)(eventObj.type)) {
              const lifecycleEventObj = eventObj;
              const handler = instrumentation._wrapExtMethods(lifecycleEventObj.method, eventObj.type, pluginName);
              lifecycleEventObj.method = handler;
              eventsList[i] = lifecycleEventObj;
            }
          }
          return original.apply(this, args);
        } else if ((0, utils_1.isDirectExtInput)(args)) {
          const extInput = args;
          const method = extInput[1];
          const handler = instrumentation._wrapExtMethods(method, extInput[0], pluginName);
          return original.apply(this, [extInput[0], handler, extInput[2]]);
        } else if ((0, utils_1.isLifecycleExtEventObj)(args[0])) {
          const lifecycleEventObj = args[0];
          const handler = instrumentation._wrapExtMethods(lifecycleEventObj.method, lifecycleEventObj.type, pluginName);
          lifecycleEventObj.method = handler;
          return original.call(this, lifecycleEventObj);
        }
        return original.apply(this, args);
      };
    }
    _getServerRoutePatch(original, pluginName) {
      const instrumentation = this;
      return function route(route) {
        if (Array.isArray(route)) {
          for (let i = 0;i < route.length; i++) {
            const newRoute = instrumentation._wrapRouteHandler.call(instrumentation, route[i], pluginName);
            route[i] = newRoute;
          }
        } else {
          route = instrumentation._wrapRouteHandler.call(instrumentation, route, pluginName);
        }
        return original.apply(this, [route]);
      };
    }
    _wrapRegisterHandler(plugin) {
      const instrumentation = this;
      const pluginName = (0, utils_1.getPluginName)(plugin);
      const oldRegister = plugin.register;
      const self = this;
      const newRegisterHandler = function(server, options) {
        self._wrap(server, "route", (original) => {
          return instrumentation._getServerRoutePatch.bind(instrumentation)(original, pluginName);
        });
        self._wrap(server, "ext", (originalExtHandler) => {
          return instrumentation._getServerExtPatch.bind(instrumentation)(originalExtHandler, pluginName);
        });
        return oldRegister.call(this, server, options);
      };
      plugin.register = newRegisterHandler;
    }
    _wrapExtMethods(method, extPoint, pluginName) {
      const instrumentation = this;
      if (method instanceof Array) {
        for (let i = 0;i < method.length; i++) {
          method[i] = instrumentation._wrapExtMethods(method[i], extPoint);
        }
        return method;
      } else if ((0, utils_1.isPatchableExtMethod)(method)) {
        if (method[internal_types_1.handlerPatched] === true)
          return method;
        method[internal_types_1.handlerPatched] = true;
        const newHandler = async function(...params) {
          if (api2.trace.getSpan(api2.context.active()) === undefined) {
            return await method.apply(this, params);
          }
          const metadata = (0, utils_1.getExtMetadata)(extPoint, pluginName);
          const span = instrumentation.tracer.startSpan(metadata.name, {
            attributes: metadata.attributes
          });
          try {
            return await api2.context.with(api2.trace.setSpan(api2.context.active(), span), method, undefined, ...params);
          } catch (err) {
            span.recordException(err);
            span.setStatus({
              code: api2.SpanStatusCode.ERROR,
              message: err.message
            });
            throw err;
          } finally {
            span.end();
          }
        };
        return newHandler;
      }
      return method;
    }
    _wrapRouteHandler(route, pluginName) {
      const instrumentation = this;
      if (route[internal_types_1.handlerPatched] === true)
        return route;
      route[internal_types_1.handlerPatched] = true;
      const wrapHandler = (oldHandler) => {
        return async function(...params) {
          if (api2.trace.getSpan(api2.context.active()) === undefined) {
            return await oldHandler.call(this, ...params);
          }
          const rpcMetadata = (0, core_1.getRPCMetadata)(api2.context.active());
          if (rpcMetadata?.type === core_1.RPCType.HTTP) {
            rpcMetadata.route = route.path;
          }
          const metadata = (0, utils_1.getRouteMetadata)(route, instrumentation._semconvStability, pluginName);
          const span = instrumentation.tracer.startSpan(metadata.name, {
            attributes: metadata.attributes
          });
          try {
            return await api2.context.with(api2.trace.setSpan(api2.context.active(), span), () => oldHandler.call(this, ...params));
          } catch (err) {
            span.recordException(err);
            span.setStatus({
              code: api2.SpanStatusCode.ERROR,
              message: err.message
            });
            throw err;
          } finally {
            span.end();
          }
        };
      };
      if (typeof route.handler === "function") {
        route.handler = wrapHandler(route.handler);
      } else if (typeof route.options === "function") {
        const oldOptions = route.options;
        route.options = function(server) {
          const options = oldOptions(server);
          if (typeof options.handler === "function") {
            options.handler = wrapHandler(options.handler);
          }
          return options;
        };
      } else if (typeof route.options?.handler === "function") {
        route.options.handler = wrapHandler(route.options.handler);
      }
      return route;
    }
  }
  exports.HapiInstrumentation = HapiInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/index.js
var require_src27 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = exports.HapiInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation16();
  Object.defineProperty(exports, "HapiInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.HapiInstrumentation;
  } });
  var AttributeNames_1 = require_AttributeNames6();
  Object.defineProperty(exports, "AttributeNames", { enumerable: true, get: function() {
    return AttributeNames_1.AttributeNames;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/types.js
var require_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KoaLayerType = undefined;
  var KoaLayerType;
  (function(KoaLayerType2) {
    KoaLayerType2["ROUTER"] = "router";
    KoaLayerType2["MIDDLEWARE"] = "middleware";
  })(KoaLayerType = exports.KoaLayerType || (exports.KoaLayerType = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/version.js
var require_version17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.52.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-koa";
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/enums/AttributeNames.js
var require_AttributeNames7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeNames = undefined;
  var AttributeNames2;
  (function(AttributeNames3) {
    AttributeNames3["KOA_TYPE"] = "koa.type";
    AttributeNames3["KOA_NAME"] = "koa.name";
  })(AttributeNames2 = exports.AttributeNames || (exports.AttributeNames = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/utils.js
var require_utils20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLayerIgnored = exports.getMiddlewareMetadata = undefined;
  var types_1 = require_types3();
  var AttributeNames_1 = require_AttributeNames7();
  var semantic_conventions_1 = require_src2();
  var getMiddlewareMetadata = (context10, layer, isRouter, layerPath) => {
    if (isRouter) {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.KOA_NAME]: layerPath?.toString(),
          [AttributeNames_1.AttributeNames.KOA_TYPE]: types_1.KoaLayerType.ROUTER,
          [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: layerPath?.toString()
        },
        name: context10._matchedRouteName || `router - ${layerPath}`
      };
    } else {
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.KOA_NAME]: layer.name ?? "middleware",
          [AttributeNames_1.AttributeNames.KOA_TYPE]: types_1.KoaLayerType.MIDDLEWARE
        },
        name: `middleware - ${layer.name}`
      };
    }
  };
  exports.getMiddlewareMetadata = getMiddlewareMetadata;
  var isLayerIgnored = (type, config) => {
    return !!(Array.isArray(config?.ignoreLayersType) && config?.ignoreLayersType?.includes(type));
  };
  exports.isLayerIgnored = isLayerIgnored;
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/internal-types.js
var require_internal_types8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kLayerPatched = undefined;
  exports.kLayerPatched = Symbol("koa-layer-patched");
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/instrumentation.js
var require_instrumentation17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KoaInstrumentation = undefined;
  var api2 = require_src();
  var instrumentation_1 = require_src6();
  var types_1 = require_types3();
  var version_1 = require_version17();
  var utils_1 = require_utils20();
  var core_1 = require_src3();
  var internal_types_1 = require_internal_types8();

  class KoaInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return new instrumentation_1.InstrumentationNodeModuleDefinition("koa", [">=2.0.0 <3"], (module2) => {
        const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
        if (moduleExports == null) {
          return moduleExports;
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.use)) {
          this._unwrap(moduleExports.prototype, "use");
        }
        this._wrap(moduleExports.prototype, "use", this._getKoaUsePatch.bind(this));
        return module2;
      }, (module2) => {
        const moduleExports = module2[Symbol.toStringTag] === "Module" ? module2.default : module2;
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.use)) {
          this._unwrap(moduleExports.prototype, "use");
        }
      });
    }
    _getKoaUsePatch(original) {
      const plugin = this;
      return function use(middlewareFunction) {
        let patchedFunction;
        if (middlewareFunction.router) {
          patchedFunction = plugin._patchRouterDispatch(middlewareFunction);
        } else {
          patchedFunction = plugin._patchLayer(middlewareFunction, false);
        }
        return original.apply(this, [patchedFunction]);
      };
    }
    _patchRouterDispatch(dispatchLayer) {
      api2.diag.debug("Patching @koa/router dispatch");
      const router = dispatchLayer.router;
      const routesStack = router?.stack ?? [];
      for (const pathLayer of routesStack) {
        const path8 = pathLayer.path;
        const pathStack = pathLayer.stack;
        for (let j = 0;j < pathStack.length; j++) {
          const routedMiddleware = pathStack[j];
          pathStack[j] = this._patchLayer(routedMiddleware, true, path8);
        }
      }
      return dispatchLayer;
    }
    _patchLayer(middlewareLayer, isRouter, layerPath) {
      const layerType = isRouter ? types_1.KoaLayerType.ROUTER : types_1.KoaLayerType.MIDDLEWARE;
      if (middlewareLayer[internal_types_1.kLayerPatched] === true || (0, utils_1.isLayerIgnored)(layerType, this.getConfig()))
        return middlewareLayer;
      if (middlewareLayer.constructor.name === "GeneratorFunction" || middlewareLayer.constructor.name === "AsyncGeneratorFunction") {
        api2.diag.debug("ignoring generator-based Koa middleware layer");
        return middlewareLayer;
      }
      middlewareLayer[internal_types_1.kLayerPatched] = true;
      api2.diag.debug("patching Koa middleware layer");
      return async (context10, next) => {
        const parent = api2.trace.getSpan(api2.context.active());
        if (parent === undefined) {
          return middlewareLayer(context10, next);
        }
        const metadata = (0, utils_1.getMiddlewareMetadata)(context10, middlewareLayer, isRouter, layerPath);
        const span = this.tracer.startSpan(metadata.name, {
          attributes: metadata.attributes
        });
        const rpcMetadata = (0, core_1.getRPCMetadata)(api2.context.active());
        if (rpcMetadata?.type === core_1.RPCType.HTTP && context10._matchedRoute) {
          rpcMetadata.route = context10._matchedRoute.toString();
        }
        const { requestHook: requestHook2 } = this.getConfig();
        if (requestHook2) {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => requestHook2(span, {
            context: context10,
            middlewareLayer,
            layerType
          }), (e) => {
            if (e) {
              api2.diag.error("koa instrumentation: request hook failed", e);
            }
          }, true);
        }
        const newContext = api2.trace.setSpan(api2.context.active(), span);
        return api2.context.with(newContext, async () => {
          try {
            return await middlewareLayer(context10, next);
          } catch (err) {
            span.recordException(err);
            throw err;
          } finally {
            span.end();
          }
        });
      };
    }
  }
  exports.KoaInstrumentation = KoaInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/index.js
var require_src28 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KoaLayerType = exports.AttributeNames = exports.KoaInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation17();
  Object.defineProperty(exports, "KoaInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.KoaInstrumentation;
  } });
  var AttributeNames_1 = require_AttributeNames7();
  Object.defineProperty(exports, "AttributeNames", { enumerable: true, get: function() {
    return AttributeNames_1.AttributeNames;
  } });
  var types_1 = require_types3();
  Object.defineProperty(exports, "KoaLayerType", { enumerable: true, get: function() {
    return types_1.KoaLayerType;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/enums/AttributeNames.js
var require_AttributeNames8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectNames = exports.ConnectTypes = exports.AttributeNames = undefined;
  var AttributeNames2;
  (function(AttributeNames3) {
    AttributeNames3["CONNECT_TYPE"] = "connect.type";
    AttributeNames3["CONNECT_NAME"] = "connect.name";
  })(AttributeNames2 = exports.AttributeNames || (exports.AttributeNames = {}));
  var ConnectTypes;
  (function(ConnectTypes2) {
    ConnectTypes2["MIDDLEWARE"] = "middleware";
    ConnectTypes2["REQUEST_HANDLER"] = "request_handler";
  })(ConnectTypes = exports.ConnectTypes || (exports.ConnectTypes = {}));
  var ConnectNames;
  (function(ConnectNames2) {
    ConnectNames2["MIDDLEWARE"] = "middleware";
    ConnectNames2["REQUEST_HANDLER"] = "request handler";
  })(ConnectNames = exports.ConnectNames || (exports.ConnectNames = {}));
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/version.js
var require_version18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.48.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-connect";
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/internal-types.js
var require_internal_types9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._LAYERS_STORE_PROPERTY = undefined;
  exports._LAYERS_STORE_PROPERTY = Symbol("opentelemetry.instrumentation-connect.request-route-stack");
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/utils.js
var require_utils21 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateRoute = exports.replaceCurrentStackRoute = exports.addNewStackLayer = undefined;
  var api_1 = require_src();
  var internal_types_1 = require_internal_types9();
  var addNewStackLayer = (request2) => {
    if (Array.isArray(request2[internal_types_1._LAYERS_STORE_PROPERTY]) === false) {
      Object.defineProperty(request2, internal_types_1._LAYERS_STORE_PROPERTY, {
        enumerable: false,
        value: []
      });
    }
    request2[internal_types_1._LAYERS_STORE_PROPERTY].push("/");
    const stackLength = request2[internal_types_1._LAYERS_STORE_PROPERTY].length;
    return () => {
      if (stackLength === request2[internal_types_1._LAYERS_STORE_PROPERTY].length) {
        request2[internal_types_1._LAYERS_STORE_PROPERTY].pop();
      } else {
        api_1.diag.warn("Connect: Trying to pop the stack multiple time");
      }
    };
  };
  exports.addNewStackLayer = addNewStackLayer;
  var replaceCurrentStackRoute = (request2, newRoute) => {
    if (newRoute) {
      request2[internal_types_1._LAYERS_STORE_PROPERTY].splice(-1, 1, newRoute);
    }
  };
  exports.replaceCurrentStackRoute = replaceCurrentStackRoute;
  var generateRoute = (request2) => {
    return request2[internal_types_1._LAYERS_STORE_PROPERTY].reduce((acc, sub) => acc.replace(/\/+$/, "") + sub);
  };
  exports.generateRoute = generateRoute;
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/instrumentation.js
var require_instrumentation18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectInstrumentation = exports.ANONYMOUS_NAME = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var AttributeNames_1 = require_AttributeNames8();
  var version_1 = require_version18();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var utils_1 = require_utils21();
  exports.ANONYMOUS_NAME = "anonymous";

  class ConnectInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition("connect", [">=3.0.0 <4"], (moduleExports) => {
          return this._patchConstructor(moduleExports);
        })
      ];
    }
    _patchApp(patchedApp) {
      if (!(0, instrumentation_1.isWrapped)(patchedApp.use)) {
        this._wrap(patchedApp, "use", this._patchUse.bind(this));
      }
      if (!(0, instrumentation_1.isWrapped)(patchedApp.handle)) {
        this._wrap(patchedApp, "handle", this._patchHandle.bind(this));
      }
    }
    _patchConstructor(original) {
      const instrumentation = this;
      return function(...args) {
        const app = original.apply(this, args);
        instrumentation._patchApp(app);
        return app;
      };
    }
    _patchNext(next, finishSpan) {
      return function nextFunction(err) {
        const result = next.apply(this, [err]);
        finishSpan();
        return result;
      };
    }
    _startSpan(routeName, middleWare) {
      let connectType;
      let connectName;
      let connectTypeName;
      if (routeName) {
        connectType = AttributeNames_1.ConnectTypes.REQUEST_HANDLER;
        connectTypeName = AttributeNames_1.ConnectNames.REQUEST_HANDLER;
        connectName = routeName;
      } else {
        connectType = AttributeNames_1.ConnectTypes.MIDDLEWARE;
        connectTypeName = AttributeNames_1.ConnectNames.MIDDLEWARE;
        connectName = middleWare.name || exports.ANONYMOUS_NAME;
      }
      const spanName = `${connectTypeName} - ${connectName}`;
      const options = {
        attributes: {
          [semantic_conventions_1.ATTR_HTTP_ROUTE]: routeName.length > 0 ? routeName : "/",
          [AttributeNames_1.AttributeNames.CONNECT_TYPE]: connectType,
          [AttributeNames_1.AttributeNames.CONNECT_NAME]: connectName
        }
      };
      return this.tracer.startSpan(spanName, options);
    }
    _patchMiddleware(routeName, middleWare) {
      const instrumentation = this;
      const isErrorMiddleware = middleWare.length === 4;
      function patchedMiddleware() {
        if (!instrumentation.isEnabled()) {
          return middleWare.apply(this, arguments);
        }
        const [reqArgIdx, resArgIdx, nextArgIdx] = isErrorMiddleware ? [1, 2, 3] : [0, 1, 2];
        const req = arguments[reqArgIdx];
        const res = arguments[resArgIdx];
        const next = arguments[nextArgIdx];
        (0, utils_1.replaceCurrentStackRoute)(req, routeName);
        const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
        if (routeName && rpcMetadata?.type === core_1.RPCType.HTTP) {
          rpcMetadata.route = (0, utils_1.generateRoute)(req);
        }
        let spanName = "";
        if (routeName) {
          spanName = `request handler - ${routeName}`;
        } else {
          spanName = `middleware - ${middleWare.name || exports.ANONYMOUS_NAME}`;
        }
        const span = instrumentation._startSpan(routeName, middleWare);
        instrumentation._diag.debug("start span", spanName);
        let spanFinished = false;
        function finishSpan() {
          if (!spanFinished) {
            spanFinished = true;
            instrumentation._diag.debug(`finishing span ${span.name}`);
            span.end();
          } else {
            instrumentation._diag.debug(`span ${span.name} - already finished`);
          }
          res.removeListener("close", finishSpan);
        }
        res.addListener("close", finishSpan);
        arguments[nextArgIdx] = instrumentation._patchNext(next, finishSpan);
        return middleWare.apply(this, arguments);
      }
      Object.defineProperty(patchedMiddleware, "length", {
        value: middleWare.length,
        writable: false,
        configurable: true
      });
      return patchedMiddleware;
    }
    _patchUse(original) {
      const instrumentation = this;
      return function(...args) {
        const middleWare = args[args.length - 1];
        const routeName = args[args.length - 2] || "";
        args[args.length - 1] = instrumentation._patchMiddleware(routeName, middleWare);
        return original.apply(this, args);
      };
    }
    _patchHandle(original) {
      const instrumentation = this;
      return function() {
        const [reqIdx, outIdx] = [0, 2];
        const req = arguments[reqIdx];
        const out = arguments[outIdx];
        const completeStack = (0, utils_1.addNewStackLayer)(req);
        if (typeof out === "function") {
          arguments[outIdx] = instrumentation._patchOut(out, completeStack);
        }
        return original.apply(this, arguments);
      };
    }
    _patchOut(out, completeStack) {
      return function nextFunction(...args) {
        completeStack();
        return Reflect.apply(out, this, args);
      };
    }
  }
  exports.ConnectInstrumentation = ConnectInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/index.js
var require_src29 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectTypes = exports.ConnectNames = exports.AttributeNames = exports.ANONYMOUS_NAME = exports.ConnectInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation18();
  Object.defineProperty(exports, "ConnectInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.ConnectInstrumentation;
  } });
  Object.defineProperty(exports, "ANONYMOUS_NAME", { enumerable: true, get: function() {
    return instrumentation_1.ANONYMOUS_NAME;
  } });
  var AttributeNames_1 = require_AttributeNames8();
  Object.defineProperty(exports, "AttributeNames", { enumerable: true, get: function() {
    return AttributeNames_1.AttributeNames;
  } });
  Object.defineProperty(exports, "ConnectNames", { enumerable: true, get: function() {
    return AttributeNames_1.ConnectNames;
  } });
  Object.defineProperty(exports, "ConnectTypes", { enumerable: true, get: function() {
    return AttributeNames_1.ConnectTypes;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-tedious/build/src/utils.js
var require_utils22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.once = exports.getSpanName = undefined;
  function getSpanName(operation, db, sql, bulkLoadTable) {
    if (operation === "execBulkLoad" && bulkLoadTable && db) {
      return `${operation} ${bulkLoadTable} ${db}`;
    }
    if (operation === "callProcedure") {
      if (db) {
        return `${operation} ${sql} ${db}`;
      }
      return `${operation} ${sql}`;
    }
    if (db) {
      return `${operation} ${db}`;
    }
    return `${operation}`;
  }
  exports.getSpanName = getSpanName;
  var once = (fn) => {
    let called = false;
    return (...args) => {
      if (called)
        return;
      called = true;
      return fn(...args);
    };
  };
  exports.once = once;
});

// ../../node_modules/@opentelemetry/instrumentation-tedious/build/src/version.js
var require_version19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.23.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-tedious";
});

// ../../node_modules/@opentelemetry/instrumentation-tedious/build/src/instrumentation.js
var require_instrumentation19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TediousInstrumentation = undefined;
  var api2 = require_src();
  var events_1 = __require("events");
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var utils_1 = require_utils22();
  var version_1 = require_version19();
  var CURRENT_DATABASE = Symbol("opentelemetry.instrumentation-tedious.current-database");
  var PATCHED_METHODS = [
    "callProcedure",
    "execSql",
    "execSqlBatch",
    "execBulkLoad",
    "prepare",
    "execute"
  ];
  function setDatabase(databaseName) {
    Object.defineProperty(this, CURRENT_DATABASE, {
      value: databaseName,
      writable: true
    });
  }

  class TediousInstrumentation extends instrumentation_1.InstrumentationBase {
    static COMPONENT = "tedious";
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition(TediousInstrumentation.COMPONENT, [">=1.11.0 <20"], (moduleExports) => {
          const ConnectionPrototype = moduleExports.Connection.prototype;
          for (const method of PATCHED_METHODS) {
            if ((0, instrumentation_1.isWrapped)(ConnectionPrototype[method])) {
              this._unwrap(ConnectionPrototype, method);
            }
            this._wrap(ConnectionPrototype, method, this._patchQuery(method));
          }
          if ((0, instrumentation_1.isWrapped)(ConnectionPrototype.connect)) {
            this._unwrap(ConnectionPrototype, "connect");
          }
          this._wrap(ConnectionPrototype, "connect", this._patchConnect);
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === undefined)
            return;
          const ConnectionPrototype = moduleExports.Connection.prototype;
          for (const method of PATCHED_METHODS) {
            this._unwrap(ConnectionPrototype, method);
          }
          this._unwrap(ConnectionPrototype, "connect");
        })
      ];
    }
    _patchConnect(original) {
      return function patchedConnect() {
        setDatabase.call(this, this.config?.options?.database);
        this.removeListener("databaseChange", setDatabase);
        this.on("databaseChange", setDatabase);
        this.once("end", () => {
          this.removeListener("databaseChange", setDatabase);
        });
        return original.apply(this, arguments);
      };
    }
    _patchQuery(operation) {
      return (originalMethod) => {
        const thisPlugin = this;
        function patchedMethod(request2) {
          if (!(request2 instanceof events_1.EventEmitter)) {
            thisPlugin._diag.warn(`Unexpected invocation of patched ${operation} method. Span not recorded`);
            return originalMethod.apply(this, arguments);
          }
          let procCount = 0;
          let statementCount = 0;
          const incrementStatementCount = () => statementCount++;
          const incrementProcCount = () => procCount++;
          const databaseName = this[CURRENT_DATABASE];
          const sql = ((request3) => {
            if (request3.sqlTextOrProcedure === "sp_prepare" && request3.parametersByName?.stmt?.value) {
              return request3.parametersByName.stmt.value;
            }
            return request3.sqlTextOrProcedure;
          })(request2);
          const span = thisPlugin.tracer.startSpan((0, utils_1.getSpanName)(operation, databaseName, sql, request2.table), {
            kind: api2.SpanKind.CLIENT,
            attributes: {
              [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MSSQL,
              [semantic_conventions_1.SEMATTRS_DB_NAME]: databaseName,
              [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: this.config?.options?.port,
              [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: this.config?.server,
              [semantic_conventions_1.SEMATTRS_DB_USER]: this.config?.userName ?? this.config?.authentication?.options?.userName,
              [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: sql,
              [semantic_conventions_1.SEMATTRS_DB_SQL_TABLE]: request2.table
            }
          });
          const endSpan3 = (0, utils_1.once)((err) => {
            request2.removeListener("done", incrementStatementCount);
            request2.removeListener("doneInProc", incrementStatementCount);
            request2.removeListener("doneProc", incrementProcCount);
            request2.removeListener("error", endSpan3);
            this.removeListener("end", endSpan3);
            span.setAttribute("tedious.procedure_count", procCount);
            span.setAttribute("tedious.statement_count", statementCount);
            if (err) {
              span.setStatus({
                code: api2.SpanStatusCode.ERROR,
                message: err.message
              });
            }
            span.end();
          });
          request2.on("done", incrementStatementCount);
          request2.on("doneInProc", incrementStatementCount);
          request2.on("doneProc", incrementProcCount);
          request2.once("error", endSpan3);
          this.on("end", endSpan3);
          if (typeof request2.callback === "function") {
            thisPlugin._wrap(request2, "callback", thisPlugin._patchCallbackQuery(endSpan3));
          } else {
            thisPlugin._diag.error("Expected request.callback to be a function");
          }
          return api2.context.with(api2.trace.setSpan(api2.context.active(), span), originalMethod, this, ...arguments);
        }
        Object.defineProperty(patchedMethod, "length", {
          value: originalMethod.length,
          writable: false
        });
        return patchedMethod;
      };
    }
    _patchCallbackQuery(endSpan3) {
      return (originalCallback) => {
        return function(err, rowCount, rows) {
          endSpan3(err);
          return originalCallback.apply(this, arguments);
        };
      };
    }
  }
  exports.TediousInstrumentation = TediousInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-tedious/build/src/index.js
var require_src30 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TediousInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation19();
  Object.defineProperty(exports, "TediousInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.TediousInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-generic-pool/build/src/version.js
var require_version20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.48.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-generic-pool";
});

// ../../node_modules/@opentelemetry/instrumentation-generic-pool/build/src/instrumentation.js
var require_instrumentation20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GenericPoolInstrumentation = undefined;
  var api2 = require_src();
  var instrumentation_1 = require_src6();
  var version_1 = require_version20();
  var MODULE_NAME2 = "generic-pool";

  class GenericPoolInstrumentation extends instrumentation_1.InstrumentationBase {
    _isDisabled = false;
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
    }
    init() {
      return [
        new instrumentation_1.InstrumentationNodeModuleDefinition(MODULE_NAME2, [">=3.0.0 <4"], (moduleExports) => {
          const Pool = moduleExports.Pool;
          if ((0, instrumentation_1.isWrapped)(Pool.prototype.acquire)) {
            this._unwrap(Pool.prototype, "acquire");
          }
          this._wrap(Pool.prototype, "acquire", this._acquirePatcher.bind(this));
          return moduleExports;
        }, (moduleExports) => {
          const Pool = moduleExports.Pool;
          this._unwrap(Pool.prototype, "acquire");
          return moduleExports;
        }),
        new instrumentation_1.InstrumentationNodeModuleDefinition(MODULE_NAME2, [">=2.4.0 <3"], (moduleExports) => {
          const Pool = moduleExports.Pool;
          if ((0, instrumentation_1.isWrapped)(Pool.prototype.acquire)) {
            this._unwrap(Pool.prototype, "acquire");
          }
          this._wrap(Pool.prototype, "acquire", this._acquireWithCallbacksPatcher.bind(this));
          return moduleExports;
        }, (moduleExports) => {
          const Pool = moduleExports.Pool;
          this._unwrap(Pool.prototype, "acquire");
          return moduleExports;
        }),
        new instrumentation_1.InstrumentationNodeModuleDefinition(MODULE_NAME2, [">=2.0.0 <2.4"], (moduleExports) => {
          this._isDisabled = false;
          if ((0, instrumentation_1.isWrapped)(moduleExports.Pool)) {
            this._unwrap(moduleExports, "Pool");
          }
          this._wrap(moduleExports, "Pool", this._poolWrapper.bind(this));
          return moduleExports;
        }, (moduleExports) => {
          this._isDisabled = true;
          return moduleExports;
        })
      ];
    }
    _acquirePatcher(original) {
      const instrumentation = this;
      return function wrapped_acquire(...args) {
        const parent = api2.context.active();
        const span = instrumentation.tracer.startSpan("generic-pool.acquire", {}, parent);
        return api2.context.with(api2.trace.setSpan(parent, span), () => {
          return original.call(this, ...args).then((value) => {
            span.end();
            return value;
          }, (err) => {
            span.recordException(err);
            span.end();
            throw err;
          });
        });
      };
    }
    _poolWrapper(original) {
      const instrumentation = this;
      return function wrapped_pool() {
        const pool = original.apply(this, arguments);
        instrumentation._wrap(pool, "acquire", instrumentation._acquireWithCallbacksPatcher.bind(instrumentation));
        return pool;
      };
    }
    _acquireWithCallbacksPatcher(original) {
      const instrumentation = this;
      return function wrapped_acquire(cb, priority) {
        if (instrumentation._isDisabled) {
          return original.call(this, cb, priority);
        }
        const parent = api2.context.active();
        const span = instrumentation.tracer.startSpan("generic-pool.acquire", {}, parent);
        return api2.context.with(api2.trace.setSpan(parent, span), () => {
          original.call(this, (err, client) => {
            span.end();
            if (cb) {
              return cb(err, client);
            }
          }, priority);
        });
      };
    }
  }
  exports.GenericPoolInstrumentation = GenericPoolInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-generic-pool/build/src/index.js
var require_src31 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GenericPoolInstrumentation = undefined;
  var instrumentation_1 = require_instrumentation20();
  Object.defineProperty(exports, "GenericPoolInstrumentation", { enumerable: true, get: function() {
    return instrumentation_1.GenericPoolInstrumentation;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js
var require_types4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_CONFIG = exports.EndOperation = undefined;
  var EndOperation;
  (function(EndOperation2) {
    EndOperation2["AutoAck"] = "auto ack";
    EndOperation2["Ack"] = "ack";
    EndOperation2["AckAll"] = "ackAll";
    EndOperation2["Reject"] = "reject";
    EndOperation2["Nack"] = "nack";
    EndOperation2["NackAll"] = "nackAll";
    EndOperation2["ChannelClosed"] = "channel closed";
    EndOperation2["ChannelError"] = "channel error";
    EndOperation2["InstrumentationTimeout"] = "instrumentation timeout";
  })(EndOperation = exports.EndOperation || (exports.EndOperation = {}));
  exports.DEFAULT_CONFIG = {
    consumeTimeoutMs: 1000 * 60,
    useLinksForConsume: false
  };
});

// ../../node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js
var require_utils23 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isConfirmChannelTracing = exports.unmarkConfirmChannelTracing = exports.markConfirmChannelTracing = exports.getConnectionAttributesFromUrl = exports.getConnectionAttributesFromServer = exports.normalizeExchange = exports.CONNECTION_ATTRIBUTES = exports.CHANNEL_CONSUME_TIMEOUT_TIMER = exports.CHANNEL_SPANS_NOT_ENDED = exports.MESSAGE_STORED_SPAN = undefined;
  var api_1 = require_src();
  var semantic_conventions_1 = require_src2();
  exports.MESSAGE_STORED_SPAN = Symbol("opentelemetry.amqplib.message.stored-span");
  exports.CHANNEL_SPANS_NOT_ENDED = Symbol("opentelemetry.amqplib.channel.spans-not-ended");
  exports.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol("opentelemetry.amqplib.channel.consumer-timeout-timer");
  exports.CONNECTION_ATTRIBUTES = Symbol("opentelemetry.amqplib.connection.attributes");
  var IS_CONFIRM_CHANNEL_CONTEXT_KEY = (0, api_1.createContextKey)("opentelemetry.amqplib.channel.is-confirm-channel");
  var normalizeExchange = (exchangeName) => exchangeName !== "" ? exchangeName : "<default>";
  exports.normalizeExchange = normalizeExchange;
  var censorPassword = (url) => {
    return url.replace(/:[^:@/]*@/, ":***@");
  };
  var getPort = (portFromUrl, resolvedProtocol) => {
    return portFromUrl || (resolvedProtocol === "AMQP" ? 5672 : 5671);
  };
  var getProtocol = (protocolFromUrl) => {
    const resolvedProtocol = protocolFromUrl || "amqp";
    const noEndingColon = resolvedProtocol.endsWith(":") ? resolvedProtocol.substring(0, resolvedProtocol.length - 1) : resolvedProtocol;
    return noEndingColon.toUpperCase();
  };
  var getHostname = (hostnameFromUrl) => {
    return hostnameFromUrl || "localhost";
  };
  var extractConnectionAttributeOrLog = (url, attributeKey, attributeValue, nameForLog) => {
    if (attributeValue) {
      return { [attributeKey]: attributeValue };
    } else {
      api_1.diag.error(`amqplib instrumentation: could not extract connection attribute ${nameForLog} from user supplied url`, {
        url
      });
      return {};
    }
  };
  var getConnectionAttributesFromServer = (conn) => {
    const product = conn.serverProperties.product?.toLowerCase?.();
    if (product) {
      return {
        [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: product
      };
    } else {
      return {};
    }
  };
  exports.getConnectionAttributesFromServer = getConnectionAttributesFromServer;
  var getConnectionAttributesFromUrl = (url) => {
    const attributes = {
      [semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL_VERSION]: "0.9.1"
    };
    url = url || "amqp://localhost";
    if (typeof url === "object") {
      const connectOptions = url;
      const protocol = getProtocol(connectOptions?.protocol);
      Object.assign(attributes, {
        ...extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, "protocol")
      });
      const hostname2 = getHostname(connectOptions?.hostname);
      Object.assign(attributes, {
        ...extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname2, "hostname")
      });
      const port = getPort(connectOptions.port, protocol);
      Object.assign(attributes, {
        ...extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, "port")
      });
    } else {
      const censoredUrl = censorPassword(url);
      attributes[semantic_conventions_1.SEMATTRS_MESSAGING_URL] = censoredUrl;
      try {
        const urlParts = new URL(censoredUrl);
        const protocol = getProtocol(urlParts.protocol);
        Object.assign(attributes, {
          ...extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, "protocol")
        });
        const hostname2 = getHostname(urlParts.hostname);
        Object.assign(attributes, {
          ...extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname2, "hostname")
        });
        const port = getPort(urlParts.port ? parseInt(urlParts.port) : undefined, protocol);
        Object.assign(attributes, {
          ...extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, "port")
        });
      } catch (err) {
        api_1.diag.error("amqplib instrumentation: error while extracting connection details from connection url", {
          censoredUrl,
          err
        });
      }
    }
    return attributes;
  };
  exports.getConnectionAttributesFromUrl = getConnectionAttributesFromUrl;
  var markConfirmChannelTracing = (context10) => {
    return context10.setValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY, true);
  };
  exports.markConfirmChannelTracing = markConfirmChannelTracing;
  var unmarkConfirmChannelTracing = (context10) => {
    return context10.deleteValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY);
  };
  exports.unmarkConfirmChannelTracing = unmarkConfirmChannelTracing;
  var isConfirmChannelTracing = (context10) => {
    return context10.getValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY) === true;
  };
  exports.isConfirmChannelTracing = isConfirmChannelTracing;
});

// ../../node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js
var require_version21 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PACKAGE_NAME = exports.PACKAGE_VERSION = undefined;
  exports.PACKAGE_VERSION = "0.51.0";
  exports.PACKAGE_NAME = "@opentelemetry/instrumentation-amqplib";
});

// ../../node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js
var require_amqplib = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AmqplibInstrumentation = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var instrumentation_1 = require_src6();
  var semantic_conventions_1 = require_src2();
  var types_1 = require_types4();
  var utils_1 = require_utils23();
  var version_1 = require_version21();
  var supportedVersions = [">=0.5.5 <1"];

  class AmqplibInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
      super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, { ...types_1.DEFAULT_CONFIG, ...config });
    }
    setConfig(config = {}) {
      super.setConfig({ ...types_1.DEFAULT_CONFIG, ...config });
    }
    init() {
      const channelModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile("amqplib/lib/channel_model.js", supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));
      const callbackModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile("amqplib/lib/callback_model.js", supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));
      const connectModuleFile = new instrumentation_1.InstrumentationNodeModuleFile("amqplib/lib/connect.js", supportedVersions, this.patchConnect.bind(this), this.unpatchConnect.bind(this));
      const module2 = new instrumentation_1.InstrumentationNodeModuleDefinition("amqplib", supportedVersions, undefined, undefined, [channelModelModuleFile, connectModuleFile, callbackModelModuleFile]);
      return module2;
    }
    patchConnect(moduleExports) {
      moduleExports = this.unpatchConnect(moduleExports);
      if (!(0, instrumentation_1.isWrapped)(moduleExports.connect)) {
        this._wrap(moduleExports, "connect", this.getConnectPatch.bind(this));
      }
      return moduleExports;
    }
    unpatchConnect(moduleExports) {
      if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {
        this._unwrap(moduleExports, "connect");
      }
      return moduleExports;
    }
    patchChannelModel(moduleExports, moduleVersion) {
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {
        this._wrap(moduleExports.Channel.prototype, "publish", this.getPublishPatch.bind(this, moduleVersion));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {
        this._wrap(moduleExports.Channel.prototype, "consume", this.getConsumePatch.bind(this, moduleVersion));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {
        this._wrap(moduleExports.Channel.prototype, "ack", this.getAckPatch.bind(this, false, types_1.EndOperation.Ack));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {
        this._wrap(moduleExports.Channel.prototype, "nack", this.getAckPatch.bind(this, true, types_1.EndOperation.Nack));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {
        this._wrap(moduleExports.Channel.prototype, "reject", this.getAckPatch.bind(this, true, types_1.EndOperation.Reject));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {
        this._wrap(moduleExports.Channel.prototype, "ackAll", this.getAckAllPatch.bind(this, false, types_1.EndOperation.AckAll));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {
        this._wrap(moduleExports.Channel.prototype, "nackAll", this.getAckAllPatch.bind(this, true, types_1.EndOperation.NackAll));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {
        this._wrap(moduleExports.Channel.prototype, "emit", this.getChannelEmitPatch.bind(this));
      }
      if (!(0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {
        this._wrap(moduleExports.ConfirmChannel.prototype, "publish", this.getConfirmedPublishPatch.bind(this, moduleVersion));
      }
      return moduleExports;
    }
    unpatchChannelModel(moduleExports) {
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {
        this._unwrap(moduleExports.Channel.prototype, "publish");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {
        this._unwrap(moduleExports.Channel.prototype, "consume");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {
        this._unwrap(moduleExports.Channel.prototype, "ack");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {
        this._unwrap(moduleExports.Channel.prototype, "nack");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {
        this._unwrap(moduleExports.Channel.prototype, "reject");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {
        this._unwrap(moduleExports.Channel.prototype, "ackAll");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {
        this._unwrap(moduleExports.Channel.prototype, "nackAll");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {
        this._unwrap(moduleExports.Channel.prototype, "emit");
      }
      if ((0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {
        this._unwrap(moduleExports.ConfirmChannel.prototype, "publish");
      }
      return moduleExports;
    }
    getConnectPatch(original) {
      return function patchedConnect(url, socketOptions, openCallback) {
        return original.call(this, url, socketOptions, function(err, conn) {
          if (err == null) {
            const urlAttributes = (0, utils_1.getConnectionAttributesFromUrl)(url);
            const serverAttributes = (0, utils_1.getConnectionAttributesFromServer)(conn);
            conn[utils_1.CONNECTION_ATTRIBUTES] = {
              ...urlAttributes,
              ...serverAttributes
            };
          }
          openCallback.apply(this, arguments);
        });
      };
    }
    getChannelEmitPatch(original) {
      const self = this;
      return function emit(eventName) {
        if (eventName === "close") {
          self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelClosed, undefined);
          const activeTimer = this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER];
          if (activeTimer) {
            clearInterval(activeTimer);
          }
          this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = undefined;
        } else if (eventName === "error") {
          self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelError, undefined);
        }
        return original.apply(this, arguments);
      };
    }
    getAckAllPatch(isRejected, endOperation, original) {
      const self = this;
      return function ackAll(requeueOrEmpty) {
        self.endAllSpansOnChannel(this, isRejected, endOperation, requeueOrEmpty);
        return original.apply(this, arguments);
      };
    }
    getAckPatch(isRejected, endOperation, original) {
      const self = this;
      return function ack(message, allUpToOrRequeue, requeue) {
        const channel3 = this;
        const requeueResolved = endOperation === types_1.EndOperation.Reject ? allUpToOrRequeue : requeue;
        const spansNotEnded = channel3[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];
        const msgIndex = spansNotEnded.findIndex((msgDetails) => msgDetails.msg === message);
        if (msgIndex < 0) {
          self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);
        } else if (endOperation !== types_1.EndOperation.Reject && allUpToOrRequeue) {
          for (let i = 0;i <= msgIndex; i++) {
            self.endConsumerSpan(spansNotEnded[i].msg, isRejected, endOperation, requeueResolved);
          }
          spansNotEnded.splice(0, msgIndex + 1);
        } else {
          self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);
          spansNotEnded.splice(msgIndex, 1);
        }
        return original.apply(this, arguments);
      };
    }
    getConsumePatch(moduleVersion, original) {
      const self = this;
      return function consume(queue, onMessage, options) {
        const channel3 = this;
        if (!Object.prototype.hasOwnProperty.call(channel3, utils_1.CHANNEL_SPANS_NOT_ENDED)) {
          const { consumeTimeoutMs } = self.getConfig();
          if (consumeTimeoutMs) {
            const timer = setInterval(() => {
              self.checkConsumeTimeoutOnChannel(channel3);
            }, consumeTimeoutMs);
            timer.unref();
            channel3[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = timer;
          }
          channel3[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];
        }
        const patchedOnMessage = function(msg) {
          if (!msg) {
            return onMessage.call(this, msg);
          }
          const headers = msg.properties.headers ?? {};
          let parentContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);
          const exchange = msg.fields?.exchange;
          let links;
          if (self._config.useLinksForConsume) {
            const parentSpanContext = parentContext ? api_1.trace.getSpan(parentContext)?.spanContext() : undefined;
            parentContext = undefined;
            if (parentSpanContext) {
              links = [
                {
                  context: parentSpanContext
                }
              ];
            }
          }
          const span = self.tracer.startSpan(`${queue} process`, {
            kind: api_1.SpanKind.CONSUMER,
            attributes: {
              ...channel3?.connection?.[utils_1.CONNECTION_ATTRIBUTES],
              [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange,
              [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC,
              [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: msg.fields?.routingKey,
              [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS,
              [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: msg?.properties.messageId,
              [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: msg?.properties.correlationId
            },
            links
          }, parentContext);
          const { consumeHook } = self.getConfig();
          if (consumeHook) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeHook(span, { moduleVersion, msg }), (e) => {
              if (e) {
                api_1.diag.error("amqplib instrumentation: consumerHook error", e);
              }
            }, true);
          }
          if (!options?.noAck) {
            channel3[utils_1.CHANNEL_SPANS_NOT_ENDED].push({
              msg,
              timeOfConsume: (0, core_1.hrTime)()
            });
            msg[utils_1.MESSAGE_STORED_SPAN] = span;
          }
          const setContext2 = parentContext ? parentContext : api_1.ROOT_CONTEXT;
          api_1.context.with(api_1.trace.setSpan(setContext2, span), () => {
            onMessage.call(this, msg);
          });
          if (options?.noAck) {
            self.callConsumeEndHook(span, msg, false, types_1.EndOperation.AutoAck);
            span.end();
          }
        };
        arguments[1] = patchedOnMessage;
        return original.apply(this, arguments);
      };
    }
    getConfirmedPublishPatch(moduleVersion, original) {
      const self = this;
      return function confirmedPublish(exchange, routingKey, content, options, callback) {
        const channel3 = this;
        const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel3, options);
        const { publishHook } = self.getConfig();
        if (publishHook) {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {
            moduleVersion,
            exchange,
            routingKey,
            content,
            options: modifiedOptions,
            isConfirmChannel: true
          }), (e) => {
            if (e) {
              api_1.diag.error("amqplib instrumentation: publishHook error", e);
            }
          }, true);
        }
        const patchedOnConfirm = function(err, ok) {
          try {
            callback?.call(this, err, ok);
          } finally {
            const { publishConfirmHook } = self.getConfig();
            if (publishConfirmHook) {
              (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishConfirmHook(span, {
                moduleVersion,
                exchange,
                routingKey,
                content,
                options,
                isConfirmChannel: true,
                confirmError: err
              }), (e) => {
                if (e) {
                  api_1.diag.error("amqplib instrumentation: publishConfirmHook error", e);
                }
              }, true);
            }
            if (err) {
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: "message confirmation has been nack'ed"
              });
            }
            span.end();
          }
        };
        const markedContext = (0, utils_1.markConfirmChannelTracing)(api_1.context.active());
        const argumentsCopy = [...arguments];
        argumentsCopy[3] = modifiedOptions;
        argumentsCopy[4] = api_1.context.bind((0, utils_1.unmarkConfirmChannelTracing)(api_1.trace.setSpan(markedContext, span)), patchedOnConfirm);
        return api_1.context.with(markedContext, original.bind(this, ...argumentsCopy));
      };
    }
    getPublishPatch(moduleVersion, original) {
      const self = this;
      return function publish(exchange, routingKey, content, options) {
        if ((0, utils_1.isConfirmChannelTracing)(api_1.context.active())) {
          return original.apply(this, arguments);
        } else {
          const channel3 = this;
          const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel3, options);
          const { publishHook } = self.getConfig();
          if (publishHook) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {
              moduleVersion,
              exchange,
              routingKey,
              content,
              options: modifiedOptions,
              isConfirmChannel: false
            }), (e) => {
              if (e) {
                api_1.diag.error("amqplib instrumentation: publishHook error", e);
              }
            }, true);
          }
          const argumentsCopy = [...arguments];
          argumentsCopy[3] = modifiedOptions;
          const originalRes = original.apply(this, argumentsCopy);
          span.end();
          return originalRes;
        }
      };
    }
    createPublishSpan(self, exchange, routingKey, channel3, options) {
      const normalizedExchange = (0, utils_1.normalizeExchange)(exchange);
      const span = self.tracer.startSpan(`publish ${normalizedExchange}`, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
          ...channel3.connection[utils_1.CONNECTION_ATTRIBUTES],
          [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange,
          [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC,
          [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: routingKey,
          [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: options?.messageId,
          [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: options?.correlationId
        }
      });
      const modifiedOptions = options ?? {};
      modifiedOptions.headers = modifiedOptions.headers ?? {};
      api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), modifiedOptions.headers);
      return { span, modifiedOptions };
    }
    endConsumerSpan(message, isRejected, operation, requeue) {
      const storedSpan = message[utils_1.MESSAGE_STORED_SPAN];
      if (!storedSpan)
        return;
      if (isRejected !== false) {
        storedSpan.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: operation !== types_1.EndOperation.ChannelClosed && operation !== types_1.EndOperation.ChannelError ? `${operation} called on message${requeue === true ? " with requeue" : requeue === false ? " without requeue" : ""}` : operation
        });
      }
      this.callConsumeEndHook(storedSpan, message, isRejected, operation);
      storedSpan.end();
      message[utils_1.MESSAGE_STORED_SPAN] = undefined;
    }
    endAllSpansOnChannel(channel3, isRejected, operation, requeue) {
      const spansNotEnded = channel3[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];
      spansNotEnded.forEach((msgDetails) => {
        this.endConsumerSpan(msgDetails.msg, isRejected, operation, requeue);
      });
      channel3[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];
    }
    callConsumeEndHook(span, msg, rejected, endOperation) {
      const { consumeEndHook } = this.getConfig();
      if (!consumeEndHook)
        return;
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeEndHook(span, { msg, rejected, endOperation }), (e) => {
        if (e) {
          api_1.diag.error("amqplib instrumentation: consumerEndHook error", e);
        }
      }, true);
    }
    checkConsumeTimeoutOnChannel(channel3) {
      const currentTime = (0, core_1.hrTime)();
      const spansNotEnded = channel3[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];
      let i;
      const { consumeTimeoutMs } = this.getConfig();
      for (i = 0;i < spansNotEnded.length; i++) {
        const currMessage = spansNotEnded[i];
        const timeFromConsume = (0, core_1.hrTimeDuration)(currMessage.timeOfConsume, currentTime);
        if ((0, core_1.hrTimeToMilliseconds)(timeFromConsume) < consumeTimeoutMs) {
          break;
        }
        this.endConsumerSpan(currMessage.msg, null, types_1.EndOperation.InstrumentationTimeout, true);
      }
      spansNotEnded.splice(0, i);
    }
  }
  exports.AmqplibInstrumentation = AmqplibInstrumentation;
});

// ../../node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js
var require_src32 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndOperation = exports.DEFAULT_CONFIG = exports.AmqplibInstrumentation = undefined;
  var amqplib_1 = require_amqplib();
  Object.defineProperty(exports, "AmqplibInstrumentation", { enumerable: true, get: function() {
    return amqplib_1.AmqplibInstrumentation;
  } });
  var types_1 = require_types4();
  Object.defineProperty(exports, "DEFAULT_CONFIG", { enumerable: true, get: function() {
    return types_1.DEFAULT_CONFIG;
  } });
  Object.defineProperty(exports, "EndOperation", { enumerable: true, get: function() {
    return types_1.EndOperation;
  } });
});

// src/index.ts
import {
  logger as logger30,
  parseBooleanFromText,
  getDatabaseDir,
  getGeneratedDir as getGeneratedDir2,
  getUploadsAgentsDir as getUploadsAgentsDir4
} from "@elizaos/core";
import cors2 from "cors";
import express33 from "express";

// ../../node_modules/helmet/index.mjs
var dangerouslyDisableDefaultSrc = Symbol("dangerouslyDisableDefaultSrc");
var SHOULD_BE_QUOTED = new Set(["none", "self", "strict-dynamic", "report-sample", "inline-speculation-rules", "unsafe-inline", "unsafe-eval", "unsafe-hashes", "wasm-unsafe-eval"]);
var getDefaultDirectives = () => ({
  "default-src": ["'self'"],
  "base-uri": ["'self'"],
  "font-src": ["'self'", "https:", "data:"],
  "form-action": ["'self'"],
  "frame-ancestors": ["'self'"],
  "img-src": ["'self'", "data:"],
  "object-src": ["'none'"],
  "script-src": ["'self'"],
  "script-src-attr": ["'none'"],
  "style-src": ["'self'", "https:", "'unsafe-inline'"],
  "upgrade-insecure-requests": []
});
var dashify = (str) => str.replace(/[A-Z]/g, (capitalLetter) => "-" + capitalLetter.toLowerCase());
var assertDirectiveValueIsValid = (directiveName, directiveValue) => {
  if (/;|,/.test(directiveValue)) {
    throw new Error(`Content-Security-Policy received an invalid directive value for ${JSON.stringify(directiveName)}`);
  }
};
var assertDirectiveValueEntryIsValid = (directiveName, directiveValueEntry) => {
  if (SHOULD_BE_QUOTED.has(directiveValueEntry) || directiveValueEntry.startsWith("nonce-") || directiveValueEntry.startsWith("sha256-") || directiveValueEntry.startsWith("sha384-") || directiveValueEntry.startsWith("sha512-")) {
    throw new Error(`Content-Security-Policy received an invalid directive value for ${JSON.stringify(directiveName)}. ${JSON.stringify(directiveValueEntry)} should be quoted`);
  }
};
function normalizeDirectives(options) {
  const defaultDirectives = getDefaultDirectives();
  const { useDefaults = true, directives: rawDirectives = defaultDirectives } = options;
  const result = new Map;
  const directiveNamesSeen = new Set;
  const directivesExplicitlyDisabled = new Set;
  for (const rawDirectiveName in rawDirectives) {
    if (!Object.hasOwn(rawDirectives, rawDirectiveName)) {
      continue;
    }
    if (rawDirectiveName.length === 0 || /[^a-zA-Z0-9-]/.test(rawDirectiveName)) {
      throw new Error(`Content-Security-Policy received an invalid directive name ${JSON.stringify(rawDirectiveName)}`);
    }
    const directiveName = dashify(rawDirectiveName);
    if (directiveNamesSeen.has(directiveName)) {
      throw new Error(`Content-Security-Policy received a duplicate directive ${JSON.stringify(directiveName)}`);
    }
    directiveNamesSeen.add(directiveName);
    const rawDirectiveValue = rawDirectives[rawDirectiveName];
    let directiveValue;
    if (rawDirectiveValue === null) {
      if (directiveName === "default-src") {
        throw new Error("Content-Security-Policy needs a default-src but it was set to `null`. If you really want to disable it, set it to `contentSecurityPolicy.dangerouslyDisableDefaultSrc`.");
      }
      directivesExplicitlyDisabled.add(directiveName);
      continue;
    } else if (typeof rawDirectiveValue === "string") {
      directiveValue = [rawDirectiveValue];
    } else if (!rawDirectiveValue) {
      throw new Error(`Content-Security-Policy received an invalid directive value for ${JSON.stringify(directiveName)}`);
    } else if (rawDirectiveValue === dangerouslyDisableDefaultSrc) {
      if (directiveName === "default-src") {
        directivesExplicitlyDisabled.add("default-src");
        continue;
      } else {
        throw new Error(`Content-Security-Policy: tried to disable ${JSON.stringify(directiveName)} as if it were default-src; simply omit the key`);
      }
    } else {
      directiveValue = rawDirectiveValue;
    }
    for (const element of directiveValue) {
      if (typeof element !== "string")
        continue;
      assertDirectiveValueIsValid(directiveName, element);
      assertDirectiveValueEntryIsValid(directiveName, element);
    }
    result.set(directiveName, directiveValue);
  }
  if (useDefaults) {
    Object.entries(defaultDirectives).forEach(([defaultDirectiveName, defaultDirectiveValue]) => {
      if (!result.has(defaultDirectiveName) && !directivesExplicitlyDisabled.has(defaultDirectiveName)) {
        result.set(defaultDirectiveName, defaultDirectiveValue);
      }
    });
  }
  if (!result.size) {
    throw new Error("Content-Security-Policy has no directives. Either set some or disable the header");
  }
  if (!result.has("default-src") && !directivesExplicitlyDisabled.has("default-src")) {
    throw new Error("Content-Security-Policy needs a default-src but none was provided. If you really want to disable it, set it to `contentSecurityPolicy.dangerouslyDisableDefaultSrc`.");
  }
  return result;
}
function getHeaderValue(req, res, normalizedDirectives) {
  const result = [];
  for (const [directiveName, rawDirectiveValue] of normalizedDirectives) {
    let directiveValue = "";
    for (const element of rawDirectiveValue) {
      if (typeof element === "function") {
        const newElement = element(req, res);
        assertDirectiveValueEntryIsValid(directiveName, newElement);
        directiveValue += " " + newElement;
      } else {
        directiveValue += " " + element;
      }
    }
    if (directiveValue) {
      assertDirectiveValueIsValid(directiveName, directiveValue);
      result.push(`${directiveName}${directiveValue}`);
    } else {
      result.push(directiveName);
    }
  }
  return result.join(";");
}
var contentSecurityPolicy = function contentSecurityPolicy2(options = {}) {
  const headerName = options.reportOnly ? "Content-Security-Policy-Report-Only" : "Content-Security-Policy";
  const normalizedDirectives = normalizeDirectives(options);
  return function contentSecurityPolicyMiddleware(req, res, next) {
    const result = getHeaderValue(req, res, normalizedDirectives);
    if (result instanceof Error) {
      next(result);
    } else {
      res.setHeader(headerName, result);
      next();
    }
  };
};
contentSecurityPolicy.getDefaultDirectives = getDefaultDirectives;
contentSecurityPolicy.dangerouslyDisableDefaultSrc = dangerouslyDisableDefaultSrc;
var ALLOWED_POLICIES$2 = new Set(["require-corp", "credentialless", "unsafe-none"]);
function getHeaderValueFromOptions$6({ policy = "require-corp" }) {
  if (ALLOWED_POLICIES$2.has(policy)) {
    return policy;
  } else {
    throw new Error(`Cross-Origin-Embedder-Policy does not support the ${JSON.stringify(policy)} policy`);
  }
}
function crossOriginEmbedderPolicy(options = {}) {
  const headerValue = getHeaderValueFromOptions$6(options);
  return function crossOriginEmbedderPolicyMiddleware(_req, res, next) {
    res.setHeader("Cross-Origin-Embedder-Policy", headerValue);
    next();
  };
}
var ALLOWED_POLICIES$1 = new Set(["same-origin", "same-origin-allow-popups", "unsafe-none"]);
function getHeaderValueFromOptions$5({ policy = "same-origin" }) {
  if (ALLOWED_POLICIES$1.has(policy)) {
    return policy;
  } else {
    throw new Error(`Cross-Origin-Opener-Policy does not support the ${JSON.stringify(policy)} policy`);
  }
}
function crossOriginOpenerPolicy(options = {}) {
  const headerValue = getHeaderValueFromOptions$5(options);
  return function crossOriginOpenerPolicyMiddleware(_req, res, next) {
    res.setHeader("Cross-Origin-Opener-Policy", headerValue);
    next();
  };
}
var ALLOWED_POLICIES = new Set(["same-origin", "same-site", "cross-origin"]);
function getHeaderValueFromOptions$4({ policy = "same-origin" }) {
  if (ALLOWED_POLICIES.has(policy)) {
    return policy;
  } else {
    throw new Error(`Cross-Origin-Resource-Policy does not support the ${JSON.stringify(policy)} policy`);
  }
}
function crossOriginResourcePolicy(options = {}) {
  const headerValue = getHeaderValueFromOptions$4(options);
  return function crossOriginResourcePolicyMiddleware(_req, res, next) {
    res.setHeader("Cross-Origin-Resource-Policy", headerValue);
    next();
  };
}
function originAgentCluster() {
  return function originAgentClusterMiddleware(_req, res, next) {
    res.setHeader("Origin-Agent-Cluster", "?1");
    next();
  };
}
var ALLOWED_TOKENS = new Set(["no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url", ""]);
function getHeaderValueFromOptions$3({ policy = ["no-referrer"] }) {
  const tokens = typeof policy === "string" ? [policy] : policy;
  if (tokens.length === 0) {
    throw new Error("Referrer-Policy received no policy tokens");
  }
  const tokensSeen = new Set;
  tokens.forEach((token) => {
    if (!ALLOWED_TOKENS.has(token)) {
      throw new Error(`Referrer-Policy received an unexpected policy token ${JSON.stringify(token)}`);
    } else if (tokensSeen.has(token)) {
      throw new Error(`Referrer-Policy received a duplicate policy token ${JSON.stringify(token)}`);
    }
    tokensSeen.add(token);
  });
  return tokens.join(",");
}
function referrerPolicy(options = {}) {
  const headerValue = getHeaderValueFromOptions$3(options);
  return function referrerPolicyMiddleware(_req, res, next) {
    res.setHeader("Referrer-Policy", headerValue);
    next();
  };
}
var DEFAULT_MAX_AGE = 365 * 24 * 60 * 60;
function parseMaxAge(value = DEFAULT_MAX_AGE) {
  if (value >= 0 && Number.isFinite(value)) {
    return Math.floor(value);
  } else {
    throw new Error(`Strict-Transport-Security: ${JSON.stringify(value)} is not a valid value for maxAge. Please choose a positive integer.`);
  }
}
function getHeaderValueFromOptions$2(options) {
  if ("maxage" in options) {
    throw new Error("Strict-Transport-Security received an unsupported property, `maxage`. Did you mean to pass `maxAge`?");
  }
  if ("includeSubdomains" in options) {
    throw new Error('Strict-Transport-Security middleware should use `includeSubDomains` instead of `includeSubdomains`. (The correct one has an uppercase "D".)');
  }
  const directives = [`max-age=${parseMaxAge(options.maxAge)}`];
  if (options.includeSubDomains === undefined || options.includeSubDomains) {
    directives.push("includeSubDomains");
  }
  if (options.preload) {
    directives.push("preload");
  }
  return directives.join("; ");
}
function strictTransportSecurity(options = {}) {
  const headerValue = getHeaderValueFromOptions$2(options);
  return function strictTransportSecurityMiddleware(_req, res, next) {
    res.setHeader("Strict-Transport-Security", headerValue);
    next();
  };
}
function xContentTypeOptions() {
  return function xContentTypeOptionsMiddleware(_req, res, next) {
    res.setHeader("X-Content-Type-Options", "nosniff");
    next();
  };
}
function xDnsPrefetchControl(options = {}) {
  const headerValue = options.allow ? "on" : "off";
  return function xDnsPrefetchControlMiddleware(_req, res, next) {
    res.setHeader("X-DNS-Prefetch-Control", headerValue);
    next();
  };
}
function xDownloadOptions() {
  return function xDownloadOptionsMiddleware(_req, res, next) {
    res.setHeader("X-Download-Options", "noopen");
    next();
  };
}
function getHeaderValueFromOptions$1({ action = "sameorigin" }) {
  const normalizedAction = typeof action === "string" ? action.toUpperCase() : action;
  switch (normalizedAction) {
    case "SAME-ORIGIN":
      return "SAMEORIGIN";
    case "DENY":
    case "SAMEORIGIN":
      return normalizedAction;
    default:
      throw new Error(`X-Frame-Options received an invalid action ${JSON.stringify(action)}`);
  }
}
function xFrameOptions(options = {}) {
  const headerValue = getHeaderValueFromOptions$1(options);
  return function xFrameOptionsMiddleware(_req, res, next) {
    res.setHeader("X-Frame-Options", headerValue);
    next();
  };
}
var ALLOWED_PERMITTED_POLICIES = new Set(["none", "master-only", "by-content-type", "all"]);
function getHeaderValueFromOptions({ permittedPolicies = "none" }) {
  if (ALLOWED_PERMITTED_POLICIES.has(permittedPolicies)) {
    return permittedPolicies;
  } else {
    throw new Error(`X-Permitted-Cross-Domain-Policies does not support ${JSON.stringify(permittedPolicies)}`);
  }
}
function xPermittedCrossDomainPolicies(options = {}) {
  const headerValue = getHeaderValueFromOptions(options);
  return function xPermittedCrossDomainPoliciesMiddleware(_req, res, next) {
    res.setHeader("X-Permitted-Cross-Domain-Policies", headerValue);
    next();
  };
}
function xPoweredBy() {
  return function xPoweredByMiddleware(_req, res, next) {
    res.removeHeader("X-Powered-By");
    next();
  };
}
function xXssProtection() {
  return function xXssProtectionMiddleware(_req, res, next) {
    res.setHeader("X-XSS-Protection", "0");
    next();
  };
}
function getMiddlewareFunctionsFromOptions(options) {
  const result = [];
  switch (options.contentSecurityPolicy) {
    case undefined:
    case true:
      result.push(contentSecurityPolicy());
      break;
    case false:
      break;
    default:
      result.push(contentSecurityPolicy(options.contentSecurityPolicy));
      break;
  }
  switch (options.crossOriginEmbedderPolicy) {
    case undefined:
    case false:
      break;
    case true:
      result.push(crossOriginEmbedderPolicy());
      break;
    default:
      result.push(crossOriginEmbedderPolicy(options.crossOriginEmbedderPolicy));
      break;
  }
  switch (options.crossOriginOpenerPolicy) {
    case undefined:
    case true:
      result.push(crossOriginOpenerPolicy());
      break;
    case false:
      break;
    default:
      result.push(crossOriginOpenerPolicy(options.crossOriginOpenerPolicy));
      break;
  }
  switch (options.crossOriginResourcePolicy) {
    case undefined:
    case true:
      result.push(crossOriginResourcePolicy());
      break;
    case false:
      break;
    default:
      result.push(crossOriginResourcePolicy(options.crossOriginResourcePolicy));
      break;
  }
  switch (options.originAgentCluster) {
    case undefined:
    case true:
      result.push(originAgentCluster());
      break;
    case false:
      break;
    default:
      console.warn("Origin-Agent-Cluster does not take options. Remove the property to silence this warning.");
      result.push(originAgentCluster());
      break;
  }
  switch (options.referrerPolicy) {
    case undefined:
    case true:
      result.push(referrerPolicy());
      break;
    case false:
      break;
    default:
      result.push(referrerPolicy(options.referrerPolicy));
      break;
  }
  if ("strictTransportSecurity" in options && "hsts" in options) {
    throw new Error("Strict-Transport-Security option was specified twice. Remove `hsts` to silence this warning.");
  }
  const strictTransportSecurityOption = options.strictTransportSecurity ?? options.hsts;
  switch (strictTransportSecurityOption) {
    case undefined:
    case true:
      result.push(strictTransportSecurity());
      break;
    case false:
      break;
    default:
      result.push(strictTransportSecurity(strictTransportSecurityOption));
      break;
  }
  if ("xContentTypeOptions" in options && "noSniff" in options) {
    throw new Error("X-Content-Type-Options option was specified twice. Remove `noSniff` to silence this warning.");
  }
  const xContentTypeOptionsOption = options.xContentTypeOptions ?? options.noSniff;
  switch (xContentTypeOptionsOption) {
    case undefined:
    case true:
      result.push(xContentTypeOptions());
      break;
    case false:
      break;
    default:
      console.warn("X-Content-Type-Options does not take options. Remove the property to silence this warning.");
      result.push(xContentTypeOptions());
      break;
  }
  if ("xDnsPrefetchControl" in options && "dnsPrefetchControl" in options) {
    throw new Error("X-DNS-Prefetch-Control option was specified twice. Remove `dnsPrefetchControl` to silence this warning.");
  }
  const xDnsPrefetchControlOption = options.xDnsPrefetchControl ?? options.dnsPrefetchControl;
  switch (xDnsPrefetchControlOption) {
    case undefined:
    case true:
      result.push(xDnsPrefetchControl());
      break;
    case false:
      break;
    default:
      result.push(xDnsPrefetchControl(xDnsPrefetchControlOption));
      break;
  }
  if ("xDownloadOptions" in options && "ieNoOpen" in options) {
    throw new Error("X-Download-Options option was specified twice. Remove `ieNoOpen` to silence this warning.");
  }
  const xDownloadOptionsOption = options.xDownloadOptions ?? options.ieNoOpen;
  switch (xDownloadOptionsOption) {
    case undefined:
    case true:
      result.push(xDownloadOptions());
      break;
    case false:
      break;
    default:
      console.warn("X-Download-Options does not take options. Remove the property to silence this warning.");
      result.push(xDownloadOptions());
      break;
  }
  if ("xFrameOptions" in options && "frameguard" in options) {
    throw new Error("X-Frame-Options option was specified twice. Remove `frameguard` to silence this warning.");
  }
  const xFrameOptionsOption = options.xFrameOptions ?? options.frameguard;
  switch (xFrameOptionsOption) {
    case undefined:
    case true:
      result.push(xFrameOptions());
      break;
    case false:
      break;
    default:
      result.push(xFrameOptions(xFrameOptionsOption));
      break;
  }
  if ("xPermittedCrossDomainPolicies" in options && "permittedCrossDomainPolicies" in options) {
    throw new Error("X-Permitted-Cross-Domain-Policies option was specified twice. Remove `permittedCrossDomainPolicies` to silence this warning.");
  }
  const xPermittedCrossDomainPoliciesOption = options.xPermittedCrossDomainPolicies ?? options.permittedCrossDomainPolicies;
  switch (xPermittedCrossDomainPoliciesOption) {
    case undefined:
    case true:
      result.push(xPermittedCrossDomainPolicies());
      break;
    case false:
      break;
    default:
      result.push(xPermittedCrossDomainPolicies(xPermittedCrossDomainPoliciesOption));
      break;
  }
  if ("xPoweredBy" in options && "hidePoweredBy" in options) {
    throw new Error("X-Powered-By option was specified twice. Remove `hidePoweredBy` to silence this warning.");
  }
  const xPoweredByOption = options.xPoweredBy ?? options.hidePoweredBy;
  switch (xPoweredByOption) {
    case undefined:
    case true:
      result.push(xPoweredBy());
      break;
    case false:
      break;
    default:
      console.warn("X-Powered-By does not take options. Remove the property to silence this warning.");
      result.push(xPoweredBy());
      break;
  }
  if ("xXssProtection" in options && "xssFilter" in options) {
    throw new Error("X-XSS-Protection option was specified twice. Remove `xssFilter` to silence this warning.");
  }
  const xXssProtectionOption = options.xXssProtection ?? options.xssFilter;
  switch (xXssProtectionOption) {
    case undefined:
    case true:
      result.push(xXssProtection());
      break;
    case false:
      break;
    default:
      console.warn("X-XSS-Protection does not take options. Remove the property to silence this warning.");
      result.push(xXssProtection());
      break;
  }
  return result;
}
var helmet = Object.assign(function helmet2(options = {}) {
  if (options.constructor?.name === "IncomingMessage") {
    throw new Error("It appears you have done something like `app.use(helmet)`, but it should be `app.use(helmet())`.");
  }
  const middlewareFunctions = getMiddlewareFunctionsFromOptions(options);
  return function helmetMiddleware(req, res, next) {
    let middlewareIndex = 0;
    (function internalNext(err) {
      if (err) {
        next(err);
        return;
      }
      const middlewareFunction = middlewareFunctions[middlewareIndex];
      if (middlewareFunction) {
        middlewareIndex++;
        middlewareFunction(req, res, internalNext);
      } else {
        next();
      }
    })();
  };
}, {
  contentSecurityPolicy,
  crossOriginEmbedderPolicy,
  crossOriginOpenerPolicy,
  crossOriginResourcePolicy,
  originAgentCluster,
  referrerPolicy,
  strictTransportSecurity,
  xContentTypeOptions,
  xDnsPrefetchControl,
  xDownloadOptions,
  xFrameOptions,
  xPermittedCrossDomainPolicies,
  xPoweredBy,
  xXssProtection,
  dnsPrefetchControl: xDnsPrefetchControl,
  xssFilter: xXssProtection,
  permittedCrossDomainPolicies: xPermittedCrossDomainPolicies,
  ieNoOpen: xDownloadOptions,
  noSniff: xContentTypeOptions,
  frameguard: xFrameOptions,
  hidePoweredBy: xPoweredBy,
  hsts: strictTransportSecurity
});

// src/index.ts
import * as fs6 from "node:fs";
import http4 from "node:http";
import os3 from "node:os";
import path8, { basename as basename2, dirname as dirname3, extname, join as join4 } from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";

// src/api/index.ts
import { logger as logger26, validateUuid as validateUuid23 } from "@elizaos/core";
import cors from "cors";
import express32 from "express";
var import_path_to_regexp = __toESM(require_dist(), 1);
import { Server as SocketIOServer } from "socket.io";

// src/api/agents/index.ts
import express9 from "express";

// src/api/agents/crud.ts
import {
  validateUuid,
  logger,
  stringToUuid,
  getSalt,
  encryptObjectValues,
  encryptStringValue
} from "@elizaos/core";
import express from "express";

// src/api/shared/response-utils.ts
var sendError = (res, status, code, message, details) => {
  res.status(status).json({
    success: false,
    error: {
      code,
      message,
      ...details && { details }
    }
  });
};
var sendSuccess = (res, data, status = 200) => {
  res.status(status).json({
    success: true,
    data
  });
};

// src/api/agents/crud.ts
function createAgentCrudRouter(agents, serverInstance) {
  const router = express.Router();
  const db = serverInstance?.database;
  router.get("/", async (_, res) => {
    try {
      if (!db) {
        return sendError(res, 500, "DB_ERROR", "Database not available");
      }
      const allAgents = await db.getAgents();
      const runtimes = Array.from(agents.keys());
      const response = allAgents.map((agent) => ({
        id: agent.id,
        name: agent.name || "",
        characterName: agent.name || "",
        bio: agent.bio?.[0] ?? "",
        status: agent.id && runtimes.includes(agent.id) ? "active" : "inactive"
      })).filter((agent) => agent.id).sort((a, b) => {
        if (a.status === b.status) {
          return a.name.localeCompare(b.name);
        }
        return a.status === "active" ? -1 : 1;
      });
      sendSuccess(res, { agents: response });
    } catch (error) {
      logger.error("[AGENTS LIST] Error retrieving agents:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "500", "Error retrieving agents", error instanceof Error ? error.message : String(error));
    }
  });
  router.get("/:agentId", async (req, res) => {
    const agentId = validateUuid(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    try {
      const agent = await db.getAgent(agentId);
      if (!agent) {
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      const runtime = agents.get(agentId);
      const response = {
        ...agent,
        status: runtime ? "active" : "inactive"
      };
      sendSuccess(res, response);
    } catch (error) {
      logger.error("[AGENT GET] Error retrieving agent:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "500", "Error retrieving agent", error instanceof Error ? error.message : String(error));
    }
  });
  router.post("/", async (req, res) => {
    logger.debug("[AGENT CREATE] Creating new agent");
    const { characterPath, characterJson, agent } = req.body;
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    try {
      let character;
      if (characterJson) {
        logger.debug("[AGENT CREATE] Parsing character from JSON");
        character = await serverInstance?.jsonToCharacter(characterJson);
      } else if (characterPath) {
        logger.debug(`[AGENT CREATE] Loading character from path: ${characterPath}`);
        character = await serverInstance?.loadCharacterTryPath(characterPath);
      } else if (agent) {
        logger.debug("[AGENT CREATE] Parsing character from agent object");
        character = await serverInstance?.jsonToCharacter(agent);
      } else {
        throw new Error("No character configuration provided");
      }
      if (!character) {
        throw new Error("Failed to create character configuration");
      }
      if (character.settings?.secrets && typeof character.settings.secrets === "object") {
        logger.debug("[AGENT CREATE] Encrypting secrets");
        const salt = getSalt();
        character.settings.secrets = encryptObjectValues(character.settings.secrets, salt);
      }
      const ensureAgentExists = async (character2) => {
        const agentId = stringToUuid(character2.name);
        let agent2 = await db.getAgent(agentId);
        if (!agent2) {
          await db.createAgent({ ...character2, id: agentId });
          agent2 = await db.getAgent(agentId);
        }
        return agent2;
      };
      const newAgent = await ensureAgentExists(character);
      if (!newAgent) {
        throw new Error(`Failed to create agent ${character.name}`);
      }
      res.status(201).json({
        success: true,
        data: {
          id: newAgent.id,
          character
        }
      });
      logger.success(`[AGENT CREATE] Successfully created agent: ${character.name}`);
    } catch (error) {
      logger.error("[AGENT CREATE] Error creating agent:", error instanceof Error ? error.message : String(error));
      res.status(400).json({
        success: false,
        error: {
          code: "CREATE_ERROR",
          message: error instanceof Error ? error.message : "Error creating agent",
          details: error instanceof Error ? error.message : String(error)
        }
      });
    }
  });
  router.patch("/:agentId", async (req, res) => {
    const agentId = validateUuid(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    const updates = req.body;
    try {
      if (updates.settings?.secrets) {
        const salt = getSalt();
        const encryptedSecrets = {};
        Object.entries(updates.settings.secrets).forEach(([key, value]) => {
          if (value === null) {
            encryptedSecrets[key] = null;
          } else if (typeof value === "string") {
            encryptedSecrets[key] = encryptStringValue(value, salt);
          } else {
            encryptedSecrets[key] = value;
          }
        });
        updates.settings.secrets = encryptedSecrets;
      }
      if (Object.keys(updates).length > 0) {
        await db.updateAgent(agentId, updates);
      }
      const updatedAgent = await db.getAgent(agentId);
      const isActive = !!agents.get(agentId);
      if (isActive && updatedAgent) {
        serverInstance?.unregisterAgent(agentId);
        await serverInstance?.startAgent(updatedAgent);
      }
      const runtime = agents.get(agentId);
      const status = runtime ? "active" : "inactive";
      sendSuccess(res, { ...updatedAgent, status });
    } catch (error) {
      logger.error("[AGENT UPDATE] Error updating agent:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "UPDATE_ERROR", "Error updating agent", error instanceof Error ? error.message : String(error));
    }
  });
  router.delete("/:agentId", async (req, res) => {
    logger.debug(`[AGENT DELETE] Received request to delete agent with ID: ${req.params.agentId}`);
    const agentId = validateUuid(req.params.agentId);
    if (!agentId) {
      logger.error(`[AGENT DELETE] Invalid agent ID format: ${req.params.agentId}`);
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    logger.debug(`[AGENT DELETE] Validated agent ID: ${agentId}, proceeding with deletion`);
    try {
      const agent = await db.getAgent(agentId);
      if (!agent) {
        logger.warn(`[AGENT DELETE] Agent not found: ${agentId}`);
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      logger.debug(`[AGENT DELETE] Agent found: ${agent.name} (${agentId})`);
    } catch (checkError) {
      logger.error(`[AGENT DELETE] Error checking if agent exists: ${agentId}`, checkError instanceof Error ? checkError.message : String(checkError));
    }
    const timeoutId = setTimeout(() => {
      logger.warn(`[AGENT DELETE] Operation taking longer than expected for agent: ${agentId}`);
      if (!res.headersSent) {
        res.status(202).json({
          success: true,
          partial: true,
          message: "Agent deletion initiated but taking longer than expected. The operation will continue in the background."
        });
      }
    }, 1e4);
    const MAX_RETRIES = 2;
    let retryCount = 0;
    let lastError = null;
    while (retryCount <= MAX_RETRIES) {
      try {
        const runtime = agents.get(agentId);
        if (runtime) {
          logger.debug(`[AGENT DELETE] Agent ${agentId} is running, unregistering from server`);
          try {
            serverInstance?.unregisterAgent(agentId);
            logger.debug(`[AGENT DELETE] Agent ${agentId} unregistered successfully`);
          } catch (stopError) {
            logger.error(`[AGENT DELETE] Error stopping agent ${agentId}:`, stopError instanceof Error ? stopError.message : String(stopError));
          }
        } else {
          logger.debug(`[AGENT DELETE] Agent ${agentId} was not running, no need to unregister`);
        }
        logger.debug(`[AGENT DELETE] Calling database deleteAgent method for agent: ${agentId}`);
        const deleteResult = await db.deleteAgent(agentId);
        logger.debug(`[AGENT DELETE] Database deleteAgent result: ${JSON.stringify(deleteResult)}`);
        clearTimeout(timeoutId);
        logger.success(`[AGENT DELETE] Successfully deleted agent: ${agentId}`);
        if (!res.headersSent) {
          res.status(204).send();
        }
        return;
      } catch (error) {
        lastError = error;
        retryCount++;
        logger.error(`[AGENT DELETE] Error deleting agent ${agentId} (attempt ${retryCount}/${MAX_RETRIES + 1}):`, error instanceof Error ? error.message : String(error));
        if (retryCount > MAX_RETRIES) {
          break;
        }
        const delay = 1000 * Math.pow(2, retryCount - 1);
        logger.debug(`[AGENT DELETE] Waiting ${delay}ms before retry ${retryCount}`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    clearTimeout(timeoutId);
    if (!res.headersSent) {
      let statusCode = 500;
      let errorMessage = "Error deleting agent";
      if (lastError instanceof Error) {
        const message = lastError.message;
        if (message.includes("foreign key constraint")) {
          errorMessage = "Cannot delete agent because it has active references in the system";
          statusCode = 409;
        } else if (message.includes("timed out")) {
          errorMessage = "Agent deletion operation timed out";
          statusCode = 408;
        }
      }
      res.status(statusCode).json({
        success: false,
        error: {
          code: "DELETE_ERROR",
          message: errorMessage,
          details: lastError instanceof Error ? lastError.message : String(lastError)
        }
      });
    }
  });
  return router;
}

// src/api/agents/lifecycle.ts
import { validateUuid as validateUuid2, logger as logger2 } from "@elizaos/core";
import express2 from "express";
function createAgentLifecycleRouter(agents, serverInstance) {
  const router = express2.Router();
  const db = serverInstance?.database;
  router.post("/:agentId/start", async (req, res) => {
    const agentId = validateUuid2(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    try {
      const agent = await db.getAgent(agentId);
      if (!agent) {
        logger2.debug("[AGENT START] Agent not found");
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      const isActive = !!agents.get(agentId);
      if (isActive) {
        logger2.debug(`[AGENT START] Agent ${agentId} is already running`);
        return sendSuccess(res, {
          id: agentId,
          name: agent.name,
          status: "active"
        });
      }
      await serverInstance?.startAgent(agent);
      const runtime = agents.get(agentId);
      if (!runtime) {
        throw new Error("Failed to start agent");
      }
      logger2.debug(`[AGENT START] Successfully started agent: ${agent.name}`);
      sendSuccess(res, {
        id: agentId,
        name: agent.name,
        status: "active"
      });
    } catch (error) {
      logger2.error("[AGENT START] Error starting agent:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "START_ERROR", "Error starting agent", error instanceof Error ? error.message : String(error));
    }
  });
  router.post("/:agentId/stop", async (req, res) => {
    const agentId = validateUuid2(req.params.agentId);
    if (!agentId) {
      logger2.debug("[AGENT STOP] Invalid agent ID format");
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    serverInstance?.unregisterAgent(agentId);
    logger2.debug(`[AGENT STOP] Successfully stopped agent: ${runtime.character.name} (${agentId})`);
    sendSuccess(res, {
      message: "Agent stopped"
    });
  });
  return router;
}

// src/api/agents/worlds.ts
import { validateUuid as validateUuid3, logger as logger3, createUniqueUuid } from "@elizaos/core";
import express3 from "express";
function createAgentWorldsRouter(agents) {
  const router = express3.Router();
  router.get("/worlds", async (_req, res) => {
    try {
      const runtime = Array.from(agents.values())[0];
      if (!runtime) {
        return sendError(res, 404, "NOT_FOUND", "No active agents found to get worlds");
      }
      const worlds = await runtime.getAllWorlds();
      sendSuccess(res, { worlds });
    } catch (error) {
      logger3.error("[WORLDS LIST] Error retrieving worlds:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "500", "Error retrieving worlds", error instanceof Error ? error.message : String(error));
    }
  });
  const createWorldHelper = async (runtime, req, res) => {
    try {
      const { name, serverId, metadata } = req.body;
      if (!name) {
        return sendError(res, 400, "BAD_REQUEST", "World name is required");
      }
      const worldId = createUniqueUuid(runtime, `world-${Date.now()}`);
      await runtime.createWorld({
        id: worldId,
        name,
        agentId: runtime.agentId,
        serverId: serverId || `server-${Date.now()}`,
        metadata
      });
      const world = (await runtime.getAllWorlds()).find((w) => w.id === worldId);
      sendSuccess(res, { world }, 201);
    } catch (error) {
      logger3.error("[WORLD CREATE] Error creating world:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "500", "Error creating world", error instanceof Error ? error.message : String(error));
    }
  };
  router.post("/:agentId/worlds", async (req, res) => {
    const agentId = validateUuid3(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    await createWorldHelper(runtime, req, res);
  });
  router.patch("/:agentId/worlds/:worldId", async (req, res) => {
    const agentId = validateUuid3(req.params.agentId);
    const worldId = validateUuid3(req.params.worldId);
    if (!agentId || !worldId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID or world ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const world = (await runtime.getAllWorlds()).find((w) => w.id === worldId);
      if (!world) {
        return sendError(res, 404, "NOT_FOUND", "World not found");
      }
      const { name, metadata } = req.body;
      const updatedWorld = {
        ...world,
        name: name !== undefined ? name : world.name,
        metadata: metadata !== undefined ? world.metadata ? { ...world.metadata, ...metadata } : metadata : world.metadata
      };
      await runtime.updateWorld(updatedWorld);
      const refreshedWorld = (await runtime.getAllWorlds()).find((w) => w.id === worldId);
      sendSuccess(res, { world: refreshedWorld });
    } catch (error) {
      logger3.error("[WORLD UPDATE] Error updating world:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "500", "Error updating world", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/agents/panels.ts
import { validateUuid as validateUuid4, logger as logger4 } from "@elizaos/core";
import express4 from "express";
function createAgentPanelsRouter(agents) {
  const router = express4.Router();
  router.get("/:agentId/panels", async (req, res) => {
    const agentId = validateUuid4(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const publicPanels = runtime.routes.filter((route) => route.public === true && route.type === "GET" && route.name).map((route) => ({
        name: route.name,
        path: `/api/agents/${agentId}/plugins${route.path.startsWith("/") ? route.path : `/${route.path}`}?agentId=${agentId}`
      }));
      sendSuccess(res, publicPanels);
    } catch (error) {
      logger4.error(`[AGENT PANELS] Error retrieving panels for agent ${agentId}:`, error instanceof Error ? error.message : String(error));
      sendError(res, 500, "PANEL_ERROR", "Error retrieving agent panels", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/agents/logs.ts
import { validateUuid as validateUuid5, logger as logger5 } from "@elizaos/core";
import express5 from "express";
function createAgentLogsRouter(agents) {
  const router = express5.Router();
  router.get("/:agentId/logs", async (req, res) => {
    const agentId = validateUuid5(req.params.agentId);
    const { roomId, type, count, offset, excludeTypes } = req.query;
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    if (roomId) {
      const roomIdValidated = validateUuid5(roomId);
      if (!roomIdValidated) {
        return sendError(res, 400, "INVALID_ID", "Invalid room ID format");
      }
    }
    try {
      const logs = await runtime.getLogs({
        entityId: agentId,
        roomId: roomId ? roomId : undefined,
        type: type ? type : undefined,
        count: count ? Number(count) : undefined,
        offset: offset ? Number(offset) : undefined
      });
      let filteredLogs = logs;
      if (excludeTypes) {
        const excludeTypesArray = Array.isArray(excludeTypes) ? excludeTypes : [excludeTypes];
        filteredLogs = logs.filter((log) => {
          if (log.type && excludeTypesArray.includes(log.type)) {
            return false;
          }
          if (log.body && typeof log.body === "object") {
            const body = log.body;
            if (body.modelType && excludeTypesArray.some((excludeType) => body.modelType.toLowerCase().includes(excludeType.toLowerCase()))) {
              return false;
            }
          }
          return true;
        });
      }
      sendSuccess(res, filteredLogs);
    } catch (error) {
      logger5.error(`[AGENT LOGS] Error retrieving logs for agent ${agentId}:`, error instanceof Error ? error.message : String(error));
      sendError(res, 500, "LOG_ERROR", "Error retrieving agent logs", error instanceof Error ? error.message : String(error));
    }
  });
  router.delete("/:agentId/logs/:logId", async (req, res) => {
    const agentId = validateUuid5(req.params.agentId);
    const logId = validateUuid5(req.params.logId);
    if (!agentId || !logId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent or log ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      await runtime.deleteLog(logId);
      res.status(204).send();
    } catch (error) {
      logger5.error(`[LOG DELETE] Error deleting log ${logId} for agent ${agentId}:`, error instanceof Error ? error.message : String(error));
      sendError(res, 500, "DELETE_ERROR", "Failed to delete log", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/agents/runs.ts
import { validateUuid as validateUuid6 } from "@elizaos/core";
import express6 from "express";
function createAgentRunsRouter(agents) {
  const router = express6.Router();
  router.get("/:agentId/runs", async (req, res) => {
    const agentId = validateUuid6(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    const { roomId, status, limit = 20, from, to } = req.query;
    if (roomId && !validateUuid6(roomId)) {
      return sendError(res, 400, "INVALID_ID", "Invalid room ID format");
    }
    try {
      const limitNum = Math.min(Number(limit) || 20, 100);
      const fromTime = from ? Number(from) : undefined;
      const toTime = to ? Number(to) : undefined;
      const runEventLogs = await runtime.getLogs({
        entityId: agentId,
        roomId: roomId ? roomId : undefined,
        type: "run_event",
        count: limitNum * 3
      });
      const runMap = new Map;
      for (const log of runEventLogs) {
        const body = log.body;
        const runId = body.runId;
        if (!runId)
          continue;
        const logTime = new Date(log.createdAt).getTime();
        if (fromTime && logTime < fromTime)
          continue;
        if (toTime && logTime > toTime)
          continue;
        if (!runMap.has(runId)) {
          runMap.set(runId, {
            runId,
            status: "started",
            startedAt: null,
            endedAt: null,
            durationMs: null,
            messageId: body.messageId,
            roomId: body.roomId,
            entityId: body.entityId,
            metadata: body.metadata || {}
          });
        }
        const run = runMap.get(runId);
        const eventStatus = body.status;
        if (eventStatus === "started") {
          run.startedAt = logTime;
        } else if (eventStatus === "completed" || eventStatus === "timeout" || eventStatus === "error") {
          run.status = eventStatus;
          run.endedAt = logTime;
          if (run.startedAt) {
            run.durationMs = logTime - run.startedAt;
          }
        }
      }
      let runs = Array.from(runMap.values());
      if (status && status !== "all") {
        runs = runs.filter((run) => run.status === status);
      }
      runs.sort((a, b) => (b.startedAt || 0) - (a.startedAt || 0));
      const limitedRuns = runs.slice(0, limitNum);
      const runIdSet = new Set(limitedRuns.map((r) => r.runId));
      const [actionLogs, evaluatorLogs, genericLogs] = await Promise.all([
        runtime.getLogs({
          entityId: agentId,
          roomId: roomId ? roomId : undefined,
          type: "action",
          count: 5000
        }),
        runtime.getLogs({
          entityId: agentId,
          roomId: roomId ? roomId : undefined,
          type: "evaluator",
          count: 5000
        }),
        runtime.getLogs({
          entityId: agentId,
          roomId: roomId ? roomId : undefined,
          count: 5000
        })
      ]);
      const countsByRunId = {};
      for (const run of limitedRuns) {
        countsByRunId[run.runId] = { actions: 0, modelCalls: 0, errors: 0, evaluators: 0 };
      }
      for (const log of actionLogs) {
        const rid = log.body.runId;
        if (!rid || !runIdSet.has(rid))
          continue;
        const entry = countsByRunId[rid];
        if (!entry)
          continue;
        entry.actions += 1;
        const bodyForAction = log.body;
        if (bodyForAction.result?.success === false)
          entry.errors += 1;
        const promptCount = Number(bodyForAction.promptCount || 0);
        if (promptCount > 0)
          entry.modelCalls += promptCount;
      }
      for (const log of evaluatorLogs) {
        const rid = log.body.runId;
        if (!rid || !runIdSet.has(rid))
          continue;
        const entry = countsByRunId[rid];
        if (!entry)
          continue;
        entry.evaluators += 1;
      }
      for (const log of genericLogs) {
        const rid = log.body.runId;
        if (!rid || !runIdSet.has(rid))
          continue;
        const entry = countsByRunId[rid];
        if (!entry)
          continue;
        if (typeof log.type === "string" && log.type.startsWith("useModel:")) {
          entry.modelCalls += 1;
        } else if (log.type === "embedding_event" && log.body.status === "failed") {
          entry.errors += 1;
        }
      }
      for (const run of limitedRuns) {
        run.counts = countsByRunId[run.runId] || {
          actions: 0,
          modelCalls: 0,
          errors: 0,
          evaluators: 0
        };
      }
      const response = {
        runs: limitedRuns,
        total: runs.length,
        hasMore: runs.length > limitNum
      };
      sendSuccess(res, response);
    } catch (error) {
      sendError(res, 500, "RUNS_ERROR", "Error retrieving agent runs", error instanceof Error ? error.message : String(error));
    }
  });
  router.get("/:agentId/runs/:runId", async (req, res) => {
    const agentId = validateUuid6(req.params.agentId);
    const runId = validateUuid6(req.params.runId);
    const { roomId } = req.query;
    if (!agentId || !runId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent or run ID format");
    }
    if (roomId && !validateUuid6(roomId)) {
      return sendError(res, 400, "INVALID_ID", "Invalid room ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const logs = await runtime.getLogs({
        entityId: agentId,
        roomId: roomId ? roomId : undefined,
        count: 2000
      });
      const related = logs.filter((l) => l.body.runId === runId);
      const runEvents = related.filter((l) => l.type === "run_event").sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
      const started = runEvents.find((e) => e.body.status === "started");
      const last = runEvents[runEvents.length - 1];
      const startedAt = started ? new Date(started.createdAt).getTime() : undefined;
      const endedAt = last && last.body.status !== "started" ? new Date(last.createdAt).getTime() : undefined;
      const status = last?.body?.status || "started";
      const durationMs = startedAt && endedAt ? endedAt - startedAt : undefined;
      const actionLogs = related.filter((l) => l.type === "action");
      const actionEventLogs = related.filter((l) => l.type === "action_event");
      const evaluatorLogs = related.filter((l) => l.type === "evaluator");
      const embeddingLogs = related.filter((l) => l.type === "embedding_event");
      const modelLogs = related.filter((l) => typeof l.type === "string" && l.type.startsWith("useModel:"));
      const counts = {
        actions: actionEventLogs.length || actionLogs.length,
        modelCalls: (actionLogs.reduce((sum, l) => sum + Number(l.body.promptCount || 0), 0) || 0) + modelLogs.length,
        errors: actionLogs.filter((l) => l.body.result?.success === false).length + embeddingLogs.filter((l) => l.body.status === "failed").length,
        evaluators: evaluatorLogs.length
      };
      const events = [];
      for (const e of runEvents) {
        const t = new Date(e.createdAt).getTime();
        const body = e.body;
        const st = body.status;
        if (st === "started") {
          events.push({
            type: "RUN_STARTED",
            timestamp: t,
            data: { source: body.source ?? undefined, messageId: body.messageId }
          });
        } else {
          events.push({
            type: "RUN_ENDED",
            timestamp: t,
            data: { status: st, error: body.error, durationMs: body.duration }
          });
        }
      }
      for (const e of actionEventLogs) {
        const body = e.body;
        events.push({
          type: "ACTION_STARTED",
          timestamp: new Date(e.createdAt).getTime(),
          data: {
            actionId: body.actionId,
            actionName: body.actionName || body.content?.actions?.[0],
            messageId: body.messageId,
            planStep: body.planStep
          }
        });
      }
      for (const e of actionLogs) {
        const body = e.body;
        events.push({
          type: "ACTION_COMPLETED",
          timestamp: new Date(e.createdAt).getTime(),
          data: {
            actionId: body.actionId,
            actionName: body.action,
            success: body.result?.success !== false,
            result: body.result,
            promptCount: body.promptCount
          }
        });
      }
      for (const e of modelLogs) {
        const body = e.body;
        events.push({
          type: "MODEL_USED",
          timestamp: new Date(e.createdAt).getTime(),
          data: {
            modelType: body.modelType || (typeof e.type === "string" ? e.type.replace("useModel:", "") : undefined),
            provider: body.provider,
            executionTime: body.executionTime,
            actionContext: body.actionContext
          }
        });
      }
      for (const e of evaluatorLogs) {
        const body = e.body;
        events.push({
          type: "EVALUATOR_COMPLETED",
          timestamp: new Date(e.createdAt).getTime(),
          data: {
            evaluatorName: body.evaluator,
            success: true
          }
        });
      }
      for (const e of embeddingLogs) {
        const body = e.body;
        events.push({
          type: "EMBEDDING_EVENT",
          timestamp: new Date(e.createdAt).getTime(),
          data: {
            status: body.status,
            memoryId: body.memoryId,
            durationMs: body.duration
          }
        });
      }
      events.sort((a, b) => a.timestamp - b.timestamp);
      const firstRunEvent = started || runEvents[0] || related[0];
      const summary = {
        runId,
        status,
        startedAt: startedAt || (firstRunEvent ? new Date(firstRunEvent.createdAt).getTime() : undefined),
        endedAt,
        durationMs,
        messageId: firstRunEvent?.body?.messageId,
        roomId: firstRunEvent?.body?.roomId || roomId,
        entityId: firstRunEvent?.body?.entityId || agentId,
        counts
      };
      sendSuccess(res, { summary, events });
    } catch (error) {
      sendError(res, 500, "RUN_DETAIL_ERROR", "Error retrieving run details", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/memory/agents.ts
import { MemoryType, createUniqueUuid as createUniqueUuid2 } from "@elizaos/core";
import { validateUuid as validateUuid7, logger as logger6 } from "@elizaos/core";
import express7 from "express";
function createAgentMemoryRouter(agents) {
  const router = express7.Router();
  router.get("/:agentId/rooms/:roomId/memories", async (req, res) => {
    const agentId = validateUuid7(req.params.agentId);
    const roomId = validateUuid7(req.params.roomId);
    if (!agentId || !roomId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID or room ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const limit = req.query.limit ? Number.parseInt(req.query.limit, 10) : 20;
      const before = req.query.before ? Number.parseInt(req.query.before, 10) : Date.now();
      const includeEmbedding = req.query.includeEmbedding === "true";
      const tableName = req.query.tableName || "messages";
      const memories = await runtime.getMemories({
        tableName,
        roomId,
        count: limit,
        end: before
      });
      const cleanMemories = includeEmbedding ? memories : memories.map((memory) => ({
        ...memory,
        embedding: undefined
      }));
      sendSuccess(res, { memories: cleanMemories });
    } catch (error) {
      logger6.error("[MEMORIES GET] Error retrieving memories for room:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "500", "Failed to retrieve memories", error instanceof Error ? error.message : String(error));
    }
  });
  router.get("/:agentId/memories", async (req, res) => {
    const agentId = validateUuid7(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const tableName = req.query.tableName || "messages";
      const includeEmbedding = req.query.includeEmbedding === "true";
      let roomIdToUse;
      if (req.query.channelId) {
        const channelId = validateUuid7(req.query.channelId);
        if (!channelId) {
          return sendError(res, 400, "INVALID_ID", "Invalid channel ID format");
        }
        roomIdToUse = createUniqueUuid2(runtime, channelId);
        logger6.info(`[AGENT MEMORIES] Converting channelId ${channelId} to roomId ${roomIdToUse} for agent ${agentId}`);
      } else if (req.query.roomId) {
        const roomId = validateUuid7(req.query.roomId);
        if (!roomId) {
          return sendError(res, 400, "INVALID_ID", "Invalid room ID format");
        }
        roomIdToUse = roomId;
      }
      const memories = await runtime.getMemories({
        agentId,
        tableName,
        roomId: roomIdToUse
      });
      const cleanMemories = includeEmbedding ? memories : memories.map((memory) => ({
        ...memory,
        embedding: undefined
      }));
      sendSuccess(res, { memories: cleanMemories });
    } catch (error) {
      logger6.error(`[AGENT MEMORIES] Error retrieving memories for agent ${agentId}:`, error instanceof Error ? error.message : String(error));
      sendError(res, 500, "MEMORY_ERROR", "Error retrieving agent memories", error instanceof Error ? error.message : String(error));
    }
  });
  router.patch("/:agentId/memories/:memoryId", async (req, res) => {
    const agentId = validateUuid7(req.params.agentId);
    const memoryId = validateUuid7(req.params.memoryId);
    const { id: _idFromData, ...restOfMemoryData } = req.body;
    if (!agentId || !memoryId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID or memory ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const memoryToUpdate = {
        id: memoryId,
        ...restOfMemoryData,
        agentId: restOfMemoryData.agentId ? validateUuid7(restOfMemoryData.agentId) || undefined : agentId,
        roomId: restOfMemoryData.roomId ? validateUuid7(restOfMemoryData.roomId) || undefined : undefined,
        entityId: restOfMemoryData.entityId ? validateUuid7(restOfMemoryData.entityId) || undefined : undefined,
        worldId: restOfMemoryData.worldId ? validateUuid7(restOfMemoryData.worldId) || undefined : undefined,
        metadata: restOfMemoryData.metadata
      };
      Object.keys(memoryToUpdate).forEach((key) => {
        if (memoryToUpdate[key] === undefined) {
          delete memoryToUpdate[key];
        }
      });
      await runtime.updateMemory(memoryToUpdate);
      logger6.success(`[MEMORY UPDATE] Successfully updated memory ${memoryId}`);
      sendSuccess(res, { id: memoryId, message: "Memory updated successfully" });
    } catch (error) {
      logger6.error(`[MEMORY UPDATE] Error updating memory ${memoryId}:`, error instanceof Error ? error.message : String(error));
      sendError(res, 500, "UPDATE_ERROR", "Failed to update memory", error instanceof Error ? error.message : String(error));
    }
  });
  router.delete("/:agentId/memories", async (req, res) => {
    try {
      const agentId = validateUuid7(req.params.agentId);
      if (!agentId) {
        return sendError(res, 400, "INVALID_ID", "Invalid agent ID");
      }
      const runtime = agents.get(agentId);
      if (!runtime) {
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      const deleted = (await runtime.getAllMemories()).length;
      await runtime.clearAllAgentMemories();
      sendSuccess(res, { deleted, message: "All agent memories cleared successfully" });
    } catch (error) {
      logger6.error("[DELETE ALL AGENT MEMORIES] Error deleting all agent memories:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "DELETE_ERROR", "Error deleting all agent memories", error instanceof Error ? error.message : String(error));
    }
  });
  router.delete("/:agentId/memories/all/:roomId", async (req, res) => {
    try {
      const agentId = validateUuid7(req.params.agentId);
      const roomId = validateUuid7(req.params.roomId);
      if (!agentId) {
        return sendError(res, 400, "INVALID_ID", "Invalid agent ID");
      }
      if (!roomId) {
        return sendError(res, 400, "INVALID_ID", "Invalid room ID");
      }
      const runtime = agents.get(agentId);
      if (!runtime) {
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      await runtime.deleteAllMemories(roomId, MemoryType.MESSAGE);
      await runtime.deleteAllMemories(roomId, MemoryType.DOCUMENT);
      res.status(204).send();
    } catch (error) {
      logger6.error("[DELETE ALL MEMORIES] Error deleting all memories:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "DELETE_ERROR", "Error deleting all memories", error instanceof Error ? error.message : String(error));
    }
  });
  router.delete("/:agentId/memories/:memoryId", async (req, res) => {
    try {
      const agentId = validateUuid7(req.params.agentId);
      const memoryId = validateUuid7(req.params.memoryId);
      if (!agentId || !memoryId) {
        return sendError(res, 400, "INVALID_ID", "Invalid agent ID or memory ID format");
      }
      const runtime = agents.get(agentId);
      if (!runtime) {
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      await runtime.deleteMemory(memoryId);
      sendSuccess(res, { message: "Memory deleted successfully" });
    } catch (error) {
      logger6.error(`[DELETE MEMORY] Error deleting memory ${req.params.memoryId}:`, error instanceof Error ? error.message : String(error));
      sendError(res, 500, "DELETE_ERROR", "Error deleting memory", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/memory/rooms.ts
import { validateUuid as validateUuid8, logger as logger7, createUniqueUuid as createUniqueUuid3, ChannelType } from "@elizaos/core";
import express8 from "express";
function createRoomManagementRouter(agents) {
  const router = express8.Router();
  router.post("/:agentId/rooms", async (req, res) => {
    const agentId = validateUuid8(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const { name, type = ChannelType.DM, source = "client", worldId, metadata } = req.body;
      if (!name) {
        return sendError(res, 400, "MISSING_PARAM", "Room name is required");
      }
      const roomId = createUniqueUuid3(runtime, `room-${Date.now()}`);
      const serverId = req.body.serverId || `server-${Date.now()}`;
      let resolvedWorldId = worldId;
      if (!resolvedWorldId) {
        const worldName = `World for ${name}`;
        resolvedWorldId = createUniqueUuid3(runtime, `world-${Date.now()}`);
        await runtime.ensureWorldExists({
          id: resolvedWorldId,
          name: worldName,
          agentId: runtime.agentId,
          serverId,
          metadata
        });
      }
      await runtime.ensureRoomExists({
        id: roomId,
        name,
        source,
        type,
        channelId: roomId,
        serverId,
        worldId: resolvedWorldId,
        metadata
      });
      await runtime.addParticipant(runtime.agentId, roomId);
      await runtime.ensureParticipantInRoom(runtime.agentId, roomId);
      await runtime.setParticipantUserState(roomId, runtime.agentId, "FOLLOWED");
      sendSuccess(res, {
        id: roomId,
        name,
        agentId,
        createdAt: Date.now(),
        source,
        type,
        worldId: resolvedWorldId,
        serverId,
        metadata
      }, 201);
    } catch (error) {
      logger7.error(`[ROOM CREATE] Error creating room for agent ${agentId}:`, error instanceof Error ? error.message : String(error));
      sendError(res, 500, "CREATE_ERROR", "Failed to create room", error instanceof Error ? error.message : String(error));
    }
  });
  router.get("/:agentId/rooms", async (req, res) => {
    const agentId = validateUuid8(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const worlds = await runtime.getAllWorlds();
      const participantRoomIds = await runtime.getRoomsForParticipant(agentId);
      const agentRooms = [];
      for (const world of worlds) {
        const worldRooms = await runtime.getRooms(world.id);
        for (const room of worldRooms) {
          if (participantRoomIds.includes(room.id)) {
            agentRooms.push({
              ...room
            });
          }
        }
      }
      sendSuccess(res, { rooms: agentRooms });
    } catch (error) {
      logger7.error(`[ROOMS LIST] Error retrieving rooms for agent ${agentId}:`, error instanceof Error ? error.message : String(error));
      sendError(res, 500, "RETRIEVAL_ERROR", "Failed to retrieve agent rooms", error instanceof Error ? error.message : String(error));
    }
  });
  router.get("/:agentId/rooms/:roomId", async (req, res) => {
    const agentId = validateUuid8(req.params.agentId);
    const roomId = validateUuid8(req.params.roomId);
    if (!agentId || !roomId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID or room ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const room = await runtime.getRoom(roomId);
      if (!room) {
        return sendError(res, 404, "NOT_FOUND", "Room not found");
      }
      let worldName;
      if (room.worldId) {
        const world = await runtime.getWorld(room.worldId);
        worldName = world?.name;
      }
      sendSuccess(res, {
        ...room,
        ...worldName && { worldName }
      });
    } catch (error) {
      logger7.error(`[ROOM DETAILS] Error retrieving room ${roomId} for agent ${agentId}:`, error instanceof Error ? error.message : String(error));
      sendError(res, 500, "RETRIEVAL_ERROR", "Failed to retrieve room details", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/agents/index.ts
function agentsRouter(agents, serverInstance) {
  const router = express9.Router();
  router.use("/", createAgentCrudRouter(agents, serverInstance));
  router.use("/", createAgentLifecycleRouter(agents, serverInstance));
  router.use("/", createAgentWorldsRouter(agents));
  router.use("/", createAgentPanelsRouter(agents));
  router.use("/", createAgentLogsRouter(agents));
  router.use("/", createAgentRunsRouter(agents));
  router.use("/", createAgentMemoryRouter(agents));
  router.use("/", createRoomManagementRouter(agents));
  return router;
}

// src/api/messaging/index.ts
import express14 from "express";

// src/api/messaging/core.ts
import { logger as logger8, validateUuid as validateUuid9 } from "@elizaos/core";
import express10 from "express";

// src/bus.ts
class InternalMessageBus extends EventTarget {
  _maxListeners = 50;
  handlers = new Map;
  emit(event, data) {
    return this.dispatchEvent(new CustomEvent(event, { detail: data }));
  }
  on(event, handler) {
    if (!this.handlers.has(event)) {
      this.handlers.set(event, new Map);
    }
    const eventHandlers = this.handlers.get(event);
    if (eventHandlers.has(handler)) {
      return this;
    }
    const wrappedHandler = (e) => {
      if (e instanceof CustomEvent) {
        handler(e.detail);
      } else {
        handler(undefined);
      }
    };
    eventHandlers.set(handler, wrappedHandler);
    this.addEventListener(event, wrappedHandler);
    return this;
  }
  off(event, handler) {
    const eventHandlers = this.handlers.get(event);
    const wrappedHandler = eventHandlers?.get(handler);
    if (wrappedHandler) {
      this.removeEventListener(event, wrappedHandler);
      eventHandlers?.delete(handler);
      if (eventHandlers && eventHandlers.size === 0) {
        this.handlers.delete(event);
      }
    }
  }
  getMaxListeners() {
    return this._maxListeners;
  }
  setMaxListeners(n) {
    this._maxListeners = n;
  }
  removeAllListeners(event) {
    if (event) {
      const eventHandlers = this.handlers.get(event);
      if (eventHandlers) {
        for (const [_handler, wrappedHandler] of eventHandlers) {
          this.removeEventListener(event, wrappedHandler);
        }
        this.handlers.delete(event);
      }
    } else {
      for (const [eventName, eventHandlers] of this.handlers) {
        for (const [_handler, wrappedHandler] of eventHandlers) {
          this.removeEventListener(eventName, wrappedHandler);
        }
      }
      this.handlers.clear();
    }
  }
}
var internalMessageBus = new InternalMessageBus;
internalMessageBus.setMaxListeners(50);
var bus_default = internalMessageBus;

// src/utils/media-transformer.ts
import path from "node:path";
import { getGeneratedDir, getUploadsAgentsDir, getUploadsChannelsDir } from "@elizaos/core";
var ID_PATTERN = /^([^/\\]+)[/\\]([^/\\]+)$/;
var PATH_CONFIGS = [
  {
    getPath: getGeneratedDir,
    apiPrefix: "/media/generated/",
    pattern: ID_PATTERN
  },
  {
    getPath: getUploadsAgentsDir,
    apiPrefix: "/media/uploads/agents/",
    pattern: ID_PATTERN
  },
  {
    getPath: getUploadsChannelsDir,
    apiPrefix: "/media/uploads/channels/",
    pattern: ID_PATTERN
  }
];
var isExternalUrl = (p) => /^(?:https?:|blob:|data:|file:|ipfs:|s3:|gs:)/i.test(p);
function transformPathToApiUrl(filePath) {
  if (!filePath || isExternalUrl(filePath) || filePath.startsWith("/media/") || !path.isAbsolute(filePath)) {
    return filePath;
  }
  const normalizedPath = filePath.replace(/\\/g, "/");
  for (const config of PATH_CONFIGS) {
    const configPathRaw = config.getPath().replace(/\\/g, "/");
    const configPath = configPathRaw.endsWith("/") ? configPathRaw : `${configPathRaw}/`;
    if (normalizedPath === configPathRaw || normalizedPath.startsWith(configPath)) {
      const relative = normalizedPath === configPathRaw ? "" : normalizedPath.slice(configPath.length);
      if (relative) {
        const match = relative.match(config.pattern);
        if (match) {
          const [, id, filename] = match;
          return `${config.apiPrefix}${encodeURIComponent(id)}${"/"}${encodeURIComponent(filename)}`;
        }
      }
    }
  }
  return filePath;
}
function attachmentsToApiUrls(attachments) {
  if (!attachments)
    return attachments;
  if (Array.isArray(attachments)) {
    return attachments.map((attachment) => {
      if (typeof attachment === "string") {
        return transformPathToApiUrl(attachment);
      }
      if (attachment?.url) {
        return { ...attachment, url: transformPathToApiUrl(attachment.url) };
      }
      return attachment;
    });
  }
  if (typeof attachments === "string") {
    return transformPathToApiUrl(attachments);
  }
  if (attachments?.url) {
    return { ...attachments, url: transformPathToApiUrl(attachments.url) };
  }
  return attachments;
}
function transformMessageAttachments(message) {
  if (!message || typeof message !== "object") {
    return message;
  }
  if (message.content && typeof message.content === "object" && "attachments" in message.content) {
    const content = message.content;
    if (content.attachments) {
      content.attachments = attachmentsToApiUrls(content.attachments);
    }
  }
  if (message.metadata?.attachments) {
    message.metadata.attachments = attachmentsToApiUrls(message.metadata.attachments);
  }
  return message;
}

// src/api/messaging/core.ts
var DEFAULT_SERVER_ID = "00000000-0000-0000-0000-000000000000";
function createMessagingCoreRouter(serverInstance) {
  const router = express10.Router();
  router.post("/submit", async (req, res) => {
    const {
      channel_id,
      server_id,
      author_id,
      content,
      in_reply_to_message_id,
      source_type,
      raw_message,
      metadata
    } = req.body;
    const isValidServerId = server_id === DEFAULT_SERVER_ID || validateUuid9(server_id);
    if (!validateUuid9(channel_id) || !validateUuid9(author_id) || !content || !isValidServerId || !source_type || !raw_message) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: channel_id, server_id, author_id, content, source_type, raw_message"
      });
    }
    if (in_reply_to_message_id && !validateUuid9(in_reply_to_message_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid in_reply_to_message_id format"
      });
    }
    try {
      const newRootMessageData = {
        channelId: validateUuid9(channel_id),
        authorId: validateUuid9(author_id),
        content,
        rawMessage: raw_message,
        sourceType: source_type || "agent_response",
        inReplyToRootMessageId: in_reply_to_message_id ? validateUuid9(in_reply_to_message_id) || undefined : undefined,
        metadata
      };
      const createdMessage = await serverInstance.createMessage(newRootMessageData);
      const transformedAttachments = attachmentsToApiUrls(metadata?.attachments ?? raw_message?.attachments);
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(channel_id).emit("messageBroadcast", {
          senderId: author_id,
          senderName: metadata?.agentName || "Agent",
          text: content,
          roomId: channel_id,
          serverId: server_id,
          createdAt: new Date(createdMessage.createdAt).getTime(),
          source: createdMessage.sourceType,
          id: createdMessage.id,
          thought: raw_message?.thought,
          actions: raw_message?.actions,
          attachments: transformedAttachments
        });
      }
      res.status(201).json({ success: true, data: createdMessage });
    } catch (error) {
      logger8.error("[Messages Router /submit] Error submitting agent message:", error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to submit agent message" });
    }
  });
  router.post("/action", async (req, res) => {
    const {
      messageId,
      channel_id,
      server_id,
      author_id,
      content,
      in_reply_to_message_id,
      source_type,
      raw_message,
      metadata
    } = req.body;
    const isValidServerId = server_id === DEFAULT_SERVER_ID || validateUuid9(server_id);
    if (!validateUuid9(channel_id) || !validateUuid9(author_id) || !content || !isValidServerId || !source_type || !raw_message) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: channel_id, server_id, author_id, content, source_type, raw_message"
      });
    }
    if (in_reply_to_message_id && !validateUuid9(in_reply_to_message_id)) {
      return res.status(400).json({ success: false, error: "Invalid in_reply_to_message_id format" });
    }
    if (messageId && !validateUuid9(messageId)) {
      return res.status(400).json({ success: false, error: "Invalid messageId format" });
    }
    try {
      const baseData = {
        messageId,
        channelId: validateUuid9(channel_id),
        authorId: validateUuid9(author_id),
        content,
        rawMessage: raw_message,
        sourceType: source_type || "agent_response",
        inReplyToRootMessageId: in_reply_to_message_id ? validateUuid9(in_reply_to_message_id) || undefined : undefined,
        metadata
      };
      const savedMessage = await serverInstance.createMessage(baseData);
      const transformedAttachments = attachmentsToApiUrls(metadata?.attachments ?? raw_message?.attachments);
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(channel_id).emit("messageBroadcast", {
          senderId: author_id,
          senderName: metadata?.agentName || "Agent",
          text: savedMessage.content,
          roomId: channel_id,
          serverId: server_id,
          createdAt: new Date(savedMessage.createdAt).getTime(),
          source: savedMessage.sourceType,
          id: savedMessage.id,
          thought: raw_message?.thought,
          actions: raw_message?.actions,
          attachments: transformedAttachments,
          updatedAt: new Date(savedMessage.updatedAt).getTime(),
          rawMessage: raw_message
        });
      }
      return res.status(201).json({ success: true, data: savedMessage });
    } catch (error) {
      logger8.error("[POST /actions] Error creating action:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({ success: false, error: "Failed to create action" });
    }
  });
  router.patch("/action/:id", async (req, res) => {
    const { id } = req.params;
    if (!validateUuid9(id)) {
      return res.status(400).json({ success: false, error: "Invalid message id" });
    }
    const {
      content,
      raw_message,
      source_type,
      in_reply_to_message_id,
      metadata,
      author_id,
      server_id
    } = req.body ?? {};
    if (in_reply_to_message_id && !validateUuid9(in_reply_to_message_id)) {
      return res.status(400).json({ success: false, error: "Invalid in_reply_to_message_id format" });
    }
    if (author_id && !validateUuid9(author_id)) {
      return res.status(400).json({ success: false, error: "Invalid author_id format" });
    }
    if (server_id && !(server_id === DEFAULT_SERVER_ID || validateUuid9(server_id))) {
      return res.status(400).json({ success: false, error: "Invalid server_id format" });
    }
    try {
      const updated = await serverInstance.updateMessage(id, {
        content,
        rawMessage: raw_message,
        sourceType: source_type,
        inReplyToRootMessageId: in_reply_to_message_id ? validateUuid9(in_reply_to_message_id) || undefined : undefined,
        metadata
      });
      if (!updated) {
        return res.status(404).json({ success: false, error: "Message not found" });
      }
      const transformedAttachments = attachmentsToApiUrls(metadata?.attachments ?? raw_message?.attachments);
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(updated.channelId).emit("messageBroadcast", {
          senderId: author_id || updated.authorId,
          senderName: metadata?.agentName || "Agent",
          text: updated.content,
          roomId: updated.channelId,
          serverId: server_id,
          createdAt: new Date(updated.createdAt).getTime(),
          source: updated.sourceType,
          id: updated.id,
          thought: raw_message?.thought,
          actions: raw_message?.actions,
          attachments: transformedAttachments,
          updatedAt: new Date(updated.updatedAt).getTime(),
          rawMessage: raw_message
        });
      }
      return res.status(200).json({ success: true, data: updated });
    } catch (error) {
      logger8.error("[PATCH /action/:id] Error updating action:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({ success: false, error: "Failed to update action" });
    }
  });
  router.post("/ingest-external", async (req, res) => {
    const messagePayload = req.body;
    if (!messagePayload.channel_id || !messagePayload.server_id || !messagePayload.author_id || !messagePayload.content) {
      return res.status(400).json({ success: false, error: "Invalid external message payload" });
    }
    try {
      const messageToCreate = {
        channelId: messagePayload.channel_id,
        authorId: messagePayload.author_id,
        content: messagePayload.content,
        rawMessage: messagePayload.raw_message,
        sourceId: messagePayload.source_id,
        sourceType: messagePayload.source_type,
        inReplyToRootMessageId: messagePayload.in_reply_to_message_id ? validateUuid9(messagePayload.in_reply_to_message_id) || undefined : undefined,
        metadata: messagePayload.metadata
      };
      const createdRootMessage = await serverInstance.createMessage(messageToCreate);
      const messageForBus = {
        id: createdRootMessage.id,
        channel_id: createdRootMessage.channelId,
        server_id: messagePayload.server_id,
        author_id: createdRootMessage.authorId,
        author_display_name: messagePayload.author_display_name,
        content: createdRootMessage.content,
        raw_message: createdRootMessage.rawMessage,
        source_id: createdRootMessage.sourceId,
        source_type: createdRootMessage.sourceType,
        in_reply_to_message_id: createdRootMessage.inReplyToRootMessageId,
        created_at: new Date(createdRootMessage.createdAt).getTime(),
        metadata: createdRootMessage.metadata
      };
      bus_default.emit("new_message", messageForBus);
      logger8.info("[Messages Router /ingest-external] Published to internal message bus:", createdRootMessage.id);
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(messageForBus.channel_id).emit("messageBroadcast", {
          senderId: messageForBus.author_id,
          senderName: messageForBus.author_display_name || "User",
          text: messageForBus.content,
          roomId: messageForBus.channel_id,
          serverId: messageForBus.server_id,
          createdAt: messageForBus.created_at,
          source: messageForBus.source_type,
          id: messageForBus.id
        });
      }
      res.status(202).json({
        success: true,
        message: "Message ingested and published to bus",
        data: { messageId: createdRootMessage.id }
      });
    } catch (error) {
      logger8.error("[Messages Router /ingest-external] Error ingesting external message:", error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to ingest message" });
    }
  });
  return router;
}

// src/api/messaging/servers.ts
import { logger as logger9, validateUuid as validateUuid10 } from "@elizaos/core";
import express11 from "express";
var DEFAULT_SERVER_ID2 = "00000000-0000-0000-0000-000000000000";
function createServersRouter(serverInstance) {
  const router = express11.Router();
  router.get("/central-servers", async (_req, res) => {
    try {
      const servers = await serverInstance.getServers();
      res.json({ success: true, data: { servers } });
    } catch (error) {
      logger9.error("[Messages Router /central-servers] Error fetching servers:", error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to fetch servers" });
    }
  });
  router.post("/servers", async (req, res) => {
    const { name, sourceType, sourceId, metadata } = req.body;
    if (!name || !sourceType) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: name, sourceType"
      });
    }
    try {
      const server = await serverInstance.createServer({
        name,
        sourceType,
        sourceId,
        metadata
      });
      res.status(201).json({ success: true, data: { server } });
    } catch (error) {
      logger9.error("[Messages Router /servers] Error creating server:", error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to create server" });
    }
  });
  router.post("/servers/:serverId/agents", async (req, res) => {
    const serverId = req.params.serverId === DEFAULT_SERVER_ID2 ? DEFAULT_SERVER_ID2 : validateUuid10(req.params.serverId);
    const { agentId } = req.body;
    if (!serverId || !validateUuid10(agentId)) {
      return res.status(400).json({
        success: false,
        error: "Invalid serverId or agentId format"
      });
    }
    try {
      await serverInstance.addAgentToServer(serverId, agentId);
      const messageForBus = {
        type: "agent_added_to_server",
        serverId,
        agentId
      };
      bus_default.emit("server_agent_update", messageForBus);
      res.status(201).json({
        success: true,
        data: {
          serverId,
          agentId,
          message: "Agent added to server successfully"
        }
      });
    } catch (error) {
      logger9.error(`[MessagesRouter] Error adding agent ${agentId} to server ${serverId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to add agent to server" });
    }
  });
  router.delete("/servers/:serverId/agents/:agentId", async (req, res) => {
    const serverId = req.params.serverId === DEFAULT_SERVER_ID2 ? DEFAULT_SERVER_ID2 : validateUuid10(req.params.serverId);
    const agentId = validateUuid10(req.params.agentId);
    if (!serverId || !agentId) {
      return res.status(400).json({
        success: false,
        error: "Invalid serverId or agentId format"
      });
    }
    try {
      await serverInstance.removeAgentFromServer(serverId, agentId);
      const messageForBus = {
        type: "agent_removed_from_server",
        serverId,
        agentId
      };
      bus_default.emit("server_agent_update", messageForBus);
      res.status(200).json({
        success: true,
        data: {
          serverId,
          agentId,
          message: "Agent removed from server successfully"
        }
      });
    } catch (error) {
      logger9.error(`[MessagesRouter] Error removing agent ${agentId} from server ${serverId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to remove agent from server" });
    }
  });
  router.get("/servers/:serverId/agents", async (req, res) => {
    const serverId = req.params.serverId === DEFAULT_SERVER_ID2 ? DEFAULT_SERVER_ID2 : validateUuid10(req.params.serverId);
    if (!serverId) {
      return res.status(400).json({
        success: false,
        error: "Invalid serverId format"
      });
    }
    try {
      const agents = await serverInstance.getAgentsForServer(serverId);
      res.json({
        success: true,
        data: {
          serverId,
          agents
        }
      });
    } catch (error) {
      logger9.error(`[MessagesRouter] Error fetching agents for server ${serverId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to fetch server agents" });
    }
  });
  router.get("/agents/:agentId/servers", async (req, res) => {
    const agentId = validateUuid10(req.params.agentId);
    if (!agentId) {
      return res.status(400).json({
        success: false,
        error: "Invalid agentId format"
      });
    }
    try {
      const servers = await serverInstance.getServersForAgent(agentId);
      res.json({
        success: true,
        data: {
          agentId,
          servers
        }
      });
    } catch (error) {
      logger9.error(`[MessagesRouter] Error fetching servers for agent ${agentId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to fetch agent servers" });
    }
  });
  return router;
}

// src/api/messaging/channels.ts
import {
  composePromptFromState,
  ModelType,
  ChannelType as ChannelType2,
  logger as logger12,
  validateUuid as validateUuid13,
  getUploadsChannelsDir as getUploadsChannelsDir2
} from "@elizaos/core";
import express12 from "express";

// src/api/shared/middleware.ts
import { validateUuid as validateUuid12, logger as logger11 } from "@elizaos/core";

// src/api/shared/validation.ts
import { validateUuid as validateUuid11, logger as logger10 } from "@elizaos/core";
var getRuntime = (agents, agentId) => {
  const runtime = agents.get(agentId);
  if (!runtime) {
    throw new Error(`Agent not found: ${agentId}`);
  }
  return runtime;
};

// ../../node_modules/express-rate-limit/dist/index.mjs
import { Buffer as Buffer2 } from "node:buffer";
import { createHash } from "node:crypto";
import { isIP } from "node:net";
var SUPPORTED_DRAFT_VERSIONS = [
  "draft-6",
  "draft-7",
  "draft-8"
];
var getResetSeconds = (resetTime, windowMs) => {
  let resetSeconds = undefined;
  if (resetTime) {
    const deltaSeconds = Math.ceil((resetTime.getTime() - Date.now()) / 1000);
    resetSeconds = Math.max(0, deltaSeconds);
  } else if (windowMs) {
    resetSeconds = Math.ceil(windowMs / 1000);
  }
  return resetSeconds;
};
var getPartitionKey = (key) => {
  const hash = createHash("sha256");
  hash.update(key);
  const partitionKey = hash.digest("hex").slice(0, 12);
  return Buffer2.from(partitionKey).toString("base64");
};
var setLegacyHeaders = (response, info) => {
  if (response.headersSent)
    return;
  response.setHeader("X-RateLimit-Limit", info.limit.toString());
  response.setHeader("X-RateLimit-Remaining", info.remaining.toString());
  if (info.resetTime instanceof Date) {
    response.setHeader("Date", (/* @__PURE__ */ new Date()).toUTCString());
    response.setHeader("X-RateLimit-Reset", Math.ceil(info.resetTime.getTime() / 1000).toString());
  }
};
var setDraft6Headers = (response, info, windowMs) => {
  if (response.headersSent)
    return;
  const windowSeconds = Math.ceil(windowMs / 1000);
  const resetSeconds = getResetSeconds(info.resetTime);
  response.setHeader("RateLimit-Policy", `${info.limit};w=${windowSeconds}`);
  response.setHeader("RateLimit-Limit", info.limit.toString());
  response.setHeader("RateLimit-Remaining", info.remaining.toString());
  if (resetSeconds)
    response.setHeader("RateLimit-Reset", resetSeconds.toString());
};
var setDraft7Headers = (response, info, windowMs) => {
  if (response.headersSent)
    return;
  const windowSeconds = Math.ceil(windowMs / 1000);
  const resetSeconds = getResetSeconds(info.resetTime, windowMs);
  response.setHeader("RateLimit-Policy", `${info.limit};w=${windowSeconds}`);
  response.setHeader("RateLimit", `limit=${info.limit}, remaining=${info.remaining}, reset=${resetSeconds}`);
};
var setDraft8Headers = (response, info, windowMs, name, key) => {
  if (response.headersSent)
    return;
  const windowSeconds = Math.ceil(windowMs / 1000);
  const resetSeconds = getResetSeconds(info.resetTime, windowMs);
  const partitionKey = getPartitionKey(key);
  const policy = `q=${info.limit}; w=${windowSeconds}; pk=:${partitionKey}:`;
  const header = `r=${info.remaining}; t=${resetSeconds}`;
  response.append("RateLimit-Policy", `"${name}"; ${policy}`);
  response.append("RateLimit", `"${name}"; ${header}`);
};
var setRetryAfterHeader = (response, info, windowMs) => {
  if (response.headersSent)
    return;
  const resetSeconds = getResetSeconds(info.resetTime, windowMs);
  response.setHeader("Retry-After", resetSeconds.toString());
};
var ValidationError = class extends Error {
  constructor(code, message) {
    const url = `https://express-rate-limit.github.io/${code}/`;
    super(`${message} See ${url} for more information.`);
    this.name = this.constructor.name;
    this.code = code;
    this.help = url;
  }
};
var ChangeWarning = class extends ValidationError {
};
var usedStores = /* @__PURE__ */ new Set;
var singleCountKeys = /* @__PURE__ */ new WeakMap;
var validations = {
  enabled: {
    default: true
  },
  disable() {
    for (const k of Object.keys(this.enabled))
      this.enabled[k] = false;
  },
  ip(ip) {
    if (ip === undefined) {
      throw new ValidationError("ERR_ERL_UNDEFINED_IP_ADDRESS", `An undefined 'request.ip' was detected. This might indicate a misconfiguration or the connection being destroyed prematurely.`);
    }
    if (!isIP(ip)) {
      throw new ValidationError("ERR_ERL_INVALID_IP_ADDRESS", `An invalid 'request.ip' (${ip}) was detected. Consider passing a custom 'keyGenerator' function to the rate limiter.`);
    }
  },
  trustProxy(request) {
    if (request.app.get("trust proxy") === true) {
      throw new ValidationError("ERR_ERL_PERMISSIVE_TRUST_PROXY", `The Express 'trust proxy' setting is true, which allows anyone to trivially bypass IP-based rate limiting.`);
    }
  },
  xForwardedForHeader(request) {
    if (request.headers["x-forwarded-for"] && request.app.get("trust proxy") === false) {
      throw new ValidationError("ERR_ERL_UNEXPECTED_X_FORWARDED_FOR", `The 'X-Forwarded-For' header is set but the Express 'trust proxy' setting is false (default). This could indicate a misconfiguration which would prevent express-rate-limit from accurately identifying users.`);
    }
  },
  positiveHits(hits) {
    if (typeof hits !== "number" || hits < 1 || hits !== Math.round(hits)) {
      throw new ValidationError("ERR_ERL_INVALID_HITS", `The totalHits value returned from the store must be a positive integer, got ${hits}`);
    }
  },
  unsharedStore(store) {
    if (usedStores.has(store)) {
      const maybeUniquePrefix = store?.localKeys ? "" : " (with a unique prefix)";
      throw new ValidationError("ERR_ERL_STORE_REUSE", `A Store instance must not be shared across multiple rate limiters. Create a new instance of ${store.constructor.name}${maybeUniquePrefix} for each limiter instead.`);
    }
    usedStores.add(store);
  },
  singleCount(request, store, key) {
    let storeKeys = singleCountKeys.get(request);
    if (!storeKeys) {
      storeKeys = /* @__PURE__ */ new Map;
      singleCountKeys.set(request, storeKeys);
    }
    const storeKey = store.localKeys ? store : store.constructor.name;
    let keys = storeKeys.get(storeKey);
    if (!keys) {
      keys = [];
      storeKeys.set(storeKey, keys);
    }
    const prefixedKey = `${store.prefix ?? ""}${key}`;
    if (keys.includes(prefixedKey)) {
      throw new ValidationError("ERR_ERL_DOUBLE_COUNT", `The hit count for ${key} was incremented more than once for a single request.`);
    }
    keys.push(prefixedKey);
  },
  limit(limit) {
    if (limit === 0) {
      throw new ChangeWarning("WRN_ERL_MAX_ZERO", `Setting limit or max to 0 disables rate limiting in express-rate-limit v6 and older, but will cause all requests to be blocked in v7`);
    }
  },
  draftPolliHeaders(draft_polli_ratelimit_headers) {
    if (draft_polli_ratelimit_headers) {
      throw new ChangeWarning("WRN_ERL_DEPRECATED_DRAFT_POLLI_HEADERS", `The draft_polli_ratelimit_headers configuration option is deprecated and has been removed in express-rate-limit v7, please set standardHeaders: 'draft-6' instead.`);
    }
  },
  onLimitReached(onLimitReached) {
    if (onLimitReached) {
      throw new ChangeWarning("WRN_ERL_DEPRECATED_ON_LIMIT_REACHED", `The onLimitReached configuration option is deprecated and has been removed in express-rate-limit v7.`);
    }
  },
  headersDraftVersion(version) {
    if (typeof version !== "string" || !SUPPORTED_DRAFT_VERSIONS.includes(version)) {
      const versionString = SUPPORTED_DRAFT_VERSIONS.join(", ");
      throw new ValidationError("ERR_ERL_HEADERS_UNSUPPORTED_DRAFT_VERSION", `standardHeaders: only the following versions of the IETF draft specification are supported: ${versionString}.`);
    }
  },
  headersResetTime(resetTime) {
    if (!resetTime) {
      throw new ValidationError("ERR_ERL_HEADERS_NO_RESET", `standardHeaders:  'draft-7' requires a 'resetTime', but the store did not provide one. The 'windowMs' value will be used instead, which may cause clients to wait longer than necessary.`);
    }
  },
  validationsConfig() {
    const supportedValidations = Object.keys(this).filter((k) => !["enabled", "disable"].includes(k));
    supportedValidations.push("default");
    for (const key of Object.keys(this.enabled)) {
      if (!supportedValidations.includes(key)) {
        throw new ValidationError("ERR_ERL_UNKNOWN_VALIDATION", `options.validate.${key} is not recognized. Supported validate options are: ${supportedValidations.join(", ")}.`);
      }
    }
  },
  creationStack(store) {
    const { stack } = new Error("express-rate-limit validation check (set options.validate.creationStack=false to disable)");
    if (stack?.includes("Layer.handle [as handle_request]")) {
      if (!store.localKeys) {
        throw new ValidationError("ERR_ERL_CREATED_IN_REQUEST_HANDLER", "express-rate-limit instance should *usually* be created at app initialization, not when responding to a request.");
      }
      throw new ValidationError("ERR_ERL_CREATED_IN_REQUEST_HANDLER", `express-rate-limit instance should be created at app initialization, not when responding to a request.`);
    }
  }
};
var getValidations = (_enabled) => {
  let enabled;
  if (typeof _enabled === "boolean") {
    enabled = {
      default: _enabled
    };
  } else {
    enabled = {
      default: true,
      ..._enabled
    };
  }
  const wrappedValidations = {
    enabled
  };
  for (const [name, validation] of Object.entries(validations)) {
    if (typeof validation === "function")
      wrappedValidations[name] = (...args) => {
        if (!(enabled[name] ?? enabled.default)) {
          return;
        }
        try {
          validation.apply(wrappedValidations, args);
        } catch (error) {
          if (error instanceof ChangeWarning)
            console.warn(error);
          else
            console.error(error);
        }
      };
  }
  return wrappedValidations;
};
var MemoryStore = class {
  constructor() {
    this.previous = /* @__PURE__ */ new Map;
    this.current = /* @__PURE__ */ new Map;
    this.localKeys = true;
  }
  init(options) {
    this.windowMs = options.windowMs;
    if (this.interval)
      clearInterval(this.interval);
    this.interval = setInterval(() => {
      this.clearExpired();
    }, this.windowMs);
    if (this.interval.unref)
      this.interval.unref();
  }
  async get(key) {
    return this.current.get(key) ?? this.previous.get(key);
  }
  async increment(key) {
    const client = this.getClient(key);
    const now = Date.now();
    if (client.resetTime.getTime() <= now) {
      this.resetClient(client, now);
    }
    client.totalHits++;
    return client;
  }
  async decrement(key) {
    const client = this.getClient(key);
    if (client.totalHits > 0)
      client.totalHits--;
  }
  async resetKey(key) {
    this.current.delete(key);
    this.previous.delete(key);
  }
  async resetAll() {
    this.current.clear();
    this.previous.clear();
  }
  shutdown() {
    clearInterval(this.interval);
    this.resetAll();
  }
  resetClient(client, now = Date.now()) {
    client.totalHits = 0;
    client.resetTime.setTime(now + this.windowMs);
    return client;
  }
  getClient(key) {
    if (this.current.has(key))
      return this.current.get(key);
    let client;
    if (this.previous.has(key)) {
      client = this.previous.get(key);
      this.previous.delete(key);
    } else {
      client = { totalHits: 0, resetTime: /* @__PURE__ */ new Date };
      this.resetClient(client);
    }
    this.current.set(key, client);
    return client;
  }
  clearExpired() {
    this.previous = this.current;
    this.current = /* @__PURE__ */ new Map;
  }
};
var isLegacyStore = (store) => typeof store.incr === "function" && typeof store.increment !== "function";
var promisifyStore = (passedStore) => {
  if (!isLegacyStore(passedStore)) {
    return passedStore;
  }
  const legacyStore = passedStore;

  class PromisifiedStore {
    async increment(key) {
      return new Promise((resolve, reject) => {
        legacyStore.incr(key, (error, totalHits, resetTime) => {
          if (error)
            reject(error);
          resolve({ totalHits, resetTime });
        });
      });
    }
    async decrement(key) {
      return legacyStore.decrement(key);
    }
    async resetKey(key) {
      return legacyStore.resetKey(key);
    }
    async resetAll() {
      if (typeof legacyStore.resetAll === "function")
        return legacyStore.resetAll();
    }
  }
  return new PromisifiedStore;
};
var getOptionsFromConfig = (config) => {
  const { validations: validations2, ...directlyPassableEntries } = config;
  return {
    ...directlyPassableEntries,
    validate: validations2.enabled
  };
};
var omitUndefinedOptions = (passedOptions) => {
  const omittedOptions = {};
  for (const k of Object.keys(passedOptions)) {
    const key = k;
    if (passedOptions[key] !== undefined) {
      omittedOptions[key] = passedOptions[key];
    }
  }
  return omittedOptions;
};
var parseOptions = (passedOptions) => {
  const notUndefinedOptions = omitUndefinedOptions(passedOptions);
  const validations2 = getValidations(notUndefinedOptions?.validate ?? true);
  validations2.validationsConfig();
  validations2.draftPolliHeaders(notUndefinedOptions.draft_polli_ratelimit_headers);
  validations2.onLimitReached(notUndefinedOptions.onLimitReached);
  let standardHeaders = notUndefinedOptions.standardHeaders ?? false;
  if (standardHeaders === true)
    standardHeaders = "draft-6";
  const config = {
    windowMs: 60 * 1000,
    limit: passedOptions.max ?? 5,
    message: "Too many requests, please try again later.",
    statusCode: 429,
    legacyHeaders: passedOptions.headers ?? true,
    identifier(request, _response) {
      let duration = "";
      const property = config.requestPropertyName;
      const { limit } = request[property];
      const seconds = config.windowMs / 1000;
      const minutes = config.windowMs / (1000 * 60);
      const hours = config.windowMs / (1000 * 60 * 60);
      const days = config.windowMs / (1000 * 60 * 60 * 24);
      if (seconds < 60)
        duration = `${seconds}sec`;
      else if (minutes < 60)
        duration = `${minutes}min`;
      else if (hours < 24)
        duration = `${hours}hr${hours > 1 ? "s" : ""}`;
      else
        duration = `${days}day${days > 1 ? "s" : ""}`;
      return `${limit}-in-${duration}`;
    },
    requestPropertyName: "rateLimit",
    skipFailedRequests: false,
    skipSuccessfulRequests: false,
    requestWasSuccessful: (_request, response) => response.statusCode < 400,
    skip: (_request, _response) => false,
    keyGenerator(request, _response) {
      validations2.ip(request.ip);
      validations2.trustProxy(request);
      validations2.xForwardedForHeader(request);
      return request.ip;
    },
    async handler(request, response, _next, _optionsUsed) {
      response.status(config.statusCode);
      const message = typeof config.message === "function" ? await config.message(request, response) : config.message;
      if (!response.writableEnded) {
        response.send(message);
      }
    },
    passOnStoreError: false,
    ...notUndefinedOptions,
    standardHeaders,
    store: promisifyStore(notUndefinedOptions.store ?? new MemoryStore),
    validations: validations2
  };
  if (typeof config.store.increment !== "function" || typeof config.store.decrement !== "function" || typeof config.store.resetKey !== "function" || config.store.resetAll !== undefined && typeof config.store.resetAll !== "function" || config.store.init !== undefined && typeof config.store.init !== "function") {
    throw new TypeError("An invalid store was passed. Please ensure that the store is a class that implements the `Store` interface.");
  }
  return config;
};
var handleAsyncErrors = (fn) => async (request, response, next) => {
  try {
    await Promise.resolve(fn(request, response, next)).catch(next);
  } catch (error) {
    next(error);
  }
};
var rateLimit = (passedOptions) => {
  const config = parseOptions(passedOptions ?? {});
  const options = getOptionsFromConfig(config);
  config.validations.creationStack(config.store);
  config.validations.unsharedStore(config.store);
  if (typeof config.store.init === "function")
    config.store.init(options);
  const middleware = handleAsyncErrors(async (request, response, next) => {
    const skip = await config.skip(request, response);
    if (skip) {
      next();
      return;
    }
    const augmentedRequest = request;
    const key = await config.keyGenerator(request, response);
    let totalHits = 0;
    let resetTime;
    try {
      const incrementResult = await config.store.increment(key);
      totalHits = incrementResult.totalHits;
      resetTime = incrementResult.resetTime;
    } catch (error) {
      if (config.passOnStoreError) {
        console.error("express-rate-limit: error from store, allowing request without rate-limiting.", error);
        next();
        return;
      }
      throw error;
    }
    config.validations.positiveHits(totalHits);
    config.validations.singleCount(request, config.store, key);
    const retrieveLimit = typeof config.limit === "function" ? config.limit(request, response) : config.limit;
    const limit = await retrieveLimit;
    config.validations.limit(limit);
    const info = {
      limit,
      used: totalHits,
      remaining: Math.max(limit - totalHits, 0),
      resetTime
    };
    Object.defineProperty(info, "current", {
      configurable: false,
      enumerable: false,
      value: totalHits
    });
    augmentedRequest[config.requestPropertyName] = info;
    if (config.legacyHeaders && !response.headersSent) {
      setLegacyHeaders(response, info);
    }
    if (config.standardHeaders && !response.headersSent) {
      switch (config.standardHeaders) {
        case "draft-6": {
          setDraft6Headers(response, info, config.windowMs);
          break;
        }
        case "draft-7": {
          config.validations.headersResetTime(info.resetTime);
          setDraft7Headers(response, info, config.windowMs);
          break;
        }
        case "draft-8": {
          const retrieveName = typeof config.identifier === "function" ? config.identifier(request, response) : config.identifier;
          const name = await retrieveName;
          config.validations.headersResetTime(info.resetTime);
          setDraft8Headers(response, info, config.windowMs, name, key);
          break;
        }
        default: {
          config.validations.headersDraftVersion(config.standardHeaders);
          break;
        }
      }
    }
    if (config.skipFailedRequests || config.skipSuccessfulRequests) {
      let decremented = false;
      const decrementKey = async () => {
        if (!decremented) {
          await config.store.decrement(key);
          decremented = true;
        }
      };
      if (config.skipFailedRequests) {
        response.on("finish", async () => {
          if (!await config.requestWasSuccessful(request, response))
            await decrementKey();
        });
        response.on("close", async () => {
          if (!response.writableEnded)
            await decrementKey();
        });
        response.on("error", async () => {
          await decrementKey();
        });
      }
      if (config.skipSuccessfulRequests) {
        response.on("finish", async () => {
          if (await config.requestWasSuccessful(request, response))
            await decrementKey();
        });
      }
    }
    config.validations.disable();
    if (totalHits > limit) {
      if (config.legacyHeaders || config.standardHeaders) {
        setRetryAfterHeader(response, info, config.windowMs);
      }
      config.handler(request, response, next, options);
      return;
    }
    next();
  });
  const getThrowFn = () => {
    throw new Error("The current store does not support the get/getKey method");
  };
  middleware.resetKey = config.store.resetKey.bind(config.store);
  middleware.getKey = typeof config.store.get === "function" ? config.store.get.bind(config.store) : getThrowFn;
  return middleware;
};
var lib_default = rateLimit;

// src/api/shared/middleware.ts
var securityMiddleware = () => {
  return (req, res, next) => {
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("X-Frame-Options", "SAMEORIGIN");
    res.setHeader("X-XSS-Protection", "1; mode=block");
    res.setHeader("Referrer-Policy", "no-referrer");
    res.removeHeader("X-Powered-By");
    res.removeHeader("Server");
    const userAgent = req.get("User-Agent");
    const forwarded = req.get("X-Forwarded-For");
    const realIp = req.get("X-Real-IP");
    const clientIp = forwarded || realIp || req.ip;
    if (userAgent && (userAgent.includes("..") || userAgent.includes("<script"))) {
      logger11.warn(`[SECURITY] Suspicious User-Agent from ${clientIp}: ${userAgent}`);
    }
    const url = req.originalUrl || req.url;
    const queryString = JSON.stringify(req.query);
    const suspiciousIndicators = [
      { pattern: "..", name: "Path traversal" },
      { pattern: "<script", name: "XSS attempt" },
      { pattern: "javascript:", name: "JavaScript injection" }
    ];
    const sqlKeywords = ["union", "select", "drop", "delete", "insert", "update"];
    let hasSqlPattern = false;
    const lowerUrl = url.toLowerCase();
    const lowerQuery = queryString.toLowerCase();
    for (let i = 0;i < sqlKeywords.length - 1; i++) {
      const keyword1 = sqlKeywords[i];
      for (let j = i + 1;j < sqlKeywords.length; j++) {
        const keyword2 = sqlKeywords[j];
        if (lowerUrl.includes(keyword1) && lowerUrl.includes(keyword2) || lowerQuery.includes(keyword1) && lowerQuery.includes(keyword2)) {
          hasSqlPattern = true;
          break;
        }
      }
      if (hasSqlPattern)
        break;
    }
    for (const indicator of suspiciousIndicators) {
      if (url.includes(indicator.pattern) || queryString.includes(indicator.pattern)) {
        logger11.warn(`[SECURITY] ${indicator.name} detected from ${clientIp}: ${url}`);
        break;
      }
    }
    if (hasSqlPattern) {
      logger11.warn(`[SECURITY] SQL injection pattern detected from ${clientIp}: ${url}`);
    }
    next();
  };
};
var validateContentTypeMiddleware = () => {
  return (req, res, next) => {
    if (["POST", "PUT", "PATCH"].includes(req.method)) {
      const contentType = req.get("Content-Type");
      const contentLength = req.get("Content-Length");
      if (!contentLength || contentLength === "0") {
        return next();
      }
      const validTypes = [
        "application/json",
        "multipart/form-data",
        "application/x-www-form-urlencoded"
      ];
      if (!contentType || !validTypes.some((type) => contentType.includes(type))) {
        return sendError(res, 400, "INVALID_CONTENT_TYPE", "Invalid or missing Content-Type header");
      }
    }
    next();
  };
};
var createApiRateLimit = () => {
  return lib_default({
    windowMs: 15 * 60 * 1000,
    max: 1000,
    message: {
      success: false,
      error: {
        code: "RATE_LIMIT_EXCEEDED",
        message: "Too many requests. Please try again later."
      }
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
      const clientIp = req.ip || "unknown";
      logger11.warn(`[SECURITY] Rate limit exceeded for IP: ${clientIp}`);
      res.status(429).json({
        success: false,
        error: {
          code: "RATE_LIMIT_EXCEEDED",
          message: "Too many requests. Please try again later."
        }
      });
    }
  });
};
var createFileSystemRateLimit = () => {
  return lib_default({
    windowMs: 5 * 60 * 1000,
    max: 100,
    message: {
      success: false,
      error: {
        code: "FILE_RATE_LIMIT_EXCEEDED",
        message: "Too many file operations. Please try again later."
      }
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
      const clientIp = req.ip || "unknown";
      logger11.warn(`[SECURITY] File system rate limit exceeded for IP: ${clientIp}, endpoint: ${req.path}`);
      res.status(429).json({
        success: false,
        error: {
          code: "FILE_RATE_LIMIT_EXCEEDED",
          message: "Too many file operations. Please try again later."
        }
      });
    }
  });
};
var createUploadRateLimit = () => {
  return lib_default({
    windowMs: 15 * 60 * 1000,
    max: 50,
    message: {
      success: false,
      error: {
        code: "UPLOAD_RATE_LIMIT_EXCEEDED",
        message: "Too many upload attempts. Please try again later."
      }
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
      const clientIp = req.ip || "unknown";
      logger11.warn(`[SECURITY] Upload rate limit exceeded for IP: ${clientIp}, endpoint: ${req.path}`);
      res.status(429).json({
        success: false,
        error: {
          code: "UPLOAD_RATE_LIMIT_EXCEEDED",
          message: "Too many upload attempts. Please try again later."
        }
      });
    }
  });
};

// src/api/shared/constants.ts
var MAX_FILE_SIZE = 50 * 1024 * 1024;
var MAX_FILE_SIZE_DISPLAY = "50MB";
var ALLOWED_AUDIO_MIME_TYPES = [
  "audio/mpeg",
  "audio/mp3",
  "audio/wav",
  "audio/ogg",
  "audio/webm",
  "audio/mp4",
  "audio/aac",
  "audio/flac",
  "audio/x-wav",
  "audio/wave"
];
var ALLOWED_MEDIA_MIME_TYPES = [
  ...ALLOWED_AUDIO_MIME_TYPES,
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "video/mp4",
  "video/webm",
  "application/pdf",
  "text/plain"
];

// src/api/messaging/channels.ts
import multer from "multer";
import fs from "fs";
import path2 from "path";
var DEFAULT_SERVER_ID3 = "00000000-0000-0000-0000-000000000000";
var channelStorage = multer.memoryStorage();
var channelUploadMiddleware = multer({
  storage: channelStorage,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 1
  },
  fileFilter: (_req, file, cb) => {
    const isAllowed = ALLOWED_MEDIA_MIME_TYPES.some((allowed) => allowed === file.mimetype);
    if (isAllowed) {
      cb(null, true);
    } else {
      cb(new Error(`Invalid file type. Only ${ALLOWED_MEDIA_MIME_TYPES.join(", ")} are allowed`));
    }
  }
});
async function saveChannelUploadedFile(file, channelId) {
  const uploadDir = path2.join(getUploadsChannelsDir2(), channelId);
  if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
  }
  const timestamp = Date.now();
  const random = Math.round(Math.random() * 1e9);
  const ext = path2.extname(file.originalname);
  const filename = `${timestamp}-${random}${ext}`;
  const filePath = path2.join(uploadDir, filename);
  fs.writeFileSync(filePath, file.buffer);
  const url = `/media/uploads/channels/${channelId}/${filename}`;
  return { filename, url };
}
function createChannelsRouter(agents, serverInstance) {
  const router = express12.Router();
  router.post("/central-channels/:channelId/messages", async (req, res) => {
    const channelIdParam = validateUuid13(req.params.channelId);
    const {
      author_id,
      content,
      in_reply_to_message_id,
      server_id,
      raw_message,
      metadata,
      source_type
    } = req.body;
    const isValidServerId = server_id === DEFAULT_SERVER_ID3 || validateUuid13(server_id);
    if (!channelIdParam || !validateUuid13(author_id) || !content || !isValidServerId) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: channelId, server_id, author_id, content"
      });
    }
    try {
      logger12.info(`[Messages Router] Checking if channel ${channelIdParam} exists before creating message`);
      let channelExists = false;
      try {
        const existingChannel = await serverInstance.getChannelDetails(channelIdParam);
        channelExists = !!existingChannel;
        logger12.info(`[Messages Router] Channel ${channelIdParam} exists: ${channelExists}`);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger12.info(`[Messages Router] Channel ${channelIdParam} does not exist, will create it. Error: ${errorMessage}`);
      }
      if (!channelExists) {
        logger12.info(`[Messages Router] Auto-creating channel ${channelIdParam} with serverId ${server_id}`);
        try {
          const servers = await serverInstance.getServers();
          const serverExists = servers.some((s) => s.id === server_id);
          logger12.info(`[Messages Router] Server ${server_id} exists: ${serverExists}. Available servers: ${servers.map((s) => s.id).join(", ")}`);
          if (!serverExists) {
            logger12.error(`[Messages Router] Server ${server_id} does not exist, cannot create channel`);
            return res.status(500).json({ success: false, error: `Server ${server_id} does not exist` });
          }
          const isDmChannel = metadata?.isDm || metadata?.channelType === ChannelType2.DM || metadata?.channel_type === ChannelType2.DM;
          const channelData = {
            id: channelIdParam,
            messageServerId: server_id,
            name: isDmChannel ? `DM ${channelIdParam.substring(0, 8)}` : `Chat ${channelIdParam.substring(0, 8)}`,
            type: isDmChannel ? ChannelType2.DM : ChannelType2.GROUP,
            sourceType: "auto_created",
            metadata: {
              created_by: "gui_auto_creation",
              created_for_user: author_id,
              created_at: new Date().toISOString(),
              channel_type: isDmChannel ? ChannelType2.DM : ChannelType2.GROUP,
              ...metadata
            }
          };
          logger12.info("[Messages Router] Creating channel with data:", JSON.stringify(channelData, null, 2));
          const participants = [author_id];
          if (isDmChannel) {
            const otherParticipant = metadata?.targetUserId || metadata?.recipientId;
            if (otherParticipant && validateUuid13(otherParticipant)) {
              participants.push(otherParticipant);
              logger12.info(`[Messages Router] DM channel will include participants: ${participants.join(", ")}`);
            } else {
              logger12.warn(`[Messages Router] DM channel missing second participant, only adding author: ${author_id}`);
            }
          }
          await serverInstance.createChannel(channelData, participants);
          logger12.info(`[Messages Router] Auto-created ${isDmChannel ? ChannelType2.DM : ChannelType2.GROUP} channel ${channelIdParam} for message submission with ${participants.length} participants`);
        } catch (createError) {
          const errorMessage = createError instanceof Error ? createError.message : String(createError);
          logger12.error(`[Messages Router] Failed to auto-create channel ${channelIdParam}:`, createError instanceof Error ? createError.message : String(createError));
          return res.status(500).json({ success: false, error: `Failed to create channel: ${errorMessage}` });
        }
      } else {
        logger12.info(`[Messages Router] Channel ${channelIdParam} already exists, proceeding with message creation`);
      }
      const newRootMessageData = {
        channelId: channelIdParam,
        authorId: author_id,
        content,
        inReplyToRootMessageId: in_reply_to_message_id ? validateUuid13(in_reply_to_message_id) || undefined : undefined,
        rawMessage: raw_message,
        metadata,
        sourceType: source_type || "eliza_gui"
      };
      const createdRootMessage = await serverInstance.createMessage(newRootMessageData);
      if (!createdRootMessage.id) {
        throw new Error("Created message does not have an ID");
      }
      const messageForBus = {
        id: createdRootMessage.id,
        channel_id: createdRootMessage.channelId,
        server_id,
        author_id: createdRootMessage.authorId,
        content: createdRootMessage.content,
        created_at: new Date(createdRootMessage.createdAt).getTime(),
        source_type: createdRootMessage.sourceType,
        raw_message: createdRootMessage.rawMessage,
        metadata: createdRootMessage.metadata,
        author_display_name: metadata?.user_display_name,
        in_reply_to_message_id: createdRootMessage.inReplyToRootMessageId,
        source_id: createdRootMessage.sourceId
      };
      bus_default.emit("new_message", messageForBus);
      logger12.info("[Messages Router /central-channels/:channelId/messages] GUI Message published to internal bus:", messageForBus.id);
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(channelIdParam).emit("messageBroadcast", {
          senderId: author_id,
          senderName: metadata?.user_display_name || "User",
          text: content,
          roomId: channelIdParam,
          serverId: server_id,
          createdAt: messageForBus.created_at,
          source: messageForBus.source_type,
          id: messageForBus.id
        });
      }
      res.status(201).json({ success: true, data: messageForBus });
    } catch (error) {
      logger12.error("[Messages Router /central-channels/:channelId/messages] Error processing GUI message:", error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to process message" });
    }
  });
  router.get("/central-channels/:channelId/messages", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    const limit = req.query.limit ? Number.parseInt(req.query.limit, 10) : 50;
    const before = req.query.before ? Number.parseInt(req.query.before, 10) : undefined;
    const beforeDate = before ? new Date(before) : undefined;
    if (!channelId) {
      return res.status(400).json({ success: false, error: "Invalid channelId" });
    }
    try {
      const messages = await serverInstance.getMessagesForChannel(channelId, limit, beforeDate);
      const messagesForGui = messages.map((msg) => {
        let rawMessage = {};
        try {
          rawMessage = typeof msg.rawMessage === "string" ? JSON.parse(msg.rawMessage) : msg.rawMessage;
        } catch (e) {
          logger12.warn("[Messages Router] Failed to parse rawMessage for message", msg.id);
        }
        const { content, metadata } = transformMessageAttachments({
          content: msg.content,
          metadata: {
            ...msg.metadata,
            thought: rawMessage?.thought,
            actions: rawMessage?.actions,
            attachments: rawMessage?.attachments ?? msg.metadata?.attachments
          }
        });
        return {
          ...msg,
          content,
          metadata,
          created_at: new Date(msg.createdAt).getTime(),
          updated_at: new Date(msg.updatedAt).getTime()
        };
      });
      res.json({ success: true, data: { messages: messagesForGui } });
    } catch (error) {
      logger12.error(`[Messages Router /central-channels/:channelId/messages] Error fetching messages for channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to fetch messages" });
    }
  });
  router.get("/central-servers/:serverId/channels", async (req, res) => {
    const serverId = req.params.serverId === DEFAULT_SERVER_ID3 ? DEFAULT_SERVER_ID3 : validateUuid13(req.params.serverId);
    if (!serverId) {
      return res.status(400).json({ success: false, error: "Invalid serverId" });
    }
    try {
      const channels = await serverInstance.getChannelsForServer(serverId);
      res.json({ success: true, data: { channels } });
    } catch (error) {
      logger12.error(`[Messages Router /central-servers/:serverId/channels] Error fetching channels for server ${serverId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to fetch channels" });
    }
  });
  router.post("/channels", async (req, res) => {
    const serverId = req.body.serverId;
    const { name, type, sourceType, sourceId, metadata } = req.body;
    const topic = req.body.topic ?? req.body.description;
    if (!serverId) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: serverId."
      });
    }
    if (!name) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: name."
      });
    }
    if (!type) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: type."
      });
    }
    if (!validateUuid13(serverId)) {
      return res.status(400).json({
        success: false,
        error: "Invalid serverId format"
      });
    }
    try {
      const channel = await serverInstance.createChannel({
        messageServerId: serverId,
        name,
        type,
        sourceType,
        sourceId,
        topic,
        metadata
      });
      res.status(201).json({ success: true, data: { channel } });
    } catch (error) {
      logger12.error("[Messages Router /channels] Error creating channel:", error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to create channel" });
    }
  });
  router.get("/dm-channel", async (req, res) => {
    const targetUserId = validateUuid13(req.query.targetUserId);
    const currentUserId = validateUuid13(req.query.currentUserId);
    const providedDmServerId = req.query.dmServerId === DEFAULT_SERVER_ID3 ? DEFAULT_SERVER_ID3 : validateUuid13(req.query.dmServerId);
    if (!targetUserId || !currentUserId) {
      res.status(400).json({ success: false, error: "Missing targetUserId or currentUserId" });
      return;
    }
    if (targetUserId === currentUserId) {
      res.status(400).json({ success: false, error: "Cannot create DM channel with oneself" });
      return;
    }
    let dmServerIdToUse = DEFAULT_SERVER_ID3;
    try {
      if (providedDmServerId) {
        const existingServer = await serverInstance.getServerById(providedDmServerId);
        if (existingServer) {
          dmServerIdToUse = providedDmServerId;
        } else {
          logger12.warn(`Provided dmServerId ${providedDmServerId} not found, using default DM server logic.`);
          dmServerIdToUse = DEFAULT_SERVER_ID3;
        }
      }
      const channel = await serverInstance.findOrCreateCentralDmChannel(currentUserId, targetUserId, dmServerIdToUse);
      res.json({ success: true, data: channel });
    } catch (error) {
      const errorDetails = error instanceof Error ? {
        message: error.message,
        stack: error.stack,
        originalError: error
      } : { message: String(error) };
      logger12.error("Error finding/creating DM channel:", JSON.stringify(errorDetails));
      res.status(500).json({ success: false, error: "Failed to find or create DM channel" });
    }
  });
  router.post("/central-channels", async (req, res) => {
    const {
      name,
      participantCentralUserIds,
      type = ChannelType2.GROUP,
      server_id,
      metadata
    } = req.body;
    const isValidServerId = server_id === DEFAULT_SERVER_ID3 || validateUuid13(server_id);
    if (!name || !isValidServerId || !Array.isArray(participantCentralUserIds) || participantCentralUserIds.some((id) => !validateUuid13(id))) {
      return res.status(400).json({
        success: false,
        error: 'Invalid payload. Required: name, server_id (UUID or "0"), participantCentralUserIds (array of UUIDs). Optional: type, metadata.'
      });
    }
    try {
      const channelData = {
        messageServerId: server_id,
        name,
        type,
        metadata: {
          ...metadata || {}
        }
      };
      const newChannel = await serverInstance.createChannel(channelData, participantCentralUserIds);
      res.status(201).json({ success: true, data: newChannel });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger12.error("[Messages Router /central-channels] Error creating group channel:", errorMessage);
      res.status(500).json({ success: false, error: "Failed to create group channel", details: errorMessage });
    }
  });
  router.get("/central-channels/:channelId/details", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    if (!channelId) {
      return res.status(400).json({ success: false, error: "Invalid channelId" });
    }
    try {
      const channelDetails = await serverInstance.getChannelDetails(channelId);
      if (!channelDetails) {
        return res.status(404).json({ success: false, error: "Channel not found" });
      }
      res.json({ success: true, data: channelDetails });
    } catch (error) {
      logger12.error(`[Messages Router] Error fetching details for channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to fetch channel details" });
    }
  });
  router.get("/central-channels/:channelId/participants", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    if (!channelId) {
      return res.status(400).json({ success: false, error: "Invalid channelId" });
    }
    try {
      const participants = await serverInstance.getChannelParticipants(channelId);
      res.json({ success: true, data: participants });
    } catch (error) {
      logger12.error(`[Messages Router] Error fetching participants for channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to fetch channel participants" });
    }
  });
  router.post("/central-channels/:channelId/agents", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    const { agentId } = req.body;
    if (!channelId || !validateUuid13(agentId)) {
      return res.status(400).json({
        success: false,
        error: "Invalid channelId or agentId format"
      });
    }
    try {
      const channel = await serverInstance.getChannelDetails(channelId);
      if (!channel) {
        return res.status(404).json({
          success: false,
          error: "Channel not found"
        });
      }
      await serverInstance.addParticipantsToChannel(channelId, [agentId]);
      logger12.info(`[Messages Router] Added agent ${agentId} to channel ${channelId}`);
      res.status(201).json({
        success: true,
        data: {
          channelId,
          agentId,
          message: "Agent added to channel successfully"
        }
      });
    } catch (error) {
      logger12.error(`[Messages Router] Error adding agent ${agentId} to channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({
        success: false,
        error: "Failed to add agent to channel",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  router.delete("/central-channels/:channelId/agents/:agentId", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    const agentId = validateUuid13(req.params.agentId);
    if (!channelId || !agentId) {
      return res.status(400).json({
        success: false,
        error: "Invalid channelId or agentId format"
      });
    }
    try {
      const channel = await serverInstance.getChannelDetails(channelId);
      if (!channel) {
        return res.status(404).json({
          success: false,
          error: "Channel not found"
        });
      }
      const currentParticipants = await serverInstance.getChannelParticipants(channelId);
      if (!currentParticipants.includes(agentId)) {
        return res.status(404).json({
          success: false,
          error: "Agent is not a participant in this channel"
        });
      }
      const updatedParticipants = currentParticipants.filter((id) => id !== agentId);
      await serverInstance.updateChannel(channelId, {
        participantCentralUserIds: updatedParticipants
      });
      logger12.info(`[Messages Router] Removed agent ${agentId} from channel ${channelId}`);
      res.status(200).json({
        success: true,
        data: {
          channelId,
          agentId,
          message: "Agent removed from channel successfully"
        }
      });
    } catch (error) {
      logger12.error(`[Messages Router] Error removing agent ${agentId} from channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({
        success: false,
        error: "Failed to remove agent from channel",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  router.get("/central-channels/:channelId/agents", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    if (!channelId) {
      return res.status(400).json({
        success: false,
        error: "Invalid channelId format"
      });
    }
    try {
      const allParticipants = await serverInstance.getChannelParticipants(channelId);
      res.json({
        success: true,
        data: {
          channelId,
          participants: allParticipants
        }
      });
    } catch (error) {
      logger12.error(`[Messages Router] Error fetching agents for channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({
        success: false,
        error: "Failed to fetch channel agents"
      });
    }
  });
  router.delete("/central-channels/:channelId/messages/:messageId", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    const messageId = validateUuid13(req.params.messageId);
    if (!channelId || !messageId) {
      return res.status(400).json({ success: false, error: "Invalid channelId or messageId" });
    }
    try {
      await serverInstance.deleteMessage(messageId);
      logger12.info(`[Messages Router] Deleted message ${messageId} from central database`);
      const deletedMessagePayload = {
        messageId,
        channelId
      };
      bus_default.emit("message_deleted", deletedMessagePayload);
      logger12.info(`[Messages Router] Emitted message_deleted event to internal bus for message ${messageId}`);
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(channelId).emit("messageDeleted", {
          messageId,
          channelId
        });
      }
      res.status(204).send();
    } catch (error) {
      logger12.error(`[Messages Router] Error deleting message ${messageId} from channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to delete message" });
    }
  });
  router.delete("/central-channels/:channelId/messages", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    if (!channelId) {
      return res.status(400).json({ success: false, error: "Invalid channelId" });
    }
    try {
      await serverInstance.clearChannelMessages(channelId);
      const channelClearedPayload = {
        channelId
      };
      bus_default.emit("channel_cleared", channelClearedPayload);
      logger12.info(`[Messages Router] Emitted channel_cleared event to internal bus for channel ${channelId}`);
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(channelId).emit("channelCleared", {
          channelId
        });
      }
      res.status(204).send();
    } catch (error) {
      logger12.error(`[Messages Router] Error clearing messages for channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to clear messages" });
    }
  });
  router.patch("/central-channels/:channelId", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    if (!channelId) {
      return res.status(400).json({ success: false, error: "Invalid channelId" });
    }
    const { name, participantCentralUserIds, metadata } = req.body;
    try {
      const updatedChannel = await serverInstance.updateChannel(channelId, {
        name,
        participantCentralUserIds,
        metadata
      });
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(channelId).emit("channelUpdated", {
          channelId,
          updates: updatedChannel
        });
      }
      res.json({ success: true, data: updatedChannel });
    } catch (error) {
      logger12.error(`[Messages Router] Error updating channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to update channel" });
    }
  });
  router.delete("/central-channels/:channelId", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    if (!channelId) {
      return res.status(400).json({ success: false, error: "Invalid channelId" });
    }
    try {
      const messages = await serverInstance.getMessagesForChannel(channelId);
      const messageCount = messages.length;
      await serverInstance.deleteChannel(channelId);
      logger12.info(`[Messages Router] Deleted channel ${channelId} with ${messageCount} messages from central database`);
      const channelClearedPayload = {
        channelId
      };
      bus_default.emit("channel_cleared", channelClearedPayload);
      logger12.info(`[Messages Router] Emitted channel_cleared event to internal bus for deleted channel ${channelId}`);
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(channelId).emit("channelDeleted", {
          channelId
        });
      }
      res.status(204).send();
    } catch (error) {
      logger12.error(`[Messages Router] Error deleting channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to delete channel" });
    }
  });
  router.post("/channels/:channelId/upload-media", createUploadRateLimit(), createFileSystemRateLimit(), channelUploadMiddleware.single("file"), async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    if (!channelId) {
      res.status(400).json({ success: false, error: "Invalid channelId format" });
      return;
    }
    if (!req.file) {
      res.status(400).json({ success: false, error: "No media file provided" });
      return;
    }
    try {
      if (!req.file.originalname || req.file.originalname.includes("..") || req.file.originalname.includes("/")) {
        res.status(400).json({ success: false, error: "Invalid filename detected" });
        return;
      }
      const result = await saveChannelUploadedFile(req.file, channelId);
      logger12.info(`[MessagesRouter /upload-media] Secure file uploaded for channel ${channelId}: ${result.filename}. URL: ${result.url}`);
      res.json({
        success: true,
        data: {
          url: result.url,
          type: req.file.mimetype,
          filename: result.filename,
          originalName: req.file.originalname,
          size: req.file.size
        }
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger12.error(`[MessagesRouter /upload-media] Error processing upload for channel ${channelId}: ${errorMessage}`, error instanceof Error ? error.message : String(error));
      res.status(500).json({ success: false, error: "Failed to process media upload" });
    }
  });
  router.post("/central-channels/:channelId/generate-title", async (req, res) => {
    const channelId = validateUuid13(req.params.channelId);
    const { agentId } = req.body;
    if (!channelId) {
      return res.status(400).json({
        success: false,
        error: "Invalid channel ID format"
      });
    }
    if (!agentId || !validateUuid13(agentId)) {
      return res.status(400).json({
        success: false,
        error: "Valid agent ID is required"
      });
    }
    try {
      const runtime = agents.get(agentId);
      if (!runtime) {
        return res.status(404).json({
          success: false,
          error: "Agent not found or not active"
        });
      }
      logger12.info(`[CHANNEL SUMMARIZE] Summarizing channel ${channelId}`);
      const limit = req.query.limit ? Number.parseInt(req.query.limit, 10) : 50;
      const before = req.query.before ? Number.parseInt(req.query.before, 10) : undefined;
      const beforeDate = before ? new Date(before) : undefined;
      const messages = await serverInstance.getMessagesForChannel(channelId, limit, beforeDate);
      if (!messages || messages.length < 4) {
        return res.status(200).json({
          success: true,
          data: {
            title: null,
            channelId,
            reason: "Not enough messages to generate a title"
          }
        });
      }
      const recentMessages = messages.reverse().map((msg) => {
        const isUser = msg.authorId !== runtime.agentId;
        const role = isUser ? "User" : "Agent";
        return `${role}: ${msg.content}`;
      }).join(`
`);
      const prompt = composePromptFromState({
        state: {
          recentMessages,
          values: {},
          data: {},
          text: recentMessages
        },
        template: `
Based on the conversation below, generate a short, descriptive title for this chat. The title should capture the main topic or theme of the discussion.
Rules:
- Keep it concise (3-6 words)
- Make it descriptive and specific
- Avoid generic terms like "Chat" or "Conversation"
- Focus on the main topic, activity, or subject matter
- Use natural language, not hashtags or symbols
Examples:
- "React Component Help"
- "Weekend Trip Planning"
- "Database Design Discussion"
- "Recipe Exchange"
- "Career Advice Session"
Recent conversation:
{{recentMessages}}
Respond with just the title, nothing else.
            `
      });
      const newTitle = await runtime.useModel(ModelType.TEXT_SMALL, {
        prompt,
        temperature: 0.3,
        maxTokens: 50
      });
      if (!newTitle || newTitle.trim().length === 0) {
        logger12.warn(`[ChatTitleEvaluator] Failed to generate title for room ${channelId}`);
        return;
      }
      const cleanTitle = newTitle.trim().replace(/^["']|["']$/g, "");
      logger12.info(`[ChatTitleEvaluator] Generated title: "${cleanTitle}" for room ${channelId}`);
      const result = {
        title: cleanTitle,
        channelId
      };
      logger12.success(`[CHANNEL SUMMARIZE] Successfully summarized channel ${channelId}`);
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      logger12.error("[CHANNEL SUMMARIZE] Error summarizing channel:", error instanceof Error ? error.message : String(error));
      res.status(500).json({
        success: false,
        error: "Failed to summarize channel",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  return router;
}

// src/api/messaging/sessions.ts
import { logger as logger13, validateUuid as validateUuid14, ChannelType as ChannelType3 } from "@elizaos/core";
import express13 from "express";

// ../../node_modules/uuid/dist/esm/stringify.js
var byteToHex = [];
for (let i = 0;i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// ../../node_modules/uuid/dist/esm/rng.js
import { randomFillSync } from "crypto";
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// ../../node_modules/uuid/dist/esm/native.js
import { randomUUID } from "crypto";
var native_default = { randomUUID };

// ../../node_modules/uuid/dist/esm/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0;i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;
// src/api/messaging/errors/SessionErrors.ts
class SessionError extends Error {
  code;
  statusCode;
  details;
  timestamp;
  constructor(code, message, statusCode = 500, details) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
    this.timestamp = new Date;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  toJSON() {
    return {
      error: {
        code: this.code,
        message: this.message,
        timestamp: this.timestamp.toISOString(),
        ...{
          details: this.details,
          stack: this.stack
        }
      }
    };
  }
}

class SessionNotFoundError extends SessionError {
  constructor(sessionId, details) {
    super("SESSION_NOT_FOUND", `Session with ID '${sessionId}' not found`, 404, details);
  }
}

class SessionExpiredError extends SessionError {
  constructor(sessionId, expiredAt, details) {
    const message = expiredAt ? `Session '${sessionId}' expired at ${expiredAt.toISOString()}` : `Session '${sessionId}' has expired`;
    super("SESSION_EXPIRED", message, 410, details);
  }
}

class SessionCreationError extends SessionError {
  constructor(reason, details) {
    super("SESSION_CREATION_FAILED", `Failed to create session: ${reason}`, 500, details);
  }
}

class AgentNotFoundError extends SessionError {
  constructor(agentId, details) {
    super("AGENT_NOT_FOUND", `Agent with ID '${agentId}' not found`, 404, details);
  }
}

class ValidationError2 extends SessionError {
  field;
  value;
  constructor(message, field, value, details) {
    super("VALIDATION_ERROR", message, 400, details);
    this.field = field;
    this.value = value;
  }
}

class InvalidUuidError extends ValidationError2 {
  constructor(field, value) {
    super(`Invalid UUID format for field '${field}'`, field, value, {
      providedValue: value,
      expectedFormat: "UUID v4"
    });
  }
}

class MissingFieldsError extends ValidationError2 {
  constructor(fields) {
    super(`Missing required fields: ${fields.join(", ")}`, undefined, undefined, {
      missingFields: fields
    });
  }
}

class InvalidContentError extends ValidationError2 {
  constructor(reason, content) {
    super(`Invalid content: ${reason}`, "content", content, { reason });
  }
}

class InvalidMetadataError extends ValidationError2 {
  constructor(reason, metadata) {
    super(`Invalid metadata: ${reason}`, "metadata", metadata, {
      reason,
      providedMetadata: metadata
    });
  }
}

class InvalidPaginationError extends ValidationError2 {
  constructor(parameter, value, reason) {
    super(`Invalid pagination parameter '${parameter}': ${reason}`, parameter, value, {
      parameter,
      value,
      reason
    });
  }
}

class InvalidTimeoutConfigError extends ValidationError2 {
  constructor(reason, config) {
    super(`Invalid timeout configuration: ${reason}`, "timeoutConfig", config, {
      reason,
      providedConfig: config
    });
  }
}

class SessionRenewalError extends SessionError {
  constructor(sessionId, reason, details) {
    super("SESSION_RENEWAL_FAILED", `Cannot renew session '${sessionId}': ${reason}`, 400, details);
  }
}
class MessageSendError extends SessionError {
  constructor(sessionId, reason, details) {
    super("MESSAGE_SEND_FAILED", `Failed to send message in session '${sessionId}': ${reason}`, 500, details);
  }
}
function createErrorHandler() {
  return (err, _req, res, next) => {
    if (res.headersSent) {
      return next(err);
    }
    if (err instanceof SessionError) {
      return res.status(err.statusCode).json(err.toJSON());
    }
    if (err.name === "ValidationError") {
      return res.status(400).json({
        error: {
          code: "VALIDATION_ERROR",
          message: err.message,
          timestamp: new Date().toISOString()
        }
      });
    }
    console.error("Unexpected error:", err);
    return res.status(500).json({
      error: {
        code: "INTERNAL_SERVER_ERROR",
        message: "An unexpected error occurred",
        timestamp: new Date().toISOString(),
        ...{
          details: err.message,
          stack: err.stack
        }
      }
    });
  };
}

// src/api/messaging/sessions.ts
function safeParseInt(value, fallback, min, max) {
  if (!value) {
    return fallback;
  }
  const parsed = parseInt(value, 10);
  if (isNaN(parsed) || !isFinite(parsed)) {
    logger13.warn(`[Sessions API] Invalid integer value: "${value}", using fallback: ${fallback}`);
    return fallback;
  }
  let result = parsed;
  if (min !== undefined && result < min) {
    logger13.warn(`[Sessions API] Value ${result} is below minimum ${min}, clamping to minimum`);
    result = min;
  }
  if (max !== undefined && result > max) {
    logger13.warn(`[Sessions API] Value ${result} is above maximum ${max}, clamping to maximum`);
    result = max;
  }
  return result;
}
var DEFAULT_TIMEOUT_MINUTES = safeParseInt(process.env.SESSION_DEFAULT_TIMEOUT_MINUTES, 30, 1, 10080);
var MIN_TIMEOUT_MINUTES = safeParseInt(process.env.SESSION_MIN_TIMEOUT_MINUTES, 5, 1, 60);
var MAX_TIMEOUT_MINUTES = safeParseInt(process.env.SESSION_MAX_TIMEOUT_MINUTES, 1440, 60, 10080);
var DEFAULT_MAX_DURATION_MINUTES = safeParseInt(process.env.SESSION_MAX_DURATION_MINUTES, 720, 60, 20160);
var DEFAULT_WARNING_THRESHOLD_MINUTES = safeParseInt(process.env.SESSION_WARNING_THRESHOLD_MINUTES, 5, 1, 60);
var CLEANUP_INTERVAL_MS = safeParseInt(process.env.SESSION_CLEANUP_INTERVAL_MINUTES, 5, 1, 60) * 60 * 1000;
var sessions = new Map;
var DEFAULT_SERVER_ID4 = "00000000-0000-0000-0000-000000000000";
var agentTimeoutConfigs = new Map;
var activeCleanupIntervals = new Set;
var processHandlersRegistered = false;
function isValidSession(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  const session = obj;
  return typeof session.id === "string" && typeof session.agentId === "string" && typeof session.channelId === "string" && typeof session.userId === "string" && session.createdAt instanceof Date && session.lastActivity instanceof Date && session.expiresAt instanceof Date && typeof session.renewalCount === "number" && session.timeoutConfig !== undefined && typeof session.timeoutConfig === "object";
}
function isCreateSessionRequest(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  const req = obj;
  return typeof req.agentId === "string" && typeof req.userId === "string";
}
function isSendMessageRequest(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  const req = obj;
  return typeof req.content === "string";
}
function isValidTimeoutConfig(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  const config = obj;
  return (config.timeoutMinutes === undefined || typeof config.timeoutMinutes === "number" || typeof config.timeoutMinutes === "string") && (config.autoRenew === undefined || typeof config.autoRenew === "boolean") && (config.maxDurationMinutes === undefined || typeof config.maxDurationMinutes === "number" || typeof config.maxDurationMinutes === "string") && (config.warningThresholdMinutes === undefined || typeof config.warningThresholdMinutes === "number" || typeof config.warningThresholdMinutes === "string");
}
var MAX_CONTENT_LENGTH = 4000;
var MAX_METADATA_SIZE = 1024 * 10;
var MAX_LIMIT = 100;
var DEFAULT_LIMIT = 50;
function getAgentTimeoutConfig(agent) {
  if (agentTimeoutConfigs.has(agent.agentId)) {
    return agentTimeoutConfigs.get(agent.agentId);
  }
  const timeoutSetting = agent.getSetting("SESSION_TIMEOUT_MINUTES");
  const maxDurationSetting = agent.getSetting("SESSION_MAX_DURATION_MINUTES");
  const warningThresholdSetting = agent.getSetting("SESSION_WARNING_THRESHOLD_MINUTES");
  const agentConfig = {
    timeoutMinutes: timeoutSetting ? safeParseInt(String(timeoutSetting), DEFAULT_TIMEOUT_MINUTES, MIN_TIMEOUT_MINUTES, MAX_TIMEOUT_MINUTES) : DEFAULT_TIMEOUT_MINUTES,
    autoRenew: agent.getSetting("SESSION_AUTO_RENEW") ? agent.getSetting("SESSION_AUTO_RENEW") === "true" : true,
    maxDurationMinutes: maxDurationSetting ? safeParseInt(String(maxDurationSetting), DEFAULT_MAX_DURATION_MINUTES, MIN_TIMEOUT_MINUTES, MAX_TIMEOUT_MINUTES * 2) : DEFAULT_MAX_DURATION_MINUTES,
    warningThresholdMinutes: warningThresholdSetting ? safeParseInt(String(warningThresholdSetting), DEFAULT_WARNING_THRESHOLD_MINUTES, 1, MAX_TIMEOUT_MINUTES) : DEFAULT_WARNING_THRESHOLD_MINUTES
  };
  agentTimeoutConfigs.set(agent.agentId, agentConfig);
  return agentConfig;
}
function mergeTimeoutConfigs(sessionConfig, agentConfig) {
  const merged = {
    timeoutMinutes: DEFAULT_TIMEOUT_MINUTES,
    autoRenew: true,
    maxDurationMinutes: DEFAULT_MAX_DURATION_MINUTES,
    warningThresholdMinutes: DEFAULT_WARNING_THRESHOLD_MINUTES
  };
  if (agentConfig) {
    Object.assign(merged, agentConfig);
  }
  if (sessionConfig) {
    if (sessionConfig.timeoutMinutes !== undefined) {
      const timeoutValue = Number(sessionConfig.timeoutMinutes);
      if (isNaN(timeoutValue) || !isFinite(timeoutValue)) {
        logger13.warn(`[Sessions API] Invalid timeout minutes in session config: ${sessionConfig.timeoutMinutes}, using default`);
        merged.timeoutMinutes = DEFAULT_TIMEOUT_MINUTES;
      } else {
        const timeout = Math.max(MIN_TIMEOUT_MINUTES, Math.min(MAX_TIMEOUT_MINUTES, timeoutValue));
        merged.timeoutMinutes = timeout;
      }
    }
    if (sessionConfig.autoRenew !== undefined) {
      merged.autoRenew = sessionConfig.autoRenew;
    }
    if (sessionConfig.maxDurationMinutes !== undefined) {
      const maxDurationValue = Number(sessionConfig.maxDurationMinutes);
      if (isNaN(maxDurationValue) || !isFinite(maxDurationValue)) {
        logger13.warn(`[Sessions API] Invalid max duration minutes in session config: ${sessionConfig.maxDurationMinutes}, using default`);
        merged.maxDurationMinutes = DEFAULT_MAX_DURATION_MINUTES;
      } else {
        merged.maxDurationMinutes = Math.max(merged.timeoutMinutes, Math.min(MAX_TIMEOUT_MINUTES * 2, maxDurationValue));
      }
    }
    if (sessionConfig.warningThresholdMinutes !== undefined) {
      const warningValue = Number(sessionConfig.warningThresholdMinutes);
      if (isNaN(warningValue) || !isFinite(warningValue)) {
        logger13.warn(`[Sessions API] Invalid warning threshold minutes in session config: ${sessionConfig.warningThresholdMinutes}, using default`);
        merged.warningThresholdMinutes = DEFAULT_WARNING_THRESHOLD_MINUTES;
      } else {
        merged.warningThresholdMinutes = Math.max(1, warningValue);
      }
    }
  }
  return merged;
}
function calculateExpirationDate(createdAt, lastActivity, config, _renewalCount) {
  const baseTime = config.autoRenew ? lastActivity : createdAt;
  const timeoutMs = (config.timeoutMinutes || DEFAULT_TIMEOUT_MINUTES) * 60 * 1000;
  if (config.maxDurationMinutes) {
    const maxDurationMs = config.maxDurationMinutes * 60 * 1000;
    const timeSinceCreation = Date.now() - createdAt.getTime();
    if (timeSinceCreation + timeoutMs > maxDurationMs) {
      return new Date(createdAt.getTime() + maxDurationMs);
    }
  }
  return new Date(baseTime.getTime() + timeoutMs);
}
function shouldWarnAboutExpiration(session) {
  if (session.warningState?.sent) {
    return false;
  }
  const warningThresholdMs = (session.timeoutConfig.warningThresholdMinutes || DEFAULT_WARNING_THRESHOLD_MINUTES) * 60 * 1000;
  const timeRemaining = session.expiresAt.getTime() - Date.now();
  return timeRemaining <= warningThresholdMs && timeRemaining > 0;
}
function renewSession(session) {
  if (!session.timeoutConfig.autoRenew) {
    return false;
  }
  const now = new Date;
  const maxDurationMs = (session.timeoutConfig.maxDurationMinutes || DEFAULT_MAX_DURATION_MINUTES) * 60 * 1000;
  const timeSinceCreation = now.getTime() - session.createdAt.getTime();
  if (timeSinceCreation >= maxDurationMs) {
    return false;
  }
  session.lastActivity = now;
  session.renewalCount++;
  session.expiresAt = calculateExpirationDate(session.createdAt, session.lastActivity, session.timeoutConfig, session.renewalCount);
  session.warningState = undefined;
  logger13.info(`[Sessions API] Renewed session ${session.id}, renewal count: ${session.renewalCount}`);
  return true;
}
function createSessionInfoResponse(session) {
  const now = Date.now();
  const timeRemaining = Math.max(0, session.expiresAt.getTime() - now);
  const warningThresholdMs = (session.timeoutConfig.warningThresholdMinutes || DEFAULT_WARNING_THRESHOLD_MINUTES) * 60 * 1000;
  return {
    sessionId: session.id,
    agentId: session.agentId,
    userId: session.userId,
    createdAt: session.createdAt,
    lastActivity: session.lastActivity,
    metadata: session.metadata,
    expiresAt: session.expiresAt,
    timeoutConfig: session.timeoutConfig,
    renewalCount: session.renewalCount,
    timeRemaining,
    isNearExpiration: timeRemaining <= warningThresholdMs && timeRemaining > 0
  };
}
function validateMetadata(metadata) {
  if (!metadata || typeof metadata !== "object") {
    return;
  }
  const metadataStr = JSON.stringify(metadata);
  if (metadataStr.length > MAX_METADATA_SIZE) {
    throw new InvalidMetadataError(`Metadata exceeds maximum size of ${MAX_METADATA_SIZE} bytes`, metadata);
  }
}
function validateContent(content) {
  if (typeof content !== "string") {
    throw new InvalidContentError("Content must be a string", content);
  }
  if (content.length === 0) {
    throw new InvalidContentError("Content cannot be empty", content);
  }
  if (content.length > MAX_CONTENT_LENGTH) {
    throw new InvalidContentError(`Content exceeds maximum length of ${MAX_CONTENT_LENGTH} characters`, content);
  }
  return true;
}
function asyncHandler(fn) {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}
function createSessionsRouter(agents, serverInstance) {
  const router = express13.Router();
  router.get("/sessions/health", (_req, res) => {
    const now = Date.now();
    let activeSessions = 0;
    let expiringSoon = 0;
    let invalidSessions = 0;
    for (const session of sessions.values()) {
      if (!isValidSession(session)) {
        invalidSessions++;
        continue;
      }
      if (session.expiresAt.getTime() > now) {
        activeSessions++;
        if (shouldWarnAboutExpiration(session)) {
          expiringSoon++;
        }
      }
    }
    const response = {
      status: "healthy",
      activeSessions,
      timestamp: new Date().toISOString(),
      expiringSoon,
      ...invalidSessions > 0 && { invalidSessions },
      uptime: process.uptime()
    };
    res.json(response);
  });
  router.post("/sessions", asyncHandler(async (req, res) => {
    const body = req.body;
    if (!isCreateSessionRequest(body)) {
      throw new MissingFieldsError(["agentId", "userId"]);
    }
    if (!validateUuid14(body.agentId)) {
      throw new InvalidUuidError("agentId", body.agentId);
    }
    if (!validateUuid14(body.userId)) {
      throw new InvalidUuidError("userId", body.userId);
    }
    const agent = agents.get(body.agentId);
    if (!agent) {
      throw new AgentNotFoundError(body.agentId);
    }
    if (body.metadata) {
      validateMetadata(body.metadata);
    }
    const agentTimeoutConfig = getAgentTimeoutConfig(agent);
    const finalTimeoutConfig = mergeTimeoutConfigs(body.timeoutConfig, agentTimeoutConfig);
    logger13.info(`[Sessions API] Creating session with timeout config: agentId=${body.agentId}, timeout=${finalTimeoutConfig.timeoutMinutes}, autoRenew=${finalTimeoutConfig.autoRenew}, maxDuration=${finalTimeoutConfig.maxDurationMinutes}`);
    const sessionId = v4_default();
    const channelId = v4_default();
    try {
      await serverInstance.createChannel({
        id: channelId,
        name: `session-${sessionId}`,
        type: ChannelType3.DM,
        messageServerId: DEFAULT_SERVER_ID4,
        metadata: {
          sessionId,
          agentId: body.agentId,
          userId: body.userId,
          timeoutConfig: finalTimeoutConfig,
          ...body.metadata || {}
        }
      });
      await serverInstance.addParticipantsToChannel(channelId, [body.agentId]);
    } catch (error) {
      throw new SessionCreationError("Failed to create channel or add participants", {
        originalError: error instanceof Error ? error.message : String(error)
      });
    }
    const now = new Date;
    const session = {
      id: sessionId,
      agentId: body.agentId,
      channelId,
      userId: body.userId,
      metadata: body.metadata || {},
      createdAt: now,
      lastActivity: now,
      expiresAt: calculateExpirationDate(now, now, finalTimeoutConfig, 0),
      timeoutConfig: finalTimeoutConfig,
      renewalCount: 0
    };
    sessions.set(sessionId, session);
    const response = {
      sessionId,
      agentId: session.agentId,
      userId: session.userId,
      createdAt: session.createdAt,
      metadata: session.metadata,
      expiresAt: session.expiresAt,
      timeoutConfig: session.timeoutConfig
    };
    res.status(201).json(response);
  }));
  router.get("/sessions/:sessionId", asyncHandler(async (req, res) => {
    const { sessionId } = req.params;
    const session = sessions.get(sessionId);
    if (!session || !isValidSession(session)) {
      throw new SessionNotFoundError(sessionId);
    }
    if (session.expiresAt.getTime() <= Date.now()) {
      sessions.delete(sessionId);
      throw new SessionExpiredError(sessionId, session.expiresAt);
    }
    const response = createSessionInfoResponse(session);
    res.json(response);
  }));
  router.post("/sessions/:sessionId/messages", asyncHandler(async (req, res) => {
    const { sessionId } = req.params;
    const body = req.body;
    if (!isSendMessageRequest(body)) {
      throw new InvalidContentError("Invalid message request format", body);
    }
    const session = sessions.get(sessionId);
    if (!session) {
      throw new SessionNotFoundError(sessionId);
    }
    if (session.expiresAt.getTime() <= Date.now()) {
      sessions.delete(sessionId);
      throw new SessionExpiredError(sessionId, session.expiresAt);
    }
    validateContent(body.content);
    if (body.metadata) {
      validateMetadata(body.metadata);
    }
    const wasRenewed = renewSession(session);
    if (!wasRenewed && session.timeoutConfig.autoRenew) {
      const maxDurationMs = (session.timeoutConfig.maxDurationMinutes || DEFAULT_MAX_DURATION_MINUTES) * 60 * 1000;
      const timeSinceCreation = Date.now() - session.createdAt.getTime();
      if (timeSinceCreation >= maxDurationMs) {
        logger13.warn(`[Sessions API] Session ${sessionId} has reached maximum duration`);
      }
    } else if (!session.timeoutConfig.autoRenew) {
      session.lastActivity = new Date;
    }
    if (shouldWarnAboutExpiration(session)) {
      session.warningState = {
        sent: true,
        sentAt: new Date
      };
      logger13.info(`[Sessions API] Session ${sessionId} is near expiration, warning state set`);
    }
    let message;
    try {
      let channelMetadata = {};
      try {
        const channel = await serverInstance.getChannelDetails(session.channelId);
        if (channel && channel.metadata) {
          channelMetadata = channel.metadata;
        }
      } catch (error) {
        logger13.debug(`[Sessions API] Could not fetch channel metadata for ${session.channelId}: ${error}`);
      }
      const mergedMetadata = {
        ...channelMetadata,
        sessionId,
        ...body.metadata || {}
      };
      message = await serverInstance.createMessage({
        channelId: session.channelId,
        authorId: session.userId,
        content: body.content,
        rawMessage: {
          content: body.content,
          attachments: body.attachments
        },
        sourceType: "user",
        metadata: mergedMetadata
      });
    } catch (error) {
      throw new MessageSendError(sessionId, "Failed to create message in database", {
        originalError: error instanceof Error ? error.message : String(error)
      });
    }
    const response = {
      id: message.id,
      content: message.content,
      authorId: message.authorId,
      createdAt: message.createdAt,
      metadata: message.metadata,
      sessionStatus: {
        expiresAt: session.expiresAt,
        renewalCount: session.renewalCount,
        wasRenewed,
        isNearExpiration: shouldWarnAboutExpiration(session)
      }
    };
    res.status(201).json(response);
  }));
  router.get("/sessions/:sessionId/messages", asyncHandler(async (req, res) => {
    const { sessionId } = req.params;
    const query = {
      limit: req.query.limit,
      before: req.query.before,
      after: req.query.after
    };
    const session = sessions.get(sessionId);
    if (!session) {
      throw new SessionNotFoundError(sessionId);
    }
    if (session.expiresAt.getTime() <= Date.now()) {
      sessions.delete(sessionId);
      throw new SessionExpiredError(sessionId, session.expiresAt);
    }
    let messageLimit = DEFAULT_LIMIT;
    if (query.limit) {
      const parsedLimit = safeParseInt(query.limit, DEFAULT_LIMIT, 1, MAX_LIMIT);
      messageLimit = parsedLimit;
    }
    let beforeDate;
    let afterDate;
    if (query.before) {
      const beforeTimestamp = parseInt(query.before, 10);
      if (isNaN(beforeTimestamp) || !isFinite(beforeTimestamp)) {
        throw new InvalidPaginationError("before", query.before, "Must be a valid timestamp");
      }
      beforeDate = new Date(beforeTimestamp);
      if (isNaN(beforeDate.getTime())) {
        throw new InvalidPaginationError("before", query.before, "Invalid date from timestamp");
      }
    }
    if (query.after) {
      const afterTimestamp = parseInt(query.after, 10);
      if (isNaN(afterTimestamp) || !isFinite(afterTimestamp)) {
        throw new InvalidPaginationError("after", query.after, "Must be a valid timestamp");
      }
      afterDate = new Date(afterTimestamp);
      if (isNaN(afterDate.getTime())) {
        throw new InvalidPaginationError("after", query.after, "Invalid date from timestamp");
      }
    }
    let messages;
    if (afterDate && beforeDate) {
      const fetchLimit = Math.min(500, messageLimit * 10);
      const allMessages = await serverInstance.getMessagesForChannel(session.channelId, fetchLimit, beforeDate);
      messages = allMessages.filter((msg) => msg.createdAt > afterDate && msg.createdAt < beforeDate).slice(0, messageLimit);
      if (allMessages.length === fetchLimit) {
        logger13.debug(`[Sessions API] Range query hit limit of ${fetchLimit} messages`);
      }
    } else if (afterDate) {
      const fetchLimit = Math.min(1000, messageLimit * 20);
      const recentMessages = await serverInstance.getMessagesForChannel(session.channelId, fetchLimit);
      const newerMessages = recentMessages.filter((msg) => msg.createdAt > afterDate);
      if (newerMessages.length > messageLimit) {
        messages = newerMessages.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime()).slice(0, messageLimit).reverse();
      } else {
        messages = newerMessages;
      }
    } else {
      messages = await serverInstance.getMessagesForChannel(session.channelId, messageLimit, beforeDate);
    }
    const simplifiedMessages = messages.map((msg) => {
      let rawMessage = {};
      try {
        const parsedData = typeof msg.rawMessage === "string" ? JSON.parse(msg.rawMessage) : msg.rawMessage;
        if (parsedData && typeof parsedData === "object") {
          rawMessage = parsedData;
        }
      } catch (error) {
        logger13.warn(`[Sessions API] Failed to parse rawMessage for message ${msg.id}`, error instanceof Error ? error.message : String(error));
      }
      const transformedMessage = transformMessageAttachments({
        content: msg.content,
        metadata: {
          ...msg.metadata,
          thought: rawMessage.thought,
          actions: rawMessage.actions
        }
      });
      const metadata = {
        thought: rawMessage.thought,
        actions: rawMessage.actions
      };
      if (transformedMessage.metadata && typeof transformedMessage.metadata === "object") {
        Object.assign(metadata, transformedMessage.metadata);
      }
      return {
        id: msg.id,
        content: typeof msg.content === "string" ? msg.content : JSON.stringify(msg.content),
        authorId: msg.authorId,
        isAgent: msg.sourceType === "agent_response",
        createdAt: msg.createdAt,
        metadata
      };
    });
    const oldestMessage = simplifiedMessages[simplifiedMessages.length - 1];
    const newestMessage = simplifiedMessages[0];
    const response = {
      messages: simplifiedMessages,
      hasMore: messages.length === messageLimit
    };
    if (simplifiedMessages.length > 0) {
      response.cursors = {
        before: oldestMessage?.createdAt.getTime(),
        after: newestMessage?.createdAt.getTime()
      };
    }
    res.json(response);
  }));
  router.post("/sessions/:sessionId/renew", asyncHandler(async (req, res) => {
    const { sessionId } = req.params;
    const session = sessions.get(sessionId);
    if (!session) {
      throw new SessionNotFoundError(sessionId);
    }
    if (session.expiresAt.getTime() <= Date.now()) {
      sessions.delete(sessionId);
      throw new SessionExpiredError(sessionId, session.expiresAt);
    }
    const previousAutoRenew = session.timeoutConfig.autoRenew;
    session.timeoutConfig.autoRenew = true;
    const renewed = renewSession(session);
    session.timeoutConfig.autoRenew = previousAutoRenew;
    if (!renewed) {
      throw new SessionRenewalError(sessionId, "Maximum duration reached", {
        maxDuration: session.timeoutConfig.maxDurationMinutes,
        createdAt: session.createdAt,
        timeSinceCreation: Date.now() - session.createdAt.getTime()
      });
    }
    const response = createSessionInfoResponse(session);
    res.json(response);
  }));
  router.patch("/sessions/:sessionId/timeout", asyncHandler(async (req, res) => {
    const { sessionId } = req.params;
    const newConfig = req.body;
    const session = sessions.get(sessionId);
    if (!session) {
      throw new SessionNotFoundError(sessionId);
    }
    if (session.expiresAt.getTime() <= Date.now()) {
      sessions.delete(sessionId);
      throw new SessionExpiredError(sessionId, session.expiresAt);
    }
    if (!isValidTimeoutConfig(newConfig)) {
      throw new InvalidTimeoutConfigError("Invalid timeout configuration format", newConfig);
    }
    if (newConfig.timeoutMinutes !== undefined) {
      const timeoutValue = Number(newConfig.timeoutMinutes);
      if (!isNaN(timeoutValue) && isFinite(timeoutValue)) {
        if (timeoutValue < MIN_TIMEOUT_MINUTES || timeoutValue > MAX_TIMEOUT_MINUTES) {
          throw new InvalidTimeoutConfigError(`Timeout must be between ${MIN_TIMEOUT_MINUTES} and ${MAX_TIMEOUT_MINUTES} minutes`, newConfig);
        }
      }
    }
    const agent = agents.get(session.agentId);
    const agentConfig = agent ? getAgentTimeoutConfig(agent) : undefined;
    session.timeoutConfig = mergeTimeoutConfigs(newConfig, agentConfig);
    session.expiresAt = calculateExpirationDate(session.createdAt, session.lastActivity, session.timeoutConfig, session.renewalCount);
    logger13.info(`[Sessions API] Updated timeout config for session ${sessionId}: timeout=${session.timeoutConfig.timeoutMinutes}, autoRenew=${session.timeoutConfig.autoRenew}, maxDuration=${session.timeoutConfig.maxDurationMinutes}`);
    const response = createSessionInfoResponse(session);
    res.json(response);
  }));
  router.post("/sessions/:sessionId/heartbeat", asyncHandler(async (req, res) => {
    const { sessionId } = req.params;
    const session = sessions.get(sessionId);
    if (!session || !isValidSession(session)) {
      throw new SessionNotFoundError(sessionId);
    }
    if (session.expiresAt.getTime() <= Date.now()) {
      sessions.delete(sessionId);
      throw new SessionExpiredError(sessionId, session.expiresAt);
    }
    session.lastActivity = new Date;
    if (session.timeoutConfig.autoRenew) {
      const renewed = renewSession(session);
      if (renewed) {
        logger13.info(`[Sessions API] Session renewed via heartbeat: ${sessionId}`);
      }
    }
    const response = createSessionInfoResponse(session);
    logger13.debug(`[Sessions API] Heartbeat received for session: ${sessionId}`);
    res.json(response);
  }));
  router.delete("/sessions/:sessionId", asyncHandler(async (req, res) => {
    const { sessionId } = req.params;
    const session = sessions.get(sessionId);
    if (!session) {
      throw new SessionNotFoundError(sessionId);
    }
    sessions.delete(sessionId);
    logger13.info(`[Sessions API] Deleted session ${sessionId}`);
    res.json({
      success: true,
      message: `Session ${sessionId} deleted successfully`
    });
  }));
  router.get("/sessions", asyncHandler(async (_req, res) => {
    const now = Date.now();
    const activeSessions = Array.from(sessions.values()).filter((session) => isValidSession(session) && session.expiresAt.getTime() > now).map((session) => createSessionInfoResponse(session));
    res.json({
      sessions: activeSessions,
      total: activeSessions.length,
      stats: {
        totalSessions: sessions.size,
        activeSessions: activeSessions.length,
        expiredSessions: sessions.size - activeSessions.length
      }
    });
  }));
  const cleanupInterval = setInterval(() => {
    const now = new Date;
    let cleanedCount = 0;
    let expiredCount = 0;
    let warningCount = 0;
    for (const [sessionId, session] of sessions.entries()) {
      if (!isValidSession(session)) {
        logger13.warn(`[Sessions API] Invalid session structure for ${sessionId}, removing`);
        sessions.delete(sessionId);
        cleanedCount++;
        continue;
      }
      if (session.expiresAt.getTime() <= now.getTime()) {
        sessions.delete(sessionId);
        cleanedCount++;
        expiredCount++;
        logger13.info(`[Sessions API] Cleaned up expired session: ${sessionId}`);
      } else if (shouldWarnAboutExpiration(session) && !session.warningState?.sent) {
        session.warningState = {
          sent: true,
          sentAt: now
        };
        warningCount++;
        logger13.info(`[Sessions API] Session ${sessionId} will expire soon`);
      }
    }
    if (cleanedCount > 0 || warningCount > 0) {
      logger13.info(`[Sessions API] Cleanup cycle completed: ${cleanedCount} expired sessions removed, ${warningCount} warnings issued`);
    }
  }, CLEANUP_INTERVAL_MS);
  activeCleanupIntervals.add(cleanupInterval);
  const cleanup = () => {
    if (activeCleanupIntervals.has(cleanupInterval)) {
      clearInterval(cleanupInterval);
      activeCleanupIntervals.delete(cleanupInterval);
      logger13.info("[Sessions API] Cleanup interval cleared");
    }
  };
  if (!processHandlersRegistered) {
    processHandlersRegistered = true;
    const globalCleanup = () => {
      logger13.info("[Sessions API] Global cleanup initiated");
      for (const interval of activeCleanupIntervals) {
        clearInterval(interval);
      }
      activeCleanupIntervals.clear();
      if (process.env.CLEAR_SESSIONS_ON_SHUTDOWN === "true") {
        sessions.clear();
        agentTimeoutConfigs.clear();
      }
    };
    process.once("SIGTERM", globalCleanup);
    process.once("SIGINT", globalCleanup);
    process.once("beforeExit", globalCleanup);
  }
  router.use(createErrorHandler());
  const routerWithCleanup = router;
  routerWithCleanup.cleanup = cleanup;
  return routerWithCleanup;
}

// src/api/messaging/index.ts
function messagingRouter(agents, serverInstance) {
  const router = express14.Router();
  if (!serverInstance) {
    throw new Error("ServerInstance is required for messaging router");
  }
  router.use("/", createMessagingCoreRouter(serverInstance));
  router.use("/", createServersRouter(serverInstance));
  router.use("/", createChannelsRouter(agents, serverInstance));
  router.use("/", createSessionsRouter(agents, serverInstance));
  return router;
}

// src/api/media/index.ts
import express17 from "express";

// src/api/media/agents.ts
import {
  validateUuid as validateUuid15,
  logger as logger14,
  getContentTypeFromMimeType,
  getUploadsAgentsDir as getUploadsAgentsDir2
} from "@elizaos/core";
import express15 from "express";
import multer2 from "multer";
import fs2 from "fs";
import path3 from "path";
var storage = multer2.memoryStorage();
var upload = multer2({
  storage,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 1
  },
  fileFilter: (_req, file, cb) => {
    if (ALLOWED_MEDIA_MIME_TYPES.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type"));
    }
  }
});
async function saveUploadedFile(file, agentId) {
  const uploadDir = path3.join(getUploadsAgentsDir2(), agentId);
  if (!fs2.existsSync(uploadDir)) {
    fs2.mkdirSync(uploadDir, { recursive: true });
  }
  const timestamp = Date.now();
  const random = Math.round(Math.random() * 1e9);
  const ext = path3.extname(file.originalname);
  const filename = `${timestamp}-${random}${ext}`;
  const filePath = path3.join(uploadDir, filename);
  fs2.writeFileSync(filePath, file.buffer);
  const url = `/media/uploads/agents/${agentId}/${filename}`;
  return { filename, url };
}
function createAgentMediaRouter() {
  const router = express15.Router();
  router.post("/:agentId/upload-media", upload.single("file"), async (req, res) => {
    logger14.debug("[MEDIA UPLOAD] Processing media upload with multer");
    const agentId = validateUuid15(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    if (!req.file) {
      return sendError(res, 400, "INVALID_REQUEST", "No media file provided");
    }
    const mediaType = getContentTypeFromMimeType(req.file.mimetype);
    if (!mediaType) {
      return sendError(res, 400, "UNSUPPORTED_MEDIA_TYPE", `Unsupported media MIME type: ${req.file.mimetype}`);
    }
    try {
      const result = await saveUploadedFile(req.file, agentId);
      logger14.info(`[MEDIA UPLOAD] Successfully uploaded ${mediaType}: ${result.filename}. URL: ${result.url}`);
      sendSuccess(res, {
        url: result.url,
        type: mediaType,
        filename: result.filename,
        originalName: req.file.originalname,
        size: req.file.size
      });
    } catch (error) {
      logger14.error(`[MEDIA UPLOAD] Error processing upload: ${error}`);
      sendError(res, 500, "UPLOAD_ERROR", "Failed to process media upload", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/media/channels.ts
import { validateUuid as validateUuid16, logger as logger15, getUploadsChannelsDir as getUploadsChannelsDir3 } from "@elizaos/core";
import express16 from "express";
import multer3 from "multer";
import fs3 from "fs";
import path4 from "path";
var storage2 = multer3.memoryStorage();
var upload2 = multer3({
  storage: storage2,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 1
  },
  fileFilter: (_req, file, cb) => {
    const isAllowed = ALLOWED_MEDIA_MIME_TYPES.some((allowed) => allowed === file.mimetype);
    if (isAllowed) {
      cb(null, true);
    } else {
      cb(new Error(`Invalid file type. Only ${ALLOWED_MEDIA_MIME_TYPES.join(", ")} are allowed`));
    }
  }
});
async function saveUploadedFile2(file, channelId) {
  const uploadDir = path4.join(getUploadsChannelsDir3(), channelId);
  if (!fs3.existsSync(uploadDir)) {
    fs3.mkdirSync(uploadDir, { recursive: true });
  }
  const timestamp = Date.now();
  const random = Math.round(Math.random() * 1e9);
  const ext = path4.extname(file.originalname);
  const filename = `${timestamp}-${random}${ext}`;
  const filePath = path4.join(uploadDir, filename);
  fs3.writeFileSync(filePath, file.buffer);
  const url = `/media/uploads/channels/${channelId}/${filename}`;
  return { filename, url };
}
function createChannelMediaRouter() {
  const router = express16.Router();
  const uploadMediaRateLimiter = lib_default({
    windowMs: 15 * 60 * 1000,
    max: 100,
    message: { success: false, error: "Too many requests, please try again later." }
  });
  router.post("/:channelId/upload-media", uploadMediaRateLimiter, upload2.single("file"), async (req, res) => {
    const channelId = validateUuid16(req.params.channelId);
    if (!channelId) {
      res.status(400).json({ success: false, error: "Invalid channelId format" });
      return;
    }
    if (!req.file) {
      res.status(400).json({ success: false, error: "No media file provided" });
      return;
    }
    try {
      const result = await saveUploadedFile2(req.file, channelId);
      logger15.info(`[Channel Media Upload] File uploaded for channel ${channelId}: ${result.filename}. URL: ${result.url}`);
      res.json({
        success: true,
        data: {
          url: result.url,
          type: req.file.mimetype,
          filename: result.filename,
          originalName: req.file.originalname,
          size: req.file.size
        }
      });
    } catch (error) {
      logger15.error(`[Channel Media Upload] Error processing upload for channel ${channelId}: ${error.message}`, error);
      res.status(500).json({ success: false, error: "Failed to process media upload" });
    }
  });
  return router;
}

// src/api/media/index.ts
function mediaRouter() {
  const router = express17.Router();
  router.use("/agents", createAgentMediaRouter());
  router.use("/channels", createChannelMediaRouter());
  return router;
}

// src/api/memory/index.ts
import express19 from "express";

// src/api/memory/groups.ts
import { validateUuid as validateUuid18, logger as logger18, createUniqueUuid as createUniqueUuid4, ChannelType as ChannelType4 } from "@elizaos/core";
import express18 from "express";
// src/api/shared/file-utils.ts
import { logger as logger16, getUploadsAgentsDir as getUploadsAgentsDir3, getUploadsChannelsDir as getUploadsChannelsDir4 } from "@elizaos/core";
var cleanupUploadedFile = (file) => {
  logger16.debug(`[FILE] Multer file ${file.originalname} in memory, no cleanup needed`);
};
// src/upload.ts
import multer4 from "multer";
import { validateUuid as validateUuid17, logger as logger17 } from "@elizaos/core";
var storage3 = multer4.memoryStorage();
var agentAudioUpload = () => multer4({
  storage: storage3,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 1
  },
  fileFilter: (_req, file, cb) => {
    const isAllowed = ALLOWED_AUDIO_MIME_TYPES.some((allowed) => allowed === file.mimetype);
    if (isAllowed) {
      cb(null, true);
    } else {
      cb(new Error(`Invalid audio file type. Only ${ALLOWED_AUDIO_MIME_TYPES.join(", ")} are allowed`));
    }
  }
});
function validateAudioFile(file) {
  return ALLOWED_AUDIO_MIME_TYPES.some((allowed) => allowed === file.mimetype);
}
// src/api/memory/groups.ts
function createGroupMemoryRouter(agents, serverInstance) {
  const router = express18.Router();
  const db = serverInstance?.database;
  router.post("/groups/:serverId", async (req, res) => {
    const serverId = validateUuid18(req.params.serverId);
    const { name, worldId, source, metadata, agentIds = [] } = req.body;
    if (!Array.isArray(agentIds) || agentIds.length === 0) {
      return sendError(res, 400, "BAD_REQUEST", "agentIds must be a non-empty array");
    }
    let results = [];
    let errors = [];
    for (const agentId of agentIds) {
      try {
        const runtime = getRuntime(agents, agentId);
        const roomId = createUniqueUuid4(runtime, serverId);
        const roomName = name || `Chat ${new Date().toLocaleString()}`;
        await runtime.ensureWorldExists({
          id: worldId,
          name: source,
          agentId: runtime.agentId,
          serverId
        });
        await runtime.ensureRoomExists({
          id: roomId,
          name: roomName,
          source,
          type: ChannelType4.API,
          worldId,
          serverId,
          metadata,
          channelId: roomId
        });
        await runtime.addParticipant(runtime.agentId, roomId);
        await runtime.ensureParticipantInRoom(runtime.agentId, roomId);
        await runtime.setParticipantUserState(roomId, runtime.agentId, "FOLLOWED");
        results.push({
          id: roomId,
          name: roomName,
          source: "client",
          worldId,
          type: ChannelType4.API
        });
      } catch (error) {
        logger18.error(`[ROOM CREATE] Error creating room for agent ${agentId}:`, error instanceof Error ? error.message : String(error));
        errors.push({
          agentId,
          code: error instanceof Error && error.message === "Agent not found" ? "NOT_FOUND" : "CREATE_ERROR",
          message: error instanceof Error && error.message === "Agent not found" ? error.message : "Failed to Create group",
          details: error instanceof Error ? error.message : String(error)
        });
      }
    }
    if (results.length === 0 && errors.length > 0) {
      res.status(500).json({
        success: false,
        error: errors.length ? errors : [{ code: "UNKNOWN_ERROR", message: "No rooms were created" }]
      });
      return;
    }
    res.status(errors.length ? 207 : 201).json({
      success: errors.length === 0,
      data: results,
      errors: errors.length ? errors : undefined
    });
  });
  router.delete("/groups/:serverId", async (req, res) => {
    const worldId = validateUuid18(req.params.serverId);
    if (!worldId) {
      return sendError(res, 400, "INVALID_ID", "Invalid serverId (worldId) format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    try {
      await db.deleteRoomsByWorldId(worldId);
      res.status(204).send();
    } catch (error) {
      logger18.error("[GROUP DELETE] Error deleting group:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "DELETE_ERROR", "Error deleting group", error instanceof Error ? error.message : String(error));
    }
  });
  router.delete("/groups/:serverId/memories", async (req, res) => {
    const worldId = validateUuid18(req.params.serverId);
    if (!worldId) {
      return sendError(res, 400, "INVALID_ID", "Invalid serverId (worldId) format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    try {
      const memories = await db.getMemoriesByWorldId({ worldId, tableName: "messages" });
      const memoryIds = memories.map((memory) => memory.id);
      if (memoryIds.length > 0) {
        await db.deleteManyMemories(memoryIds);
      }
      res.status(204).send();
    } catch (error) {
      logger18.error("[GROUP MEMORIES DELETE] Error clearing memories:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "DELETE_ERROR", "Error deleting group memories", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/memory/index.ts
function memoryRouter(agents, serverInstance) {
  const router = express19.Router();
  router.use("/", createAgentMemoryRouter(agents));
  router.use("/", createGroupMemoryRouter(agents, serverInstance));
  router.use("/", createRoomManagementRouter(agents));
  return router;
}

// src/api/audio/index.ts
import express23 from "express";

// src/api/audio/processing.ts
import { logger as logger19, ModelType as ModelType2, validateUuid as validateUuid19 } from "@elizaos/core";
import express20 from "express";
function createAudioProcessingRouter(agents) {
  const router = express20.Router();
  router.use(createUploadRateLimit());
  router.use(createFileSystemRateLimit());
  router.post("/:agentId/audio-messages", agentAudioUpload().single("file"), async (req, res) => {
    const audioReq = req;
    logger19.debug("[AUDIO MESSAGE] Processing audio message");
    const agentId = validateUuid19(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const audioFile = audioReq.file;
    if (!audioFile) {
      return sendError(res, 400, "INVALID_REQUEST", "No audio file provided");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      cleanupUploadedFile(audioFile);
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      if (!validateAudioFile(audioFile)) {
        cleanupUploadedFile(audioFile);
        return sendError(res, 400, "INVALID_FILE_TYPE", "Invalid audio file type");
      }
      if (audioFile.size > MAX_FILE_SIZE) {
        cleanupUploadedFile(audioFile);
        return sendError(res, 413, "FILE_TOO_LARGE", `Audio file too large (max ${MAX_FILE_SIZE_DISPLAY})`);
      }
      const transcription = await runtime.useModel(ModelType2.TRANSCRIPTION, audioFile.buffer);
      logger19.info(`[AUDIO MESSAGE] Transcription for agent ${agentId}: ${transcription}`);
      cleanupUploadedFile(audioFile);
      sendSuccess(res, { transcription, message: "Audio transcribed, further processing TBD." });
    } catch (error) {
      logger19.error("[AUDIO MESSAGE] Error processing audio:", error instanceof Error ? error.message : String(error));
      cleanupUploadedFile(audioFile);
      sendError(res, 500, "PROCESSING_ERROR", "Error processing audio message", error instanceof Error ? error.message : String(error));
    }
  });
  router.post("/:agentId/transcriptions", agentAudioUpload().single("file"), async (req, res) => {
    const audioReq = req;
    logger19.debug("[TRANSCRIPTION] Request to transcribe audio");
    const agentId = validateUuid19(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const audioFile = audioReq.file;
    if (!audioFile) {
      return sendError(res, 400, "INVALID_REQUEST", "No audio file provided");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      cleanupUploadedFile(audioFile);
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      logger19.debug("[TRANSCRIPTION] Reading audio file");
      if (!validateAudioFile(audioFile)) {
        cleanupUploadedFile(audioFile);
        return sendError(res, 400, "INVALID_FILE_TYPE", "Invalid audio file type");
      }
      if (audioFile.size > MAX_FILE_SIZE) {
        cleanupUploadedFile(audioFile);
        return sendError(res, 413, "FILE_TOO_LARGE", `Audio file too large (max ${MAX_FILE_SIZE_DISPLAY})`);
      }
      logger19.debug("[TRANSCRIPTION] Transcribing audio");
      const transcription = await runtime.useModel(ModelType2.TRANSCRIPTION, audioFile.buffer);
      cleanupUploadedFile(audioFile);
      if (!transcription) {
        return sendError(res, 500, "PROCESSING_ERROR", "Failed to transcribe audio");
      }
      logger19.success("[TRANSCRIPTION] Successfully transcribed audio");
      sendSuccess(res, { text: transcription });
    } catch (error) {
      logger19.error("[TRANSCRIPTION] Error transcribing audio:", error instanceof Error ? error.message : String(error));
      cleanupUploadedFile(audioFile);
      sendError(res, 500, "PROCESSING_ERROR", "Error transcribing audio", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/audio/synthesis.ts
import { validateUuid as validateUuid20, logger as logger20, ModelType as ModelType3 } from "@elizaos/core";
import express21 from "express";

// src/api/audio/audioBuffer.ts
import { Readable } from "node:stream";
function getAudioMimeType(audioBuffer) {
  if (audioBuffer.length >= 12 && audioBuffer.toString("ascii", 0, 4) === "RIFF" && audioBuffer.toString("ascii", 8, 12) === "WAVE") {
    return "audio/wav";
  }
  if (audioBuffer.length >= 3 && audioBuffer.toString("ascii", 0, 3) === "ID3") {
    return "audio/mpeg";
  }
  if (audioBuffer.length >= 2 && audioBuffer[0] === 255 && (audioBuffer[1] & 224) === 224) {
    return "audio/mpeg";
  }
  return "audio/mpeg";
}
async function convertToAudioBuffer(speechResponse, detectMimeType) {
  let resultBuffer;
  if (Buffer.isBuffer(speechResponse)) {
    resultBuffer = speechResponse;
  } else if (typeof speechResponse?.getReader === "function") {
    const reader = speechResponse.getReader();
    const chunks = [];
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        if (value)
          chunks.push(value);
      }
      resultBuffer = Buffer.concat(chunks);
    } finally {
      reader.releaseLock();
    }
  } else if (speechResponse instanceof Readable || speechResponse && speechResponse.readable === true && typeof speechResponse.pipe === "function" && typeof speechResponse.on === "function") {
    resultBuffer = await new Promise((resolve, reject) => {
      const chunks = [];
      speechResponse.on("data", (chunk) => chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)));
      speechResponse.on("end", () => resolve(Buffer.concat(chunks)));
      speechResponse.on("error", (err) => reject(err));
    });
  } else {
    throw new Error("Unexpected response type from TEXT_TO_SPEECH model");
  }
  if (detectMimeType) {
    return {
      buffer: resultBuffer,
      mimeType: getAudioMimeType(resultBuffer)
    };
  }
  return resultBuffer;
}

// src/api/audio/synthesis.ts
function createSynthesisRouter(agents) {
  const router = express21.Router();
  router.post("/:agentId/audio-messages/synthesize", async (req, res) => {
    const agentId = validateUuid20(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const { text } = req.body;
    if (!text) {
      return sendError(res, 400, "INVALID_REQUEST", "Text is required for speech synthesis");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const speechResponse = await runtime.useModel(ModelType3.TEXT_TO_SPEECH, text);
      const audioResult = await convertToAudioBuffer(speechResponse, true);
      logger20.debug("[TTS] Setting response headers");
      res.set({
        "Content-Type": audioResult.mimeType,
        "Content-Length": audioResult.buffer.length.toString()
      });
      res.send(audioResult.buffer);
    } catch (error) {
      logger20.error("[TTS] Error generating speech:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "PROCESSING_ERROR", "Error generating speech", error instanceof Error ? error.message : String(error));
    }
  });
  router.post("/:agentId/speech/generate", async (req, res) => {
    logger20.debug("[SPEECH GENERATE] Request to generate speech from text");
    const agentId = validateUuid20(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const { text } = req.body;
    if (!text) {
      return sendError(res, 400, "INVALID_REQUEST", "Text is required for speech synthesis");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      logger20.debug("[SPEECH GENERATE] Using text-to-speech model");
      const speechResponse = await runtime.useModel(ModelType3.TEXT_TO_SPEECH, text);
      const audioResult = await convertToAudioBuffer(speechResponse, true);
      logger20.debug("[SPEECH GENERATE] Detected audio MIME type:", audioResult.mimeType);
      logger20.debug("[SPEECH GENERATE] Setting response headers");
      res.set({
        "Content-Type": audioResult.mimeType,
        "Content-Length": audioResult.buffer.length.toString()
      });
      res.send(audioResult.buffer);
      logger20.success(`[SPEECH GENERATE] Successfully generated speech for: ${runtime.character.name}`);
    } catch (error) {
      logger20.error("[SPEECH GENERATE] Error generating speech:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "PROCESSING_ERROR", "Error generating speech", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/audio/conversation.ts
import {
  validateUuid as validateUuid21,
  logger as logger21,
  ModelType as ModelType4,
  ChannelType as ChannelType5,
  createUniqueUuid as createUniqueUuid5,
  composePrompt,
  messageHandlerTemplate
} from "@elizaos/core";
import express22 from "express";
function createConversationRouter(agents) {
  const router = express22.Router();
  router.post("/:agentId/speech/conversation", async (req, res) => {
    const agentId = validateUuid21(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const { text, roomId: rawRoomId, entityId: rawUserId, worldId: rawWorldId } = req.body;
    if (!text) {
      return sendError(res, 400, "INVALID_REQUEST", "Text is required for conversation");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const roomId = createUniqueUuid5(runtime, rawRoomId ?? `default-room-${agentId}`);
      const entityId = createUniqueUuid5(runtime, rawUserId ?? "Anon");
      const worldId = rawWorldId ?? createUniqueUuid5(runtime, "direct");
      logger21.debug("[SPEECH CONVERSATION] Ensuring connection");
      await runtime.ensureConnection({
        entityId,
        roomId,
        userName: req.body.userName,
        name: req.body.name,
        source: "direct",
        type: ChannelType5.API,
        worldId,
        worldName: "Direct"
      });
      const messageId = createUniqueUuid5(runtime, Date.now().toString());
      const content = {
        text,
        attachments: [],
        source: "direct",
        inReplyTo: undefined,
        channelType: ChannelType5.API
      };
      const userMessageMemory = {
        id: messageId,
        entityId,
        roomId,
        worldId,
        agentId: runtime.agentId,
        content,
        createdAt: Date.now()
      };
      logger21.debug("[SPEECH CONVERSATION] Creating memory");
      await runtime.createMemory(userMessageMemory, "messages");
      logger21.debug("[SPEECH CONVERSATION] Composing state");
      const state = await runtime.composeState(userMessageMemory);
      logger21.debug("[SPEECH CONVERSATION] Creating context");
      const prompt = composePrompt({
        state,
        template: messageHandlerTemplate
      });
      logger21.debug("[SPEECH CONVERSATION] Using LLM for response");
      const llmResponse = await runtime.useModel(ModelType4.TEXT_LARGE, {
        messages: [
          {
            role: "system",
            content: messageHandlerTemplate
          },
          {
            role: "user",
            content: prompt
          }
        ]
      });
      if (!llmResponse) {
        return sendError(res, 500, "MODEL_ERROR", "No response from model");
      }
      logger21.debug("[SPEECH CONVERSATION] Creating response memory");
      const responseMessage = {
        id: createUniqueUuid5(runtime, `resp-${messageId}`),
        entityId: runtime.agentId,
        agentId: runtime.agentId,
        roomId,
        worldId,
        content: { text: llmResponse, inReplyTo: messageId },
        createdAt: Date.now()
      };
      await runtime.createMemory(responseMessage, "messages");
      await runtime.evaluate(userMessageMemory, state);
      await runtime.processActions(userMessageMemory, [responseMessage], state, async () => [userMessageMemory]);
      logger21.debug("[SPEECH CONVERSATION] Generating speech response from LLM output");
      const speechAudioResponse = await runtime.useModel(ModelType4.TEXT_TO_SPEECH, llmResponse);
      const audioResult = await convertToAudioBuffer(speechAudioResponse, true);
      logger21.debug("[SPEECH CONVERSATION] Setting response headers");
      res.set({
        "Content-Type": audioResult.mimeType,
        "Content-Length": audioResult.buffer.length.toString()
      });
      res.send(audioResult.buffer);
      logger21.success(`[SPEECH CONVERSATION] Successfully processed conversation for: ${runtime.character.name}`);
    } catch (error) {
      logger21.error("[SPEECH CONVERSATION] Error processing conversation:", error instanceof Error ? error.message : String(error));
      sendError(res, 500, "PROCESSING_ERROR", "Error processing conversation", error instanceof Error ? error.message : String(error));
    }
  });
  return router;
}

// src/api/audio/index.ts
function audioRouter(agents) {
  const router = express23.Router();
  router.use("/", createAudioProcessingRouter(agents));
  router.use("/", createSynthesisRouter(agents));
  router.use("/", createConversationRouter(agents));
  return router;
}

// src/api/runtime/index.ts
import express27 from "express";

// src/api/runtime/health.ts
import { logger as logger22 } from "@elizaos/core";
import express24 from "express";
function createHealthRouter(agents, serverInstance) {
  const router = express24.Router();
  router.get("/ping", (_req, res) => {
    res.json({ pong: true, timestamp: Date.now() });
  });
  router.get("/hello", (_req, res) => {
    logger22.info("Hello endpoint hit");
    res.setHeader("Content-Type", "application/json");
    res.send(JSON.stringify({ message: "Hello World!" }));
  });
  router.get("/status", (_req, res) => {
    logger22.info("Status endpoint hit");
    res.setHeader("Content-Type", "application/json");
    res.send(JSON.stringify({
      status: "ok",
      agentCount: agents.size,
      timestamp: new Date().toISOString()
    }));
  });
  router.get("/health", (_req, res) => {
    logger22.log({ apiRoute: "/health" }, "Health check route hit");
    const healthcheck = {
      status: "OK",
      version: process.env.APP_VERSION || "unknown",
      timestamp: new Date().toISOString(),
      dependencies: {
        agents: agents.size > 0 ? "healthy" : "no_agents"
      }
    };
    const statusCode = healthcheck.dependencies.agents === "healthy" ? 200 : 503;
    res.status(statusCode).json(healthcheck);
  });
  router.post("/stop", (_req, res) => {
    logger22.log({ apiRoute: "/stop" }, "Server stopping...");
    serverInstance?.stop();
    res.json({ message: "Server stopping..." });
  });
  return router;
}

// src/api/runtime/logging.ts
import { logger as logger23, recentLogs } from "@elizaos/core";
import express25 from "express";
var LOG_LEVELS = {
  fatal: 60,
  error: 50,
  warn: 40,
  info: 30,
  log: 29,
  progress: 28,
  success: 27,
  debug: 20,
  trace: 10
};
function createLoggingRouter() {
  const router = express25.Router();
  const logsHandler = async (req, res) => {
    const since = req.query.since ? Number(req.query.since) : Date.now() - 3600000;
    const requestedLevel = req.query.level?.toString().toLowerCase() || "all";
    const requestedAgentName = req.query.agentName?.toString() || "all";
    const requestedAgentId = req.query.agentId?.toString() || "all";
    const limit = Math.min(Number(req.query.limit) || 100, 1000);
    try {
      const recentLogsString = recentLogs();
      let logEntries = [];
      if (recentLogsString) {
        const lines = recentLogsString.split(`
`).filter((line) => line.trim());
        logEntries = lines.map((line, index) => {
          const cleanLine = line.replace(/\u001B\[[0-9;]*m/g, "");
          const logMatch = cleanLine.match(/^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)\s+(\w+)\s+(.+)$/);
          if (logMatch) {
            const [, timestamp, levelStr, message] = logMatch;
            let level = LOG_LEVELS.info;
            const levelLower = levelStr.trim().toLowerCase();
            if (levelLower === "error")
              level = LOG_LEVELS.error;
            else if (levelLower === "warn")
              level = LOG_LEVELS.warn;
            else if (levelLower === "info")
              level = LOG_LEVELS.info;
            else if (levelLower === "log")
              level = LOG_LEVELS.log;
            else if (levelLower === "progress")
              level = LOG_LEVELS.progress;
            else if (levelLower === "success")
              level = LOG_LEVELS.success;
            else if (levelLower === "debug")
              level = LOG_LEVELS.debug;
            else if (levelLower === "trace")
              level = LOG_LEVELS.trace;
            else if (levelLower === "fatal")
              level = LOG_LEVELS.fatal;
            return {
              time: new Date(timestamp).getTime(),
              level,
              msg: message.trim()
            };
          } else {
            return {
              time: Date.now() - (lines.length - index) * 1000,
              level: LOG_LEVELS.info,
              msg: line.trim()
            };
          }
        });
      }
      const requestedLevelValue = requestedLevel === "all" ? 0 : LOG_LEVELS[requestedLevel] || LOG_LEVELS.info;
      const logsWithAgentNames = logEntries.filter((l) => l.agentName).length;
      const logsWithAgentIds = logEntries.filter((l) => l.agentId).length;
      const totalLogs = logEntries.length;
      const agentNamePopulationRate = totalLogs > 0 ? logsWithAgentNames / totalLogs : 0;
      const agentIdPopulationRate = totalLogs > 0 ? logsWithAgentIds / totalLogs : 0;
      const isAgentNameDataSparse = agentNamePopulationRate < 0.1;
      const isAgentIdDataSparse = agentIdPopulationRate < 0.1;
      const filtered = logEntries.filter((log) => {
        const timeMatch = log.time >= since;
        let levelMatch = true;
        if (requestedLevel && requestedLevel !== "all") {
          levelMatch = log.level === requestedLevelValue;
        }
        let agentNameMatch = true;
        if (requestedAgentName && requestedAgentName !== "all") {
          if (log.agentName) {
            agentNameMatch = log.agentName === requestedAgentName;
          } else {
            agentNameMatch = isAgentNameDataSparse;
          }
        }
        let agentIdMatch = true;
        if (requestedAgentId && requestedAgentId !== "all") {
          if (log.agentId) {
            agentIdMatch = log.agentId === requestedAgentId;
          } else {
            agentIdMatch = isAgentIdDataSparse;
          }
        }
        return timeMatch && levelMatch && agentNameMatch && agentIdMatch;
      }).slice(-limit);
      logger23.debug(`Logs request processed: ${filtered.length}/${logEntries.length} logs returned ` + `(level: ${requestedLevel}, agent: ${requestedAgentName})`);
      res.json({
        logs: filtered,
        count: filtered.length,
        total: logEntries.length,
        requestedLevel,
        agentName: requestedAgentName,
        agentId: requestedAgentId,
        levels: Object.keys(LOG_LEVELS)
      });
    } catch (error) {
      res.status(500).json({
        error: "Failed to retrieve logs",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  };
  router.get("/logs", logsHandler);
  router.post("/logs", logsHandler);
  const logsClearHandler = (_req, res) => {
    try {
      logger23.clear();
      logger23.debug("Logs cleared via API endpoint");
      res.json({ status: "success", message: "Logs cleared successfully" });
    } catch (error) {
      res.status(500).json({
        error: "Failed to clear logs",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  };
  router.delete("/logs", logsClearHandler);
  return router;
}

// src/api/runtime/debug.ts
import express26 from "express";
function createDebugRouter(serverInstance) {
  const router = express26.Router();
  router.get("/servers", async (_req, res) => {
    try {
      const servers = await serverInstance?.getServers();
      res.json({
        success: true,
        servers: servers || [],
        count: servers?.length || 0
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  return router;
}

// src/api/runtime/index.ts
function runtimeRouter(agents, serverInstance) {
  const router = express27.Router();
  router.use("/", createHealthRouter(agents, serverInstance));
  router.use("/", createLoggingRouter());
  router.use("/debug", createDebugRouter(serverInstance));
  return router;
}

// src/api/tee/index.ts
import express28 from "express";
function teeRouter() {
  const router = express28.Router();
  return router;
}

// src/api/system/index.ts
import express31 from "express";

// src/api/system/environment.ts
var import_dotenv = __toESM(require_main(), 1);
import { logger as logger24 } from "@elizaos/core";
import express29 from "express";
import { existsSync, writeFileSync } from "fs";
import path5 from "path";
import fs4 from "fs/promises";
async function parseEnvFile(filePath) {
  try {
    if (!existsSync(filePath)) {
      return {};
    }
    const content = await fs4.readFile(filePath, "utf-8");
    if (content.trim() === "") {
      return {};
    }
    return import_dotenv.default.parse(content);
  } catch (error) {
    console.error(`Error parsing .env file: ${error.message}`);
    return {};
  }
}
function serializeEnvObject(envObj) {
  return Object.entries(envObj).map(([key, val]) => `${key}=${val ?? ""}`).join(`

`);
}
function getLocalEnvPath() {
  const envPath = resolveEnvFile();
  return existsSync(envPath) ? envPath : null;
}
function resolveEnvFile(startDir = process.cwd()) {
  let currentDir = startDir;
  while (true) {
    const candidate = path5.join(currentDir, ".env");
    if (existsSync(candidate)) {
      return candidate;
    }
    const parentDir = path5.dirname(currentDir);
    if (parentDir === currentDir) {
      break;
    }
    currentDir = parentDir;
  }
  return path5.join(startDir, ".env");
}
function createEnvironmentRouter() {
  const router = express29.Router();
  router.get("/local", async (_req, res) => {
    try {
      const localEnvPath = getLocalEnvPath();
      if (!localEnvPath) {
        return res.json({
          success: true,
          data: {}
        });
      }
      const localEnvs = await parseEnvFile(localEnvPath);
      res.json({
        success: true,
        data: localEnvs
      });
    } catch (error) {
      logger24.error(`[ENVS GET] Error retrieving local envs:`, error instanceof Error ? error.message : String(error));
      if (error instanceof Error && error.stack) {
        logger24.trace("Stack trace:", error.stack);
      }
      res.status(500).json({
        success: false,
        error: {
          code: "FETCH_ERROR",
          message: "Failed to retrieve local envs",
          details: error instanceof Error ? error.message : String(error)
        }
      });
    }
  });
  router.post("/local", async (req, res) => {
    try {
      const { content } = req.body;
      if (!content || typeof content !== "object") {
        res.status(400).json({
          success: false,
          error: {
            code: "INVALID_INPUT",
            message: 'Missing or invalid "content" in request body'
          }
        });
      }
      const localEnvPath = getLocalEnvPath();
      if (!localEnvPath)
        throw new Error("Local .env file not found");
      const envString = serializeEnvObject(content);
      writeFileSync(localEnvPath, envString, "utf-8");
      res.json({
        success: true,
        message: "Local env updated"
      });
    } catch (error) {
      logger24.error(`[ENVS POST] Error updating local envs`, error instanceof Error ? error.message : String(error));
      res.status(500).json({
        success: false,
        error: {
          code: "UPDATE_ERROR",
          message: "Failed to update local envs",
          details: error instanceof Error ? error.message : String(error)
        }
      });
    }
  });
  return router;
}

// src/api/system/version.ts
import express30 from "express";
// package.json
var package_default = {
  name: "@elizaos/server",
  version: "1.5.10",
  description: "ElizaOS Server - Core server infrastructure for ElizaOS agents",
  publishConfig: {
    access: "public",
    workspaces: {
      preserveIfPresent: true
    }
  },
  license: "MIT",
  author: {
    name: "elizaOS",
    url: "https://twitter.com/eliza_OS"
  },
  repository: {
    type: "git",
    url: "https://github.com/elizaOS/eliza.git",
    directory: "packages/server"
  },
  files: [
    "dist",
    "templates"
  ],
  keywords: [],
  type: "module",
  exports: {
    ".": "./dist/index.js",
    "./package.json": "./package.json"
  },
  scripts: {
    build: "bun run build.ts",
    "type-check": "tsc --project tsconfig.build.json --noEmit",
    lint: "prettier --write ./src",
    format: "prettier --write ./src",
    "format:check": "prettier --check ./src",
    clean: "rm -rf dist .turbo node_modules .turbo-tsconfig.json *.tsbuildinfo",
    test: "bun test src/**/*.test.ts",
    "test:unit": "bun test src/**/*.test.ts --exclude **/integration/**",
    "test:integration": "bun test src/__tests__/integration/**/*.test.ts",
    "test:coverage": "bun test --coverage",
    "test:watch": "bun test --watch",
    "test:cli": "bun test tests/commands/",
    dev: "bun run build.ts --watch"
  },
  devDependencies: {
    "@elizaos/client": "workspace:*",
    "@types/node": "^24.0.1",
    prettier: "3.5.3",
    tsx: "4.19.4",
    typescript: "^5.5.4",
    which: "^4.0.0",
    ws: "^8.18.0"
  },
  gitHead: "255e37c0e4a76da0b776219db5ebb9dadf20e89f",
  dependencies: {
    "@elizaos/core": "workspace:*",
    "@elizaos/plugin-sql": "workspace:*",
    "@sentry/node": "^10.11.0",
    "@types/express": "^5.0.2",
    "@types/helmet": "^4.0.0",
    "@types/multer": "^1.4.13",
    dotenv: "^16.5.0",
    express: "^5.1.0",
    "express-rate-limit": "^7.5.0",
    helmet: "^8.1.0",
    multer: "^2.0.1",
    "path-to-regexp": "^8.2.0",
    "socket.io": "^4.8.1"
  }
};

// src/api/system/version.ts
function getVersionInfo() {
  const timestamp = new Date().toISOString();
  try {
    return {
      version: package_default.version,
      source: "server",
      timestamp,
      environment: "development",
      uptime: process.uptime()
    };
  } catch (error) {
    console.error("Error getting version info:", error);
    return {
      version: "unknown",
      source: "server",
      timestamp,
      environment: "development",
      uptime: process.uptime(),
      error: "Failed to retrieve version information"
    };
  }
}
function createVersionRouter() {
  const router = express30.Router();
  router.get("/", (_, res) => {
    const versionInfo = getVersionInfo();
    const statusCode = versionInfo.error ? 500 : 200;
    res.status(statusCode).json(versionInfo);
  });
  return router;
}

// src/api/system/index.ts
function systemRouter() {
  const router = express31.Router();
  router.use("/env", createEnvironmentRouter());
  router.use("/version", createVersionRouter());
  return router;
}

// src/socketio/index.ts
import {
  logger as logger25,
  customLevels,
  SOCKET_MESSAGE_TYPE,
  validateUuid as validateUuid22,
  ChannelType as ChannelType6,
  EventType
} from "@elizaos/core";
var DEFAULT_SERVER_ID5 = "00000000-0000-0000-0000-000000000000";

class SocketIORouter {
  agents;
  connections;
  logStreamConnections;
  serverInstance;
  constructor(agents, serverInstance) {
    this.agents = agents;
    this.connections = new Map;
    this.logStreamConnections = new Map;
    this.serverInstance = serverInstance;
    logger25.info(`[SocketIO] Router initialized with ${this.agents.size} agents`);
  }
  setupListeners(io) {
    logger25.info(`[SocketIO] Setting up Socket.IO event listeners`);
    const messageTypes = Object.keys(SOCKET_MESSAGE_TYPE).map((key) => `${key}: ${SOCKET_MESSAGE_TYPE[key]}`);
    logger25.info(`[SocketIO] Registered message types: ${messageTypes.join(", ")}`);
    io.on("connection", (socket) => {
      this.handleNewConnection(socket, io);
    });
  }
  handleNewConnection(socket, _io) {
    logger25.info(`[SocketIO] New connection: ${socket.id}`);
    socket.on(String(SOCKET_MESSAGE_TYPE.ROOM_JOINING), (payload) => {
      logger25.debug(`[SocketIO] Channel joining event received directly: ${JSON.stringify(payload)}`);
      this.handleChannelJoining(socket, payload);
    });
    socket.on(String(SOCKET_MESSAGE_TYPE.SEND_MESSAGE), (payload) => {
      const messagePreview = payload.message?.substring(0, 50) + (payload.message?.length > 50 ? "..." : "");
      const channelId = payload.channelId || payload.roomId;
      logger25.info(`[SocketIO] SEND_MESSAGE event received directly: ${JSON.stringify({
        senderId: payload.senderId,
        channelId,
        messagePreview
      })}`);
      this.handleMessageSubmission(socket, payload);
    });
    socket.on("message", (data) => {
      logger25.info(`[SocketIO] Generic 'message' event received: ${JSON.stringify(data)} (SocketID: ${socket.id})`);
      this.handleGenericMessage(socket, data);
    });
    socket.on("subscribe_logs", () => this.handleLogSubscription(socket));
    socket.on("unsubscribe_logs", () => this.handleLogUnsubscription(socket));
    socket.on("update_log_filters", (filters) => this.handleLogFilterUpdate(socket, filters));
    socket.on("disconnect", () => this.handleDisconnect(socket));
    socket.on("error", (error) => {
      logger25.error(`[SocketIO] Socket error for ${socket.id}: ${error.message}`, error instanceof Error ? error.message : String(error));
    });
    if (true) {
      socket.onAny((event, ...args) => {
        logger25.info(`[SocketIO DEBUG ${socket.id}] Event '${event}': ${JSON.stringify(args)}`);
      });
    }
    socket.emit("connection_established", {
      message: "Connected to Eliza Socket.IO server",
      socketId: socket.id
    });
  }
  handleGenericMessage(socket, data) {
    try {
      if (!(data && typeof data === "object" && ("type" in data) && ("payload" in data))) {
        logger25.warn(`[SocketIO ${socket.id}] Malformed 'message' event data: ${JSON.stringify(data)}`);
        return;
      }
      const { type, payload } = data;
      switch (type) {
        case SOCKET_MESSAGE_TYPE.ROOM_JOINING:
          logger25.info(`[SocketIO ${socket.id}] Handling channel joining via 'message' event`);
          this.handleChannelJoining(socket, payload);
          break;
        case SOCKET_MESSAGE_TYPE.SEND_MESSAGE:
          logger25.info(`[SocketIO ${socket.id}] Handling message sending via 'message' event`);
          this.handleMessageSubmission(socket, payload);
          break;
        default:
          logger25.warn(`[SocketIO ${socket.id}] Unknown message type received in 'message' event: ${type}`);
          break;
      }
    } catch (error) {
      logger25.error(`[SocketIO ${socket.id}] Error processing 'message' event: ${error.message}`, error);
    }
  }
  handleChannelJoining(socket, payload) {
    const channelId = payload.channelId || payload.roomId;
    const { agentId, entityId, serverId, metadata } = payload;
    logger25.debug(`[SocketIO] handleChannelJoining called with payload:`, JSON.stringify(payload, null, 2));
    if (!channelId) {
      this.sendErrorResponse(socket, `channelId is required for joining.`);
      return;
    }
    if (agentId) {
      const agentUuid = validateUuid22(agentId);
      if (agentUuid) {
        this.connections.set(socket.id, agentUuid);
        logger25.info(`[SocketIO] Socket ${socket.id} associated with agent ${agentUuid}`);
      }
    }
    socket.join(channelId);
    logger25.info(`[SocketIO] Socket ${socket.id} joined Socket.IO channel: ${channelId}`);
    if (entityId && (serverId || DEFAULT_SERVER_ID5)) {
      const finalServerId = serverId || DEFAULT_SERVER_ID5;
      const isDm = metadata?.isDm || metadata?.channelType === ChannelType6.DM;
      logger25.info(`[SocketIO] Emitting ENTITY_JOINED event for entityId: ${entityId}, serverId: ${finalServerId}, isDm: ${isDm}`);
      const runtime = Array.from(this.agents.values())[0];
      if (runtime) {
        runtime.emitEvent(EventType.ENTITY_JOINED, {
          entityId,
          runtime,
          worldId: finalServerId,
          roomId: channelId,
          metadata: {
            type: isDm ? ChannelType6.DM : ChannelType6.GROUP,
            isDm,
            ...metadata
          },
          source: "socketio"
        });
        logger25.info(`[SocketIO] ENTITY_JOINED event emitted successfully for ${entityId}`);
      } else {
        logger25.warn(`[SocketIO] No runtime available to emit ENTITY_JOINED event`);
      }
    } else {
      logger25.debug(`[SocketIO] Missing entityId (${entityId}) or serverId (${serverId || DEFAULT_SERVER_ID5}) - not emitting ENTITY_JOINED event`);
    }
    const successMessage = `Socket ${socket.id} successfully joined channel ${channelId}.`;
    const responsePayload = {
      message: successMessage,
      channelId,
      roomId: channelId,
      ...agentId && { agentId: validateUuid22(agentId) || agentId }
    };
    socket.emit("channel_joined", responsePayload);
    socket.emit("room_joined", responsePayload);
    logger25.info(`[SocketIO] ${successMessage}`);
  }
  async handleMessageSubmission(socket, payload) {
    const channelId = payload.channelId || payload.roomId;
    const { senderId, senderName, message, serverId, source, metadata, attachments } = payload;
    logger25.info(`[SocketIO ${socket.id}] Received SEND_MESSAGE for central submission: channel ${channelId} from ${senderName || senderId}`);
    logger25.info(`[SocketIO ${socket.id}] Full payload for debugging:`, JSON.stringify(payload, null, 2));
    const isValidServerId = serverId === DEFAULT_SERVER_ID5 || validateUuid22(serverId);
    if (!validateUuid22(channelId) || !isValidServerId || !validateUuid22(senderId) || !message) {
      this.sendErrorResponse(socket, `For SEND_MESSAGE: channelId, serverId (server_id), senderId (author_id), and message are required.`);
      return;
    }
    try {
      const isDmForWorldSetup = metadata?.isDm || metadata?.channelType === ChannelType6.DM;
      if (isDmForWorldSetup && senderId) {
        logger25.info(`[SocketIO] Detected DM channel during message submission, emitting ENTITY_JOINED for proper world setup`);
        const runtime = Array.from(this.agents.values())[0];
        if (runtime) {
          runtime.emitEvent(EventType.ENTITY_JOINED, {
            entityId: senderId,
            runtime,
            worldId: serverId,
            roomId: channelId,
            metadata: {
              type: ChannelType6.DM,
              isDm: true,
              ...metadata
            },
            source: "socketio_message"
          });
          logger25.info(`[SocketIO] ENTITY_JOINED event emitted for DM channel setup: ${senderId}`);
        }
      }
      logger25.info(`[SocketIO ${socket.id}] Checking if channel ${channelId} exists before creating message`);
      let channelExists = false;
      try {
        const existingChannel = await this.serverInstance.getChannelDetails(channelId);
        channelExists = !!existingChannel;
        logger25.info(`[SocketIO ${socket.id}] Channel ${channelId} exists: ${channelExists}`);
      } catch (error) {
        logger25.info(`[SocketIO ${socket.id}] Channel ${channelId} does not exist, will create it. Error: ${error.message}`);
      }
      if (!channelExists) {
        logger25.info(`[SocketIO ${socket.id}] Auto-creating channel ${channelId} with serverId ${serverId}`);
        try {
          const servers = await this.serverInstance.getServers();
          const serverExists = servers.some((s) => s.id === serverId);
          logger25.info(`[SocketIO ${socket.id}] Server ${serverId} exists: ${serverExists}. Available servers: ${servers.map((s) => s.id).join(", ")}`);
          if (!serverExists) {
            logger25.error(`[SocketIO ${socket.id}] Server ${serverId} does not exist, cannot create channel`);
            this.sendErrorResponse(socket, `Server ${serverId} does not exist`);
            return;
          }
          const isDmChannel = metadata?.isDm || metadata?.channelType === ChannelType6.DM;
          const channelData = {
            id: channelId,
            messageServerId: serverId,
            name: isDmChannel ? `DM ${channelId.substring(0, 8)}` : `Chat ${channelId.substring(0, 8)}`,
            type: isDmChannel ? ChannelType6.DM : ChannelType6.GROUP,
            sourceType: "auto_created",
            metadata: {
              created_by: "socketio_auto_creation",
              created_for_user: senderId,
              created_at: new Date().toISOString(),
              channel_type: isDmChannel ? ChannelType6.DM : ChannelType6.GROUP,
              ...metadata
            }
          };
          logger25.info(`[SocketIO ${socket.id}] Creating channel with data:`, JSON.stringify(channelData, null, 2));
          let participants = [senderId];
          if (isDmChannel) {
            const otherParticipant = metadata?.targetUserId || metadata?.recipientId || payload.targetUserId;
            if (otherParticipant && validateUuid22(otherParticipant)) {
              participants.push(otherParticipant);
              logger25.info(`[SocketIO ${socket.id}] DM channel will include participants: ${participants.join(", ")}`);
            } else {
              logger25.warn(`[SocketIO ${socket.id}] DM channel missing second participant, only adding sender: ${senderId}`);
            }
          }
          await this.serverInstance.createChannel(channelData, participants);
          logger25.info(`[SocketIO ${socket.id}] Auto-created ${isDmChannel ? ChannelType6.DM : ChannelType6.GROUP} channel ${channelId} for message submission with ${participants.length} participants`);
        } catch (createError) {
          logger25.error(`[SocketIO ${socket.id}] Failed to auto-create channel ${channelId}:`, createError);
          this.sendErrorResponse(socket, `Failed to create channel: ${createError.message}`);
          return;
        }
      } else {
        logger25.info(`[SocketIO ${socket.id}] Channel ${channelId} already exists, proceeding with message creation`);
      }
      const newRootMessageData = {
        channelId,
        authorId: senderId,
        content: message,
        rawMessage: payload,
        metadata: {
          ...metadata || {},
          user_display_name: senderName,
          socket_id: socket.id,
          serverId,
          attachments
        },
        sourceType: source || "socketio_client"
      };
      const createdRootMessage = await this.serverInstance.createMessage(newRootMessageData);
      logger25.info(`[SocketIO ${socket.id}] Message from ${senderId} (msgId: ${payload.messageId || "N/A"}) submitted to central store (central ID: ${createdRootMessage.id}). It will be processed by agents and broadcasted upon their reply.`);
      const transformedAttachments = attachmentsToApiUrls(attachments);
      const messageBroadcast = {
        id: createdRootMessage.id,
        senderId,
        senderName: senderName || "User",
        text: message,
        channelId,
        roomId: channelId,
        serverId,
        createdAt: new Date(createdRootMessage.createdAt).getTime(),
        source: source || "socketio_client",
        attachments: transformedAttachments
      };
      socket.to(channelId).emit("messageBroadcast", messageBroadcast);
      socket.emit("messageBroadcast", {
        ...messageBroadcast,
        clientMessageId: payload.messageId
      });
      socket.emit("messageAck", {
        clientMessageId: payload.messageId,
        messageId: createdRootMessage.id,
        status: "received_by_server_and_processing",
        channelId,
        roomId: channelId
      });
    } catch (error) {
      logger25.error(`[SocketIO ${socket.id}] Error during central submission for message: ${error.message}`, error);
      this.sendErrorResponse(socket, `[SocketIO] Error processing your message: ${error.message}`);
    }
  }
  sendErrorResponse(socket, errorMessage) {
    logger25.error(`[SocketIO ${socket.id}] Sending error to client: ${errorMessage}`);
    socket.emit("messageError", {
      error: errorMessage
    });
  }
  handleLogSubscription(socket) {
    this.logStreamConnections.set(socket.id, {});
    logger25.info(`[SocketIO ${socket.id}] Client subscribed to log stream`);
    socket.emit("log_subscription_confirmed", {
      subscribed: true,
      message: "Successfully subscribed to log stream"
    });
  }
  handleLogUnsubscription(socket) {
    this.logStreamConnections.delete(socket.id);
    logger25.info(`[SocketIO ${socket.id}] Client unsubscribed from log stream`);
    socket.emit("log_subscription_confirmed", {
      subscribed: false,
      message: "Successfully unsubscribed from log stream"
    });
  }
  handleLogFilterUpdate(socket, filters) {
    const existingFilters = this.logStreamConnections.get(socket.id);
    if (existingFilters !== undefined) {
      this.logStreamConnections.set(socket.id, { ...existingFilters, ...filters });
      logger25.info(`[SocketIO ${socket.id}] Updated log filters:`, JSON.stringify(filters));
      socket.emit("log_filters_updated", {
        success: true,
        filters: this.logStreamConnections.get(socket.id)
      });
    } else {
      logger25.warn(`[SocketIO ${socket.id}] Cannot update filters: not subscribed to log stream`);
      socket.emit("log_filters_updated", {
        success: false,
        error: "Not subscribed to log stream"
      });
    }
  }
  broadcastLog(io, logEntry) {
    if (this.logStreamConnections.size === 0)
      return;
    const logData = { type: "log_entry", payload: logEntry };
    this.logStreamConnections.forEach((filters, socketId) => {
      const socket = io.sockets.sockets.get(socketId);
      if (socket) {
        let shouldBroadcast = true;
        if (filters.agentName && filters.agentName !== "all") {
          shouldBroadcast = shouldBroadcast && logEntry.agentName === filters.agentName;
        }
        if (filters.level && filters.level !== "all") {
          const numericLevel = typeof filters.level === "string" ? customLevels[filters.level.toLowerCase()] || 70 : filters.level;
          shouldBroadcast = shouldBroadcast && logEntry.level >= numericLevel;
        }
        if (shouldBroadcast) {
          socket.emit("log_stream", logData);
        }
      }
    });
  }
  handleDisconnect(socket) {
    const agentIdAssociated = this.connections.get(socket.id);
    this.connections.delete(socket.id);
    this.logStreamConnections.delete(socket.id);
    if (agentIdAssociated) {
      logger25.info(`[SocketIO] Client ${socket.id} (associated with agent ${agentIdAssociated}) disconnected.`);
    } else {
      logger25.info(`[SocketIO] Client ${socket.id} disconnected.`);
    }
  }
}

// src/api/index.ts
function setupSocketIO(server, agents, serverInstance) {
  const io = new SocketIOServer(server, {
    cors: {
      origin: "*",
      methods: ["GET", "POST"]
    }
  });
  const centralSocketRouter = new SocketIORouter(agents, serverInstance);
  centralSocketRouter.setupListeners(io);
  setupLogStreaming(io, centralSocketRouter);
  return io;
}
function setupLogStreaming(io, router) {
  const loggerInstance = logger26;
  const destination = loggerInstance[Symbol.for("pino-destination")];
  if (destination && typeof destination.write === "function") {
    const originalWrite = destination.write.bind(destination);
    destination.write = function(data) {
      originalWrite(data);
      try {
        let logEntry;
        if (typeof data === "string") {
          try {
            logEntry = JSON.parse(data);
          } catch (parseError) {
            logEntry = { message: data, level: "info" };
          }
        } else {
          logEntry = data;
        }
        if (!logEntry.time) {
          logEntry.time = Date.now();
        }
        router.broadcastLog(io, logEntry);
      } catch (error) {}
    };
  }
}
function createPluginRouteHandler(agents) {
  return (req, res, next) => {
    logger26.debug("Handling plugin request in the plugin route handler", `path: ${req.path}, method: ${req.method}`, {
      path: req.path,
      method: req.method,
      query: req.query
    });
    const agentApiRoutePattern = /^\/agents\/[a-f0-9-]{36}\/(?!plugins\/)/i;
    if (agentApiRoutePattern.test(req.path)) {
      logger26.debug(`Skipping agent API route in plugin handler: ${req.path}`);
      return next();
    }
    if (req.path.startsWith("/api/messages/")) {
      return next();
    }
    const clientRoutePattern = /^\/(chat|settings|agents|profile|dashboard|login|register|admin|home|about)\b/i;
    if (clientRoutePattern.test(req.path)) {
      logger26.debug(`Skipping client-side route in plugin handler: ${req.path}`);
      return next();
    }
    if (req.path.endsWith(".js") || req.path.includes(".js?") || req.path.match(/index-[A-Za-z0-9]{8}\.js/)) {
      logger26.debug(`JavaScript request in plugin handler: ${req.method} ${req.path}`);
      res.setHeader("Content-Type", "application/javascript");
    }
    if (agents.size === 0) {
      logger26.debug("No agents available, skipping plugin route handling.");
      return next();
    }
    let handled = false;
    const agentIdFromQuery = req.query.agentId;
    const reqPath = req.path;
    const baselessReqPath = reqPath.replace(/\/api\/agents\/[^\/]+\/plugins/, "");
    logger26.debug("Plugin Request Path", baselessReqPath);
    function findRouteInRuntime(runtime) {
      for (const route of runtime.routes) {
        if (handled)
          break;
        const methodMatches = req.method.toLowerCase() === route.type.toLowerCase();
        if (!methodMatches)
          continue;
        const routePath = route.path;
        if (routePath.endsWith("/*")) {
          const baseRoute = routePath.slice(0, -1);
          if (baselessReqPath.startsWith(baseRoute)) {
            logger26.debug(`Agent ${runtime.character.name} plugin wildcard route: [${route.type.toUpperCase()}] ${routePath} for request: ${reqPath}`);
            try {
              if (route.handler) {
                route.handler(req, res, runtime);
                handled = true;
              }
            } catch (error) {
              logger26.error(`Error handling plugin wildcard route for agent ${agentIdFromQuery}: ${routePath}`, error instanceof Error ? error.message : String(error), {
                path: reqPath,
                agent: agentIdFromQuery
              });
              if (!res.headersSent) {
                const status = error instanceof Error && "code" in error && error.code === "ENOENT" || error instanceof Error && error.message?.includes("not found") ? 404 : 500;
                res.status(status).json({
                  error: error instanceof Error ? error.message : "Error processing wildcard route"
                });
              }
              handled = true;
            }
          }
        } else {
          logger26.debug(`Agent ${runtime.character.name} attempting plugin route match: [${route.type.toUpperCase()}] ${routePath} vs request path: ${baselessReqPath}`);
          let matcher;
          try {
            matcher = import_path_to_regexp.match(routePath, { decode: decodeURIComponent });
          } catch (err) {
            logger26.error(`Invalid plugin route path syntax for agent ${agentIdFromQuery}: "${routePath}"`, err instanceof Error ? err.message : String(err));
            continue;
          }
          const matched = matcher(baselessReqPath);
          if (matched) {
            logger26.debug(`Agent ${runtime.character.name} plugin route matched: [${route.type.toUpperCase()}] ${routePath} vs request path: ${reqPath}`);
            req.params = { ...matched.params || {} };
            try {
              if (route.handler) {
                route.handler(req, res, runtime);
                handled = true;
              }
            } catch (error) {
              logger26.error(`Error handling plugin route for agent ${agentIdFromQuery}: ${routePath}`, error instanceof Error ? error.message : String(error), {
                path: reqPath,
                agent: agentIdFromQuery,
                params: req.params
              });
              if (!res.headersSent) {
                const status = error instanceof Error && "code" in error && error.code === "ENOENT" || error instanceof Error && error.message?.includes("not found") ? 404 : 500;
                res.status(status).json({
                  error: error instanceof Error ? error.message : "Error processing route"
                });
              }
              handled = true;
            }
          }
        }
      }
      return handled;
    }
    if (agentIdFromQuery && validateUuid23(agentIdFromQuery)) {
      const runtime = agents.get(agentIdFromQuery);
      if (runtime) {
        logger26.debug(`Agent-scoped request for Agent ID: ${agentIdFromQuery} from query. Path: ${reqPath}`);
        handled = findRouteInRuntime(runtime);
      } else {
        logger26.warn(`Agent ID ${agentIdFromQuery} provided in query, but agent runtime not found. Path: ${reqPath}.`);
        if (reqPath.startsWith("/api/")) {
          res.status(404).json({
            success: false,
            error: {
              message: "Agent not found",
              code: "AGENT_NOT_FOUND"
            }
          });
          return;
        } else {
          return next();
        }
      }
    } else if (agentIdFromQuery && !validateUuid23(agentIdFromQuery)) {
      logger26.warn(`Invalid Agent ID format in query: ${agentIdFromQuery}. Path: ${reqPath}.`);
      if (reqPath.startsWith("/api/")) {
        res.status(400).json({
          success: false,
          error: {
            message: "Invalid agent ID format",
            code: "INVALID_AGENT_ID"
          }
        });
        return;
      } else {
        return next();
      }
    } else {
      logger26.debug(`No valid agentId in query. Trying global match for path: ${reqPath}`);
      for (const [_, runtime] of agents) {
        if (handled)
          break;
        handled = findRouteInRuntime(runtime);
      }
    }
    if (handled) {
      return;
    }
    logger26.debug(`No plugin route handled ${req.method} ${req.path}, passing to next middleware.`);
    next();
  };
}
function createApiRouter(agents, serverInstance) {
  const router = express32.Router();
  router.use(helmet({
    contentSecurityPolicy: false,
    crossOriginResourcePolicy: { policy: "cross-origin" },
    referrerPolicy: { policy: "no-referrer" }
  }));
  router.use(cors({
    origin: process.env.API_CORS_ORIGIN || process.env.CORS_ORIGIN || false,
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization", "X-API-KEY"],
    exposedHeaders: ["X-Total-Count"],
    maxAge: 86400
  }));
  router.use(createApiRateLimit());
  router.use(securityMiddleware());
  router.use("/media", mediaRouter());
  router.use(validateContentTypeMiddleware());
  router.use("/agents", agentsRouter(agents, serverInstance));
  router.use("/messaging", messagingRouter(agents, serverInstance));
  router.use("/memory", memoryRouter(agents, serverInstance));
  router.use("/audio", audioRouter(agents));
  router.use("/server", runtimeRouter(agents, serverInstance));
  router.use("/tee", teeRouter());
  router.use("/system", systemRouter());
  router.use(createPluginRouteHandler(agents));
  return router;
}

// src/authMiddleware.ts
import { logger as logger27 } from "@elizaos/core";
function apiKeyAuthMiddleware(req, res, next) {
  const serverAuthToken = process.env.ELIZA_SERVER_AUTH_TOKEN;
  if (!serverAuthToken) {
    return next();
  }
  if (req.method === "OPTIONS") {
    return next();
  }
  const apiKey = req.headers?.["x-api-key"];
  if (!apiKey || apiKey !== serverAuthToken) {
    logger27.warn(`Unauthorized access attempt: Missing or invalid X-API-KEY from ${req.ip}`);
    return res.status(401).send("Unauthorized: Invalid or missing X-API-KEY");
  }
  next();
}

// src/services/message.ts
import {
  ChannelType as ChannelType7,
  EventType as EventType2,
  Service,
  createUniqueUuid as createUniqueUuid6,
  logger as logger28,
  validateUuid as validateUuid24
} from "@elizaos/core";
class MessageBusService extends Service {
  static serviceType = "message-bus-service";
  capabilityDescription = "Manages connection and message synchronization with the message server.";
  boundHandleIncomingMessage;
  boundHandleServerAgentUpdate;
  boundHandleMessageDeleted;
  boundHandleChannelCleared;
  subscribedServers = new Set;
  constructor(runtime) {
    super(runtime);
    this.boundHandleIncomingMessage = (data) => {
      this.handleIncomingMessage(data).catch((error) => {
        logger28.error(`[${this.runtime.character.name}] Error handling incoming message:`, error instanceof Error ? error.message : String(error));
      });
    };
    this.boundHandleServerAgentUpdate = this.handleServerAgentUpdate.bind(this);
    this.boundHandleMessageDeleted = this.handleMessageDeleted.bind(this);
    this.boundHandleChannelCleared = this.handleChannelCleared.bind(this);
  }
  static async start(runtime) {
    const service = new MessageBusService(runtime);
    await service.connectToMessageBus();
    return service;
  }
  static async stop(runtime) {
    const service = new MessageBusService(runtime);
    await service.stop();
  }
  async connectToMessageBus() {
    logger28.info(`[${this.runtime.character.name}] MessageBusService: Subscribing to internal message bus for 'new_message', 'message_deleted', and 'channel_cleared' events.`);
    bus_default.on("new_message", this.boundHandleIncomingMessage);
    bus_default.on("server_agent_update", this.boundHandleServerAgentUpdate);
    bus_default.on("message_deleted", this.boundHandleMessageDeleted);
    bus_default.on("channel_cleared", this.boundHandleChannelCleared);
    await this.fetchAgentServers();
    await this.fetchValidChannelIds();
  }
  validChannelIds = new Set;
  async fetchValidChannelIds() {
    try {
      const serverApiUrl = this.getCentralMessageServerUrl();
      this.validChannelIds.clear();
      const DEFAULT_SERVER_ID6 = "00000000-0000-0000-0000-000000000000";
      const serversToCheck = new Set(this.subscribedServers);
      serversToCheck.add(DEFAULT_SERVER_ID6);
      for (const serverId of serversToCheck) {
        try {
          const channelsUrl = new URL(`/api/messaging/central-servers/${encodeURIComponent(serverId)}/channels`, serverApiUrl);
          const response = await fetch(channelsUrl.toString(), {
            headers: this.getAuthHeaders()
          });
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.data?.channels && Array.isArray(data.data.channels)) {
              data.data.channels.forEach((channel) => {
                if (channel.id && validateUuid24(channel.id)) {
                  this.validChannelIds.add(channel.id);
                }
              });
              logger28.info(`[${this.runtime.character.name}] MessageBusService: Fetched ${data.data.channels.length} channels from server ${serverId}`);
            }
          } else {
            logger28.warn(`[${this.runtime.character.name}] MessageBusService: Failed to fetch channels for server ${serverId}: ${response.status} ${response.statusText}`);
          }
        } catch (serverError) {
          logger28.error(`[${this.runtime.character.name}] MessageBusService: Error fetching channels for server ${serverId}:`, serverError instanceof Error ? serverError.message : String(serverError));
        }
      }
      logger28.info(`[${this.runtime.character.name}] MessageBusService: Loaded ${this.validChannelIds.size} valid channel IDs from ${serversToCheck.size} servers (including default server)`);
    } catch (error) {
      logger28.error(`[${this.runtime.character.name}] MessageBusService: Error in fetchValidChannelIds:`, error instanceof Error ? error.message : String(error));
    }
  }
  async getChannelParticipants(channelId) {
    try {
      const serverApiUrl = this.getCentralMessageServerUrl();
      if (!validateUuid24(channelId)) {
        logger28.warn(`[${this.runtime.character.name}] MessageBusService: Invalid channel ID format: ${channelId}`);
        return [];
      }
      if (!this.validChannelIds.has(channelId)) {
        const detailsUrl = new URL(`/api/messaging/central-channels/${encodeURIComponent(channelId)}/details`, serverApiUrl);
        const detailsResponse = await fetch(detailsUrl.toString(), {
          headers: this.getAuthHeaders()
        });
        if (detailsResponse.ok) {
          this.validChannelIds.add(channelId);
          logger28.info(`[${this.runtime.character.name}] MessageBusService: Discovered new channel ${channelId}, added to valid channels`);
        } else {
          logger28.warn(`[${this.runtime.character.name}] MessageBusService: Channel ${channelId} does not exist or is not accessible`);
          return [];
        }
      }
      const participantsUrl = new URL(`/api/messaging/central-channels/${encodeURIComponent(channelId)}/participants`, serverApiUrl);
      const response = await fetch(participantsUrl.toString(), {
        headers: this.getAuthHeaders()
      });
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.data) {
          return data.data;
        }
      }
      return [];
    } catch (error) {
      logger28.error(`[${this.runtime.character.name}] MessageBusService: Error fetching participants for channel ${channelId}:`, error instanceof Error ? error.message : String(error));
      return [];
    }
  }
  async fetchAgentServers() {
    try {
      const serverApiUrl = this.getCentralMessageServerUrl();
      const agentServersUrl = new URL(`/api/messaging/agents/${encodeURIComponent(this.runtime.agentId)}/servers`, serverApiUrl);
      const response = await fetch(agentServersUrl.toString(), {
        headers: this.getAuthHeaders()
      });
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.data?.servers) {
          this.subscribedServers = new Set(data.data.servers);
          const DEFAULT_SERVER_ID6 = "00000000-0000-0000-0000-000000000000";
          this.subscribedServers.add(DEFAULT_SERVER_ID6);
          logger28.info(`[${this.runtime.character.name}] MessageBusService: Agent is subscribed to ${this.subscribedServers.size} servers (including default server)`);
        }
      } else {
        const DEFAULT_SERVER_ID6 = "00000000-0000-0000-0000-000000000000";
        this.subscribedServers.add(DEFAULT_SERVER_ID6);
        logger28.warn(`[${this.runtime.character.name}] MessageBusService: Failed to fetch agent servers, but added default server`);
      }
    } catch (error) {
      logger28.error(`[${this.runtime.character.name}] MessageBusService: Error fetching agent servers:`, error instanceof Error ? error.message : String(error));
      const DEFAULT_SERVER_ID6 = "00000000-0000-0000-0000-000000000000";
      this.subscribedServers.add(DEFAULT_SERVER_ID6);
      logger28.info(`[${this.runtime.character.name}] MessageBusService: Added default server after error`);
    }
  }
  async handleServerAgentUpdate(data) {
    if (data.agentId !== this.runtime.agentId) {
      return;
    }
    if (data.type === "agent_added_to_server") {
      this.subscribedServers.add(data.serverId);
      logger28.info(`[${this.runtime.character.name}] MessageBusService: Agent added to server ${data.serverId}`);
      await this.fetchValidChannelIds();
    } else if (data.type === "agent_removed_from_server") {
      this.subscribedServers.delete(data.serverId);
      logger28.info(`[${this.runtime.character.name}] MessageBusService: Agent removed from server ${data.serverId}`);
      await this.fetchValidChannelIds();
    }
  }
  async validateServerSubscription(message) {
    if (!this.subscribedServers.has(message.server_id)) {
      logger28.debug(`[${this.runtime.character.name}] MessageBusService: Agent not subscribed to server ${message.server_id}, ignoring message`);
      return false;
    }
    logger28.info(`[${this.runtime.character.name}] MessageBusService: Passed server subscription check for ${message.server_id}`);
    return true;
  }
  async validateNotSelfMessage(message) {
    if (message.author_id === this.runtime.agentId) {
      logger28.debug(`[${this.runtime.character.name}] MessageBusService: Agent is the author of the message, ignoring message`);
      return false;
    }
    return true;
  }
  async ensureWorldAndRoomExist(message) {
    const agentWorldId = createUniqueUuid6(this.runtime, message.server_id);
    const agentRoomId = createUniqueUuid6(this.runtime, message.channel_id);
    try {
      await this.runtime.ensureWorldExists({
        id: agentWorldId,
        name: message.metadata?.serverName || `Server ${message.server_id.substring(0, 8)}`,
        agentId: this.runtime.agentId,
        serverId: message.server_id,
        metadata: {
          ...message.metadata?.serverMetadata || {}
        }
      });
    } catch (error) {
      if (error.message && error.message.includes("worlds_pkey")) {
        logger28.debug(`[${this.runtime.character.name}] MessageBusService: World ${agentWorldId} already exists, continuing with message processing`);
      } else {
        throw error;
      }
    }
    try {
      await this.runtime.ensureRoomExists({
        id: agentRoomId,
        name: message.metadata?.channelName || `Channel ${message.channel_id.substring(0, 8)}`,
        agentId: this.runtime.agentId,
        worldId: agentWorldId,
        channelId: message.channel_id,
        serverId: message.server_id,
        source: message.source_type || "central-bus",
        type: message.metadata?.channelType || ChannelType7.GROUP,
        metadata: {
          ...message.metadata?.channelMetadata || {}
        }
      });
    } catch (error) {
      if (error.message && error.message.includes("rooms_pkey")) {
        logger28.debug(`[${this.runtime.character.name}] MessageBusService: Room ${agentRoomId} already exists, continuing with message processing`);
      } else {
        throw error;
      }
    }
    return { agentWorldId, agentRoomId };
  }
  async ensureAuthorEntityExists(message) {
    const agentAuthorEntityId = createUniqueUuid6(this.runtime, message.author_id);
    const authorEntity = await this.runtime.getEntityById(agentAuthorEntityId);
    if (!authorEntity) {
      await this.runtime.createEntity({
        id: agentAuthorEntityId,
        names: [message.author_display_name || `User-${message.author_id.substring(0, 8)}`],
        agentId: this.runtime.agentId,
        metadata: {
          author_id: message.author_id,
          source: message.source_type
        }
      });
    }
    return agentAuthorEntityId;
  }
  createAgentMemory(message, agentAuthorEntityId, agentRoomId, agentWorldId) {
    const messageContent = {
      text: message.content,
      source: message.source_type || "central-bus",
      attachments: message.metadata?.attachments?.map((att) => ({
        id: att.id,
        url: att.url,
        title: att.name,
        contentType: att.type
      })),
      inReplyTo: message.in_reply_to_message_id ? createUniqueUuid6(this.runtime, message.in_reply_to_message_id) : undefined
    };
    const uniqueMemoryId = createUniqueUuid6(this.runtime, `${message.id}-${this.runtime.agentId}`);
    return {
      id: uniqueMemoryId,
      entityId: agentAuthorEntityId,
      agentId: this.runtime.agentId,
      roomId: agentRoomId,
      worldId: agentWorldId,
      content: messageContent,
      createdAt: message.created_at,
      metadata: {
        ...message.metadata || {},
        type: "message",
        source: message.source_type || "central-bus",
        sourceId: message.id,
        raw: {
          ...typeof message.raw_message === "object" && message.raw_message !== null ? message.raw_message : {},
          senderName: message.author_display_name || `User-${message.author_id.substring(0, 8)}`,
          senderId: message.author_id
        }
      }
    };
  }
  async handleIncomingMessage(data) {
    if (!data || typeof data !== "object") {
      logger28.error(`[${this.runtime.character.name}] MessageBusService: Invalid message data received`);
      return;
    }
    const messageData = data;
    if (!messageData.id || !messageData.channel_id || !messageData.author_id || !messageData.content) {
      logger28.error(`[${this.runtime.character.name}] MessageBusService: Message missing required fields`, JSON.stringify({
        hasId: !!messageData.id,
        hasChannelId: !!messageData.channel_id,
        hasAuthorId: !!messageData.author_id,
        hasContent: !!messageData.content
      }));
      return;
    }
    const message = messageData;
    logger28.info(`[${this.runtime.character.name}] MessageBusService: Received message from central bus`, JSON.stringify({ messageId: message.id }));
    const participants = await this.getChannelParticipants(message.channel_id);
    if (!participants.includes(this.runtime.agentId)) {
      logger28.info(`[${this.runtime.character.name}] MessageBusService: Agent not a participant in channel ${message.channel_id}, ignoring message`);
      return;
    }
    logger28.info(`[${this.runtime.character.name} - ${this.runtime.agentId}] MessageBusService: Agent is a participant in channel ${message.channel_id}, proceeding with message processing`);
    try {
      if (!await this.validateServerSubscription(message))
        return;
      if (!await this.validateNotSelfMessage(message))
        return;
      logger28.info(`[${this.runtime.character.name}] MessageBusService: All checks passed, proceeding to create agent memory and emit MESSAGE_RECEIVED event`);
      const { agentWorldId, agentRoomId } = await this.ensureWorldAndRoomExist(message);
      const agentAuthorEntityId = await this.ensureAuthorEntityExists(message);
      const agentMemory = this.createAgentMemory(message, agentAuthorEntityId, agentRoomId, agentWorldId);
      const existingMemory = await this.runtime.getMemoryById(agentMemory.id);
      if (existingMemory) {
        logger28.debug(`[${this.runtime.character.name}] MessageBusService: Memory ${agentMemory.id} already exists, skipping duplicate processing`);
        return;
      }
      const callbackForCentralBus = async (responseContent) => {
        logger28.info(`[${this.runtime.character.name}] Agent generated response for message. Preparing to send back to bus.`);
        await this.runtime.createMemory({
          entityId: this.runtime.agentId,
          content: responseContent,
          roomId: agentRoomId,
          worldId: agentWorldId,
          agentId: this.runtime.agentId
        }, "messages");
        await this.sendAgentResponseToBus(agentRoomId, agentWorldId, responseContent, agentMemory.id, message);
        return [];
      };
      await this.runtime.emitEvent(EventType2.MESSAGE_RECEIVED, {
        runtime: this.runtime,
        message: agentMemory,
        callback: callbackForCentralBus,
        onComplete: async () => {
          const room = await this.runtime.getRoom(agentRoomId);
          const world = await this.runtime.getWorld(agentWorldId);
          const channelId = room?.channelId;
          const serverId = world?.serverId;
          await this.notifyMessageComplete(channelId, serverId);
        }
      });
    } catch (error) {
      logger28.error(`[${this.runtime.character.name}] MessageBusService: Error processing incoming message:`, error instanceof Error ? error.message : String(error));
    }
  }
  async handleMessageDeleted(data) {
    try {
      logger28.info(`[${this.runtime.character.name}] MessageBusService: Received message_deleted event for message ${data.messageId}`);
      const agentMemoryId = createUniqueUuid6(this.runtime, data.messageId);
      const existingMemory = await this.runtime.getMemoryById(agentMemoryId);
      if (existingMemory) {
        await this.runtime.emitEvent(EventType2.MESSAGE_DELETED, {
          runtime: this.runtime,
          message: existingMemory,
          source: "message-bus-service"
        });
        logger28.debug(`[${this.runtime.character.name}] MessageBusService: Successfully processed message deletion for ${data.messageId}`);
      } else {
        logger28.warn(`[${this.runtime.character.name}] MessageBusService: No memory found for deleted message ${data.messageId}`);
      }
    } catch (error) {
      logger28.error(`[${this.runtime.character.name}] MessageBusService: Error handling message deletion:`, error instanceof Error ? error.message : String(error));
    }
  }
  async handleChannelCleared(data) {
    try {
      logger28.info(`[${this.runtime.character.name}] MessageBusService: Received channel_cleared event for channel ${data.channelId}`);
      const agentRoomId = createUniqueUuid6(this.runtime, data.channelId);
      const memories = await this.runtime.getMemoriesByRoomIds({
        tableName: "messages",
        roomIds: [agentRoomId]
      });
      logger28.info(`[${this.runtime.character.name}] MessageBusService: Found ${memories.length} memories to delete for channel ${data.channelId}`);
      await this.runtime.emitEvent(EventType2.CHANNEL_CLEARED, {
        runtime: this.runtime,
        source: "message-bus-service",
        roomId: agentRoomId,
        channelId: data.channelId,
        memoryCount: memories.length
      });
      logger28.info(`[${this.runtime.character.name}] MessageBusService: Successfully processed channel clear for ${data.channelId} -> room ${agentRoomId}`);
    } catch (error) {
      logger28.error(`[${this.runtime.character.name}] MessageBusService: Error handling channel clear:`, error instanceof Error ? error.message : String(error));
    }
  }
  async sendAgentResponseToBus(agentRoomId, agentWorldId, content, inReplyToAgentMemoryId, originalMessage) {
    try {
      const room = await this.runtime.getRoom(agentRoomId);
      const world = await this.runtime.getWorld(agentWorldId);
      const channelId = room?.channelId;
      const serverId = world?.serverId;
      if (!channelId || !serverId) {
        logger28.error(`[${this.runtime.character.name}] MessageBusService: Cannot map agent room/world to central IDs for response. AgentRoomID: ${agentRoomId}, AgentWorldID: ${agentWorldId}. Room or World object missing, or channelId/serverId not found on them.`);
        return;
      }
      const shouldSkip = content.actions?.includes("IGNORE") || !content.text || content.text.trim() === "";
      if (shouldSkip) {
        logger28.info(`[${this.runtime.character.name}] MessageBusService: Skipping response (reason: ${content.actions?.includes("IGNORE") ? "IGNORE action" : "No text"})`);
        return;
      }
      let centralInReplyToRootMessageId = undefined;
      if (inReplyToAgentMemoryId) {
        const originalAgentMemory = await this.runtime.getMemoryById(inReplyToAgentMemoryId);
        if (originalAgentMemory?.metadata?.sourceId) {
          centralInReplyToRootMessageId = originalAgentMemory.metadata.sourceId;
        }
      }
      const payloadToServer = {
        channel_id: channelId,
        server_id: serverId,
        author_id: this.runtime.agentId,
        content: content.text,
        in_reply_to_message_id: centralInReplyToRootMessageId,
        source_type: "agent_response",
        raw_message: {
          text: content.text,
          thought: content.thought,
          actions: content.actions
        },
        metadata: {
          agent_id: this.runtime.agentId,
          agentName: this.runtime.character.name,
          attachments: content.attachments,
          channelType: originalMessage?.metadata?.channelType || room?.type,
          isDm: originalMessage?.metadata?.isDm || (originalMessage?.metadata?.channelType || room?.type) === ChannelType7.DM
        }
      };
      logger28.info(`[${this.runtime.character.name}] MessageBusService: Sending payload to central server API endpoint (/api/messaging/submit):`, JSON.stringify(payloadToServer));
      const baseUrl = this.getCentralMessageServerUrl();
      const submitUrl = new URL("/api/messaging/submit", baseUrl);
      const serverApiUrl = submitUrl.toString();
      const response = await fetch(serverApiUrl, {
        method: "POST",
        headers: this.getAuthHeaders(),
        body: JSON.stringify(payloadToServer)
      });
      if (!response.ok) {
        logger28.error(`[${this.runtime.character.name}] MessageBusService: Error sending response to central server: ${response.status} ${await response.text()}`);
      }
    } catch (error) {
      logger28.error(`[${this.runtime.character.name}] MessageBusService: Error sending agent response to bus:`, error instanceof Error ? error.message : String(error));
    }
  }
  async notifyActionStart(agentRoomId, agentWorldId, content, messageId, inReplyToAgentMemoryId, originalMessage) {
    try {
      const room = await this.runtime.getRoom(agentRoomId);
      const world = await this.runtime.getWorld(agentWorldId);
      const channelId = room?.channelId;
      const serverId = world?.serverId;
      if (!channelId || !serverId) {
        logger28.error(`[${this.runtime.character.name}] MessageBusService: Cannot map room/world -> central IDs. room=${agentRoomId}, world=${agentWorldId}`);
        return;
      }
      let centralInReplyToRootMessageId;
      if (inReplyToAgentMemoryId) {
        const m = await this.runtime.getMemoryById(inReplyToAgentMemoryId);
        if (m?.metadata?.sourceId)
          centralInReplyToRootMessageId = m.metadata.sourceId;
      }
      const payloadToServer = {
        messageId,
        channel_id: channelId,
        server_id: serverId,
        author_id: this.runtime.agentId,
        content: content.text,
        in_reply_to_message_id: centralInReplyToRootMessageId,
        source_type: "agent_action",
        raw_message: {
          text: content.text,
          thought: content.thought,
          actions: content.actions,
          ...content
        },
        metadata: {
          agent_id: this.runtime.agentId,
          agentName: this.runtime.character.name,
          attachments: content.attachments,
          channelType: originalMessage?.metadata?.channelType || room?.type,
          isDm: originalMessage?.metadata?.isDm || (originalMessage?.metadata?.channelType || room?.type) === ChannelType7.DM
        }
      };
      const baseUrl = this.getCentralMessageServerUrl();
      const submitUrl = new URL("/api/messaging/action", baseUrl).toString();
      logger28.info(`[${this.runtime.character.name}] -> POST ${submitUrl} payload: ${JSON.stringify(payloadToServer)}`);
      const response = await fetch(submitUrl, {
        method: "POST",
        headers: this.getAuthHeaders(),
        body: JSON.stringify(payloadToServer)
      });
      if (!response.ok) {
        logger28.error(`[${this.runtime.character.name}] POST /action failed: ${response.status} ${await response.text()}`);
      }
      return response;
    } catch (error) {
      logger28.error(`[${this.runtime.character.name}] notifyActionStart error:`, error instanceof Error ? error.message : String(error));
    }
  }
  async notifyActionUpdate(agentRoomId, agentWorldId, content, messageId, inReplyToAgentMemoryId, originalMessage) {
    try {
      const room = await this.runtime.getRoom(agentRoomId);
      const world = await this.runtime.getWorld(agentWorldId);
      const channelId = room?.channelId;
      const serverId = world?.serverId;
      if (!channelId || !serverId) {
        logger28.error(`[${this.runtime.character.name}] MessageBusService: Cannot map room/world -> central IDs. room=${agentRoomId}, world=${agentWorldId}`);
        return;
      }
      let centralInReplyToRootMessageId;
      if (inReplyToAgentMemoryId) {
        const m = await this.runtime.getMemoryById(inReplyToAgentMemoryId);
        if (m?.metadata?.sourceId)
          centralInReplyToRootMessageId = m.metadata.sourceId;
      }
      const patchPayload = {
        content: content.text,
        raw_message: {
          text: content.text,
          thought: content.thought,
          actions: content.actions,
          ...content
        },
        source_type: "agent_action",
        in_reply_to_message_id: centralInReplyToRootMessageId,
        metadata: {
          agent_id: this.runtime.agentId,
          agentName: this.runtime.character.name,
          attachments: content.attachments,
          channelType: originalMessage?.metadata?.channelType || room?.type,
          isDm: originalMessage?.metadata?.isDm || (originalMessage?.metadata?.channelType || room?.type) === ChannelType7.DM
        }
      };
      const baseUrl = this.getCentralMessageServerUrl();
      const patchUrl = new URL(`/api/messaging/action/${messageId}`, baseUrl).toString();
      logger28.info(`[${this.runtime.character.name}] -> PATCH ${patchUrl} payload: ${JSON.stringify(patchPayload)}`);
      const response = await fetch(patchUrl, {
        method: "PATCH",
        headers: this.getAuthHeaders(),
        body: JSON.stringify(patchPayload)
      });
      if (!response.ok) {
        logger28.error(`[${this.runtime.character.name}] PATCH /action/${messageId} failed: ${response.status} ${await response.text()}`);
      }
      return response;
    } catch (error) {
      logger28.error(`[${this.runtime.character.name}] notifyActionUpdate error:`, error instanceof Error ? error.message : String(error));
    }
  }
  async notifyMessageComplete(channelId, serverId) {
    if (!channelId || !serverId)
      return;
    try {
      const completeUrl = new URL("/api/messaging/complete", this.getCentralMessageServerUrl());
      await fetch(completeUrl.toString(), {
        method: "POST",
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ channel_id: channelId, server_id: serverId })
      });
    } catch (error) {
      logger28.warn(`[${this.runtime.character.name}] MessageBusService: Failed to notify completion`, error instanceof Error ? error.message : String(error));
    }
  }
  getAuthHeaders() {
    const headers = {
      "Content-Type": "application/json"
    };
    const serverAuthToken = process.env.ELIZA_SERVER_AUTH_TOKEN;
    if (serverAuthToken) {
      headers["X-API-KEY"] = serverAuthToken;
    }
    return headers;
  }
  getCentralMessageServerUrl() {
    const serverPort = process.env.SERVER_PORT;
    const envUrl = process.env.CENTRAL_MESSAGE_SERVER_URL;
    let validatedPort = null;
    if (serverPort) {
      const portNum = parseInt(serverPort, 10);
      if (!isNaN(portNum) && portNum > 0 && portNum <= 65535) {
        validatedPort = portNum;
      } else {
        logger28.warn(`[MessageBusService] Invalid SERVER_PORT value: ${serverPort}`);
      }
    }
    const host = process.platform === "win32" ? "127.0.0.1" : "localhost";
    const defaultUrl = validatedPort ? `http://${host}:${validatedPort}` : `http://${host}:3000`;
    const baseUrl = envUrl ?? defaultUrl;
    try {
      const url = new URL(baseUrl);
      if (!["http:", "https:"].includes(url.protocol)) {
        logger28.warn(`[MessageBusService] Unsafe protocol in CENTRAL_MESSAGE_SERVER_URL: ${url.protocol}`);
        return defaultUrl;
      }
      const allowedHosts = ["localhost", "127.0.0.1", "::1"];
      if (!allowedHosts.includes(url.hostname)) {
        logger28.warn(`[MessageBusService] Unsafe hostname in CENTRAL_MESSAGE_SERVER_URL: ${url.hostname}`);
        return defaultUrl;
      }
      if (url.port) {
        const portNum = parseInt(url.port, 10);
        if (isNaN(portNum) || portNum <= 0 || portNum > 65535) {
          logger28.warn(`[MessageBusService] Invalid port in CENTRAL_MESSAGE_SERVER_URL: ${url.port}`);
          return defaultUrl;
        }
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      return url.toString().replace(/\/$/, "");
    } catch (error) {
      logger28.error(`[MessageBusService] Invalid URL format in CENTRAL_MESSAGE_SERVER_URL: ${baseUrl}`);
      return defaultUrl;
    }
  }
  async stop() {
    logger28.info(`[${this.runtime.character.name}] MessageBusService stopping...`);
    bus_default.off("new_message", this.boundHandleIncomingMessage);
    bus_default.off("server_agent_update", this.boundHandleServerAgentUpdate);
    bus_default.off("message_deleted", this.boundHandleMessageDeleted);
    bus_default.off("channel_cleared", this.boundHandleChannelCleared);
  }
}
var messageBusConnectorPlugin = {
  name: "internal-message-bus-connector",
  description: "Internal service to connect agent to the message bus.",
  services: [MessageBusService]
};

// src/loader.ts
import fs5 from "node:fs";
import path6 from "node:path";
import { fileURLToPath } from "node:url";
import {
  logger as logger29,
  parseAndValidateCharacter,
  validateCharacter,
  getCharactersDir
} from "@elizaos/core";
var __filename2 = fileURLToPath(import.meta.url);
var __dirname2 = path6.dirname(__filename2);
function tryLoadFile(filePath) {
  try {
    return fs5.readFileSync(filePath, "utf8");
  } catch (e) {
    throw new Error(`Error loading file ${filePath}: ${e}`);
  }
}
async function loadCharactersFromUrl(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}: ${response.statusText}`);
    }
    const responseJson = await response.json();
    let characters = [];
    if (Array.isArray(responseJson)) {
      characters = await Promise.all(responseJson.map((character) => jsonToCharacter(character)));
    } else {
      const character = await jsonToCharacter(responseJson);
      characters.push(character);
    }
    return characters;
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : String(e);
    logger29.error(`Error loading character(s) from ${url}: ${errorMsg}`);
    if (errorMsg.includes("Character validation failed") || errorMsg.includes("validation")) {
      throw new Error(`Invalid character data from URL '${url}'. The character data does not match the required schema: ${errorMsg}`);
    } else if (errorMsg.includes("JSON")) {
      throw new Error(`Invalid JSON response from URL '${url}'. The resource may not contain valid character data.`);
    } else if (e instanceof TypeError) {
      throw new Error(`Failed to fetch character from URL '${url}'. The URL may be incorrect or unavailable.`);
    } else {
      throw new Error(`Failed to load character from URL '${url}': ${errorMsg}`);
    }
  }
}
async function jsonToCharacter(character) {
  const validationResult = validateCharacter(character);
  if (!validationResult.success) {
    const errorDetails = validationResult.error?.issues ? validationResult.error.issues.map((issue) => `${issue.path.join(".")}: ${issue.message}`).join("; ") : validationResult.error?.message || "Unknown validation error";
    throw new Error(`Character validation failed: ${errorDetails}`);
  }
  if (!validationResult.data) {
    throw new Error("Validation succeeded but no data was returned");
  }
  const validatedCharacter = validationResult.data;
  const characterId = validatedCharacter.id || validatedCharacter.name;
  const characterPrefix = `CHARACTER.${characterId.toUpperCase().replace(/ /g, "_")}.`;
  const characterSettings = Object.entries(process.env).filter(([key]) => key.startsWith(characterPrefix)).reduce((settings, [key, value]) => {
    const settingKey = key.slice(characterPrefix.length);
    return { ...settings, [settingKey]: value };
  }, {});
  if (Object.keys(characterSettings).length > 0) {
    const combinedSecrets = {
      ...characterSettings,
      ...validatedCharacter.secrets || {},
      ...typeof validatedCharacter.settings?.secrets === "object" && validatedCharacter.settings?.secrets !== null ? validatedCharacter.settings.secrets : {}
    };
    const updatedCharacter = {
      ...validatedCharacter
    };
    if (validatedCharacter.settings || Object.keys(combinedSecrets).length > 0) {
      updatedCharacter.settings = validatedCharacter.settings || {};
    }
    if (Object.keys(combinedSecrets).length > 0) {
      updatedCharacter.secrets = combinedSecrets;
    }
    const revalidationResult = validateCharacter(updatedCharacter);
    if (!revalidationResult.success) {
      logger29.warn("Character became invalid after adding environment settings, using original validated character");
      return validatedCharacter;
    }
    if (!revalidationResult.data) {
      logger29.warn("Revalidation succeeded but no data returned, using original character");
      return validatedCharacter;
    }
    return revalidationResult.data;
  }
  return validatedCharacter;
}
async function loadCharacter(filePath) {
  const content = tryLoadFile(filePath);
  if (!content) {
    throw new Error(`Character file not found: ${filePath}`);
  }
  const parseResult = parseAndValidateCharacter(content);
  if (!parseResult.success) {
    throw new Error(`Failed to load character from ${filePath}: ${parseResult.error?.message}`);
  }
  return jsonToCharacter(parseResult.data);
}
function handleCharacterLoadError(path7, error) {
  const errorMsg = error instanceof Error ? error.message : String(error);
  if (errorMsg.includes("ENOENT") || errorMsg.includes("no such file")) {
    logger29.error(`Character file not found: ${path7}`);
    throw new Error(`Character '${path7}' not found. Please check if the file exists and the path is correct.`);
  } else if (errorMsg.includes("Character validation failed")) {
    logger29.error(`Character validation failed for: ${path7}`);
    throw new Error(`Character file '${path7}' contains invalid character data. ${errorMsg}`);
  } else if (errorMsg.includes("JSON")) {
    logger29.error(`JSON parsing error in character file: ${path7}`);
    throw new Error(`Character file '${path7}' has malformed JSON. Please check the file content.`);
  } else if (errorMsg.includes("Invalid JSON")) {
    logger29.error(`Invalid JSON in character file: ${path7}`);
    throw new Error(`Character file '${path7}' has invalid JSON format. Please check the file content.`);
  } else {
    logger29.error(`Error loading character from ${path7}: ${errorMsg}`);
    throw new Error(`Failed to load character '${path7}': ${errorMsg}`);
  }
}
async function safeLoadCharacter(path7) {
  try {
    const character = await loadCharacter(path7);
    logger29.info(`Successfully loaded character from: ${path7}`);
    return character;
  } catch (e) {
    return handleCharacterLoadError(path7, e);
  }
}
async function loadCharacterTryPath(characterPath) {
  if (characterPath.startsWith("http")) {
    try {
      const characters = await loadCharactersFromUrl(characterPath);
      if (!characters || characters.length === 0) {
        throw new Error("No characters found in the URL response");
      }
      return characters[0];
    } catch (error) {
      throw error;
    }
  }
  const hasJsonExtension = characterPath.toLowerCase().endsWith(".json");
  const basePath = hasJsonExtension ? characterPath : characterPath;
  const jsonPath = hasJsonExtension ? characterPath : `${characterPath}.json`;
  const basePathsToTry = [
    basePath,
    path6.resolve(process.cwd(), basePath),
    path6.resolve(process.cwd(), "..", "..", basePath),
    path6.resolve(process.cwd(), "..", "..", "..", basePath),
    path6.resolve(process.cwd(), "agent", basePath),
    path6.resolve(__dirname2, basePath),
    path6.resolve(__dirname2, "characters", path6.basename(basePath)),
    path6.resolve(__dirname2, "../characters", path6.basename(basePath)),
    path6.resolve(__dirname2, "../../characters", path6.basename(basePath)),
    path6.resolve(__dirname2, "../../../characters", path6.basename(basePath))
  ];
  const jsonPathsToTry = hasJsonExtension ? [] : [
    jsonPath,
    path6.resolve(process.cwd(), jsonPath),
    path6.resolve(process.cwd(), "..", "..", jsonPath),
    path6.resolve(process.cwd(), "..", "..", "..", jsonPath),
    path6.resolve(process.cwd(), "agent", jsonPath),
    path6.resolve(__dirname2, jsonPath),
    path6.resolve(__dirname2, "characters", path6.basename(jsonPath)),
    path6.resolve(__dirname2, "../characters", path6.basename(jsonPath)),
    path6.resolve(__dirname2, "../../characters", path6.basename(jsonPath)),
    path6.resolve(__dirname2, "../../../characters", path6.basename(jsonPath))
  ];
  const pathsToTry = Array.from(new Set([...basePathsToTry, ...jsonPathsToTry]));
  let lastError = null;
  for (const tryPath of pathsToTry) {
    try {
      const content = tryLoadFile(tryPath);
      if (content !== null) {
        return safeLoadCharacter(tryPath);
      }
    } catch (e) {
      lastError = e;
    }
  }
  const errorMessage = lastError ? `${lastError}` : "File not found in any of the expected locations";
  return handleCharacterLoadError(characterPath, `Character not found. Tried ${pathsToTry.length} locations. ${errorMessage}`);
}
function commaSeparatedStringToArray(commaSeparated) {
  return commaSeparated?.split(",").map((value) => value.trim());
}
async function readCharactersFromStorage(characterPaths) {
  try {
    const uploadDir = getCharactersDir();
    await fs5.promises.mkdir(uploadDir, { recursive: true });
    const fileNames = await fs5.promises.readdir(uploadDir);
    for (const fileName of fileNames) {
      characterPaths.push(path6.join(uploadDir, fileName));
    }
  } catch (err) {
    logger29.error(`Error reading directory: ${err.message}`);
  }
  return characterPaths;
}
var hasValidRemoteUrls = () => process.env.REMOTE_CHARACTER_URLS && process.env.REMOTE_CHARACTER_URLS !== "" && process.env.REMOTE_CHARACTER_URLS.startsWith("http");
async function loadCharacters(charactersArg) {
  let characterPaths = commaSeparatedStringToArray(charactersArg);
  const loadedCharacters = [];
  if (process.env.USE_CHARACTER_STORAGE === "true") {
    characterPaths = await readCharactersFromStorage(characterPaths);
  }
  if (characterPaths?.length > 0) {
    for (const characterPath of characterPaths) {
      try {
        const character = await loadCharacterTryPath(characterPath);
        loadedCharacters.push(character);
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        logger29.error(`Failed to load character from '${characterPath}': ${errorMsg}`);
      }
    }
  }
  if (hasValidRemoteUrls()) {
    logger29.info("Loading characters from remote URLs");
    const characterUrls = commaSeparatedStringToArray(process.env.REMOTE_CHARACTER_URLS || "");
    for (const characterUrl of characterUrls) {
      const characters = await loadCharactersFromUrl(characterUrl);
      loadedCharacters.push(...characters);
    }
  }
  if (loadedCharacters.length === 0) {
    logger29.info("No characters found, using default character");
    logger29.warn("Server package does not include a default character. Please provide one.");
  }
  return loadedCharacters;
}

// ../../node_modules/@sentry/node/build/esm/integrations/http.js
var import_api9 = __toESM(require_src(), 1);
var import_instrumentation_http = __toESM(require_src7(), 1);

// ../../node_modules/@sentry/core/build/esm/debug-build.js
var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../node_modules/@sentry/core/build/esm/utils/worldwide.js
var GLOBAL_OBJ = globalThis;

// ../../node_modules/@sentry/core/build/esm/utils/version.js
var SDK_VERSION = "10.12.0";

// ../../node_modules/@sentry/core/build/esm/carrier.js
function getMainCarrier() {
  getSentryCarrier(GLOBAL_OBJ);
  return GLOBAL_OBJ;
}
function getSentryCarrier(carrier) {
  const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;
  return __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
}
function getGlobalSingleton(name, creator, obj = GLOBAL_OBJ) {
  const __SENTRY__ = obj.__SENTRY__ = obj.__SENTRY__ || {};
  const carrier = __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
  return carrier[name] || (carrier[name] = creator());
}

// ../../node_modules/@sentry/core/build/esm/utils/debug-logger.js
var CONSOLE_LEVELS = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
];
var PREFIX = "Sentry Logger ";
var originalConsoleMethods = {};
function consoleSandbox(callback) {
  if (!("console" in GLOBAL_OBJ)) {
    return callback();
  }
  const console2 = GLOBAL_OBJ.console;
  const wrappedFuncs = {};
  const wrappedLevels = Object.keys(originalConsoleMethods);
  wrappedLevels.forEach((level) => {
    const originalConsoleMethod = originalConsoleMethods[level];
    wrappedFuncs[level] = console2[level];
    console2[level] = originalConsoleMethod;
  });
  try {
    return callback();
  } finally {
    wrappedLevels.forEach((level) => {
      console2[level] = wrappedFuncs[level];
    });
  }
}
function enable() {
  _getLoggerSettings().enabled = true;
}
function disable() {
  _getLoggerSettings().enabled = false;
}
function isEnabled() {
  return _getLoggerSettings().enabled;
}
function log(...args) {
  _maybeLog("log", ...args);
}
function warn(...args) {
  _maybeLog("warn", ...args);
}
function error(...args) {
  _maybeLog("error", ...args);
}
function _maybeLog(level, ...args) {
  if (!DEBUG_BUILD) {
    return;
  }
  if (isEnabled()) {
    consoleSandbox(() => {
      GLOBAL_OBJ.console[level](`${PREFIX}[${level}]:`, ...args);
    });
  }
}
function _getLoggerSettings() {
  if (!DEBUG_BUILD) {
    return { enabled: false };
  }
  return getGlobalSingleton("loggerSettings", () => ({ enabled: false }));
}
var debug = {
  enable,
  disable,
  isEnabled,
  log,
  warn,
  error
};

// ../../node_modules/@sentry/core/build/esm/utils/stacktrace.js
var STACKTRACE_FRAME_LIMIT = 50;
var UNKNOWN_FUNCTION = "?";
var WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
var STRIP_FRAME_REGEXP = /captureMessage|captureException/;
function createStackParser(...parsers) {
  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map((p) => p[1]);
  return (stack, skipFirstLines = 0, framesToPop = 0) => {
    const frames = [];
    const lines = stack.split(`
`);
    for (let i = skipFirstLines;i < lines.length; i++) {
      let line = lines[i];
      if (line.length > 1024) {
        line = line.slice(0, 1024);
      }
      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
      if (cleanedLine.match(/\S*Error: /)) {
        continue;
      }
      for (const parser of sortedParsers) {
        const frame = parser(cleanedLine);
        if (frame) {
          frames.push(frame);
          break;
        }
      }
      if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {
        break;
      }
    }
    return stripSentryFramesAndReverse(frames.slice(framesToPop));
  };
}
function stackParserFromStackParserOptions(stackParser) {
  if (Array.isArray(stackParser)) {
    return createStackParser(...stackParser);
  }
  return stackParser;
}
function stripSentryFramesAndReverse(stack) {
  if (!stack.length) {
    return [];
  }
  const localStack = Array.from(stack);
  if (/sentryWrapped/.test(getLastStackFrame(localStack).function || "")) {
    localStack.pop();
  }
  localStack.reverse();
  if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || "")) {
    localStack.pop();
    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || "")) {
      localStack.pop();
    }
  }
  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({
    ...frame,
    filename: frame.filename || getLastStackFrame(localStack).filename,
    function: frame.function || UNKNOWN_FUNCTION
  }));
}
function getLastStackFrame(arr) {
  return arr[arr.length - 1] || {};
}
var defaultFunctionName = "<anonymous>";
function getFunctionName(fn) {
  try {
    if (!fn || typeof fn !== "function") {
      return defaultFunctionName;
    }
    return fn.name || defaultFunctionName;
  } catch {
    return defaultFunctionName;
  }
}

// ../../node_modules/@sentry/core/build/esm/instrument/handlers.js
var handlers = {};
var instrumented = {};
function addHandler(type, handler) {
  handlers[type] = handlers[type] || [];
  handlers[type].push(handler);
}
function maybeInstrument(type, instrumentFn) {
  if (!instrumented[type]) {
    instrumented[type] = true;
    try {
      instrumentFn();
    } catch (e) {
      DEBUG_BUILD && debug.error(`Error while instrumenting ${type}`, e);
    }
  }
}
function triggerHandlers(type, data) {
  const typeHandlers = type && handlers[type];
  if (!typeHandlers) {
    return;
  }
  for (const handler of typeHandlers) {
    try {
      handler(data);
    } catch (e) {
      DEBUG_BUILD && debug.error(`Error while triggering instrumentation handler.
Type: ${type}
Name: ${getFunctionName(handler)}
Error:`, e);
    }
  }
}

// ../../node_modules/@sentry/core/build/esm/instrument/globalError.js
var _oldOnErrorHandler = null;
function addGlobalErrorInstrumentationHandler(handler) {
  const type = "error";
  addHandler(type, handler);
  maybeInstrument(type, instrumentError);
}
function instrumentError() {
  _oldOnErrorHandler = GLOBAL_OBJ.onerror;
  GLOBAL_OBJ.onerror = function(msg, url, line, column, error2) {
    const handlerData = {
      column,
      error: error2,
      line,
      msg,
      url
    };
    triggerHandlers("error", handlerData);
    if (_oldOnErrorHandler) {
      return _oldOnErrorHandler.apply(this, arguments);
    }
    return false;
  };
  GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
}

// ../../node_modules/@sentry/core/build/esm/instrument/globalUnhandledRejection.js
var _oldOnUnhandledRejectionHandler = null;
function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
  const type = "unhandledrejection";
  addHandler(type, handler);
  maybeInstrument(type, instrumentUnhandledRejection);
}
function instrumentUnhandledRejection() {
  _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;
  GLOBAL_OBJ.onunhandledrejection = function(e) {
    const handlerData = e;
    triggerHandlers("unhandledrejection", handlerData);
    if (_oldOnUnhandledRejectionHandler) {
      return _oldOnUnhandledRejectionHandler.apply(this, arguments);
    }
    return true;
  };
  GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
}

// ../../node_modules/@sentry/core/build/esm/utils/is.js
var objectToString = Object.prototype.toString;
function isError(wat) {
  switch (objectToString.call(wat)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return true;
    default:
      return isInstanceOf(wat, Error);
  }
}
function isBuiltin(wat, className) {
  return objectToString.call(wat) === `[object ${className}]`;
}
function isErrorEvent(wat) {
  return isBuiltin(wat, "ErrorEvent");
}
function isString(wat) {
  return isBuiltin(wat, "String");
}
function isParameterizedString(wat) {
  return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
}
function isPrimitive(wat) {
  return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
}
function isPlainObject(wat) {
  return isBuiltin(wat, "Object");
}
function isEvent(wat) {
  return typeof Event !== "undefined" && isInstanceOf(wat, Event);
}
function isElement(wat) {
  return typeof Element !== "undefined" && isInstanceOf(wat, Element);
}
function isRegExp(wat) {
  return isBuiltin(wat, "RegExp");
}
function isThenable(wat) {
  return Boolean(wat?.then && typeof wat.then === "function");
}
function isSyntheticEvent(wat) {
  return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
}
function isInstanceOf(wat, base) {
  try {
    return wat instanceof base;
  } catch {
    return false;
  }
}
function isVueViewModel(wat) {
  return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
}

// ../../node_modules/@sentry/core/build/esm/utils/browser.js
var WINDOW = GLOBAL_OBJ;
var DEFAULT_MAX_STRING_LENGTH = 80;
function htmlTreeAsString(elem, options = {}) {
  if (!elem) {
    return "<unknown>";
  }
  try {
    let currentElem = elem;
    const MAX_TRAVERSE_HEIGHT = 5;
    const out = [];
    let height = 0;
    let len = 0;
    const separator = " > ";
    const sepLength = separator.length;
    let nextStr;
    const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
    const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = _htmlElementAsString(currentElem, keyAttrs);
      if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
        break;
      }
      out.push(nextStr);
      len += nextStr.length;
      currentElem = currentElem.parentNode;
    }
    return out.reverse().join(separator);
  } catch {
    return "<unknown>";
  }
}
function _htmlElementAsString(el, keyAttrs) {
  const elem = el;
  const out = [];
  if (!elem?.tagName) {
    return "";
  }
  if (WINDOW.HTMLElement) {
    if (elem instanceof HTMLElement && elem.dataset) {
      if (elem.dataset["sentryComponent"]) {
        return elem.dataset["sentryComponent"];
      }
      if (elem.dataset["sentryElement"]) {
        return elem.dataset["sentryElement"];
      }
    }
  }
  out.push(elem.tagName.toLowerCase());
  const keyAttrPairs = keyAttrs?.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
  if (keyAttrPairs?.length) {
    keyAttrPairs.forEach((keyAttrPair) => {
      out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
    });
  } else {
    if (elem.id) {
      out.push(`#${elem.id}`);
    }
    const className = elem.className;
    if (className && isString(className)) {
      const classes = className.split(/\s+/);
      for (const c of classes) {
        out.push(`.${c}`);
      }
    }
  }
  const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
  for (const k of allowedAttrs) {
    const attr = elem.getAttribute(k);
    if (attr) {
      out.push(`[${k}="${attr}"]`);
    }
  }
  return out.join("");
}

// ../../node_modules/@sentry/core/build/esm/utils/string.js
function truncate(str, max = 0) {
  if (typeof str !== "string" || max === 0) {
    return str;
  }
  return str.length <= max ? str : `${str.slice(0, max)}...`;
}
function snipLine(line, colno) {
  let newLine = line;
  const lineLength = newLine.length;
  if (lineLength <= 150) {
    return newLine;
  }
  if (colno > lineLength) {
    colno = lineLength;
  }
  let start = Math.max(colno - 60, 0);
  if (start < 5) {
    start = 0;
  }
  let end = Math.min(start + 140, lineLength);
  if (end > lineLength - 5) {
    end = lineLength;
  }
  if (end === lineLength) {
    start = Math.max(end - 140, 0);
  }
  newLine = newLine.slice(start, end);
  if (start > 0) {
    newLine = `'{snip} ${newLine}`;
  }
  if (end < lineLength) {
    newLine += " {snip}";
  }
  return newLine;
}
function safeJoin(input, delimiter) {
  if (!Array.isArray(input)) {
    return "";
  }
  const output = [];
  for (let i = 0;i < input.length; i++) {
    const value = input[i];
    try {
      if (isVueViewModel(value)) {
        output.push("[VueViewModel]");
      } else {
        output.push(String(value));
      }
    } catch {
      output.push("[value cannot be serialized]");
    }
  }
  return output.join(delimiter);
}
function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
  if (!isString(value)) {
    return false;
  }
  if (isRegExp(pattern)) {
    return pattern.test(value);
  }
  if (isString(pattern)) {
    return requireExactStringMatch ? value === pattern : value.includes(pattern);
  }
  return false;
}
function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
  return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
}

// ../../node_modules/@sentry/core/build/esm/utils/object.js
function fill(source, name, replacementFactory) {
  if (!(name in source)) {
    return;
  }
  const original = source[name];
  if (typeof original !== "function") {
    return;
  }
  const wrapped = replacementFactory(original);
  if (typeof wrapped === "function") {
    markFunctionWrapped(wrapped, original);
  }
  try {
    source[name] = wrapped;
  } catch {
    DEBUG_BUILD && debug.log(`Failed to replace method "${name}" in object`, source);
  }
}
function addNonEnumerableProperty(obj, name, value) {
  try {
    Object.defineProperty(obj, name, {
      value,
      writable: true,
      configurable: true
    });
  } catch {
    DEBUG_BUILD && debug.log(`Failed to add non-enumerable property "${name}" to object`, obj);
  }
}
function markFunctionWrapped(wrapped, original) {
  try {
    const proto = original.prototype || {};
    wrapped.prototype = original.prototype = proto;
    addNonEnumerableProperty(wrapped, "__sentry_original__", original);
  } catch {}
}
function getOriginalFunction(func) {
  return func.__sentry_original__;
}
function convertToPlainObject(value) {
  if (isError(value)) {
    return {
      message: value.message,
      name: value.name,
      stack: value.stack,
      ...getOwnProperties(value)
    };
  } else if (isEvent(value)) {
    const newObj = {
      type: value.type,
      target: serializeEventTarget(value.target),
      currentTarget: serializeEventTarget(value.currentTarget),
      ...getOwnProperties(value)
    };
    if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
      newObj.detail = value.detail;
    }
    return newObj;
  } else {
    return value;
  }
}
function serializeEventTarget(target) {
  try {
    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
  } catch {
    return "<unknown>";
  }
}
function getOwnProperties(obj) {
  if (typeof obj === "object" && obj !== null) {
    const extractedProps = {};
    for (const property in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        extractedProps[property] = obj[property];
      }
    }
    return extractedProps;
  } else {
    return {};
  }
}
function extractExceptionKeysForMessage(exception, maxLength = 40) {
  const keys = Object.keys(convertToPlainObject(exception));
  keys.sort();
  const firstKey = keys[0];
  if (!firstKey) {
    return "[object has no keys]";
  }
  if (firstKey.length >= maxLength) {
    return truncate(firstKey, maxLength);
  }
  for (let includedKeys = keys.length;includedKeys > 0; includedKeys--) {
    const serialized = keys.slice(0, includedKeys).join(", ");
    if (serialized.length > maxLength) {
      continue;
    }
    if (includedKeys === keys.length) {
      return serialized;
    }
    return truncate(serialized, maxLength);
  }
  return "";
}

// ../../node_modules/@sentry/core/build/esm/utils/misc.js
function getCrypto() {
  const gbl = GLOBAL_OBJ;
  return gbl.crypto || gbl.msCrypto;
}
function uuid4(crypto = getCrypto()) {
  let getRandomByte = () => Math.random() * 16;
  try {
    if (crypto?.randomUUID) {
      return crypto.randomUUID().replace(/-/g, "");
    }
    if (crypto?.getRandomValues) {
      getRandomByte = () => {
        const typedArray = new Uint8Array(1);
        crypto.getRandomValues(typedArray);
        return typedArray[0];
      };
    }
  } catch {}
  return ([1e7] + 1000 + 4000 + 8000 + 100000000000).replace(/[018]/g, (c) => (c ^ (getRandomByte() & 15) >> c / 4).toString(16));
}
function getFirstException(event) {
  return event.exception?.values?.[0];
}
function getEventDescription(event) {
  const { message, event_id: eventId } = event;
  if (message) {
    return message;
  }
  const firstException = getFirstException(event);
  if (firstException) {
    if (firstException.type && firstException.value) {
      return `${firstException.type}: ${firstException.value}`;
    }
    return firstException.type || firstException.value || eventId || "<unknown>";
  }
  return eventId || "<unknown>";
}
function addExceptionTypeValue(event, value, type) {
  const exception = event.exception = event.exception || {};
  const values = exception.values = exception.values || [];
  const firstException = values[0] = values[0] || {};
  if (!firstException.value) {
    firstException.value = value || "";
  }
  if (!firstException.type) {
    firstException.type = type || "Error";
  }
}
function addExceptionMechanism(event, newMechanism) {
  const firstException = getFirstException(event);
  if (!firstException) {
    return;
  }
  const defaultMechanism = { type: "generic", handled: true };
  const currentMechanism = firstException.mechanism;
  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
  if (newMechanism && "data" in newMechanism) {
    const mergedData = { ...currentMechanism?.data, ...newMechanism.data };
    firstException.mechanism.data = mergedData;
  }
}
var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
function _parseInt(input) {
  return parseInt(input || "", 10);
}
function parseSemver(input) {
  const match2 = input.match(SEMVER_REGEXP) || [];
  const major = _parseInt(match2[1]);
  const minor = _parseInt(match2[2]);
  const patch = _parseInt(match2[3]);
  return {
    buildmetadata: match2[5],
    major: isNaN(major) ? undefined : major,
    minor: isNaN(minor) ? undefined : minor,
    patch: isNaN(patch) ? undefined : patch,
    prerelease: match2[4]
  };
}
function checkOrSetAlreadyCaught(exception) {
  if (isAlreadyCaptured(exception)) {
    return true;
  }
  try {
    addNonEnumerableProperty(exception, "__sentry_captured__", true);
  } catch {}
  return false;
}
function isAlreadyCaptured(exception) {
  try {
    return exception.__sentry_captured__;
  } catch {}
}

// ../../node_modules/@sentry/core/build/esm/utils/time.js
var ONE_SECOND_IN_MS = 1000;
function dateTimestampInSeconds() {
  return Date.now() / ONE_SECOND_IN_MS;
}
function createUnixTimestampInSecondsFunc() {
  const { performance } = GLOBAL_OBJ;
  if (!performance?.now || !performance.timeOrigin) {
    return dateTimestampInSeconds;
  }
  const timeOrigin = performance.timeOrigin;
  return () => {
    return (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;
  };
}
var _cachedTimestampInSeconds;
function timestampInSeconds() {
  const func = _cachedTimestampInSeconds ?? (_cachedTimestampInSeconds = createUnixTimestampInSecondsFunc());
  return func();
}

// ../../node_modules/@sentry/core/build/esm/session.js
function makeSession(context) {
  const startingTime = timestampInSeconds();
  const session = {
    sid: uuid4(),
    init: true,
    timestamp: startingTime,
    started: startingTime,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: false,
    toJSON: () => sessionToJSON(session)
  };
  if (context) {
    updateSession(session, context);
  }
  return session;
}
function updateSession(session, context = {}) {
  if (context.user) {
    if (!session.ipAddress && context.user.ip_address) {
      session.ipAddress = context.user.ip_address;
    }
    if (!session.did && !context.did) {
      session.did = context.user.id || context.user.email || context.user.username;
    }
  }
  session.timestamp = context.timestamp || timestampInSeconds();
  if (context.abnormal_mechanism) {
    session.abnormal_mechanism = context.abnormal_mechanism;
  }
  if (context.ignoreDuration) {
    session.ignoreDuration = context.ignoreDuration;
  }
  if (context.sid) {
    session.sid = context.sid.length === 32 ? context.sid : uuid4();
  }
  if (context.init !== undefined) {
    session.init = context.init;
  }
  if (!session.did && context.did) {
    session.did = `${context.did}`;
  }
  if (typeof context.started === "number") {
    session.started = context.started;
  }
  if (session.ignoreDuration) {
    session.duration = undefined;
  } else if (typeof context.duration === "number") {
    session.duration = context.duration;
  } else {
    const duration = session.timestamp - session.started;
    session.duration = duration >= 0 ? duration : 0;
  }
  if (context.release) {
    session.release = context.release;
  }
  if (context.environment) {
    session.environment = context.environment;
  }
  if (!session.ipAddress && context.ipAddress) {
    session.ipAddress = context.ipAddress;
  }
  if (!session.userAgent && context.userAgent) {
    session.userAgent = context.userAgent;
  }
  if (typeof context.errors === "number") {
    session.errors = context.errors;
  }
  if (context.status) {
    session.status = context.status;
  }
}
function closeSession(session, status) {
  let context = {};
  if (status) {
    context = { status };
  } else if (session.status === "ok") {
    context = { status: "exited" };
  }
  updateSession(session, context);
}
function sessionToJSON(session) {
  return {
    sid: `${session.sid}`,
    init: session.init,
    started: new Date(session.started * 1000).toISOString(),
    timestamp: new Date(session.timestamp * 1000).toISOString(),
    status: session.status,
    errors: session.errors,
    did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : undefined,
    duration: session.duration,
    abnormal_mechanism: session.abnormal_mechanism,
    attrs: {
      release: session.release,
      environment: session.environment,
      ip_address: session.ipAddress,
      user_agent: session.userAgent
    }
  };
}

// ../../node_modules/@sentry/core/build/esm/utils/merge.js
function merge(initialObj, mergeObj, levels = 2) {
  if (!mergeObj || typeof mergeObj !== "object" || levels <= 0) {
    return mergeObj;
  }
  if (initialObj && Object.keys(mergeObj).length === 0) {
    return initialObj;
  }
  const output = { ...initialObj };
  for (const key in mergeObj) {
    if (Object.prototype.hasOwnProperty.call(mergeObj, key)) {
      output[key] = merge(output[key], mergeObj[key], levels - 1);
    }
  }
  return output;
}

// ../../node_modules/@sentry/core/build/esm/utils/propagationContext.js
function generateTraceId() {
  return uuid4();
}
function generateSpanId() {
  return uuid4().substring(16);
}

// ../../node_modules/@sentry/core/build/esm/utils/spanOnScope.js
var SCOPE_SPAN_FIELD = "_sentrySpan";
function _setSpanForScope(scope, span) {
  if (span) {
    addNonEnumerableProperty(scope, SCOPE_SPAN_FIELD, span);
  } else {
    delete scope[SCOPE_SPAN_FIELD];
  }
}
function _getSpanForScope(scope) {
  return scope[SCOPE_SPAN_FIELD];
}

// ../../node_modules/@sentry/core/build/esm/scope.js
var DEFAULT_MAX_BREADCRUMBS = 100;

class Scope {
  constructor() {
    this._notifyingListeners = false;
    this._scopeListeners = [];
    this._eventProcessors = [];
    this._breadcrumbs = [];
    this._attachments = [];
    this._user = {};
    this._tags = {};
    this._extra = {};
    this._contexts = {};
    this._sdkProcessingMetadata = {};
    this._propagationContext = {
      traceId: generateTraceId(),
      sampleRand: Math.random()
    };
  }
  clone() {
    const newScope = new Scope;
    newScope._breadcrumbs = [...this._breadcrumbs];
    newScope._tags = { ...this._tags };
    newScope._extra = { ...this._extra };
    newScope._contexts = { ...this._contexts };
    if (this._contexts.flags) {
      newScope._contexts.flags = {
        values: [...this._contexts.flags.values]
      };
    }
    newScope._user = this._user;
    newScope._level = this._level;
    newScope._session = this._session;
    newScope._transactionName = this._transactionName;
    newScope._fingerprint = this._fingerprint;
    newScope._eventProcessors = [...this._eventProcessors];
    newScope._attachments = [...this._attachments];
    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
    newScope._propagationContext = { ...this._propagationContext };
    newScope._client = this._client;
    newScope._lastEventId = this._lastEventId;
    _setSpanForScope(newScope, _getSpanForScope(this));
    return newScope;
  }
  setClient(client) {
    this._client = client;
  }
  setLastEventId(lastEventId) {
    this._lastEventId = lastEventId;
  }
  getClient() {
    return this._client;
  }
  lastEventId() {
    return this._lastEventId;
  }
  addScopeListener(callback) {
    this._scopeListeners.push(callback);
  }
  addEventProcessor(callback) {
    this._eventProcessors.push(callback);
    return this;
  }
  setUser(user) {
    this._user = user || {
      email: undefined,
      id: undefined,
      ip_address: undefined,
      username: undefined
    };
    if (this._session) {
      updateSession(this._session, { user });
    }
    this._notifyScopeListeners();
    return this;
  }
  getUser() {
    return this._user;
  }
  setTags(tags) {
    this._tags = {
      ...this._tags,
      ...tags
    };
    this._notifyScopeListeners();
    return this;
  }
  setTag(key, value) {
    this._tags = { ...this._tags, [key]: value };
    this._notifyScopeListeners();
    return this;
  }
  setExtras(extras) {
    this._extra = {
      ...this._extra,
      ...extras
    };
    this._notifyScopeListeners();
    return this;
  }
  setExtra(key, extra) {
    this._extra = { ...this._extra, [key]: extra };
    this._notifyScopeListeners();
    return this;
  }
  setFingerprint(fingerprint) {
    this._fingerprint = fingerprint;
    this._notifyScopeListeners();
    return this;
  }
  setLevel(level) {
    this._level = level;
    this._notifyScopeListeners();
    return this;
  }
  setTransactionName(name) {
    this._transactionName = name;
    this._notifyScopeListeners();
    return this;
  }
  setContext(key, context) {
    if (context === null) {
      delete this._contexts[key];
    } else {
      this._contexts[key] = context;
    }
    this._notifyScopeListeners();
    return this;
  }
  setSession(session) {
    if (!session) {
      delete this._session;
    } else {
      this._session = session;
    }
    this._notifyScopeListeners();
    return this;
  }
  getSession() {
    return this._session;
  }
  update(captureContext) {
    if (!captureContext) {
      return this;
    }
    const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
    const scopeInstance = scopeToMerge instanceof Scope ? scopeToMerge.getScopeData() : isPlainObject(scopeToMerge) ? captureContext : undefined;
    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};
    this._tags = { ...this._tags, ...tags };
    this._extra = { ...this._extra, ...extra };
    this._contexts = { ...this._contexts, ...contexts };
    if (user && Object.keys(user).length) {
      this._user = user;
    }
    if (level) {
      this._level = level;
    }
    if (fingerprint.length) {
      this._fingerprint = fingerprint;
    }
    if (propagationContext) {
      this._propagationContext = propagationContext;
    }
    return this;
  }
  clear() {
    this._breadcrumbs = [];
    this._tags = {};
    this._extra = {};
    this._user = {};
    this._contexts = {};
    this._level = undefined;
    this._transactionName = undefined;
    this._fingerprint = undefined;
    this._session = undefined;
    _setSpanForScope(this, undefined);
    this._attachments = [];
    this.setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });
    this._notifyScopeListeners();
    return this;
  }
  addBreadcrumb(breadcrumb, maxBreadcrumbs) {
    const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
    if (maxCrumbs <= 0) {
      return this;
    }
    const mergedBreadcrumb = {
      timestamp: dateTimestampInSeconds(),
      ...breadcrumb,
      message: breadcrumb.message ? truncate(breadcrumb.message, 2048) : breadcrumb.message
    };
    this._breadcrumbs.push(mergedBreadcrumb);
    if (this._breadcrumbs.length > maxCrumbs) {
      this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);
      this._client?.recordDroppedEvent("buffer_overflow", "log_item");
    }
    this._notifyScopeListeners();
    return this;
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  clearBreadcrumbs() {
    this._breadcrumbs = [];
    this._notifyScopeListeners();
    return this;
  }
  addAttachment(attachment) {
    this._attachments.push(attachment);
    return this;
  }
  clearAttachments() {
    this._attachments = [];
    return this;
  }
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: _getSpanForScope(this)
    };
  }
  setSDKProcessingMetadata(newData) {
    this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, newData, 2);
    return this;
  }
  setPropagationContext(context) {
    this._propagationContext = context;
    return this;
  }
  getPropagationContext() {
    return this._propagationContext;
  }
  captureException(exception, hint) {
    const eventId = hint?.event_id || uuid4();
    if (!this._client) {
      DEBUG_BUILD && debug.warn("No client configured on scope - will not capture exception!");
      return eventId;
    }
    const syntheticException = new Error("Sentry syntheticException");
    this._client.captureException(exception, {
      originalException: exception,
      syntheticException,
      ...hint,
      event_id: eventId
    }, this);
    return eventId;
  }
  captureMessage(message, level, hint) {
    const eventId = hint?.event_id || uuid4();
    if (!this._client) {
      DEBUG_BUILD && debug.warn("No client configured on scope - will not capture message!");
      return eventId;
    }
    const syntheticException = new Error(message);
    this._client.captureMessage(message, level, {
      originalException: message,
      syntheticException,
      ...hint,
      event_id: eventId
    }, this);
    return eventId;
  }
  captureEvent(event, hint) {
    const eventId = hint?.event_id || uuid4();
    if (!this._client) {
      DEBUG_BUILD && debug.warn("No client configured on scope - will not capture event!");
      return eventId;
    }
    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
    return eventId;
  }
  _notifyScopeListeners() {
    if (!this._notifyingListeners) {
      this._notifyingListeners = true;
      this._scopeListeners.forEach((callback) => {
        callback(this);
      });
      this._notifyingListeners = false;
    }
  }
}

// ../../node_modules/@sentry/core/build/esm/defaultScopes.js
function getDefaultCurrentScope() {
  return getGlobalSingleton("defaultCurrentScope", () => new Scope);
}
function getDefaultIsolationScope() {
  return getGlobalSingleton("defaultIsolationScope", () => new Scope);
}

// ../../node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js
class AsyncContextStack {
  constructor(scope, isolationScope) {
    let assignedScope;
    if (!scope) {
      assignedScope = new Scope;
    } else {
      assignedScope = scope;
    }
    let assignedIsolationScope;
    if (!isolationScope) {
      assignedIsolationScope = new Scope;
    } else {
      assignedIsolationScope = isolationScope;
    }
    this._stack = [{ scope: assignedScope }];
    this._isolationScope = assignedIsolationScope;
  }
  withScope(callback) {
    const scope = this._pushScope();
    let maybePromiseResult;
    try {
      maybePromiseResult = callback(scope);
    } catch (e) {
      this._popScope();
      throw e;
    }
    if (isThenable(maybePromiseResult)) {
      return maybePromiseResult.then((res) => {
        this._popScope();
        return res;
      }, (e) => {
        this._popScope();
        throw e;
      });
    }
    this._popScope();
    return maybePromiseResult;
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getIsolationScope() {
    return this._isolationScope;
  }
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  _pushScope() {
    const scope = this.getScope().clone();
    this._stack.push({
      client: this.getClient(),
      scope
    });
    return scope;
  }
  _popScope() {
    if (this._stack.length <= 1)
      return false;
    return !!this._stack.pop();
  }
}
function getAsyncContextStack() {
  const registry = getMainCarrier();
  const sentry = getSentryCarrier(registry);
  return sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope());
}
function withScope(callback) {
  return getAsyncContextStack().withScope(callback);
}
function withSetScope(scope, callback) {
  const stack = getAsyncContextStack();
  return stack.withScope(() => {
    stack.getStackTop().scope = scope;
    return callback(scope);
  });
}
function withIsolationScope(callback) {
  return getAsyncContextStack().withScope(() => {
    return callback(getAsyncContextStack().getIsolationScope());
  });
}
function getStackAsyncContextStrategy() {
  return {
    withIsolationScope,
    withScope,
    withSetScope,
    withSetIsolationScope: (_isolationScope, callback) => {
      return withIsolationScope(callback);
    },
    getCurrentScope: () => getAsyncContextStack().getScope(),
    getIsolationScope: () => getAsyncContextStack().getIsolationScope()
  };
}

// ../../node_modules/@sentry/core/build/esm/asyncContext/index.js
function setAsyncContextStrategy(strategy) {
  const registry = getMainCarrier();
  const sentry = getSentryCarrier(registry);
  sentry.acs = strategy;
}
function getAsyncContextStrategy(carrier) {
  const sentry = getSentryCarrier(carrier);
  if (sentry.acs) {
    return sentry.acs;
  }
  return getStackAsyncContextStrategy();
}

// ../../node_modules/@sentry/core/build/esm/currentScopes.js
function getCurrentScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getCurrentScope();
}
function getIsolationScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getIsolationScope();
}
function getGlobalScope() {
  return getGlobalSingleton("globalScope", () => new Scope);
}
function withScope2(...rest) {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (rest.length === 2) {
    const [scope, callback] = rest;
    if (!scope) {
      return acs.withScope(callback);
    }
    return acs.withSetScope(scope, callback);
  }
  return acs.withScope(rest[0]);
}
function withIsolationScope2(...rest) {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (rest.length === 2) {
    const [isolationScope, callback] = rest;
    if (!isolationScope) {
      return acs.withIsolationScope(callback);
    }
    return acs.withSetIsolationScope(isolationScope, callback);
  }
  return acs.withIsolationScope(rest[0]);
}
function getClient() {
  return getCurrentScope().getClient();
}
function getTraceContextFromScope(scope) {
  const propagationContext = scope.getPropagationContext();
  const { traceId, parentSpanId, propagationSpanId } = propagationContext;
  const traceContext = {
    trace_id: traceId,
    span_id: propagationSpanId || generateSpanId()
  };
  if (parentSpanId) {
    traceContext.parent_span_id = parentSpanId;
  }
  return traceContext;
}

// ../../node_modules/@sentry/core/build/esm/semanticAttributes.js
var SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source";
var SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate";
var SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE = "sentry.previous_trace_sample_rate";
var SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op";
var SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin";
var SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = "sentry.measurement_unit";
var SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = "sentry.measurement_value";
var SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = "sentry.custom_span_name";
var SEMANTIC_ATTRIBUTE_PROFILE_ID = "sentry.profile_id";
var SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = "sentry.exclusive_time";
var SEMANTIC_ATTRIBUTE_CACHE_HIT = "cache.hit";
var SEMANTIC_ATTRIBUTE_CACHE_KEY = "cache.key";
var SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = "cache.item_size";

// ../../node_modules/@sentry/core/build/esm/tracing/spanstatus.js
var SPAN_STATUS_UNSET = 0;
var SPAN_STATUS_OK = 1;
var SPAN_STATUS_ERROR = 2;
function getSpanStatusFromHttpCode(httpStatus) {
  if (httpStatus < 400 && httpStatus >= 100) {
    return { code: SPAN_STATUS_OK };
  }
  if (httpStatus >= 400 && httpStatus < 500) {
    switch (httpStatus) {
      case 401:
        return { code: SPAN_STATUS_ERROR, message: "unauthenticated" };
      case 403:
        return { code: SPAN_STATUS_ERROR, message: "permission_denied" };
      case 404:
        return { code: SPAN_STATUS_ERROR, message: "not_found" };
      case 409:
        return { code: SPAN_STATUS_ERROR, message: "already_exists" };
      case 413:
        return { code: SPAN_STATUS_ERROR, message: "failed_precondition" };
      case 429:
        return { code: SPAN_STATUS_ERROR, message: "resource_exhausted" };
      case 499:
        return { code: SPAN_STATUS_ERROR, message: "cancelled" };
      default:
        return { code: SPAN_STATUS_ERROR, message: "invalid_argument" };
    }
  }
  if (httpStatus >= 500 && httpStatus < 600) {
    switch (httpStatus) {
      case 501:
        return { code: SPAN_STATUS_ERROR, message: "unimplemented" };
      case 503:
        return { code: SPAN_STATUS_ERROR, message: "unavailable" };
      case 504:
        return { code: SPAN_STATUS_ERROR, message: "deadline_exceeded" };
      default:
        return { code: SPAN_STATUS_ERROR, message: "internal_error" };
    }
  }
  return { code: SPAN_STATUS_ERROR, message: "unknown_error" };
}

// ../../node_modules/@sentry/core/build/esm/tracing/utils.js
var SCOPE_ON_START_SPAN_FIELD = "_sentryScope";
var ISOLATION_SCOPE_ON_START_SPAN_FIELD = "_sentryIsolationScope";
function setCapturedScopesOnSpan(span, scope, isolationScope) {
  if (span) {
    addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);
    addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);
  }
}
function getCapturedScopesOnSpan(span) {
  return {
    scope: span[SCOPE_ON_START_SPAN_FIELD],
    isolationScope: span[ISOLATION_SCOPE_ON_START_SPAN_FIELD]
  };
}

// ../../node_modules/@sentry/core/build/esm/utils/baggage.js
var SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
var MAX_BAGGAGE_STRING_LENGTH = 8192;
function baggageHeaderToDynamicSamplingContext(baggageHeader) {
  const baggageObject = parseBaggageHeader(baggageHeader);
  if (!baggageObject) {
    return;
  }
  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
      acc[nonPrefixedKey] = value;
    }
    return acc;
  }, {});
  if (Object.keys(dynamicSamplingContext).length > 0) {
    return dynamicSamplingContext;
  } else {
    return;
  }
}
function dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext) {
  if (!dynamicSamplingContext) {
    return;
  }
  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce((acc, [dscKey, dscValue]) => {
    if (dscValue) {
      acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;
    }
    return acc;
  }, {});
  return objectToBaggageHeader(sentryPrefixedDSC);
}
function parseBaggageHeader(baggageHeader) {
  if (!baggageHeader || !isString(baggageHeader) && !Array.isArray(baggageHeader)) {
    return;
  }
  if (Array.isArray(baggageHeader)) {
    return baggageHeader.reduce((acc, curr) => {
      const currBaggageObject = baggageHeaderToObject(curr);
      Object.entries(currBaggageObject).forEach(([key, value]) => {
        acc[key] = value;
      });
      return acc;
    }, {});
  }
  return baggageHeaderToObject(baggageHeader);
}
function baggageHeaderToObject(baggageHeader) {
  return baggageHeader.split(",").map((baggageEntry) => baggageEntry.split("=").map((keyOrValue) => {
    try {
      return decodeURIComponent(keyOrValue.trim());
    } catch {
      return;
    }
  })).reduce((acc, [key, value]) => {
    if (key && value) {
      acc[key] = value;
    }
    return acc;
  }, {});
}
function objectToBaggageHeader(object) {
  if (Object.keys(object).length === 0) {
    return;
  }
  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {
    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;
    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;
    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {
      DEBUG_BUILD && debug.warn(`Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`);
      return baggageHeader;
    } else {
      return newBaggageHeader;
    }
  }, "");
}

// ../../node_modules/@sentry/core/build/esm/utils/dsn.js
var ORG_ID_REGEX = /^o(\d+)\./;
var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(protocol) {
  return protocol === "http" || protocol === "https";
}
function dsnToString(dsn, withPassword = false) {
  const { host, path: path7, pass, port, projectId, protocol, publicKey } = dsn;
  return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}` + `@${host}${port ? `:${port}` : ""}/${path7 ? `${path7}/` : path7}${projectId}`;
}
function dsnFromString(str) {
  const match2 = DSN_REGEX.exec(str);
  if (!match2) {
    consoleSandbox(() => {
      console.error(`Invalid Sentry Dsn: ${str}`);
    });
    return;
  }
  const [protocol, publicKey, pass = "", host = "", port = "", lastPath = ""] = match2.slice(1);
  let path7 = "";
  let projectId = lastPath;
  const split = projectId.split("/");
  if (split.length > 1) {
    path7 = split.slice(0, -1).join("/");
    projectId = split.pop();
  }
  if (projectId) {
    const projectMatch = projectId.match(/^\d+/);
    if (projectMatch) {
      projectId = projectMatch[0];
    }
  }
  return dsnFromComponents({ host, pass, path: path7, projectId, port, protocol, publicKey });
}
function dsnFromComponents(components) {
  return {
    protocol: components.protocol,
    publicKey: components.publicKey || "",
    pass: components.pass || "",
    host: components.host,
    port: components.port || "",
    path: components.path || "",
    projectId: components.projectId
  };
}
function validateDsn(dsn) {
  if (!DEBUG_BUILD) {
    return true;
  }
  const { port, projectId, protocol } = dsn;
  const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
  const hasMissingRequiredComponent = requiredComponents.find((component) => {
    if (!dsn[component]) {
      debug.error(`Invalid Sentry Dsn: ${component} missing`);
      return true;
    }
    return false;
  });
  if (hasMissingRequiredComponent) {
    return false;
  }
  if (!projectId.match(/^\d+$/)) {
    debug.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
    return false;
  }
  if (!isValidProtocol(protocol)) {
    debug.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
    return false;
  }
  if (port && isNaN(parseInt(port, 10))) {
    debug.error(`Invalid Sentry Dsn: Invalid port ${port}`);
    return false;
  }
  return true;
}
function extractOrgIdFromDsnHost(host) {
  const match2 = host.match(ORG_ID_REGEX);
  return match2?.[1];
}
function extractOrgIdFromClient(client) {
  const options = client.getOptions();
  const { host } = client.getDsn() || {};
  let org_id;
  if (options.orgId) {
    org_id = String(options.orgId);
  } else if (host) {
    org_id = extractOrgIdFromDsnHost(host);
  }
  return org_id;
}
function makeDsn(from) {
  const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
  if (!components || !validateDsn(components)) {
    return;
  }
  return components;
}

// ../../node_modules/@sentry/core/build/esm/utils/parseSampleRate.js
function parseSampleRate(sampleRate) {
  if (typeof sampleRate === "boolean") {
    return Number(sampleRate);
  }
  const rate = typeof sampleRate === "string" ? parseFloat(sampleRate) : sampleRate;
  if (typeof rate !== "number" || isNaN(rate) || rate < 0 || rate > 1) {
    return;
  }
  return rate;
}

// ../../node_modules/@sentry/core/build/esm/utils/tracing.js
var TRACEPARENT_REGEXP = new RegExp("^[ \\t]*" + "([0-9a-f]{32})?" + "-?([0-9a-f]{16})?" + "-?([01])?" + "[ \\t]*$");
function extractTraceparentData(traceparent) {
  if (!traceparent) {
    return;
  }
  const matches = traceparent.match(TRACEPARENT_REGEXP);
  if (!matches) {
    return;
  }
  let parentSampled;
  if (matches[3] === "1") {
    parentSampled = true;
  } else if (matches[3] === "0") {
    parentSampled = false;
  }
  return {
    traceId: matches[1],
    parentSampled,
    parentSpanId: matches[2]
  };
}
function propagationContextFromHeaders(sentryTrace, baggage) {
  const traceparentData = extractTraceparentData(sentryTrace);
  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);
  if (!traceparentData?.traceId) {
    return {
      traceId: generateTraceId(),
      sampleRand: Math.random()
    };
  }
  const sampleRand = getSampleRandFromTraceparentAndDsc(traceparentData, dynamicSamplingContext);
  if (dynamicSamplingContext) {
    dynamicSamplingContext.sample_rand = sampleRand.toString();
  }
  const { traceId, parentSpanId, parentSampled } = traceparentData;
  return {
    traceId,
    parentSpanId,
    sampled: parentSampled,
    dsc: dynamicSamplingContext || {},
    sampleRand
  };
}
function generateSentryTraceHeader(traceId = generateTraceId(), spanId = generateSpanId(), sampled) {
  let sampledString = "";
  if (sampled !== undefined) {
    sampledString = sampled ? "-1" : "-0";
  }
  return `${traceId}-${spanId}${sampledString}`;
}
function generateTraceparentHeader(traceId = generateTraceId(), spanId = generateSpanId(), sampled) {
  return `00-${traceId}-${spanId}-${sampled ? "01" : "00"}`;
}
function getSampleRandFromTraceparentAndDsc(traceparentData, dsc) {
  const parsedSampleRand = parseSampleRate(dsc?.sample_rand);
  if (parsedSampleRand !== undefined) {
    return parsedSampleRand;
  }
  const parsedSampleRate = parseSampleRate(dsc?.sample_rate);
  if (parsedSampleRate && traceparentData?.parentSampled !== undefined) {
    return traceparentData.parentSampled ? Math.random() * parsedSampleRate : parsedSampleRate + Math.random() * (1 - parsedSampleRate);
  } else {
    return Math.random();
  }
}
function shouldContinueTrace(client, baggageOrgId) {
  const clientOrgId = extractOrgIdFromClient(client);
  if (baggageOrgId && clientOrgId && baggageOrgId !== clientOrgId) {
    debug.log(`Won't continue trace because org IDs don't match (incoming baggage: ${baggageOrgId}, SDK options: ${clientOrgId})`);
    return false;
  }
  const strictTraceContinuation = client.getOptions().strictTraceContinuation || false;
  if (strictTraceContinuation) {
    if (baggageOrgId && !clientOrgId || !baggageOrgId && clientOrgId) {
      debug.log(`Starting a new trace because strict trace continuation is enabled but one org ID is missing (incoming baggage: ${baggageOrgId}, Sentry client: ${clientOrgId})`);
      return false;
    }
  }
  return true;
}

// ../../node_modules/@sentry/core/build/esm/utils/spanUtils.js
var TRACE_FLAG_NONE = 0;
var TRACE_FLAG_SAMPLED = 1;
var hasShownSpanDropWarning = false;
function spanToTransactionTraceContext(span) {
  const { spanId: span_id, traceId: trace_id } = span.spanContext();
  const { data, op, parent_span_id, status, origin, links } = spanToJSON(span);
  return {
    parent_span_id,
    span_id,
    trace_id,
    data,
    op,
    status,
    origin,
    links
  };
}
function spanToTraceContext(span) {
  const { spanId, traceId: trace_id, isRemote } = span.spanContext();
  const parent_span_id = isRemote ? spanId : spanToJSON(span).parent_span_id;
  const scope = getCapturedScopesOnSpan(span).scope;
  const span_id = isRemote ? scope?.getPropagationContext().propagationSpanId || generateSpanId() : spanId;
  return {
    parent_span_id,
    span_id,
    trace_id
  };
}
function spanToTraceHeader(span) {
  const { traceId, spanId } = span.spanContext();
  const sampled = spanIsSampled(span);
  return generateSentryTraceHeader(traceId, spanId, sampled);
}
function spanToTraceparentHeader(span) {
  const { traceId, spanId } = span.spanContext();
  const sampled = spanIsSampled(span);
  return generateTraceparentHeader(traceId, spanId, sampled);
}
function convertSpanLinksForEnvelope(links) {
  if (links && links.length > 0) {
    return links.map(({ context: { spanId, traceId, traceFlags, ...restContext }, attributes }) => ({
      span_id: spanId,
      trace_id: traceId,
      sampled: traceFlags === TRACE_FLAG_SAMPLED,
      attributes,
      ...restContext
    }));
  } else {
    return;
  }
}
function spanTimeInputToSeconds(input) {
  if (typeof input === "number") {
    return ensureTimestampInSeconds(input);
  }
  if (Array.isArray(input)) {
    return input[0] + input[1] / 1e9;
  }
  if (input instanceof Date) {
    return ensureTimestampInSeconds(input.getTime());
  }
  return timestampInSeconds();
}
function ensureTimestampInSeconds(timestamp) {
  const isMs = timestamp > 9999999999;
  return isMs ? timestamp / 1000 : timestamp;
}
function spanToJSON(span) {
  if (spanIsSentrySpan(span)) {
    return span.getSpanJSON();
  }
  const { spanId: span_id, traceId: trace_id } = span.spanContext();
  if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {
    const { attributes, startTime, name, endTime, status, links } = span;
    const parentSpanId = "parentSpanId" in span ? span.parentSpanId : ("parentSpanContext" in span) ? span.parentSpanContext?.spanId : undefined;
    return {
      span_id,
      trace_id,
      data: attributes,
      description: name,
      parent_span_id: parentSpanId,
      start_timestamp: spanTimeInputToSeconds(startTime),
      timestamp: spanTimeInputToSeconds(endTime) || undefined,
      status: getStatusMessage(status),
      op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
      origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
      links: convertSpanLinksForEnvelope(links)
    };
  }
  return {
    span_id,
    trace_id,
    start_timestamp: 0,
    data: {}
  };
}
function spanIsOpenTelemetrySdkTraceBaseSpan(span) {
  const castSpan = span;
  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;
}
function spanIsSentrySpan(span) {
  return typeof span.getSpanJSON === "function";
}
function spanIsSampled(span) {
  const { traceFlags } = span.spanContext();
  return traceFlags === TRACE_FLAG_SAMPLED;
}
function getStatusMessage(status) {
  if (!status || status.code === SPAN_STATUS_UNSET) {
    return;
  }
  if (status.code === SPAN_STATUS_OK) {
    return "ok";
  }
  return status.message || "unknown_error";
}
var CHILD_SPANS_FIELD = "_sentryChildSpans";
var ROOT_SPAN_FIELD = "_sentryRootSpan";
function addChildSpanToSpan(span, childSpan) {
  const rootSpan = span[ROOT_SPAN_FIELD] || span;
  addNonEnumerableProperty(childSpan, ROOT_SPAN_FIELD, rootSpan);
  if (span[CHILD_SPANS_FIELD]) {
    span[CHILD_SPANS_FIELD].add(childSpan);
  } else {
    addNonEnumerableProperty(span, CHILD_SPANS_FIELD, new Set([childSpan]));
  }
}
function getSpanDescendants(span) {
  const resultSet = new Set;
  function addSpanChildren(span2) {
    if (resultSet.has(span2)) {
      return;
    } else if (spanIsSampled(span2)) {
      resultSet.add(span2);
      const childSpans = span2[CHILD_SPANS_FIELD] ? Array.from(span2[CHILD_SPANS_FIELD]) : [];
      for (const childSpan of childSpans) {
        addSpanChildren(childSpan);
      }
    }
  }
  addSpanChildren(span);
  return Array.from(resultSet);
}
function getRootSpan(span) {
  return span[ROOT_SPAN_FIELD] || span;
}
function getActiveSpan() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (acs.getActiveSpan) {
    return acs.getActiveSpan();
  }
  return _getSpanForScope(getCurrentScope());
}
function showSpanDropWarning() {
  if (!hasShownSpanDropWarning) {
    consoleSandbox(() => {
      console.warn("[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly.");
    });
    hasShownSpanDropWarning = true;
  }
}

// ../../node_modules/@sentry/core/build/esm/tracing/errors.js
var errorsInstrumented = false;
function registerSpanErrorInstrumentation() {
  if (errorsInstrumented) {
    return;
  }
  function errorCallback() {
    const activeSpan = getActiveSpan();
    const rootSpan = activeSpan && getRootSpan(activeSpan);
    if (rootSpan) {
      const message = "internal_error";
      DEBUG_BUILD && debug.log(`[Tracing] Root span: ${message} -> Global error occurred`);
      rootSpan.setStatus({ code: SPAN_STATUS_ERROR, message });
    }
  }
  errorCallback.tag = "sentry_tracingErrorCallback";
  errorsInstrumented = true;
  addGlobalErrorInstrumentationHandler(errorCallback);
  addGlobalUnhandledRejectionInstrumentationHandler(errorCallback);
}
// ../../node_modules/@sentry/core/build/esm/utils/hasSpansEnabled.js
function hasSpansEnabled(maybeOptions) {
  if (typeof __SENTRY_TRACING__ === "boolean" && !__SENTRY_TRACING__) {
    return false;
  }
  const options = maybeOptions || getClient()?.getOptions();
  return !!options && (options.tracesSampleRate != null || !!options.tracesSampler);
}

// ../../node_modules/@sentry/core/build/esm/constants.js
var DEFAULT_ENVIRONMENT = "production";

// ../../node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js
var FROZEN_DSC_FIELD = "_frozenDsc";
function freezeDscOnSpan(span, dsc) {
  const spanWithMaybeDsc = span;
  addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);
}
function getDynamicSamplingContextFromClient(trace_id, client) {
  const options = client.getOptions();
  const { publicKey: public_key } = client.getDsn() || {};
  const dsc = {
    environment: options.environment || DEFAULT_ENVIRONMENT,
    release: options.release,
    public_key,
    trace_id,
    org_id: extractOrgIdFromClient(client)
  };
  client.emit("createDsc", dsc);
  return dsc;
}
function getDynamicSamplingContextFromScope(client, scope) {
  const propagationContext = scope.getPropagationContext();
  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);
}
function getDynamicSamplingContextFromSpan(span) {
  const client = getClient();
  if (!client) {
    return {};
  }
  const rootSpan = getRootSpan(span);
  const rootSpanJson = spanToJSON(rootSpan);
  const rootSpanAttributes = rootSpanJson.data;
  const traceState = rootSpan.spanContext().traceState;
  const rootSpanSampleRate = traceState?.get("sentry.sample_rate") ?? rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ?? rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE];
  function applyLocalSampleRateToDsc(dsc2) {
    if (typeof rootSpanSampleRate === "number" || typeof rootSpanSampleRate === "string") {
      dsc2.sample_rate = `${rootSpanSampleRate}`;
    }
    return dsc2;
  }
  const frozenDsc = rootSpan[FROZEN_DSC_FIELD];
  if (frozenDsc) {
    return applyLocalSampleRateToDsc(frozenDsc);
  }
  const traceStateDsc = traceState?.get("sentry.dsc");
  const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);
  if (dscOnTraceState) {
    return applyLocalSampleRateToDsc(dscOnTraceState);
  }
  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);
  const source = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
  const name = rootSpanJson.description;
  if (source !== "url" && name) {
    dsc.transaction = name;
  }
  if (hasSpansEnabled()) {
    dsc.sampled = String(spanIsSampled(rootSpan));
    dsc.sample_rand = traceState?.get("sentry.sample_rand") ?? getCapturedScopesOnSpan(rootSpan).scope?.getPropagationContext().sampleRand.toString();
  }
  applyLocalSampleRateToDsc(dsc);
  client.emit("createDsc", dsc, rootSpan);
  return dsc;
}

// ../../node_modules/@sentry/core/build/esm/tracing/sentryNonRecordingSpan.js
class SentryNonRecordingSpan {
  constructor(spanContext = {}) {
    this._traceId = spanContext.traceId || generateTraceId();
    this._spanId = spanContext.spanId || generateSpanId();
  }
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: TRACE_FLAG_NONE
    };
  }
  end(_timestamp) {}
  setAttribute(_key, _value) {
    return this;
  }
  setAttributes(_values) {
    return this;
  }
  setStatus(_status) {
    return this;
  }
  updateName(_name) {
    return this;
  }
  isRecording() {
    return false;
  }
  addEvent(_name, _attributesOrStartTime, _startTime) {
    return this;
  }
  addLink(_link) {
    return this;
  }
  addLinks(_links) {
    return this;
  }
  recordException(_exception, _time) {}
}

// ../../node_modules/@sentry/core/build/esm/utils/normalize.js
function normalize(input, depth = 100, maxProperties = Infinity) {
  try {
    return visit("", input, depth, maxProperties);
  } catch (err) {
    return { ERROR: `**non-serializable** (${err})` };
  }
}
function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {
  const normalized = normalize(object, depth);
  if (jsonSize(normalized) > maxSize) {
    return normalizeToSize(object, depth - 1, maxSize);
  }
  return normalized;
}
function visit(key, value, depth = Infinity, maxProperties = Infinity, memo = memoBuilder()) {
  const [memoize, unmemoize] = memo;
  if (value == null || ["boolean", "string"].includes(typeof value) || typeof value === "number" && Number.isFinite(value)) {
    return value;
  }
  const stringified = stringifyValue(key, value);
  if (!stringified.startsWith("[object ")) {
    return stringified;
  }
  if (value["__sentry_skip_normalization__"]) {
    return value;
  }
  const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
  if (remainingDepth === 0) {
    return stringified.replace("object ", "");
  }
  if (memoize(value)) {
    return "[Circular ~]";
  }
  const valueWithToJSON = value;
  if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
    try {
      const jsonValue = valueWithToJSON.toJSON();
      return visit("", jsonValue, remainingDepth - 1, maxProperties, memo);
    } catch {}
  }
  const normalized = Array.isArray(value) ? [] : {};
  let numAdded = 0;
  const visitable = convertToPlainObject(value);
  for (const visitKey in visitable) {
    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
      continue;
    }
    if (numAdded >= maxProperties) {
      normalized[visitKey] = "[MaxProperties ~]";
      break;
    }
    const visitValue = visitable[visitKey];
    normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);
    numAdded++;
  }
  unmemoize(value);
  return normalized;
}
function stringifyValue(key, value) {
  try {
    if (key === "domain" && value && typeof value === "object" && value._events) {
      return "[Domain]";
    }
    if (key === "domainEmitter") {
      return "[DomainEmitter]";
    }
    if (typeof global !== "undefined" && value === global) {
      return "[Global]";
    }
    if (typeof window !== "undefined" && value === window) {
      return "[Window]";
    }
    if (typeof document !== "undefined" && value === document) {
      return "[Document]";
    }
    if (isVueViewModel(value)) {
      return "[VueViewModel]";
    }
    if (isSyntheticEvent(value)) {
      return "[SyntheticEvent]";
    }
    if (typeof value === "number" && !Number.isFinite(value)) {
      return `[${value}]`;
    }
    if (typeof value === "function") {
      return `[Function: ${getFunctionName(value)}]`;
    }
    if (typeof value === "symbol") {
      return `[${String(value)}]`;
    }
    if (typeof value === "bigint") {
      return `[BigInt: ${String(value)}]`;
    }
    const objName = getConstructorName(value);
    if (/^HTML(\w*)Element$/.test(objName)) {
      return `[HTMLElement: ${objName}]`;
    }
    return `[object ${objName}]`;
  } catch (err) {
    return `**non-serializable** (${err})`;
  }
}
function getConstructorName(value) {
  const prototype = Object.getPrototypeOf(value);
  return prototype?.constructor ? prototype.constructor.name : "null prototype";
}
function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}
function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}
function memoBuilder() {
  const inner = new WeakSet;
  function memoize(obj) {
    if (inner.has(obj)) {
      return true;
    }
    inner.add(obj);
    return false;
  }
  function unmemoize(obj) {
    inner.delete(obj);
  }
  return [memoize, unmemoize];
}

// ../../node_modules/@sentry/core/build/esm/utils/envelope.js
function createEnvelope(headers, items = []) {
  return [headers, items];
}
function addItemToEnvelope(envelope, newItem) {
  const [headers, items] = envelope;
  return [headers, [...items, newItem]];
}
function forEachEnvelopeItem(envelope, callback) {
  const envelopeItems = envelope[1];
  for (const envelopeItem of envelopeItems) {
    const envelopeItemType = envelopeItem[0].type;
    const result = callback(envelopeItem, envelopeItemType);
    if (result) {
      return true;
    }
  }
  return false;
}
function encodeUTF8(input) {
  const carrier = getSentryCarrier(GLOBAL_OBJ);
  return carrier.encodePolyfill ? carrier.encodePolyfill(input) : new TextEncoder().encode(input);
}
function serializeEnvelope(envelope) {
  const [envHeaders, items] = envelope;
  let parts = JSON.stringify(envHeaders);
  function append(next) {
    if (typeof parts === "string") {
      parts = typeof next === "string" ? parts + next : [encodeUTF8(parts), next];
    } else {
      parts.push(typeof next === "string" ? encodeUTF8(next) : next);
    }
  }
  for (const item of items) {
    const [itemHeaders, payload] = item;
    append(`
${JSON.stringify(itemHeaders)}
`);
    if (typeof payload === "string" || payload instanceof Uint8Array) {
      append(payload);
    } else {
      let stringifiedPayload;
      try {
        stringifiedPayload = JSON.stringify(payload);
      } catch {
        stringifiedPayload = JSON.stringify(normalize(payload));
      }
      append(stringifiedPayload);
    }
  }
  return typeof parts === "string" ? parts : concatBuffers(parts);
}
function concatBuffers(buffers) {
  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
  const merged = new Uint8Array(totalLength);
  let offset = 0;
  for (const buffer of buffers) {
    merged.set(buffer, offset);
    offset += buffer.length;
  }
  return merged;
}
function createSpanEnvelopeItem(spanJson) {
  const spanHeaders = {
    type: "span"
  };
  return [spanHeaders, spanJson];
}
function createAttachmentEnvelopeItem(attachment) {
  const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data) : attachment.data;
  return [
    {
      type: "attachment",
      length: buffer.length,
      filename: attachment.filename,
      content_type: attachment.contentType,
      attachment_type: attachment.attachmentType
    },
    buffer
  ];
}
var ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  raw_security: "security",
  log: "log_item"
};
function envelopeItemTypeToDataCategory(type) {
  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
}
function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
  if (!metadataOrEvent?.sdk) {
    return;
  }
  const { name, version } = metadataOrEvent.sdk;
  return { name, version };
}
function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {
  const dynamicSamplingContext = event.sdkProcessingMetadata?.dynamicSamplingContext;
  return {
    event_id: event.event_id,
    sent_at: new Date().toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) },
    ...dynamicSamplingContext && {
      trace: dynamicSamplingContext
    }
  };
}

// ../../node_modules/@sentry/core/build/esm/utils/should-ignore-span.js
function shouldIgnoreSpan(span, ignoreSpans) {
  if (!ignoreSpans?.length || !span.description) {
    return false;
  }
  for (const pattern of ignoreSpans) {
    if (isStringOrRegExp(pattern)) {
      if (isMatchingPattern(span.description, pattern)) {
        return true;
      }
      continue;
    }
    if (!pattern.name && !pattern.op) {
      continue;
    }
    const nameMatches = pattern.name ? isMatchingPattern(span.description, pattern.name) : true;
    const opMatches = pattern.op ? span.op && isMatchingPattern(span.op, pattern.op) : true;
    if (nameMatches && opMatches) {
      return true;
    }
  }
  return false;
}
function reparentChildSpans(spans, dropSpan) {
  const droppedSpanParentId = dropSpan.parent_span_id;
  const droppedSpanId = dropSpan.span_id;
  if (!droppedSpanParentId) {
    return;
  }
  for (const span of spans) {
    if (span.parent_span_id === droppedSpanId) {
      span.parent_span_id = droppedSpanParentId;
    }
  }
}
function isStringOrRegExp(value) {
  return typeof value === "string" || value instanceof RegExp;
}

// ../../node_modules/@sentry/core/build/esm/envelope.js
function _enhanceEventWithSdkInfo(event, newSdkInfo) {
  if (!newSdkInfo) {
    return event;
  }
  const eventSdkInfo = event.sdk || {};
  event.sdk = {
    ...eventSdkInfo,
    name: eventSdkInfo.name || newSdkInfo.name,
    version: eventSdkInfo.version || newSdkInfo.version,
    integrations: [...event.sdk?.integrations || [], ...newSdkInfo.integrations || []],
    packages: [...event.sdk?.packages || [], ...newSdkInfo.packages || []],
    settings: event.sdk?.settings || newSdkInfo.settings ? {
      ...event.sdk?.settings,
      ...newSdkInfo.settings
    } : undefined
  };
  return event;
}
function createSessionEnvelope(session, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const envelopeHeaders = {
    sent_at: new Date().toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
  };
  const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
  return createEnvelope(envelopeHeaders, [envelopeItem]);
}
function createEventEnvelope(event, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
  _enhanceEventWithSdkInfo(event, metadata?.sdk);
  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
  delete event.sdkProcessingMetadata;
  const eventItem = [{ type: eventType }, event];
  return createEnvelope(envelopeHeaders, [eventItem]);
}
function createSpanEnvelope(spans, client) {
  function dscHasRequiredProps(dsc2) {
    return !!dsc2.trace_id && !!dsc2.public_key;
  }
  const dsc = getDynamicSamplingContextFromSpan(spans[0]);
  const dsn = client?.getDsn();
  const tunnel = client?.getOptions().tunnel;
  const headers = {
    sent_at: new Date().toISOString(),
    ...dscHasRequiredProps(dsc) && { trace: dsc },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
  };
  const { beforeSendSpan, ignoreSpans } = client?.getOptions() || {};
  const filteredSpans = ignoreSpans?.length ? spans.filter((span) => !shouldIgnoreSpan(spanToJSON(span), ignoreSpans)) : spans;
  const droppedSpans = spans.length - filteredSpans.length;
  if (droppedSpans) {
    client?.recordDroppedEvent("before_send", "span", droppedSpans);
  }
  const convertToSpanJSON = beforeSendSpan ? (span) => {
    const spanJson = spanToJSON(span);
    const processedSpan = beforeSendSpan(spanJson);
    if (!processedSpan) {
      showSpanDropWarning();
      return spanJson;
    }
    return processedSpan;
  } : spanToJSON;
  const items = [];
  for (const span of filteredSpans) {
    const spanJson = convertToSpanJSON(span);
    if (spanJson) {
      items.push(createSpanEnvelopeItem(spanJson));
    }
  }
  return createEnvelope(headers, items);
}

// ../../node_modules/@sentry/core/build/esm/tracing/logSpans.js
function logSpanStart(span) {
  if (!DEBUG_BUILD)
    return;
  const { description = "< unknown name >", op = "< unknown op >", parent_span_id: parentSpanId } = spanToJSON(span);
  const { spanId } = span.spanContext();
  const sampled = spanIsSampled(span);
  const rootSpan = getRootSpan(span);
  const isRootSpan = rootSpan === span;
  const header = `[Tracing] Starting ${sampled ? "sampled" : "unsampled"} ${isRootSpan ? "root " : ""}span`;
  const infoParts = [`op: ${op}`, `name: ${description}`, `ID: ${spanId}`];
  if (parentSpanId) {
    infoParts.push(`parent ID: ${parentSpanId}`);
  }
  if (!isRootSpan) {
    const { op: op2, description: description2 } = spanToJSON(rootSpan);
    infoParts.push(`root ID: ${rootSpan.spanContext().spanId}`);
    if (op2) {
      infoParts.push(`root op: ${op2}`);
    }
    if (description2) {
      infoParts.push(`root description: ${description2}`);
    }
  }
  debug.log(`${header}
  ${infoParts.join(`
  `)}`);
}
function logSpanEnd(span) {
  if (!DEBUG_BUILD)
    return;
  const { description = "< unknown name >", op = "< unknown op >" } = spanToJSON(span);
  const { spanId } = span.spanContext();
  const rootSpan = getRootSpan(span);
  const isRootSpan = rootSpan === span;
  const msg = `[Tracing] Finishing "${op}" ${isRootSpan ? "root " : ""}span "${description}" with ID ${spanId}`;
  debug.log(msg);
}

// ../../node_modules/@sentry/core/build/esm/tracing/measurement.js
function timedEventsToMeasurements(events) {
  if (!events || events.length === 0) {
    return;
  }
  const measurements = {};
  events.forEach((event) => {
    const attributes = event.attributes || {};
    const unit = attributes[SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT];
    const value = attributes[SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE];
    if (typeof unit === "string" && typeof value === "number") {
      measurements[event.name] = { value, unit };
    }
  });
  return measurements;
}

// ../../node_modules/@sentry/core/build/esm/tracing/sentrySpan.js
var MAX_SPAN_COUNT = 1000;

class SentrySpan {
  constructor(spanContext = {}) {
    this._traceId = spanContext.traceId || generateTraceId();
    this._spanId = spanContext.spanId || generateSpanId();
    this._startTime = spanContext.startTimestamp || timestampInSeconds();
    this._links = spanContext.links;
    this._attributes = {};
    this.setAttributes({
      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "manual",
      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,
      ...spanContext.attributes
    });
    this._name = spanContext.name;
    if (spanContext.parentSpanId) {
      this._parentSpanId = spanContext.parentSpanId;
    }
    if ("sampled" in spanContext) {
      this._sampled = spanContext.sampled;
    }
    if (spanContext.endTimestamp) {
      this._endTime = spanContext.endTimestamp;
    }
    this._events = [];
    this._isStandaloneSpan = spanContext.isStandalone;
    if (this._endTime) {
      this._onSpanEnded();
    }
  }
  addLink(link) {
    if (this._links) {
      this._links.push(link);
    } else {
      this._links = [link];
    }
    return this;
  }
  addLinks(links) {
    if (this._links) {
      this._links.push(...links);
    } else {
      this._links = links;
    }
    return this;
  }
  recordException(_exception, _time) {}
  spanContext() {
    const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;
    return {
      spanId,
      traceId,
      traceFlags: sampled ? TRACE_FLAG_SAMPLED : TRACE_FLAG_NONE
    };
  }
  setAttribute(key, value) {
    if (value === undefined) {
      delete this._attributes[key];
    } else {
      this._attributes[key] = value;
    }
    return this;
  }
  setAttributes(attributes) {
    Object.keys(attributes).forEach((key) => this.setAttribute(key, attributes[key]));
    return this;
  }
  updateStartTime(timeInput) {
    this._startTime = spanTimeInputToSeconds(timeInput);
  }
  setStatus(value) {
    this._status = value;
    return this;
  }
  updateName(name) {
    this._name = name;
    this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, "custom");
    return this;
  }
  end(endTimestamp) {
    if (this._endTime) {
      return;
    }
    this._endTime = spanTimeInputToSeconds(endTimestamp);
    logSpanEnd(this);
    this._onSpanEnded();
  }
  getSpanJSON() {
    return {
      data: this._attributes,
      description: this._name,
      op: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: getStatusMessage(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
      profile_id: this._attributes[SEMANTIC_ATTRIBUTE_PROFILE_ID],
      exclusive_time: this._attributes[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],
      measurements: timedEventsToMeasurements(this._events),
      is_segment: this._isStandaloneSpan && getRootSpan(this) === this || undefined,
      segment_id: this._isStandaloneSpan ? getRootSpan(this).spanContext().spanId : undefined,
      links: convertSpanLinksForEnvelope(this._links)
    };
  }
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  addEvent(name, attributesOrStartTime, startTime) {
    DEBUG_BUILD && debug.log("[Tracing] Adding an event to span:", name);
    const time = isSpanTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime || timestampInSeconds();
    const attributes = isSpanTimeInput(attributesOrStartTime) ? {} : attributesOrStartTime || {};
    const event = {
      name,
      time: spanTimeInputToSeconds(time),
      attributes
    };
    this._events.push(event);
    return this;
  }
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  _onSpanEnded() {
    const client = getClient();
    if (client) {
      client.emit("spanEnd", this);
    }
    const isSegmentSpan = this._isStandaloneSpan || this === getRootSpan(this);
    if (!isSegmentSpan) {
      return;
    }
    if (this._isStandaloneSpan) {
      if (this._sampled) {
        sendSpanEnvelope(createSpanEnvelope([this], client));
      } else {
        DEBUG_BUILD && debug.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled.");
        if (client) {
          client.recordDroppedEvent("sample_rate", "span");
        }
      }
      return;
    }
    const transactionEvent = this._convertSpanToTransaction();
    if (transactionEvent) {
      const scope = getCapturedScopesOnSpan(this).scope || getCurrentScope();
      scope.captureEvent(transactionEvent);
    }
  }
  _convertSpanToTransaction() {
    if (!isFullFinishedSpan(spanToJSON(this))) {
      return;
    }
    if (!this._name) {
      DEBUG_BUILD && debug.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
      this._name = "<unlabeled transaction>";
    }
    const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = getCapturedScopesOnSpan(this);
    const normalizedRequest = capturedSpanScope?.getScopeData().sdkProcessingMetadata?.normalizedRequest;
    if (this._sampled !== true) {
      return;
    }
    const finishedSpans = getSpanDescendants(this).filter((span) => span !== this && !isStandaloneSpan(span));
    const spans = finishedSpans.map((span) => spanToJSON(span)).filter(isFullFinishedSpan);
    const source = this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    delete this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
    spans.forEach((span) => {
      delete span.data[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
    });
    const transaction = {
      contexts: {
        trace: spanToTransactionTraceContext(this)
      },
      spans: spans.length > MAX_SPAN_COUNT ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT) : spans,
      start_timestamp: this._startTime,
      timestamp: this._endTime,
      transaction: this._name,
      type: "transaction",
      sdkProcessingMetadata: {
        capturedSpanScope,
        capturedSpanIsolationScope,
        dynamicSamplingContext: getDynamicSamplingContextFromSpan(this)
      },
      request: normalizedRequest,
      ...source && {
        transaction_info: {
          source
        }
      }
    };
    const measurements = timedEventsToMeasurements(this._events);
    const hasMeasurements = measurements && Object.keys(measurements).length;
    if (hasMeasurements) {
      DEBUG_BUILD && debug.log("[Measurements] Adding measurements to transaction event", JSON.stringify(measurements, undefined, 2));
      transaction.measurements = measurements;
    }
    return transaction;
  }
}
function isSpanTimeInput(value) {
  return value && typeof value === "number" || value instanceof Date || Array.isArray(value);
}
function isFullFinishedSpan(input) {
  return !!input.start_timestamp && !!input.timestamp && !!input.span_id && !!input.trace_id;
}
function isStandaloneSpan(span) {
  return span instanceof SentrySpan && span.isStandaloneSpan();
}
function sendSpanEnvelope(envelope) {
  const client = getClient();
  if (!client) {
    return;
  }
  const spanItems = envelope[1];
  if (!spanItems || spanItems.length === 0) {
    client.recordDroppedEvent("before_send", "span");
    return;
  }
  client.sendEnvelope(envelope);
}

// ../../node_modules/@sentry/core/build/esm/utils/handleCallbackErrors.js
function handleCallbackErrors(fn, onError, onFinally = () => {}) {
  let maybePromiseResult;
  try {
    maybePromiseResult = fn();
  } catch (e) {
    onError(e);
    onFinally();
    throw e;
  }
  return maybeHandlePromiseRejection(maybePromiseResult, onError, onFinally);
}
function maybeHandlePromiseRejection(value, onError, onFinally) {
  if (isThenable(value)) {
    return value.then((res) => {
      onFinally();
      return res;
    }, (e) => {
      onError(e);
      onFinally();
      throw e;
    });
  }
  onFinally();
  return value;
}

// ../../node_modules/@sentry/core/build/esm/tracing/sampling.js
function sampleSpan(options, samplingContext, sampleRand) {
  if (!hasSpansEnabled(options)) {
    return [false];
  }
  let localSampleRateWasApplied = undefined;
  let sampleRate;
  if (typeof options.tracesSampler === "function") {
    sampleRate = options.tracesSampler({
      ...samplingContext,
      inheritOrSampleWith: (fallbackSampleRate) => {
        if (typeof samplingContext.parentSampleRate === "number") {
          return samplingContext.parentSampleRate;
        }
        if (typeof samplingContext.parentSampled === "boolean") {
          return Number(samplingContext.parentSampled);
        }
        return fallbackSampleRate;
      }
    });
    localSampleRateWasApplied = true;
  } else if (samplingContext.parentSampled !== undefined) {
    sampleRate = samplingContext.parentSampled;
  } else if (typeof options.tracesSampleRate !== "undefined") {
    sampleRate = options.tracesSampleRate;
    localSampleRateWasApplied = true;
  }
  const parsedSampleRate = parseSampleRate(sampleRate);
  if (parsedSampleRate === undefined) {
    DEBUG_BUILD && debug.warn(`[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(sampleRate)} of type ${JSON.stringify(typeof sampleRate)}.`);
    return [false];
  }
  if (!parsedSampleRate) {
    DEBUG_BUILD && debug.log(`[Tracing] Discarding transaction because ${typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`);
    return [false, parsedSampleRate, localSampleRateWasApplied];
  }
  const shouldSample = sampleRand < parsedSampleRate;
  if (!shouldSample) {
    DEBUG_BUILD && debug.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(sampleRate)})`);
  }
  return [shouldSample, parsedSampleRate, localSampleRateWasApplied];
}

// ../../node_modules/@sentry/core/build/esm/tracing/trace.js
var SUPPRESS_TRACING_KEY = "__SENTRY_SUPPRESS_TRACING__";
function startSpan(options, callback) {
  const acs = getAcs();
  if (acs.startSpan) {
    return acs.startSpan(options, callback);
  }
  const spanArguments = parseSentrySpanArguments(options);
  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;
  const customForkedScope = customScope?.clone();
  return withScope2(customForkedScope, () => {
    const wrapper = getActiveSpanWrapper(customParentSpan);
    return wrapper(() => {
      const scope = getCurrentScope();
      const parentSpan = getParentSpan(scope, customParentSpan);
      const shouldSkipSpan = options.onlyIfParent && !parentSpan;
      const activeSpan = shouldSkipSpan ? new SentryNonRecordingSpan : createChildOrRootSpan({
        parentSpan,
        spanArguments,
        forceTransaction,
        scope
      });
      _setSpanForScope(scope, activeSpan);
      return handleCallbackErrors(() => callback(activeSpan), () => {
        const { status } = spanToJSON(activeSpan);
        if (activeSpan.isRecording() && (!status || status === "ok")) {
          activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: "internal_error" });
        }
      }, () => {
        activeSpan.end();
      });
    });
  });
}
function startSpanManual(options, callback) {
  const acs = getAcs();
  if (acs.startSpanManual) {
    return acs.startSpanManual(options, callback);
  }
  const spanArguments = parseSentrySpanArguments(options);
  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;
  const customForkedScope = customScope?.clone();
  return withScope2(customForkedScope, () => {
    const wrapper = getActiveSpanWrapper(customParentSpan);
    return wrapper(() => {
      const scope = getCurrentScope();
      const parentSpan = getParentSpan(scope, customParentSpan);
      const shouldSkipSpan = options.onlyIfParent && !parentSpan;
      const activeSpan = shouldSkipSpan ? new SentryNonRecordingSpan : createChildOrRootSpan({
        parentSpan,
        spanArguments,
        forceTransaction,
        scope
      });
      _setSpanForScope(scope, activeSpan);
      return handleCallbackErrors(() => callback(activeSpan, () => activeSpan.end()), () => {
        const { status } = spanToJSON(activeSpan);
        if (activeSpan.isRecording() && (!status || status === "ok")) {
          activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: "internal_error" });
        }
      });
    });
  });
}
function withActiveSpan(span, callback) {
  const acs = getAcs();
  if (acs.withActiveSpan) {
    return acs.withActiveSpan(span, callback);
  }
  return withScope2((scope) => {
    _setSpanForScope(scope, span || undefined);
    return callback(scope);
  });
}
function suppressTracing(callback) {
  const acs = getAcs();
  if (acs.suppressTracing) {
    return acs.suppressTracing(callback);
  }
  return withScope2((scope) => {
    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: true });
    const res = callback();
    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: undefined });
    return res;
  });
}
function createChildOrRootSpan({
  parentSpan,
  spanArguments,
  forceTransaction,
  scope
}) {
  if (!hasSpansEnabled()) {
    const span2 = new SentryNonRecordingSpan;
    if (forceTransaction || !parentSpan) {
      const dsc = {
        sampled: "false",
        sample_rate: "0",
        transaction: spanArguments.name,
        ...getDynamicSamplingContextFromSpan(span2)
      };
      freezeDscOnSpan(span2, dsc);
    }
    return span2;
  }
  const isolationScope = getIsolationScope();
  let span;
  if (parentSpan && !forceTransaction) {
    span = _startChildSpan(parentSpan, scope, spanArguments);
    addChildSpanToSpan(parentSpan, span);
  } else if (parentSpan) {
    const dsc = getDynamicSamplingContextFromSpan(parentSpan);
    const { traceId, spanId: parentSpanId } = parentSpan.spanContext();
    const parentSampled = spanIsSampled(parentSpan);
    span = _startRootSpan({
      traceId,
      parentSpanId,
      ...spanArguments
    }, scope, parentSampled);
    freezeDscOnSpan(span, dsc);
  } else {
    const {
      traceId,
      dsc,
      parentSpanId,
      sampled: parentSampled
    } = {
      ...isolationScope.getPropagationContext(),
      ...scope.getPropagationContext()
    };
    span = _startRootSpan({
      traceId,
      parentSpanId,
      ...spanArguments
    }, scope, parentSampled);
    if (dsc) {
      freezeDscOnSpan(span, dsc);
    }
  }
  logSpanStart(span);
  setCapturedScopesOnSpan(span, scope, isolationScope);
  return span;
}
function parseSentrySpanArguments(options) {
  const exp = options.experimental || {};
  const initialCtx = {
    isStandalone: exp.standalone,
    ...options
  };
  if (options.startTime) {
    const ctx = { ...initialCtx };
    ctx.startTimestamp = spanTimeInputToSeconds(options.startTime);
    delete ctx.startTime;
    return ctx;
  }
  return initialCtx;
}
function getAcs() {
  const carrier = getMainCarrier();
  return getAsyncContextStrategy(carrier);
}
function _startRootSpan(spanArguments, scope, parentSampled) {
  const client = getClient();
  const options = client?.getOptions() || {};
  const { name = "" } = spanArguments;
  const mutableSpanSamplingData = { spanAttributes: { ...spanArguments.attributes }, spanName: name, parentSampled };
  client?.emit("beforeSampling", mutableSpanSamplingData, { decision: false });
  const finalParentSampled = mutableSpanSamplingData.parentSampled ?? parentSampled;
  const finalAttributes = mutableSpanSamplingData.spanAttributes;
  const currentPropagationContext = scope.getPropagationContext();
  const [sampled, sampleRate, localSampleRateWasApplied] = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? [false] : sampleSpan(options, {
    name,
    parentSampled: finalParentSampled,
    attributes: finalAttributes,
    parentSampleRate: parseSampleRate(currentPropagationContext.dsc?.sample_rate)
  }, currentPropagationContext.sampleRand);
  const rootSpan = new SentrySpan({
    ...spanArguments,
    attributes: {
      [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "custom",
      [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate !== undefined && localSampleRateWasApplied ? sampleRate : undefined,
      ...finalAttributes
    },
    sampled
  });
  if (!sampled && client) {
    DEBUG_BUILD && debug.log("[Tracing] Discarding root span because its trace was not chosen to be sampled.");
    client.recordDroppedEvent("sample_rate", "transaction");
  }
  if (client) {
    client.emit("spanStart", rootSpan);
  }
  return rootSpan;
}
function _startChildSpan(parentSpan, scope, spanArguments) {
  const { spanId, traceId } = parentSpan.spanContext();
  const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanIsSampled(parentSpan);
  const childSpan = sampled ? new SentrySpan({
    ...spanArguments,
    parentSpanId: spanId,
    traceId,
    sampled
  }) : new SentryNonRecordingSpan({ traceId });
  addChildSpanToSpan(parentSpan, childSpan);
  const client = getClient();
  if (client) {
    client.emit("spanStart", childSpan);
    if (spanArguments.endTimestamp) {
      client.emit("spanEnd", childSpan);
    }
  }
  return childSpan;
}
function getParentSpan(scope, customParentSpan) {
  if (customParentSpan) {
    return customParentSpan;
  }
  if (customParentSpan === null) {
    return;
  }
  const span = _getSpanForScope(scope);
  if (!span) {
    return;
  }
  const client = getClient();
  const options = client ? client.getOptions() : {};
  if (options.parentSpanIsAlwaysRootSpan) {
    return getRootSpan(span);
  }
  return span;
}
function getActiveSpanWrapper(parentSpan) {
  return parentSpan !== undefined ? (callback) => {
    return withActiveSpan(parentSpan, callback);
  } : (callback) => callback();
}
// ../../node_modules/@sentry/core/build/esm/utils/syncpromise.js
var STATE_PENDING = 0;
var STATE_RESOLVED = 1;
var STATE_REJECTED = 2;
function resolvedSyncPromise(value) {
  return new SyncPromise((resolve) => {
    resolve(value);
  });
}
function rejectedSyncPromise(reason) {
  return new SyncPromise((_, reject) => {
    reject(reason);
  });
}

class SyncPromise {
  constructor(executor) {
    this._state = STATE_PENDING;
    this._handlers = [];
    this._runExecutor(executor);
  }
  then(onfulfilled, onrejected) {
    return new SyncPromise((resolve, reject) => {
      this._handlers.push([
        false,
        (result) => {
          if (!onfulfilled) {
            resolve(result);
          } else {
            try {
              resolve(onfulfilled(result));
            } catch (e) {
              reject(e);
            }
          }
        },
        (reason) => {
          if (!onrejected) {
            reject(reason);
          } else {
            try {
              resolve(onrejected(reason));
            } catch (e) {
              reject(e);
            }
          }
        }
      ]);
      this._executeHandlers();
    });
  }
  catch(onrejected) {
    return this.then((val) => val, onrejected);
  }
  finally(onfinally) {
    return new SyncPromise((resolve, reject) => {
      let val;
      let isRejected;
      return this.then((value) => {
        isRejected = false;
        val = value;
        if (onfinally) {
          onfinally();
        }
      }, (reason) => {
        isRejected = true;
        val = reason;
        if (onfinally) {
          onfinally();
        }
      }).then(() => {
        if (isRejected) {
          reject(val);
          return;
        }
        resolve(val);
      });
    });
  }
  _executeHandlers() {
    if (this._state === STATE_PENDING) {
      return;
    }
    const cachedHandlers = this._handlers.slice();
    this._handlers = [];
    cachedHandlers.forEach((handler) => {
      if (handler[0]) {
        return;
      }
      if (this._state === STATE_RESOLVED) {
        handler[1](this._value);
      }
      if (this._state === STATE_REJECTED) {
        handler[2](this._value);
      }
      handler[0] = true;
    });
  }
  _runExecutor(executor) {
    const setResult = (state, value) => {
      if (this._state !== STATE_PENDING) {
        return;
      }
      if (isThenable(value)) {
        value.then(resolve, reject);
        return;
      }
      this._state = state;
      this._value = value;
      this._executeHandlers();
    };
    const resolve = (value) => {
      setResult(STATE_RESOLVED, value);
    };
    const reject = (reason) => {
      setResult(STATE_REJECTED, reason);
    };
    try {
      executor(resolve, reject);
    } catch (e) {
      reject(e);
    }
  }
}

// ../../node_modules/@sentry/core/build/esm/eventProcessors.js
function notifyEventProcessors(processors, event, hint, index = 0) {
  try {
    const result = _notifyEventProcessors(event, hint, processors, index);
    return isThenable(result) ? result : resolvedSyncPromise(result);
  } catch (error2) {
    return rejectedSyncPromise(error2);
  }
}
function _notifyEventProcessors(event, hint, processors, index) {
  const processor = processors[index];
  if (!event || !processor) {
    return event;
  }
  const result = processor({ ...event }, hint);
  DEBUG_BUILD && result === null && debug.log(`Event processor "${processor.id || "?"}" dropped event`);
  if (isThenable(result)) {
    return result.then((final) => _notifyEventProcessors(final, hint, processors, index + 1));
  }
  return _notifyEventProcessors(result, hint, processors, index + 1);
}

// ../../node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js
function applyScopeDataToEvent(event, data) {
  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
  applyDataToEvent(event, data);
  if (span) {
    applySpanToEvent(event, span);
  }
  applyFingerprintToEvent(event, fingerprint);
  applyBreadcrumbsToEvent(event, breadcrumbs);
  applySdkMetadataToEvent(event, sdkProcessingMetadata);
}
function mergeScopeData(data, mergeData) {
  const {
    extra,
    tags,
    user,
    contexts,
    level,
    sdkProcessingMetadata,
    breadcrumbs,
    fingerprint,
    eventProcessors,
    attachments,
    propagationContext,
    transactionName,
    span
  } = mergeData;
  mergeAndOverwriteScopeData(data, "extra", extra);
  mergeAndOverwriteScopeData(data, "tags", tags);
  mergeAndOverwriteScopeData(data, "user", user);
  mergeAndOverwriteScopeData(data, "contexts", contexts);
  data.sdkProcessingMetadata = merge(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);
  if (level) {
    data.level = level;
  }
  if (transactionName) {
    data.transactionName = transactionName;
  }
  if (span) {
    data.span = span;
  }
  if (breadcrumbs.length) {
    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
  }
  if (fingerprint.length) {
    data.fingerprint = [...data.fingerprint, ...fingerprint];
  }
  if (eventProcessors.length) {
    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
  }
  if (attachments.length) {
    data.attachments = [...data.attachments, ...attachments];
  }
  data.propagationContext = { ...data.propagationContext, ...propagationContext };
}
function mergeAndOverwriteScopeData(data, prop, mergeVal) {
  data[prop] = merge(data[prop], mergeVal, 1);
}
function applyDataToEvent(event, data) {
  const { extra, tags, user, contexts, level, transactionName } = data;
  if (Object.keys(extra).length) {
    event.extra = { ...extra, ...event.extra };
  }
  if (Object.keys(tags).length) {
    event.tags = { ...tags, ...event.tags };
  }
  if (Object.keys(user).length) {
    event.user = { ...user, ...event.user };
  }
  if (Object.keys(contexts).length) {
    event.contexts = { ...contexts, ...event.contexts };
  }
  if (level) {
    event.level = level;
  }
  if (transactionName && event.type !== "transaction") {
    event.transaction = transactionName;
  }
}
function applyBreadcrumbsToEvent(event, breadcrumbs) {
  const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;
}
function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
  event.sdkProcessingMetadata = {
    ...event.sdkProcessingMetadata,
    ...sdkProcessingMetadata
  };
}
function applySpanToEvent(event, span) {
  event.contexts = {
    trace: spanToTraceContext(span),
    ...event.contexts
  };
  event.sdkProcessingMetadata = {
    dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
    ...event.sdkProcessingMetadata
  };
  const rootSpan = getRootSpan(span);
  const transactionName = spanToJSON(rootSpan).description;
  if (transactionName && !event.transaction && event.type === "transaction") {
    event.transaction = transactionName;
  }
}
function applyFingerprintToEvent(event, fingerprint) {
  event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
  if (fingerprint) {
    event.fingerprint = event.fingerprint.concat(fingerprint);
  }
  if (!event.fingerprint.length) {
    delete event.fingerprint;
  }
}

// ../../node_modules/@sentry/core/build/esm/utils/debug-ids.js
var parsedStackResults;
var lastKeysCount;
var cachedFilenameDebugIds;
function getFilenameToDebugIdMap(stackParser) {
  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
  if (!debugIdMap) {
    return {};
  }
  const debugIdKeys = Object.keys(debugIdMap);
  if (cachedFilenameDebugIds && debugIdKeys.length === lastKeysCount) {
    return cachedFilenameDebugIds;
  }
  lastKeysCount = debugIdKeys.length;
  cachedFilenameDebugIds = debugIdKeys.reduce((acc, stackKey) => {
    if (!parsedStackResults) {
      parsedStackResults = {};
    }
    const result = parsedStackResults[stackKey];
    if (result) {
      acc[result[0]] = result[1];
    } else {
      const parsedStack = stackParser(stackKey);
      for (let i = parsedStack.length - 1;i >= 0; i--) {
        const stackFrame = parsedStack[i];
        const filename = stackFrame?.filename;
        const debugId = debugIdMap[stackKey];
        if (filename && debugId) {
          acc[filename] = debugId;
          parsedStackResults[stackKey] = [filename, debugId];
          break;
        }
      }
    }
    return acc;
  }, {});
  return cachedFilenameDebugIds;
}

// ../../node_modules/@sentry/core/build/esm/utils/prepareEvent.js
function prepareEvent(options, event, hint, scope, client, isolationScope) {
  const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;
  const prepared = {
    ...event,
    event_id: event.event_id || hint.event_id || uuid4(),
    timestamp: event.timestamp || dateTimestampInSeconds()
  };
  const integrations = hint.integrations || options.integrations.map((i) => i.name);
  applyClientOptions(prepared, options);
  applyIntegrationsMetadata(prepared, integrations);
  if (client) {
    client.emit("applyFrameMetadata", event);
  }
  if (event.type === undefined) {
    applyDebugIds(prepared, options.stackParser);
  }
  const finalScope = getFinalScope(scope, hint.captureContext);
  if (hint.mechanism) {
    addExceptionMechanism(prepared, hint.mechanism);
  }
  const clientEventProcessors = client ? client.getEventProcessors() : [];
  const data = getGlobalScope().getScopeData();
  if (isolationScope) {
    const isolationData = isolationScope.getScopeData();
    mergeScopeData(data, isolationData);
  }
  if (finalScope) {
    const finalScopeData = finalScope.getScopeData();
    mergeScopeData(data, finalScopeData);
  }
  const attachments = [...hint.attachments || [], ...data.attachments];
  if (attachments.length) {
    hint.attachments = attachments;
  }
  applyScopeDataToEvent(prepared, data);
  const eventProcessors = [
    ...clientEventProcessors,
    ...data.eventProcessors
  ];
  const result = notifyEventProcessors(eventProcessors, prepared, hint);
  return result.then((evt) => {
    if (evt) {
      applyDebugMeta(evt);
    }
    if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
    }
    return evt;
  });
}
function applyClientOptions(event, options) {
  const { environment, release, dist, maxValueLength = 250 } = options;
  event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;
  if (!event.release && release) {
    event.release = release;
  }
  if (!event.dist && dist) {
    event.dist = dist;
  }
  const request = event.request;
  if (request?.url) {
    request.url = truncate(request.url, maxValueLength);
  }
}
function applyDebugIds(event, stackParser) {
  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);
  event.exception?.values?.forEach((exception) => {
    exception.stacktrace?.frames?.forEach((frame) => {
      if (frame.filename) {
        frame.debug_id = filenameDebugIdMap[frame.filename];
      }
    });
  });
}
function applyDebugMeta(event) {
  const filenameDebugIdMap = {};
  event.exception?.values?.forEach((exception) => {
    exception.stacktrace?.frames?.forEach((frame) => {
      if (frame.debug_id) {
        if (frame.abs_path) {
          filenameDebugIdMap[frame.abs_path] = frame.debug_id;
        } else if (frame.filename) {
          filenameDebugIdMap[frame.filename] = frame.debug_id;
        }
        delete frame.debug_id;
      }
    });
  });
  if (Object.keys(filenameDebugIdMap).length === 0) {
    return;
  }
  event.debug_meta = event.debug_meta || {};
  event.debug_meta.images = event.debug_meta.images || [];
  const images = event.debug_meta.images;
  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {
    images.push({
      type: "sourcemap",
      code_file: filename,
      debug_id
    });
  });
}
function applyIntegrationsMetadata(event, integrationNames) {
  if (integrationNames.length > 0) {
    event.sdk = event.sdk || {};
    event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
  }
}
function normalizeEvent(event, depth, maxBreadth) {
  if (!event) {
    return null;
  }
  const normalized = {
    ...event,
    ...event.breadcrumbs && {
      breadcrumbs: event.breadcrumbs.map((b) => ({
        ...b,
        ...b.data && {
          data: normalize(b.data, depth, maxBreadth)
        }
      }))
    },
    ...event.user && {
      user: normalize(event.user, depth, maxBreadth)
    },
    ...event.contexts && {
      contexts: normalize(event.contexts, depth, maxBreadth)
    },
    ...event.extra && {
      extra: normalize(event.extra, depth, maxBreadth)
    }
  };
  if (event.contexts?.trace && normalized.contexts) {
    normalized.contexts.trace = event.contexts.trace;
    if (event.contexts.trace.data) {
      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);
    }
  }
  if (event.spans) {
    normalized.spans = event.spans.map((span) => {
      return {
        ...span,
        ...span.data && {
          data: normalize(span.data, depth, maxBreadth)
        }
      };
    });
  }
  if (event.contexts?.flags && normalized.contexts) {
    normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);
  }
  return normalized;
}
function getFinalScope(scope, captureContext) {
  if (!captureContext) {
    return scope;
  }
  const finalScope = scope ? scope.clone() : new Scope;
  finalScope.update(captureContext);
  return finalScope;
}
function parseEventHintOrCaptureContext(hint) {
  if (!hint) {
    return;
  }
  if (hintIsScopeOrFunction(hint)) {
    return { captureContext: hint };
  }
  if (hintIsScopeContext(hint)) {
    return {
      captureContext: hint
    };
  }
  return hint;
}
function hintIsScopeOrFunction(hint) {
  return hint instanceof Scope || typeof hint === "function";
}
var captureContextKeys = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "propagationContext"
];
function hintIsScopeContext(hint) {
  return Object.keys(hint).some((key) => captureContextKeys.includes(key));
}

// ../../node_modules/@sentry/core/build/esm/exports.js
function captureException(exception, hint) {
  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));
}
function captureEvent(event, hint) {
  return getCurrentScope().captureEvent(event, hint);
}
function isEnabled2() {
  const client = getClient();
  return client?.getOptions().enabled !== false && !!client?.getTransport();
}
function startSession(context) {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const { userAgent } = GLOBAL_OBJ.navigator || {};
  const session = makeSession({
    user: currentScope.getUser() || isolationScope.getUser(),
    ...userAgent && { userAgent },
    ...context
  });
  const currentSession = isolationScope.getSession();
  if (currentSession?.status === "ok") {
    updateSession(currentSession, { status: "exited" });
  }
  endSession();
  isolationScope.setSession(session);
  return session;
}
function endSession() {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const session = currentScope.getSession() || isolationScope.getSession();
  if (session) {
    closeSession(session);
  }
  _sendSessionUpdate();
  isolationScope.setSession();
}
function _sendSessionUpdate() {
  const isolationScope = getIsolationScope();
  const client = getClient();
  const session = isolationScope.getSession();
  if (session && client) {
    client.captureSession(session);
  }
}
// ../../node_modules/@sentry/core/build/esm/api.js
var SENTRY_API_VERSION = "7";
function getBaseApiEndpoint(dsn) {
  const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
  const port = dsn.port ? `:${dsn.port}` : "";
  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
}
function _getIngestEndpoint(dsn) {
  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
}
function _encodedAuth(dsn, sdkInfo) {
  const params = {
    sentry_version: SENTRY_API_VERSION
  };
  if (dsn.publicKey) {
    params.sentry_key = dsn.publicKey;
  }
  if (sdkInfo) {
    params.sentry_client = `${sdkInfo.name}/${sdkInfo.version}`;
  }
  return new URLSearchParams(params).toString();
}
function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel, sdkInfo) {
  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
}

// ../../node_modules/@sentry/core/build/esm/integration.js
var installedIntegrations = [];
function filterDuplicates(integrations) {
  const integrationsByName = {};
  integrations.forEach((currentInstance) => {
    const { name } = currentInstance;
    const existingInstance = integrationsByName[name];
    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
      return;
    }
    integrationsByName[name] = currentInstance;
  });
  return Object.values(integrationsByName);
}
function getIntegrationsToSetup(options) {
  const defaultIntegrations = options.defaultIntegrations || [];
  const userIntegrations = options.integrations;
  defaultIntegrations.forEach((integration) => {
    integration.isDefaultInstance = true;
  });
  let integrations;
  if (Array.isArray(userIntegrations)) {
    integrations = [...defaultIntegrations, ...userIntegrations];
  } else if (typeof userIntegrations === "function") {
    const resolvedUserIntegrations = userIntegrations(defaultIntegrations);
    integrations = Array.isArray(resolvedUserIntegrations) ? resolvedUserIntegrations : [resolvedUserIntegrations];
  } else {
    integrations = defaultIntegrations;
  }
  return filterDuplicates(integrations);
}
function setupIntegrations(client, integrations) {
  const integrationIndex = {};
  integrations.forEach((integration) => {
    if (integration) {
      setupIntegration(client, integration, integrationIndex);
    }
  });
  return integrationIndex;
}
function afterSetupIntegrations(client, integrations) {
  for (const integration of integrations) {
    if (integration?.afterAllSetup) {
      integration.afterAllSetup(client);
    }
  }
}
function setupIntegration(client, integration, integrationIndex) {
  if (integrationIndex[integration.name]) {
    DEBUG_BUILD && debug.log(`Integration skipped because it was already installed: ${integration.name}`);
    return;
  }
  integrationIndex[integration.name] = integration;
  if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === "function") {
    integration.setupOnce();
    installedIntegrations.push(integration.name);
  }
  if (integration.setup && typeof integration.setup === "function") {
    integration.setup(client);
  }
  if (typeof integration.preprocessEvent === "function") {
    const callback = integration.preprocessEvent.bind(integration);
    client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
  }
  if (typeof integration.processEvent === "function") {
    const callback = integration.processEvent.bind(integration);
    const processor = Object.assign((event, hint) => callback(event, hint, client), {
      id: integration.name
    });
    client.addEventProcessor(processor);
  }
  DEBUG_BUILD && debug.log(`Integration installed: ${integration.name}`);
}
function defineIntegration(fn) {
  return fn;
}

// ../../node_modules/@sentry/core/build/esm/utils/clientreport.js
function createClientReportEnvelope(discarded_events, dsn, timestamp) {
  const clientReportItem = [
    { type: "client_report" },
    {
      timestamp: timestamp || dateTimestampInSeconds(),
      discarded_events
    }
  ];
  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
}

// ../../node_modules/@sentry/core/build/esm/utils/eventUtils.js
function getPossibleEventMessages(event) {
  const possibleMessages = [];
  if (event.message) {
    possibleMessages.push(event.message);
  }
  try {
    const lastException = event.exception.values[event.exception.values.length - 1];
    if (lastException?.value) {
      possibleMessages.push(lastException.value);
      if (lastException.type) {
        possibleMessages.push(`${lastException.type}: ${lastException.value}`);
      }
    }
  } catch {}
  return possibleMessages;
}

// ../../node_modules/@sentry/core/build/esm/utils/transactionEvent.js
function convertTransactionEventToSpanJson(event) {
  const { trace_id, parent_span_id, span_id, status, origin, data, op } = event.contexts?.trace ?? {};
  return {
    data: data ?? {},
    description: event.transaction,
    op,
    parent_span_id,
    span_id: span_id ?? "",
    start_timestamp: event.start_timestamp ?? 0,
    status,
    timestamp: event.timestamp,
    trace_id: trace_id ?? "",
    origin,
    profile_id: data?.[SEMANTIC_ATTRIBUTE_PROFILE_ID],
    exclusive_time: data?.[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],
    measurements: event.measurements,
    is_segment: true
  };
}
function convertSpanJsonToTransactionEvent(span) {
  return {
    type: "transaction",
    timestamp: span.timestamp,
    start_timestamp: span.start_timestamp,
    transaction: span.description,
    contexts: {
      trace: {
        trace_id: span.trace_id,
        span_id: span.span_id,
        parent_span_id: span.parent_span_id,
        op: span.op,
        status: span.status,
        origin: span.origin,
        data: {
          ...span.data,
          ...span.profile_id && { [SEMANTIC_ATTRIBUTE_PROFILE_ID]: span.profile_id },
          ...span.exclusive_time && { [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: span.exclusive_time }
        }
      }
    },
    measurements: span.measurements
  };
}

// ../../node_modules/@sentry/core/build/esm/client.js
var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
var MISSING_RELEASE_FOR_SESSION_ERROR = "Discarded session because of missing or non-string release";
var INTERNAL_ERROR_SYMBOL = Symbol.for("SentryInternalError");
var DO_NOT_SEND_EVENT_SYMBOL = Symbol.for("SentryDoNotSendEventError");
function _makeInternalError(message) {
  return {
    message,
    [INTERNAL_ERROR_SYMBOL]: true
  };
}
function _makeDoNotSendEventError(message) {
  return {
    message,
    [DO_NOT_SEND_EVENT_SYMBOL]: true
  };
}
function _isInternalError(error2) {
  return !!error2 && typeof error2 === "object" && INTERNAL_ERROR_SYMBOL in error2;
}
function _isDoNotSendEventError(error2) {
  return !!error2 && typeof error2 === "object" && DO_NOT_SEND_EVENT_SYMBOL in error2;
}

class Client {
  constructor(options) {
    this._options = options;
    this._integrations = {};
    this._numProcessing = 0;
    this._outcomes = {};
    this._hooks = {};
    this._eventProcessors = [];
    if (options.dsn) {
      this._dsn = makeDsn(options.dsn);
    } else {
      DEBUG_BUILD && debug.warn("No DSN provided, client will not send events.");
    }
    if (this._dsn) {
      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options.tunnel, options._metadata ? options._metadata.sdk : undefined);
      this._transport = options.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...options.transportOptions,
        url
      });
    }
  }
  captureException(exception, hint, scope) {
    const eventId = uuid4();
    if (checkOrSetAlreadyCaught(exception)) {
      DEBUG_BUILD && debug.log(ALREADY_SEEN_ERROR);
      return eventId;
    }
    const hintWithEventId = {
      event_id: eventId,
      ...hint
    };
    this._process(this.eventFromException(exception, hintWithEventId).then((event) => this._captureEvent(event, hintWithEventId, scope)));
    return hintWithEventId.event_id;
  }
  captureMessage(message, level, hint, currentScope) {
    const hintWithEventId = {
      event_id: uuid4(),
      ...hint
    };
    const eventMessage = isParameterizedString(message) ? message : String(message);
    const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hintWithEventId) : this.eventFromException(message, hintWithEventId);
    this._process(promisedEvent.then((event) => this._captureEvent(event, hintWithEventId, currentScope)));
    return hintWithEventId.event_id;
  }
  captureEvent(event, hint, currentScope) {
    const eventId = uuid4();
    if (hint?.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
      DEBUG_BUILD && debug.log(ALREADY_SEEN_ERROR);
      return eventId;
    }
    const hintWithEventId = {
      event_id: eventId,
      ...hint
    };
    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
    this._process(this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope, capturedSpanIsolationScope));
    return hintWithEventId.event_id;
  }
  captureSession(session) {
    this.sendSession(session);
    updateSession(session, { init: false });
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  flush(timeout) {
    const transport = this._transport;
    if (transport) {
      this.emit("flush");
      return this._isClientDoneProcessing(timeout).then((clientFinished) => {
        return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
      });
    } else {
      return resolvedSyncPromise(true);
    }
  }
  close(timeout) {
    return this.flush(timeout).then((result) => {
      this.getOptions().enabled = false;
      this.emit("close");
      return result;
    });
  }
  getEventProcessors() {
    return this._eventProcessors;
  }
  addEventProcessor(eventProcessor) {
    this._eventProcessors.push(eventProcessor);
  }
  init() {
    if (this._isEnabled() || this._options.integrations.some(({ name }) => name.startsWith("Spotlight"))) {
      this._setupIntegrations();
    }
  }
  getIntegrationByName(integrationName) {
    return this._integrations[integrationName];
  }
  addIntegration(integration) {
    const isAlreadyInstalled = this._integrations[integration.name];
    setupIntegration(this, integration, this._integrations);
    if (!isAlreadyInstalled) {
      afterSetupIntegrations(this, [integration]);
    }
  }
  sendEvent(event, hint = {}) {
    this.emit("beforeSendEvent", event, hint);
    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
    for (const attachment of hint.attachments || []) {
      env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));
    }
    this.sendEnvelope(env).then((sendResponse) => this.emit("afterSendEvent", event, sendResponse));
  }
  sendSession(session) {
    const { release: clientReleaseOption, environment: clientEnvironmentOption = DEFAULT_ENVIRONMENT } = this._options;
    if ("aggregates" in session) {
      const sessionAttrs = session.attrs || {};
      if (!sessionAttrs.release && !clientReleaseOption) {
        DEBUG_BUILD && debug.warn(MISSING_RELEASE_FOR_SESSION_ERROR);
        return;
      }
      sessionAttrs.release = sessionAttrs.release || clientReleaseOption;
      sessionAttrs.environment = sessionAttrs.environment || clientEnvironmentOption;
      session.attrs = sessionAttrs;
    } else {
      if (!session.release && !clientReleaseOption) {
        DEBUG_BUILD && debug.warn(MISSING_RELEASE_FOR_SESSION_ERROR);
        return;
      }
      session.release = session.release || clientReleaseOption;
      session.environment = session.environment || clientEnvironmentOption;
    }
    this.emit("beforeSendSession", session);
    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(env);
  }
  recordDroppedEvent(reason, category, count = 1) {
    if (this._options.sendClientReports) {
      const key = `${reason}:${category}`;
      DEBUG_BUILD && debug.log(`Recording outcome: "${key}"${count > 1 ? ` (${count} times)` : ""}`);
      this._outcomes[key] = (this._outcomes[key] || 0) + count;
    }
  }
  on(hook, callback) {
    const hooks = this._hooks[hook] = this._hooks[hook] || [];
    hooks.push(callback);
    return () => {
      const cbIndex = hooks.indexOf(callback);
      if (cbIndex > -1) {
        hooks.splice(cbIndex, 1);
      }
    };
  }
  emit(hook, ...rest) {
    const callbacks = this._hooks[hook];
    if (callbacks) {
      callbacks.forEach((callback) => callback(...rest));
    }
  }
  sendEnvelope(envelope) {
    this.emit("beforeEnvelope", envelope);
    if (this._isEnabled() && this._transport) {
      return this._transport.send(envelope).then(null, (reason) => {
        DEBUG_BUILD && debug.error("Error while sending envelope:", reason);
        return {};
      });
    }
    DEBUG_BUILD && debug.error("Transport disabled");
    return resolvedSyncPromise({});
  }
  _setupIntegrations() {
    const { integrations } = this._options;
    this._integrations = setupIntegrations(this, integrations);
    afterSetupIntegrations(this, integrations);
  }
  _updateSessionFromEvent(session, event) {
    let crashed = event.level === "fatal";
    let errored = false;
    const exceptions = event.exception?.values;
    if (exceptions) {
      errored = true;
      for (const ex of exceptions) {
        const mechanism = ex.mechanism;
        if (mechanism?.handled === false) {
          crashed = true;
          break;
        }
      }
    }
    const sessionNonTerminal = session.status === "ok";
    const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
    if (shouldUpdateAndSend) {
      updateSession(session, {
        ...crashed && { status: "crashed" },
        errors: session.errors || Number(errored || crashed)
      });
      this.captureSession(session);
    }
  }
  _isClientDoneProcessing(timeout) {
    return new SyncPromise((resolve) => {
      let ticked = 0;
      const tick = 1;
      const interval = setInterval(() => {
        if (this._numProcessing == 0) {
          clearInterval(interval);
          resolve(true);
        } else {
          ticked += tick;
          if (timeout && ticked >= timeout) {
            clearInterval(interval);
            resolve(false);
          }
        }
      }, tick);
    });
  }
  _isEnabled() {
    return this.getOptions().enabled !== false && this._transport !== undefined;
  }
  _prepareEvent(event, hint, currentScope, isolationScope) {
    const options = this.getOptions();
    const integrations = Object.keys(this._integrations);
    if (!hint.integrations && integrations?.length) {
      hint.integrations = integrations;
    }
    this.emit("preprocessEvent", event, hint);
    if (!event.type) {
      isolationScope.setLastEventId(event.event_id || hint.event_id);
    }
    return prepareEvent(options, event, hint, currentScope, this, isolationScope).then((evt) => {
      if (evt === null) {
        return evt;
      }
      this.emit("postprocessEvent", evt, hint);
      evt.contexts = {
        trace: getTraceContextFromScope(currentScope),
        ...evt.contexts
      };
      const dynamicSamplingContext = getDynamicSamplingContextFromScope(this, currentScope);
      evt.sdkProcessingMetadata = {
        dynamicSamplingContext,
        ...evt.sdkProcessingMetadata
      };
      return evt;
    });
  }
  _captureEvent(event, hint = {}, currentScope = getCurrentScope(), isolationScope = getIsolationScope()) {
    if (DEBUG_BUILD && isErrorEvent2(event)) {
      debug.log(`Captured error event \`${getPossibleEventMessages(event)[0] || "<unknown>"}\``);
    }
    return this._processEvent(event, hint, currentScope, isolationScope).then((finalEvent) => {
      return finalEvent.event_id;
    }, (reason) => {
      if (DEBUG_BUILD) {
        if (_isDoNotSendEventError(reason)) {
          debug.log(reason.message);
        } else if (_isInternalError(reason)) {
          debug.warn(reason.message);
        } else {
          debug.warn(reason);
        }
      }
      return;
    });
  }
  _processEvent(event, hint, currentScope, isolationScope) {
    const options = this.getOptions();
    const { sampleRate } = options;
    const isTransaction = isTransactionEvent(event);
    const isError2 = isErrorEvent2(event);
    const eventType = event.type || "error";
    const beforeSendLabel = `before send for type \`${eventType}\``;
    const parsedSampleRate = typeof sampleRate === "undefined" ? undefined : parseSampleRate(sampleRate);
    if (isError2 && typeof parsedSampleRate === "number" && Math.random() > parsedSampleRate) {
      this.recordDroppedEvent("sample_rate", "error");
      return rejectedSyncPromise(_makeDoNotSendEventError(`Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`));
    }
    const dataCategory = eventType === "replay_event" ? "replay" : eventType;
    return this._prepareEvent(event, hint, currentScope, isolationScope).then((prepared) => {
      if (prepared === null) {
        this.recordDroppedEvent("event_processor", dataCategory);
        throw _makeDoNotSendEventError("An event processor returned `null`, will not send event.");
      }
      const isInternalException = hint.data && hint.data.__sentry__ === true;
      if (isInternalException) {
        return prepared;
      }
      const result = processBeforeSend(this, options, prepared, hint);
      return _validateBeforeSendResult(result, beforeSendLabel);
    }).then((processedEvent) => {
      if (processedEvent === null) {
        this.recordDroppedEvent("before_send", dataCategory);
        if (isTransaction) {
          const spans = event.spans || [];
          const spanCount = 1 + spans.length;
          this.recordDroppedEvent("before_send", "span", spanCount);
        }
        throw _makeDoNotSendEventError(`${beforeSendLabel} returned \`null\`, will not send event.`);
      }
      const session = currentScope.getSession() || isolationScope.getSession();
      if (isError2 && session) {
        this._updateSessionFromEvent(session, processedEvent);
      }
      if (isTransaction) {
        const spanCountBefore = processedEvent.sdkProcessingMetadata?.spanCountBeforeProcessing || 0;
        const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;
        const droppedSpanCount = spanCountBefore - spanCountAfter;
        if (droppedSpanCount > 0) {
          this.recordDroppedEvent("before_send", "span", droppedSpanCount);
        }
      }
      const transactionInfo = processedEvent.transaction_info;
      if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
        const source = "custom";
        processedEvent.transaction_info = {
          ...transactionInfo,
          source
        };
      }
      this.sendEvent(processedEvent, hint);
      return processedEvent;
    }).then(null, (reason) => {
      if (_isDoNotSendEventError(reason) || _isInternalError(reason)) {
        throw reason;
      }
      this.captureException(reason, {
        mechanism: {
          handled: false,
          type: "internal"
        },
        data: {
          __sentry__: true
        },
        originalException: reason
      });
      throw _makeInternalError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`);
    });
  }
  _process(promise) {
    this._numProcessing++;
    promise.then((value) => {
      this._numProcessing--;
      return value;
    }, (reason) => {
      this._numProcessing--;
      return reason;
    });
  }
  _clearOutcomes() {
    const outcomes = this._outcomes;
    this._outcomes = {};
    return Object.entries(outcomes).map(([key, quantity]) => {
      const [reason, category] = key.split(":");
      return {
        reason,
        category,
        quantity
      };
    });
  }
  _flushOutcomes() {
    DEBUG_BUILD && debug.log("Flushing outcomes...");
    const outcomes = this._clearOutcomes();
    if (outcomes.length === 0) {
      DEBUG_BUILD && debug.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      DEBUG_BUILD && debug.log("No dsn provided, will not send outcomes");
      return;
    }
    DEBUG_BUILD && debug.log("Sending outcomes:", outcomes);
    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
    this.sendEnvelope(envelope);
  }
}
function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
  const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
  if (isThenable(beforeSendResult)) {
    return beforeSendResult.then((event) => {
      if (!isPlainObject(event) && event !== null) {
        throw _makeInternalError(invalidValueError);
      }
      return event;
    }, (e) => {
      throw _makeInternalError(`${beforeSendLabel} rejected with ${e}`);
    });
  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {
    throw _makeInternalError(invalidValueError);
  }
  return beforeSendResult;
}
function processBeforeSend(client, options, event, hint) {
  const { beforeSend, beforeSendTransaction, beforeSendSpan, ignoreSpans } = options;
  let processedEvent = event;
  if (isErrorEvent2(processedEvent) && beforeSend) {
    return beforeSend(processedEvent, hint);
  }
  if (isTransactionEvent(processedEvent)) {
    if (beforeSendSpan || ignoreSpans) {
      const rootSpanJson = convertTransactionEventToSpanJson(processedEvent);
      if (ignoreSpans?.length && shouldIgnoreSpan(rootSpanJson, ignoreSpans)) {
        return null;
      }
      if (beforeSendSpan) {
        const processedRootSpanJson = beforeSendSpan(rootSpanJson);
        if (!processedRootSpanJson) {
          showSpanDropWarning();
        } else {
          processedEvent = merge(event, convertSpanJsonToTransactionEvent(processedRootSpanJson));
        }
      }
      if (processedEvent.spans) {
        const processedSpans = [];
        const initialSpans = processedEvent.spans;
        for (const span of initialSpans) {
          if (ignoreSpans?.length && shouldIgnoreSpan(span, ignoreSpans)) {
            reparentChildSpans(initialSpans, span);
            continue;
          }
          if (beforeSendSpan) {
            const processedSpan = beforeSendSpan(span);
            if (!processedSpan) {
              showSpanDropWarning();
              processedSpans.push(span);
            } else {
              processedSpans.push(processedSpan);
            }
          } else {
            processedSpans.push(span);
          }
        }
        const droppedSpans = processedEvent.spans.length - processedSpans.length;
        if (droppedSpans) {
          client.recordDroppedEvent("before_send", "span", droppedSpans);
        }
        processedEvent.spans = processedSpans;
      }
    }
    if (beforeSendTransaction) {
      if (processedEvent.spans) {
        const spanCountBefore = processedEvent.spans.length;
        processedEvent.sdkProcessingMetadata = {
          ...event.sdkProcessingMetadata,
          spanCountBeforeProcessing: spanCountBefore
        };
      }
      return beforeSendTransaction(processedEvent, hint);
    }
  }
  return processedEvent;
}
function isErrorEvent2(event) {
  return event.type === undefined;
}
function isTransactionEvent(event) {
  return event.type === "transaction";
}
function _getTraceInfoFromScope(client, scope) {
  if (!scope) {
    return [undefined, undefined];
  }
  return withScope2(scope, () => {
    const span = getActiveSpan();
    const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);
    const dynamicSamplingContext = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);
    return [dynamicSamplingContext, traceContext];
  });
}

// ../../node_modules/@sentry/core/build/esm/checkin.js
function createCheckInEnvelope(checkIn, dynamicSamplingContext, metadata, tunnel, dsn) {
  const headers = {
    sent_at: new Date().toISOString()
  };
  if (metadata?.sdk) {
    headers.sdk = {
      name: metadata.sdk.name,
      version: metadata.sdk.version
    };
  }
  if (!!tunnel && !!dsn) {
    headers.dsn = dsnToString(dsn);
  }
  if (dynamicSamplingContext) {
    headers.trace = dynamicSamplingContext;
  }
  const item = createCheckInEnvelopeItem(checkIn);
  return createEnvelope(headers, [item]);
}
function createCheckInEnvelopeItem(checkIn) {
  const checkInHeaders = {
    type: "check_in"
  };
  return [checkInHeaders, checkIn];
}

// ../../node_modules/@sentry/core/build/esm/logs/envelope.js
function createLogContainerEnvelopeItem(items) {
  return [
    {
      type: "log",
      item_count: items.length,
      content_type: "application/vnd.sentry.items.log+json"
    },
    {
      items
    }
  ];
}
function createLogEnvelope(logs, metadata, tunnel, dsn) {
  const headers = {};
  if (metadata?.sdk) {
    headers.sdk = {
      name: metadata.sdk.name,
      version: metadata.sdk.version
    };
  }
  if (!!tunnel && !!dsn) {
    headers.dsn = dsnToString(dsn);
  }
  return createEnvelope(headers, [createLogContainerEnvelopeItem(logs)]);
}

// ../../node_modules/@sentry/core/build/esm/logs/exports.js
function _INTERNAL_flushLogsBuffer(client, maybeLogBuffer) {
  const logBuffer = maybeLogBuffer ?? _INTERNAL_getLogBuffer(client) ?? [];
  if (logBuffer.length === 0) {
    return;
  }
  const clientOptions = client.getOptions();
  const envelope = createLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());
  _getBufferMap().set(client, []);
  client.emit("flushLogs");
  client.sendEnvelope(envelope);
}
function _INTERNAL_getLogBuffer(client) {
  return _getBufferMap().get(client);
}
function _getBufferMap() {
  return getGlobalSingleton("clientToLogBufferMap", () => new WeakMap);
}

// ../../node_modules/@sentry/core/build/esm/utils/eventbuilder.js
function parseStackFrames(stackParser, error2) {
  return stackParser(error2.stack || "", 1);
}
function exceptionFromError(stackParser, error2) {
  const exception = {
    type: error2.name || error2.constructor.name,
    value: error2.message
  };
  const frames = parseStackFrames(stackParser, error2);
  if (frames.length) {
    exception.stacktrace = { frames };
  }
  return exception;
}
function getErrorPropertyFromObject(obj) {
  for (const prop in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
      const value = obj[prop];
      if (value instanceof Error) {
        return value;
      }
    }
  }
  return;
}
function getMessageForObject(exception) {
  if ("name" in exception && typeof exception.name === "string") {
    let message = `'${exception.name}' captured as exception`;
    if ("message" in exception && typeof exception.message === "string") {
      message += ` with message '${exception.message}'`;
    }
    return message;
  } else if ("message" in exception && typeof exception.message === "string") {
    return exception.message;
  }
  const keys = extractExceptionKeysForMessage(exception);
  if (isErrorEvent(exception)) {
    return `Event \`ErrorEvent\` captured as exception with message \`${exception.message}\``;
  }
  const className = getObjectClassName(exception);
  return `${className && className !== "Object" ? `'${className}'` : "Object"} captured as exception with keys: ${keys}`;
}
function getObjectClassName(obj) {
  try {
    const prototype = Object.getPrototypeOf(obj);
    return prototype ? prototype.constructor.name : undefined;
  } catch {}
}
function getException(client, mechanism, exception, hint) {
  if (isError(exception)) {
    return [exception, undefined];
  }
  mechanism.synthetic = true;
  if (isPlainObject(exception)) {
    const normalizeDepth = client?.getOptions().normalizeDepth;
    const extras = { ["__serialized__"]: normalizeToSize(exception, normalizeDepth) };
    const errorFromProp = getErrorPropertyFromObject(exception);
    if (errorFromProp) {
      return [errorFromProp, extras];
    }
    const message = getMessageForObject(exception);
    const ex2 = hint?.syntheticException || new Error(message);
    ex2.message = message;
    return [ex2, extras];
  }
  const ex = hint?.syntheticException || new Error(exception);
  ex.message = `${exception}`;
  return [ex, undefined];
}
function eventFromUnknownInput(client, stackParser, exception, hint) {
  const providedMechanism = hint?.data && hint.data.mechanism;
  const mechanism = providedMechanism || {
    handled: true,
    type: "generic"
  };
  const [ex, extras] = getException(client, mechanism, exception, hint);
  const event = {
    exception: {
      values: [exceptionFromError(stackParser, ex)]
    }
  };
  if (extras) {
    event.extra = extras;
  }
  addExceptionTypeValue(event, undefined, undefined);
  addExceptionMechanism(event, mechanism);
  return {
    ...event,
    event_id: hint?.event_id
  };
}
function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
  const event = {
    event_id: hint?.event_id,
    level
  };
  if (attachStacktrace && hint?.syntheticException) {
    const frames = parseStackFrames(stackParser, hint.syntheticException);
    if (frames.length) {
      event.exception = {
        values: [
          {
            value: message,
            stacktrace: { frames }
          }
        ]
      };
      addExceptionMechanism(event, { synthetic: true });
    }
  }
  if (isParameterizedString(message)) {
    const { __sentry_template_string__, __sentry_template_values__ } = message;
    event.logentry = {
      message: __sentry_template_string__,
      params: __sentry_template_values__
    };
    return event;
  }
  event.message = message;
  return event;
}

// ../../node_modules/@sentry/core/build/esm/server-runtime-client.js
var DEFAULT_LOG_FLUSH_INTERVAL = 5000;

class ServerRuntimeClient extends Client {
  constructor(options) {
    registerSpanErrorInstrumentation();
    super(options);
    this._logWeight = 0;
    if (this._options.enableLogs) {
      const client = this;
      client.on("flushLogs", () => {
        client._logWeight = 0;
        clearTimeout(client._logFlushIdleTimeout);
      });
      client.on("afterCaptureLog", (log2) => {
        client._logWeight += estimateLogSizeInBytes(log2);
        if (client._logWeight >= 800000) {
          _INTERNAL_flushLogsBuffer(client);
        } else {
          client._logFlushIdleTimeout = setTimeout(() => {
            _INTERNAL_flushLogsBuffer(client);
          }, DEFAULT_LOG_FLUSH_INTERVAL);
        }
      });
      client.on("flush", () => {
        _INTERNAL_flushLogsBuffer(client);
      });
    }
  }
  eventFromException(exception, hint) {
    const event = eventFromUnknownInput(this, this._options.stackParser, exception, hint);
    event.level = "error";
    return resolvedSyncPromise(event);
  }
  eventFromMessage(message, level = "info", hint) {
    return resolvedSyncPromise(eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace));
  }
  captureException(exception, hint, scope) {
    setCurrentRequestSessionErroredOrCrashed(hint);
    return super.captureException(exception, hint, scope);
  }
  captureEvent(event, hint, scope) {
    const isException = !event.type && event.exception?.values && event.exception.values.length > 0;
    if (isException) {
      setCurrentRequestSessionErroredOrCrashed(hint);
    }
    return super.captureEvent(event, hint, scope);
  }
  captureCheckIn(checkIn, monitorConfig, scope) {
    const id = "checkInId" in checkIn && checkIn.checkInId ? checkIn.checkInId : uuid4();
    if (!this._isEnabled()) {
      DEBUG_BUILD && debug.warn("SDK not enabled, will not capture check-in.");
      return id;
    }
    const options = this.getOptions();
    const { release, environment, tunnel } = options;
    const serializedCheckIn = {
      check_in_id: id,
      monitor_slug: checkIn.monitorSlug,
      status: checkIn.status,
      release,
      environment
    };
    if ("duration" in checkIn) {
      serializedCheckIn.duration = checkIn.duration;
    }
    if (monitorConfig) {
      serializedCheckIn.monitor_config = {
        schedule: monitorConfig.schedule,
        checkin_margin: monitorConfig.checkinMargin,
        max_runtime: monitorConfig.maxRuntime,
        timezone: monitorConfig.timezone,
        failure_issue_threshold: monitorConfig.failureIssueThreshold,
        recovery_threshold: monitorConfig.recoveryThreshold
      };
    }
    const [dynamicSamplingContext, traceContext] = _getTraceInfoFromScope(this, scope);
    if (traceContext) {
      serializedCheckIn.contexts = {
        trace: traceContext
      };
    }
    const envelope = createCheckInEnvelope(serializedCheckIn, dynamicSamplingContext, this.getSdkMetadata(), tunnel, this.getDsn());
    DEBUG_BUILD && debug.log("Sending checkin:", checkIn.monitorSlug, checkIn.status);
    this.sendEnvelope(envelope);
    return id;
  }
  _prepareEvent(event, hint, currentScope, isolationScope) {
    if (this._options.platform) {
      event.platform = event.platform || this._options.platform;
    }
    if (this._options.runtime) {
      event.contexts = {
        ...event.contexts,
        runtime: event.contexts?.runtime || this._options.runtime
      };
    }
    if (this._options.serverName) {
      event.server_name = event.server_name || this._options.serverName;
    }
    return super._prepareEvent(event, hint, currentScope, isolationScope);
  }
}
function setCurrentRequestSessionErroredOrCrashed(eventHint) {
  const requestSession = getIsolationScope().getScopeData().sdkProcessingMetadata.requestSession;
  if (requestSession) {
    const isHandledException = eventHint?.mechanism?.handled ?? true;
    if (isHandledException && requestSession.status !== "crashed") {
      requestSession.status = "errored";
    } else if (!isHandledException) {
      requestSession.status = "crashed";
    }
  }
}
function estimateLogSizeInBytes(log2) {
  let weight = 0;
  if (log2.message) {
    weight += log2.message.length * 2;
  }
  if (log2.attributes) {
    Object.values(log2.attributes).forEach((value) => {
      if (Array.isArray(value)) {
        weight += value.length * estimatePrimitiveSizeInBytes(value[0]);
      } else if (isPrimitive(value)) {
        weight += estimatePrimitiveSizeInBytes(value);
      } else {
        weight += 100;
      }
    });
  }
  return weight;
}
function estimatePrimitiveSizeInBytes(value) {
  if (typeof value === "string") {
    return value.length * 2;
  } else if (typeof value === "number") {
    return 8;
  } else if (typeof value === "boolean") {
    return 4;
  }
  return 0;
}
// ../../node_modules/@sentry/core/build/esm/utils/promisebuffer.js
var SENTRY_BUFFER_FULL_ERROR = Symbol.for("SentryBufferFullError");
function makePromiseBuffer(limit) {
  const buffer = [];
  function isReady() {
    return limit === undefined || buffer.length < limit;
  }
  function remove(task) {
    return buffer.splice(buffer.indexOf(task), 1)[0] || Promise.resolve(undefined);
  }
  function add(taskProducer) {
    if (!isReady()) {
      return rejectedSyncPromise(SENTRY_BUFFER_FULL_ERROR);
    }
    const task = taskProducer();
    if (buffer.indexOf(task) === -1) {
      buffer.push(task);
    }
    task.then(() => remove(task)).then(null, () => remove(task).then(null, () => {}));
    return task;
  }
  function drain(timeout) {
    return new SyncPromise((resolve, reject) => {
      let counter = buffer.length;
      if (!counter) {
        return resolve(true);
      }
      const capturedSetTimeout = setTimeout(() => {
        if (timeout && timeout > 0) {
          resolve(false);
        }
      }, timeout);
      buffer.forEach((item) => {
        resolvedSyncPromise(item).then(() => {
          if (!--counter) {
            clearTimeout(capturedSetTimeout);
            resolve(true);
          }
        }, reject);
      });
    });
  }
  return {
    $: buffer,
    add,
    drain
  };
}

// ../../node_modules/@sentry/core/build/esm/utils/ratelimit.js
var DEFAULT_RETRY_AFTER = 60 * 1000;
function parseRetryAfterHeader(header, now = Date.now()) {
  const headerDelay = parseInt(`${header}`, 10);
  if (!isNaN(headerDelay)) {
    return headerDelay * 1000;
  }
  const headerDate = Date.parse(`${header}`);
  if (!isNaN(headerDate)) {
    return headerDate - now;
  }
  return DEFAULT_RETRY_AFTER;
}
function disabledUntil(limits, dataCategory) {
  return limits[dataCategory] || limits.all || 0;
}
function isRateLimited(limits, dataCategory, now = Date.now()) {
  return disabledUntil(limits, dataCategory) > now;
}
function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {
  const updatedRateLimits = {
    ...limits
  };
  const rateLimitHeader = headers?.["x-sentry-rate-limits"];
  const retryAfterHeader = headers?.["retry-after"];
  if (rateLimitHeader) {
    for (const limit of rateLimitHeader.trim().split(",")) {
      const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
      const headerDelay = parseInt(retryAfter, 10);
      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000;
      if (!categories) {
        updatedRateLimits.all = now + delay;
      } else {
        for (const category of categories.split(";")) {
          if (category === "metric_bucket") {
            if (!namespaces || namespaces.split(";").includes("custom")) {
              updatedRateLimits[category] = now + delay;
            }
          } else {
            updatedRateLimits[category] = now + delay;
          }
        }
      }
    }
  } else if (retryAfterHeader) {
    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
  } else if (statusCode === 429) {
    updatedRateLimits.all = now + 60 * 1000;
  }
  return updatedRateLimits;
}

// ../../node_modules/@sentry/core/build/esm/transports/base.js
var DEFAULT_TRANSPORT_BUFFER_SIZE = 64;
function createTransport(options, makeRequest, buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE)) {
  let rateLimits = {};
  const flush = (timeout) => buffer.drain(timeout);
  function send(envelope) {
    const filteredEnvelopeItems = [];
    forEachEnvelopeItem(envelope, (item, type) => {
      const dataCategory = envelopeItemTypeToDataCategory(type);
      if (isRateLimited(rateLimits, dataCategory)) {
        options.recordDroppedEvent("ratelimit_backoff", dataCategory);
      } else {
        filteredEnvelopeItems.push(item);
      }
    });
    if (filteredEnvelopeItems.length === 0) {
      return resolvedSyncPromise({});
    }
    const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);
    const recordEnvelopeLoss = (reason) => {
      forEachEnvelopeItem(filteredEnvelope, (item, type) => {
        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));
      });
    };
    const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope) }).then((response) => {
      if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {
        DEBUG_BUILD && debug.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
      }
      rateLimits = updateRateLimits(rateLimits, response);
      return response;
    }, (error2) => {
      recordEnvelopeLoss("network_error");
      DEBUG_BUILD && debug.error("Encountered error running transport request:", error2);
      throw error2;
    });
    return buffer.add(requestTask).then((result) => result, (error2) => {
      if (error2 === SENTRY_BUFFER_FULL_ERROR) {
        DEBUG_BUILD && debug.error("Skipped sending event because buffer is full.");
        recordEnvelopeLoss("queue_overflow");
        return resolvedSyncPromise({});
      } else {
        throw error2;
      }
    });
  }
  return {
    send,
    flush
  };
}
// ../../node_modules/@sentry/core/build/esm/utils/url.js
var DEFAULT_BASE_URL = "thismessage:/";
function parseStringToURLObject(url, urlBase) {
  const isRelative = url.indexOf("://") <= 0 && url.indexOf("//") !== 0;
  const base = urlBase ?? (isRelative ? DEFAULT_BASE_URL : undefined);
  try {
    if ("canParse" in URL && !URL.canParse(url, base)) {
      return;
    }
    const fullUrlObject = new URL(url, base);
    if (isRelative) {
      return {
        isRelative,
        pathname: fullUrlObject.pathname,
        search: fullUrlObject.search,
        hash: fullUrlObject.hash
      };
    }
    return fullUrlObject;
  } catch {}
  return;
}
function parseUrl(url) {
  if (!url) {
    return {};
  }
  const match2 = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!match2) {
    return {};
  }
  const query = match2[6] || "";
  const fragment = match2[8] || "";
  return {
    host: match2[4],
    path: match2[5],
    protocol: match2[2],
    search: query,
    hash: fragment,
    relative: match2[5] + query + fragment
  };
}
function stripUrlQueryAndFragment(urlPath) {
  return urlPath.split(/[?#]/, 1)[0];
}
function getSanitizedUrlString(url) {
  const { protocol, host, path: path7 } = url;
  const filteredHost = host?.replace(/^.*@/, "[filtered]:[filtered]@").replace(/(:80)$/, "").replace(/(:443)$/, "") || "";
  return `${protocol ? `${protocol}://` : ""}${filteredHost}${path7}`;
}
// ../../node_modules/@sentry/core/build/esm/utils/sdkMetadata.js
function applySdkMetadata(options, name, names = [name], source = "npm") {
  const metadata = options._metadata || {};
  if (!metadata.sdk) {
    metadata.sdk = {
      name: `sentry.javascript.${name}`,
      packages: names.map((name2) => ({
        name: `${source}:@sentry/${name2}`,
        version: SDK_VERSION
      })),
      version: SDK_VERSION
    };
  }
  options._metadata = metadata;
}
// ../../node_modules/@sentry/core/build/esm/utils/traceData.js
function getTraceData(options = {}) {
  const client = options.client || getClient();
  if (!isEnabled2() || !client) {
    return {};
  }
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (acs.getTraceData) {
    return acs.getTraceData(options);
  }
  const scope = options.scope || getCurrentScope();
  const span = options.span || getActiveSpan();
  const sentryTrace = span ? spanToTraceHeader(span) : scopeToTraceHeader(scope);
  const dsc = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);
  const baggage = dynamicSamplingContextToSentryBaggageHeader(dsc);
  const isValidSentryTraceHeader = TRACEPARENT_REGEXP.test(sentryTrace);
  if (!isValidSentryTraceHeader) {
    debug.warn("Invalid sentry-trace data. Cannot generate trace data");
    return {};
  }
  const traceData = {
    "sentry-trace": sentryTrace,
    baggage
  };
  if (options.propagateTraceparent) {
    const traceparent = span ? spanToTraceparentHeader(span) : scopeToTraceparentHeader(scope);
    if (traceparent) {
      traceData.traceparent = traceparent;
    }
  }
  return traceData;
}
function scopeToTraceHeader(scope) {
  const { traceId, sampled, propagationSpanId } = scope.getPropagationContext();
  return generateSentryTraceHeader(traceId, propagationSpanId, sampled);
}
function scopeToTraceparentHeader(scope) {
  const { traceId, sampled, propagationSpanId } = scope.getPropagationContext();
  return generateTraceparentHeader(traceId, propagationSpanId, sampled);
}
// ../../node_modules/@sentry/core/build/esm/utils/debounce.js
function debounce(func, wait, options) {
  let callbackReturnValue;
  let timerId;
  let maxTimerId;
  const maxWait = options?.maxWait ? Math.max(options.maxWait, wait) : 0;
  const setTimeoutImpl = options?.setTimeoutImpl || setTimeout;
  function invokeFunc() {
    cancelTimers();
    callbackReturnValue = func();
    return callbackReturnValue;
  }
  function cancelTimers() {
    timerId !== undefined && clearTimeout(timerId);
    maxTimerId !== undefined && clearTimeout(maxTimerId);
    timerId = maxTimerId = undefined;
  }
  function flush() {
    if (timerId !== undefined || maxTimerId !== undefined) {
      return invokeFunc();
    }
    return callbackReturnValue;
  }
  function debounced() {
    if (timerId) {
      clearTimeout(timerId);
    }
    timerId = setTimeoutImpl(invokeFunc, wait);
    if (maxWait && maxTimerId === undefined) {
      maxTimerId = setTimeoutImpl(invokeFunc, maxWait);
    }
    return callbackReturnValue;
  }
  debounced.cancel = cancelTimers;
  debounced.flush = flush;
  return debounced;
}
// ../../node_modules/@sentry/core/build/esm/utils/request.js
function headersToDict(reqHeaders) {
  const headers = Object.create(null);
  try {
    Object.entries(reqHeaders).forEach(([key, value]) => {
      if (typeof value === "string") {
        headers[key] = value;
      }
    });
  } catch {}
  return headers;
}
function httpRequestToRequestData(request) {
  const headers = request.headers || {};
  const forwardedHost = typeof headers["x-forwarded-host"] === "string" ? headers["x-forwarded-host"] : undefined;
  const host = forwardedHost || (typeof headers.host === "string" ? headers.host : undefined);
  const forwardedProto = typeof headers["x-forwarded-proto"] === "string" ? headers["x-forwarded-proto"] : undefined;
  const protocol = forwardedProto || request.protocol || (request.socket?.encrypted ? "https" : "http");
  const url = request.url || "";
  const absoluteUrl = getAbsoluteUrl({
    url,
    host,
    protocol
  });
  const data = request.body || undefined;
  const cookies = request.cookies;
  return {
    url: absoluteUrl,
    method: request.method,
    query_string: extractQueryParamsFromUrl(url),
    headers: headersToDict(headers),
    cookies,
    data
  };
}
function getAbsoluteUrl({
  url,
  protocol,
  host
}) {
  if (url?.startsWith("http")) {
    return url;
  }
  if (url && host) {
    return `${protocol}://${host}${url}`;
  }
  return;
}
var SENSITIVE_HEADER_SNIPPETS = ["auth", "token", "secret", "cookie", "-user", "password", "key"];
function httpHeadersToSpanAttributes(headers, sendDefaultPii = false) {
  const spanAttributes = {};
  try {
    Object.entries(headers).forEach(([key, value]) => {
      if (value !== undefined) {
        const lowerCasedKey = key.toLowerCase();
        if (!sendDefaultPii && SENSITIVE_HEADER_SNIPPETS.some((snippet) => lowerCasedKey.includes(snippet))) {
          return;
        }
        const normalizedKey = `http.request.header.${lowerCasedKey.replace(/-/g, "_")}`;
        if (Array.isArray(value)) {
          spanAttributes[normalizedKey] = value.map((v) => v !== null && v !== undefined ? String(v) : v).join(";");
        } else if (typeof value === "string") {
          spanAttributes[normalizedKey] = value;
        }
      }
    });
  } catch {}
  return spanAttributes;
}
function extractQueryParamsFromUrl(url) {
  if (!url) {
    return;
  }
  try {
    const queryParams = new URL(url, "http://s.io").search.slice(1);
    return queryParams.length ? queryParams : undefined;
  } catch {
    return;
  }
}
// ../../node_modules/@sentry/core/build/esm/breadcrumbs.js
var DEFAULT_BREADCRUMBS = 100;
function addBreadcrumb(breadcrumb, hint) {
  const client = getClient();
  const isolationScope = getIsolationScope();
  if (!client)
    return;
  const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions();
  if (maxBreadcrumbs <= 0)
    return;
  const timestamp = dateTimestampInSeconds();
  const mergedBreadcrumb = { timestamp, ...breadcrumb };
  const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
  if (finalBreadcrumb === null)
    return;
  if (client.emit) {
    client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
  }
  isolationScope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
}
// ../../node_modules/@sentry/core/build/esm/integrations/functiontostring.js
var originalFunctionToString;
var INTEGRATION_NAME = "FunctionToString";
var SETUP_CLIENTS = new WeakMap;
var _functionToStringIntegration = () => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      originalFunctionToString = Function.prototype.toString;
      try {
        Function.prototype.toString = function(...args) {
          const originalFunction = getOriginalFunction(this);
          const context = SETUP_CLIENTS.has(getClient()) && originalFunction !== undefined ? originalFunction : this;
          return originalFunctionToString.apply(context, args);
        };
      } catch {}
    },
    setup(client) {
      SETUP_CLIENTS.set(client, true);
    }
  };
};
var functionToStringIntegration = defineIntegration(_functionToStringIntegration);
// ../../node_modules/@sentry/core/build/esm/integrations/eventFilters.js
var DEFAULT_IGNORE_ERRORS = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  /^Cannot redefine property: googletag$/,
  /^Can't find variable: gmo$/,
  /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/,
  `can't redefine non-configurable property "solana"`,
  "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
  "Can't find variable: _AutofillCallbackHandler",
  /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/,
  /^Java exception was raised during method invocation$/
];
var INTEGRATION_NAME2 = "EventFilters";
var eventFiltersIntegration = defineIntegration((options = {}) => {
  let mergedOptions;
  return {
    name: INTEGRATION_NAME2,
    setup(client) {
      const clientOptions = client.getOptions();
      mergedOptions = _mergeOptions(options, clientOptions);
    },
    processEvent(event, _hint, client) {
      if (!mergedOptions) {
        const clientOptions = client.getOptions();
        mergedOptions = _mergeOptions(options, clientOptions);
      }
      return _shouldDropEvent(event, mergedOptions) ? null : event;
    }
  };
});
var inboundFiltersIntegration = defineIntegration((options = {}) => {
  return {
    ...eventFiltersIntegration(options),
    name: "InboundFilters"
  };
});
function _mergeOptions(internalOptions = {}, clientOptions = {}) {
  return {
    allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
    denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
    ignoreErrors: [
      ...internalOptions.ignoreErrors || [],
      ...clientOptions.ignoreErrors || [],
      ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
    ],
    ignoreTransactions: [...internalOptions.ignoreTransactions || [], ...clientOptions.ignoreTransactions || []]
  };
}
function _shouldDropEvent(event, options) {
  if (!event.type) {
    if (_isIgnoredError(event, options.ignoreErrors)) {
      DEBUG_BUILD && debug.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(event)}`);
      return true;
    }
    if (_isUselessError(event)) {
      DEBUG_BUILD && debug.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${getEventDescription(event)}`);
      return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
      DEBUG_BUILD && debug.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(event)}.
Url: ${_getEventFilterUrl(event)}`);
      return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
      DEBUG_BUILD && debug.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(event)}.
Url: ${_getEventFilterUrl(event)}`);
      return true;
    }
  } else if (event.type === "transaction") {
    if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
      DEBUG_BUILD && debug.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(event)}`);
      return true;
    }
  }
  return false;
}
function _isIgnoredError(event, ignoreErrors) {
  if (!ignoreErrors?.length) {
    return false;
  }
  return getPossibleEventMessages(event).some((message) => stringMatchesSomePattern(message, ignoreErrors));
}
function _isIgnoredTransaction(event, ignoreTransactions) {
  if (!ignoreTransactions?.length) {
    return false;
  }
  const name = event.transaction;
  return name ? stringMatchesSomePattern(name, ignoreTransactions) : false;
}
function _isDeniedUrl(event, denyUrls) {
  if (!denyUrls?.length) {
    return false;
  }
  const url = _getEventFilterUrl(event);
  return !url ? false : stringMatchesSomePattern(url, denyUrls);
}
function _isAllowedUrl(event, allowUrls) {
  if (!allowUrls?.length) {
    return true;
  }
  const url = _getEventFilterUrl(event);
  return !url ? true : stringMatchesSomePattern(url, allowUrls);
}
function _getLastValidUrl(frames = []) {
  for (let i = frames.length - 1;i >= 0; i--) {
    const frame = frames[i];
    if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
      return frame.filename || null;
    }
  }
  return null;
}
function _getEventFilterUrl(event) {
  try {
    const rootException = [...event.exception?.values ?? []].reverse().find((value) => value.mechanism?.parent_id === undefined && value.stacktrace?.frames?.length);
    const frames = rootException?.stacktrace?.frames;
    return frames ? _getLastValidUrl(frames) : null;
  } catch {
    DEBUG_BUILD && debug.error(`Cannot extract url for event ${getEventDescription(event)}`);
    return null;
  }
}
function _isUselessError(event) {
  if (!event.exception?.values?.length) {
    return false;
  }
  return !event.message && !event.exception.values.some((value) => value.stacktrace || value.type && value.type !== "Error" || value.value);
}
// ../../node_modules/@sentry/core/build/esm/utils/aggregate-errors.js
function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, key, limit, event, hint) {
  if (!event.exception?.values || !hint || !isInstanceOf(hint.originalException, Error)) {
    return;
  }
  const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : undefined;
  if (originalException) {
    event.exception.values = aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, hint.originalException, key, event.exception.values, originalException, 0);
  }
}
function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error2, key, prevExceptions, exception, exceptionId) {
  if (prevExceptions.length >= limit + 1) {
    return prevExceptions;
  }
  let newExceptions = [...prevExceptions];
  if (isInstanceOf(error2[key], Error)) {
    applyExceptionGroupFieldsForParentException(exception, exceptionId);
    const newException = exceptionFromErrorImplementation(parser, error2[key]);
    const newExceptionId = newExceptions.length;
    applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
    newExceptions = aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error2[key], key, [newException, ...newExceptions], newException, newExceptionId);
  }
  if (Array.isArray(error2.errors)) {
    error2.errors.forEach((childError, i) => {
      if (isInstanceOf(childError, Error)) {
        applyExceptionGroupFieldsForParentException(exception, exceptionId);
        const newException = exceptionFromErrorImplementation(parser, childError);
        const newExceptionId = newExceptions.length;
        applyExceptionGroupFieldsForChildException(newException, `errors[${i}]`, newExceptionId, exceptionId);
        newExceptions = aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, childError, key, [newException, ...newExceptions], newException, newExceptionId);
      }
    });
  }
  return newExceptions;
}
function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
  exception.mechanism = {
    handled: true,
    type: "auto.core.linked_errors",
    ...exception.mechanism,
    ...exception.type === "AggregateError" && { is_exception_group: true },
    exception_id: exceptionId
  };
}
function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
  exception.mechanism = {
    handled: true,
    ...exception.mechanism,
    type: "chained",
    source,
    exception_id: exceptionId,
    parent_id: parentId
  };
}

// ../../node_modules/@sentry/core/build/esm/integrations/linkederrors.js
var DEFAULT_KEY = "cause";
var DEFAULT_LIMIT2 = 5;
var INTEGRATION_NAME3 = "LinkedErrors";
var _linkedErrorsIntegration = (options = {}) => {
  const limit = options.limit || DEFAULT_LIMIT2;
  const key = options.key || DEFAULT_KEY;
  return {
    name: INTEGRATION_NAME3,
    preprocessEvent(event, hint, client) {
      const options2 = client.getOptions();
      applyAggregateErrorsToEvent(exceptionFromError, options2.stackParser, key, limit, event, hint);
    }
  };
};
var linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);
// ../../node_modules/@sentry/core/build/esm/utils/cookie.js
function parseCookie(str) {
  const obj = {};
  let index = 0;
  while (index < str.length) {
    const eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    let endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index, eqIdx).trim();
    if (obj[key] === undefined) {
      let val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      try {
        obj[key] = val.indexOf("%") !== -1 ? decodeURIComponent(val) : val;
      } catch {
        obj[key] = val;
      }
    }
    index = endIdx + 1;
  }
  return obj;
}

// ../../node_modules/@sentry/core/build/esm/vendor/getIpAddress.js
var ipHeaderNames = [
  "X-Client-IP",
  "X-Forwarded-For",
  "Fly-Client-IP",
  "CF-Connecting-IP",
  "Fastly-Client-Ip",
  "True-Client-Ip",
  "X-Real-IP",
  "X-Cluster-Client-IP",
  "X-Forwarded",
  "Forwarded-For",
  "Forwarded",
  "X-Vercel-Forwarded-For"
];
function getClientIPAddress(headers) {
  const headerValues = ipHeaderNames.map((headerName) => {
    const rawValue = headers[headerName];
    const value = Array.isArray(rawValue) ? rawValue.join(";") : rawValue;
    if (headerName === "Forwarded") {
      return parseForwardedHeader(value);
    }
    return value?.split(",").map((v) => v.trim());
  });
  const flattenedHeaderValues = headerValues.reduce((acc, val) => {
    if (!val) {
      return acc;
    }
    return acc.concat(val);
  }, []);
  const ipAddress = flattenedHeaderValues.find((ip) => ip !== null && isIP2(ip));
  return ipAddress || null;
}
function parseForwardedHeader(value) {
  if (!value) {
    return null;
  }
  for (const part of value.split(";")) {
    if (part.startsWith("for=")) {
      return part.slice(4);
    }
  }
  return null;
}
function isIP2(str) {
  const regex = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(?::[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(?::[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(?::[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(?::[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)/;
  return regex.test(str);
}

// ../../node_modules/@sentry/core/build/esm/integrations/requestdata.js
var DEFAULT_INCLUDE = {
  cookies: true,
  data: true,
  headers: true,
  query_string: true,
  url: true
};
var INTEGRATION_NAME4 = "RequestData";
var _requestDataIntegration = (options = {}) => {
  const include = {
    ...DEFAULT_INCLUDE,
    ...options.include
  };
  return {
    name: INTEGRATION_NAME4,
    processEvent(event, _hint, client) {
      const { sdkProcessingMetadata = {} } = event;
      const { normalizedRequest, ipAddress } = sdkProcessingMetadata;
      const includeWithDefaultPiiApplied = {
        ...include,
        ip: include.ip ?? client.getOptions().sendDefaultPii
      };
      if (normalizedRequest) {
        addNormalizedRequestDataToEvent(event, normalizedRequest, { ipAddress }, includeWithDefaultPiiApplied);
      }
      return event;
    }
  };
};
var requestDataIntegration = defineIntegration(_requestDataIntegration);
function addNormalizedRequestDataToEvent(event, req, additionalData, include) {
  event.request = {
    ...event.request,
    ...extractNormalizedRequestData(req, include)
  };
  if (include.ip) {
    const ip = req.headers && getClientIPAddress(req.headers) || additionalData.ipAddress;
    if (ip) {
      event.user = {
        ...event.user,
        ip_address: ip
      };
    }
  }
}
function extractNormalizedRequestData(normalizedRequest, include) {
  const requestData = {};
  const headers = { ...normalizedRequest.headers };
  if (include.headers) {
    requestData.headers = headers;
    if (!include.cookies) {
      delete headers.cookie;
    }
    if (!include.ip) {
      ipHeaderNames.forEach((ipHeaderName) => {
        delete headers[ipHeaderName];
      });
    }
  }
  requestData.method = normalizedRequest.method;
  if (include.url) {
    requestData.url = normalizedRequest.url;
  }
  if (include.cookies) {
    const cookies = normalizedRequest.cookies || (headers?.cookie ? parseCookie(headers.cookie) : undefined);
    requestData.cookies = cookies || {};
  }
  if (include.query_string) {
    requestData.query_string = normalizedRequest.query_string;
  }
  if (include.data) {
    requestData.data = normalizedRequest.data;
  }
  return requestData;
}
// ../../node_modules/@sentry/core/build/esm/instrument/console.js
function addConsoleInstrumentationHandler(handler) {
  const type = "console";
  addHandler(type, handler);
  maybeInstrument(type, instrumentConsole);
}
function instrumentConsole() {
  if (!("console" in GLOBAL_OBJ)) {
    return;
  }
  CONSOLE_LEVELS.forEach(function(level) {
    if (!(level in GLOBAL_OBJ.console)) {
      return;
    }
    fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
      originalConsoleMethods[level] = originalConsoleMethod;
      return function(...args) {
        const handlerData = { args, level };
        triggerHandlers("console", handlerData);
        const log2 = originalConsoleMethods[level];
        log2?.apply(GLOBAL_OBJ.console, args);
      };
    });
  });
}

// ../../node_modules/@sentry/core/build/esm/utils/severity.js
function severityLevelFromString(level) {
  return level === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(level) ? level : "log";
}

// ../../node_modules/@sentry/core/build/esm/utils/path.js
var splitPathRe = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
function splitPath(filename) {
  const truncated = filename.length > 1024 ? `<truncated>${filename.slice(-1024)}` : filename;
  const parts = splitPathRe.exec(truncated);
  return parts ? parts.slice(1) : [];
}
function dirname(path7) {
  const result = splitPath(path7);
  const root = result[0] || "";
  let dir = result[1];
  if (!root && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.slice(0, dir.length - 1);
  }
  return root + dir;
}

// ../../node_modules/@sentry/core/build/esm/integrations/console.js
var INTEGRATION_NAME5 = "Console";
var consoleIntegration = defineIntegration((options = {}) => {
  const levels = new Set(options.levels || CONSOLE_LEVELS);
  return {
    name: INTEGRATION_NAME5,
    setup(client) {
      addConsoleInstrumentationHandler(({ args, level }) => {
        if (getClient() !== client || !levels.has(level)) {
          return;
        }
        addConsoleBreadcrumb(level, args);
      });
    }
  };
});
function addConsoleBreadcrumb(level, args) {
  const breadcrumb = {
    category: "console",
    data: {
      arguments: args,
      logger: "console"
    },
    level: severityLevelFromString(level),
    message: formatConsoleArgs(args)
  };
  if (level === "assert") {
    if (args[0] === false) {
      const assertionArgs = args.slice(1);
      breadcrumb.message = assertionArgs.length > 0 ? `Assertion failed: ${formatConsoleArgs(assertionArgs)}` : "Assertion failed";
      breadcrumb.data.arguments = assertionArgs;
    } else {
      return;
    }
  }
  addBreadcrumb(breadcrumb, {
    input: args,
    level
  });
}
function formatConsoleArgs(values) {
  return "util" in GLOBAL_OBJ && typeof GLOBAL_OBJ.util.format === "function" ? GLOBAL_OBJ.util.format(...values) : safeJoin(values, " ");
}
// ../../node_modules/@sentry/core/build/esm/utils/vercel-ai/constants.js
var toolCallSpanMap = new Map;

// ../../node_modules/@sentry/core/build/esm/utils/ai/gen-ai-attributes.js
var GEN_AI_PROMPT_ATTRIBUTE = "gen_ai.prompt";
var GEN_AI_SYSTEM_ATTRIBUTE = "gen_ai.system";
var GEN_AI_REQUEST_MODEL_ATTRIBUTE = "gen_ai.request.model";
var GEN_AI_REQUEST_STREAM_ATTRIBUTE = "gen_ai.request.stream";
var GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE = "gen_ai.request.temperature";
var GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE = "gen_ai.request.max_tokens";
var GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE = "gen_ai.request.frequency_penalty";
var GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE = "gen_ai.request.presence_penalty";
var GEN_AI_REQUEST_TOP_P_ATTRIBUTE = "gen_ai.request.top_p";
var GEN_AI_REQUEST_TOP_K_ATTRIBUTE = "gen_ai.request.top_k";
var GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE = "gen_ai.response.finish_reasons";
var GEN_AI_RESPONSE_MODEL_ATTRIBUTE = "gen_ai.response.model";
var GEN_AI_RESPONSE_ID_ATTRIBUTE = "gen_ai.response.id";
var GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE = "gen_ai.usage.input_tokens";
var GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE = "gen_ai.usage.output_tokens";
var GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE = "gen_ai.usage.total_tokens";
var GEN_AI_OPERATION_NAME_ATTRIBUTE = "gen_ai.operation.name";
var GEN_AI_REQUEST_MESSAGES_ATTRIBUTE = "gen_ai.request.messages";
var GEN_AI_RESPONSE_TEXT_ATTRIBUTE = "gen_ai.response.text";
var GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE = "gen_ai.request.available_tools";
var GEN_AI_RESPONSE_STREAMING_ATTRIBUTE = "gen_ai.response.streaming";
var GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE = "gen_ai.response.tool_calls";
var OPENAI_RESPONSE_ID_ATTRIBUTE = "openai.response.id";
var OPENAI_RESPONSE_MODEL_ATTRIBUTE = "openai.response.model";
var OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE = "openai.response.timestamp";
var OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE = "openai.usage.completion_tokens";
var OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE = "openai.usage.prompt_tokens";
var OPENAI_OPERATIONS = {
  CHAT: "chat",
  RESPONSES: "responses"
};
var ANTHROPIC_AI_RESPONSE_TIMESTAMP_ATTRIBUTE = "anthropic.response.timestamp";

// ../../node_modules/@sentry/core/build/esm/utils/vercel-ai/utils.js
function accumulateTokensForParent(span, tokenAccumulator) {
  const parentSpanId = span.parent_span_id;
  if (!parentSpanId) {
    return;
  }
  const inputTokens = span.data[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE];
  const outputTokens = span.data[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE];
  if (typeof inputTokens === "number" || typeof outputTokens === "number") {
    const existing = tokenAccumulator.get(parentSpanId) || { inputTokens: 0, outputTokens: 0 };
    if (typeof inputTokens === "number") {
      existing.inputTokens += inputTokens;
    }
    if (typeof outputTokens === "number") {
      existing.outputTokens += outputTokens;
    }
    tokenAccumulator.set(parentSpanId, existing);
  }
}
function applyAccumulatedTokens(spanOrTrace, tokenAccumulator) {
  const accumulated = tokenAccumulator.get(spanOrTrace.span_id);
  if (!accumulated || !spanOrTrace.data) {
    return;
  }
  if (accumulated.inputTokens > 0) {
    spanOrTrace.data[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE] = accumulated.inputTokens;
  }
  if (accumulated.outputTokens > 0) {
    spanOrTrace.data[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] = accumulated.outputTokens;
  }
  if (accumulated.inputTokens > 0 || accumulated.outputTokens > 0) {
    spanOrTrace.data["gen_ai.usage.total_tokens"] = accumulated.inputTokens + accumulated.outputTokens;
  }
}
function _INTERNAL_getSpanForToolCallId(toolCallId) {
  return toolCallSpanMap.get(toolCallId);
}
function _INTERNAL_cleanupToolCallSpan(toolCallId) {
  toolCallSpanMap.delete(toolCallId);
}

// ../../node_modules/@sentry/core/build/esm/utils/vercel-ai/vercel-ai-attributes.js
var AI_PROMPT_ATTRIBUTE = "ai.prompt";
var AI_RESPONSE_OBJECT_ATTRIBUTE = "ai.response.object";
var AI_RESPONSE_TEXT_ATTRIBUTE = "ai.response.text";
var AI_RESPONSE_TOOL_CALLS_ATTRIBUTE = "ai.response.toolCalls";
var AI_PROMPT_MESSAGES_ATTRIBUTE = "ai.prompt.messages";
var AI_PROMPT_TOOLS_ATTRIBUTE = "ai.prompt.tools";
var AI_MODEL_ID_ATTRIBUTE = "ai.model.id";
var AI_MODEL_PROVIDER_ATTRIBUTE = "ai.model.provider";
var AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE = "ai.response.providerMetadata";
var AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE = "ai.telemetry.functionId";
var AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE = "ai.usage.completionTokens";
var AI_USAGE_PROMPT_TOKENS_ATTRIBUTE = "ai.usage.promptTokens";
var GEN_AI_RESPONSE_MODEL_ATTRIBUTE2 = "gen_ai.response.model";
var GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE2 = "gen_ai.usage.input_tokens";
var GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE2 = "gen_ai.usage.output_tokens";
var AI_TOOL_CALL_NAME_ATTRIBUTE = "ai.toolCall.name";
var AI_TOOL_CALL_ID_ATTRIBUTE = "ai.toolCall.id";
var AI_TOOL_CALL_ARGS_ATTRIBUTE = "ai.toolCall.args";
var AI_TOOL_CALL_RESULT_ATTRIBUTE = "ai.toolCall.result";

// ../../node_modules/@sentry/core/build/esm/utils/vercel-ai/index.js
function addOriginToSpan(span, origin) {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);
}
function onVercelAiSpanStart(span) {
  const { data: attributes, description: name } = spanToJSON(span);
  if (!name) {
    return;
  }
  if (attributes[AI_TOOL_CALL_NAME_ATTRIBUTE] && attributes[AI_TOOL_CALL_ID_ATTRIBUTE] && name === "ai.toolCall") {
    processToolCallSpan(span, attributes);
    return;
  }
  const aiModelId = attributes[AI_MODEL_ID_ATTRIBUTE];
  const aiModelProvider = attributes[AI_MODEL_PROVIDER_ATTRIBUTE];
  if (typeof aiModelId !== "string" || typeof aiModelProvider !== "string" || !aiModelId || !aiModelProvider) {
    return;
  }
  processGenerateSpan(span, name, attributes);
}
function vercelAiEventProcessor(event) {
  if (event.type === "transaction" && event.spans) {
    const tokenAccumulator = new Map;
    for (const span of event.spans) {
      processEndedVercelAiSpan(span);
      accumulateTokensForParent(span, tokenAccumulator);
    }
    for (const span of event.spans) {
      if (span.op !== "gen_ai.invoke_agent") {
        continue;
      }
      applyAccumulatedTokens(span, tokenAccumulator);
    }
    const trace = event.contexts?.trace;
    if (trace && trace.op === "gen_ai.invoke_agent") {
      applyAccumulatedTokens(trace, tokenAccumulator);
    }
  }
  return event;
}
function processEndedVercelAiSpan(span) {
  const { data: attributes, origin } = span;
  if (origin !== "auto.vercelai.otel") {
    return;
  }
  renameAttributeKey(attributes, AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE, GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE2);
  renameAttributeKey(attributes, AI_USAGE_PROMPT_TOKENS_ATTRIBUTE, GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE2);
  if (typeof attributes[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE2] === "number" && typeof attributes[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE2] === "number") {
    attributes["gen_ai.usage.total_tokens"] = attributes[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE2] + attributes[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE2];
  }
  renameAttributeKey(attributes, AI_PROMPT_MESSAGES_ATTRIBUTE, "gen_ai.request.messages");
  renameAttributeKey(attributes, AI_RESPONSE_TEXT_ATTRIBUTE, "gen_ai.response.text");
  renameAttributeKey(attributes, AI_RESPONSE_TOOL_CALLS_ATTRIBUTE, "gen_ai.response.tool_calls");
  renameAttributeKey(attributes, AI_RESPONSE_OBJECT_ATTRIBUTE, "gen_ai.response.object");
  renameAttributeKey(attributes, AI_PROMPT_TOOLS_ATTRIBUTE, "gen_ai.request.available_tools");
  renameAttributeKey(attributes, AI_TOOL_CALL_ARGS_ATTRIBUTE, "gen_ai.tool.input");
  renameAttributeKey(attributes, AI_TOOL_CALL_RESULT_ATTRIBUTE, "gen_ai.tool.output");
  addProviderMetadataToAttributes(attributes);
  for (const key of Object.keys(attributes)) {
    if (key.startsWith("ai.")) {
      renameAttributeKey(attributes, key, `vercel.${key}`);
    }
  }
}
function renameAttributeKey(attributes, oldKey, newKey) {
  if (attributes[oldKey] != null) {
    attributes[newKey] = attributes[oldKey];
    delete attributes[oldKey];
  }
}
function processToolCallSpan(span, attributes) {
  addOriginToSpan(span, "auto.vercelai.otel");
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.execute_tool");
  renameAttributeKey(attributes, AI_TOOL_CALL_NAME_ATTRIBUTE, "gen_ai.tool.name");
  renameAttributeKey(attributes, AI_TOOL_CALL_ID_ATTRIBUTE, "gen_ai.tool.call.id");
  const toolCallId = attributes["gen_ai.tool.call.id"];
  if (typeof toolCallId === "string") {
    toolCallSpanMap.set(toolCallId, span);
  }
  if (!attributes["gen_ai.tool.type"]) {
    span.setAttribute("gen_ai.tool.type", "function");
  }
  const toolName = attributes["gen_ai.tool.name"];
  if (toolName) {
    span.updateName(`execute_tool ${toolName}`);
  }
}
function processGenerateSpan(span, name, attributes) {
  addOriginToSpan(span, "auto.vercelai.otel");
  const nameWthoutAi = name.replace("ai.", "");
  span.setAttribute("ai.pipeline.name", nameWthoutAi);
  span.updateName(nameWthoutAi);
  const functionId = attributes[AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE];
  if (functionId && typeof functionId === "string" && name.split(".").length - 1 === 1) {
    span.updateName(`${nameWthoutAi} ${functionId}`);
    span.setAttribute("gen_ai.function_id", functionId);
  }
  if (attributes[AI_PROMPT_ATTRIBUTE]) {
    span.setAttribute("gen_ai.prompt", attributes[AI_PROMPT_ATTRIBUTE]);
  }
  if (attributes[AI_MODEL_ID_ATTRIBUTE] && !attributes[GEN_AI_RESPONSE_MODEL_ATTRIBUTE2]) {
    span.setAttribute(GEN_AI_RESPONSE_MODEL_ATTRIBUTE2, attributes[AI_MODEL_ID_ATTRIBUTE]);
  }
  span.setAttribute("ai.streaming", name.includes("stream"));
  if (name === "ai.generateText") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.invoke_agent");
    return;
  }
  if (name === "ai.generateText.doGenerate") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.generate_text");
    span.updateName(`generate_text ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);
    return;
  }
  if (name === "ai.streamText") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.invoke_agent");
    return;
  }
  if (name === "ai.streamText.doStream") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.stream_text");
    span.updateName(`stream_text ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);
    return;
  }
  if (name === "ai.generateObject") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.invoke_agent");
    return;
  }
  if (name === "ai.generateObject.doGenerate") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.generate_object");
    span.updateName(`generate_object ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);
    return;
  }
  if (name === "ai.streamObject") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.invoke_agent");
    return;
  }
  if (name === "ai.streamObject.doStream") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.stream_object");
    span.updateName(`stream_object ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);
    return;
  }
  if (name === "ai.embed") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.invoke_agent");
    return;
  }
  if (name === "ai.embed.doEmbed") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.embed");
    span.updateName(`embed ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);
    return;
  }
  if (name === "ai.embedMany") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.invoke_agent");
    return;
  }
  if (name === "ai.embedMany.doEmbed") {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "gen_ai.embed_many");
    span.updateName(`embed_many ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);
    return;
  }
  if (name.startsWith("ai.stream")) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.run");
    return;
  }
}
function addVercelAiProcessors(client) {
  client.on("spanStart", onVercelAiSpanStart);
  client.addEventProcessor(Object.assign(vercelAiEventProcessor, { id: "VercelAiEventProcessor" }));
}
function addProviderMetadataToAttributes(attributes) {
  const providerMetadata = attributes[AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE];
  if (providerMetadata) {
    try {
      const providerMetadataObject = JSON.parse(providerMetadata);
      if (providerMetadataObject.openai) {
        setAttributeIfDefined(attributes, "gen_ai.usage.input_tokens.cached", providerMetadataObject.openai.cachedPromptTokens);
        setAttributeIfDefined(attributes, "gen_ai.usage.output_tokens.reasoning", providerMetadataObject.openai.reasoningTokens);
        setAttributeIfDefined(attributes, "gen_ai.usage.output_tokens.prediction_accepted", providerMetadataObject.openai.acceptedPredictionTokens);
        setAttributeIfDefined(attributes, "gen_ai.usage.output_tokens.prediction_rejected", providerMetadataObject.openai.rejectedPredictionTokens);
        setAttributeIfDefined(attributes, "gen_ai.conversation.id", providerMetadataObject.openai.responseId);
      }
      if (providerMetadataObject.anthropic) {
        setAttributeIfDefined(attributes, "gen_ai.usage.input_tokens.cached", providerMetadataObject.anthropic.cacheReadInputTokens);
        setAttributeIfDefined(attributes, "gen_ai.usage.input_tokens.cache_write", providerMetadataObject.anthropic.cacheCreationInputTokens);
      }
      if (providerMetadataObject.bedrock?.usage) {
        setAttributeIfDefined(attributes, "gen_ai.usage.input_tokens.cached", providerMetadataObject.bedrock.usage.cacheReadInputTokens);
        setAttributeIfDefined(attributes, "gen_ai.usage.input_tokens.cache_write", providerMetadataObject.bedrock.usage.cacheWriteInputTokens);
      }
      if (providerMetadataObject.deepseek) {
        setAttributeIfDefined(attributes, "gen_ai.usage.input_tokens.cached", providerMetadataObject.deepseek.promptCacheHitTokens);
        setAttributeIfDefined(attributes, "gen_ai.usage.input_tokens.cache_miss", providerMetadataObject.deepseek.promptCacheMissTokens);
      }
    } catch {}
  }
}
function setAttributeIfDefined(attributes, key, value) {
  if (value != null) {
    attributes[key] = value;
  }
}
// ../../node_modules/@sentry/core/build/esm/utils/openai/constants.js
var OPENAI_INTEGRATION_NAME = "OpenAI";
var INSTRUMENTED_METHODS = ["responses.create", "chat.completions.create"];
var RESPONSES_TOOL_CALL_EVENT_TYPES = [
  "response.output_item.added",
  "response.function_call_arguments.delta",
  "response.function_call_arguments.done",
  "response.output_item.done"
];
var RESPONSE_EVENT_TYPES = [
  "response.created",
  "response.in_progress",
  "response.failed",
  "response.completed",
  "response.incomplete",
  "response.queued",
  "response.output_text.delta",
  ...RESPONSES_TOOL_CALL_EVENT_TYPES
];

// ../../node_modules/@sentry/core/build/esm/utils/openai/utils.js
function getOperationName(methodPath) {
  if (methodPath.includes("chat.completions")) {
    return OPENAI_OPERATIONS.CHAT;
  }
  if (methodPath.includes("responses")) {
    return OPENAI_OPERATIONS.RESPONSES;
  }
  return methodPath.split(".").pop() || "unknown";
}
function getSpanOperation(methodPath) {
  return `gen_ai.${getOperationName(methodPath)}`;
}
function shouldInstrument(methodPath) {
  return INSTRUMENTED_METHODS.includes(methodPath);
}
function buildMethodPath(currentPath, prop) {
  return currentPath ? `${currentPath}.${prop}` : prop;
}
function isChatCompletionResponse(response) {
  return response !== null && typeof response === "object" && "object" in response && response.object === "chat.completion";
}
function isResponsesApiResponse(response) {
  return response !== null && typeof response === "object" && "object" in response && response.object === "response";
}
function isResponsesApiStreamEvent(event) {
  return event !== null && typeof event === "object" && "type" in event && typeof event.type === "string" && event.type.startsWith("response.");
}
function isChatCompletionChunk(event) {
  return event !== null && typeof event === "object" && "object" in event && event.object === "chat.completion.chunk";
}
function setTokenUsageAttributes(span, promptTokens, completionTokens, totalTokens) {
  if (promptTokens !== undefined) {
    span.setAttributes({
      [OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE]: promptTokens,
      [GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]: promptTokens
    });
  }
  if (completionTokens !== undefined) {
    span.setAttributes({
      [OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE]: completionTokens,
      [GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE]: completionTokens
    });
  }
  if (totalTokens !== undefined) {
    span.setAttributes({
      [GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE]: totalTokens
    });
  }
}
function setCommonResponseAttributes(span, id, model, timestamp) {
  span.setAttributes({
    [OPENAI_RESPONSE_ID_ATTRIBUTE]: id,
    [GEN_AI_RESPONSE_ID_ATTRIBUTE]: id
  });
  span.setAttributes({
    [OPENAI_RESPONSE_MODEL_ATTRIBUTE]: model,
    [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: model
  });
  span.setAttributes({
    [OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(timestamp * 1000).toISOString()
  });
}

// ../../node_modules/@sentry/core/build/esm/utils/openai/streaming.js
function processChatCompletionToolCalls(toolCalls, state) {
  for (const toolCall of toolCalls) {
    const index = toolCall.index;
    if (index === undefined || !toolCall.function)
      continue;
    if (!(index in state.chatCompletionToolCalls)) {
      state.chatCompletionToolCalls[index] = {
        ...toolCall,
        function: {
          name: toolCall.function.name,
          arguments: toolCall.function.arguments || ""
        }
      };
    } else {
      const existingToolCall = state.chatCompletionToolCalls[index];
      if (toolCall.function.arguments && existingToolCall?.function) {
        existingToolCall.function.arguments += toolCall.function.arguments;
      }
    }
  }
}
function processChatCompletionChunk(chunk, state, recordOutputs) {
  state.responseId = chunk.id ?? state.responseId;
  state.responseModel = chunk.model ?? state.responseModel;
  state.responseTimestamp = chunk.created ?? state.responseTimestamp;
  if (chunk.usage) {
    state.promptTokens = chunk.usage.prompt_tokens;
    state.completionTokens = chunk.usage.completion_tokens;
    state.totalTokens = chunk.usage.total_tokens;
  }
  for (const choice of chunk.choices ?? []) {
    if (recordOutputs) {
      if (choice.delta?.content) {
        state.responseTexts.push(choice.delta.content);
      }
      if (choice.delta?.tool_calls) {
        processChatCompletionToolCalls(choice.delta.tool_calls, state);
      }
    }
    if (choice.finish_reason) {
      state.finishReasons.push(choice.finish_reason);
    }
  }
}
function processResponsesApiEvent(streamEvent, state, recordOutputs, span) {
  if (!(streamEvent && typeof streamEvent === "object")) {
    state.eventTypes.push("unknown:non-object");
    return;
  }
  if (streamEvent instanceof Error) {
    span.setStatus({ code: SPAN_STATUS_ERROR, message: "internal_error" });
    captureException(streamEvent, {
      mechanism: {
        handled: false,
        type: "auto.ai.openai.stream-response"
      }
    });
    return;
  }
  if (!("type" in streamEvent))
    return;
  const event = streamEvent;
  if (!RESPONSE_EVENT_TYPES.includes(event.type)) {
    state.eventTypes.push(event.type);
    return;
  }
  if (recordOutputs) {
    if (event.type === "response.output_item.done" && "item" in event) {
      state.responsesApiToolCalls.push(event.item);
    }
    if (event.type === "response.output_text.delta" && "delta" in event && event.delta) {
      state.responseTexts.push(event.delta);
      return;
    }
  }
  if ("response" in event) {
    const { response } = event;
    state.responseId = response.id ?? state.responseId;
    state.responseModel = response.model ?? state.responseModel;
    state.responseTimestamp = response.created_at ?? state.responseTimestamp;
    if (response.usage) {
      state.promptTokens = response.usage.input_tokens;
      state.completionTokens = response.usage.output_tokens;
      state.totalTokens = response.usage.total_tokens;
    }
    if (response.status) {
      state.finishReasons.push(response.status);
    }
    if (recordOutputs && response.output_text) {
      state.responseTexts.push(response.output_text);
    }
  }
}
async function* instrumentStream(stream, span, recordOutputs) {
  const state = {
    eventTypes: [],
    responseTexts: [],
    finishReasons: [],
    responseId: "",
    responseModel: "",
    responseTimestamp: 0,
    promptTokens: undefined,
    completionTokens: undefined,
    totalTokens: undefined,
    chatCompletionToolCalls: {},
    responsesApiToolCalls: []
  };
  try {
    for await (const event of stream) {
      if (isChatCompletionChunk(event)) {
        processChatCompletionChunk(event, state, recordOutputs);
      } else if (isResponsesApiStreamEvent(event)) {
        processResponsesApiEvent(event, state, recordOutputs, span);
      }
      yield event;
    }
  } finally {
    setCommonResponseAttributes(span, state.responseId, state.responseModel, state.responseTimestamp);
    setTokenUsageAttributes(span, state.promptTokens, state.completionTokens, state.totalTokens);
    span.setAttributes({
      [GEN_AI_RESPONSE_STREAMING_ATTRIBUTE]: true
    });
    if (state.finishReasons.length) {
      span.setAttributes({
        [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(state.finishReasons)
      });
    }
    if (recordOutputs && state.responseTexts.length) {
      span.setAttributes({
        [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: state.responseTexts.join("")
      });
    }
    const chatCompletionToolCallsArray = Object.values(state.chatCompletionToolCalls);
    const allToolCalls = [...chatCompletionToolCallsArray, ...state.responsesApiToolCalls];
    if (allToolCalls.length > 0) {
      span.setAttributes({
        [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(allToolCalls)
      });
    }
    span.end();
  }
}

// ../../node_modules/@sentry/core/build/esm/utils/openai/index.js
function extractRequestAttributes(args, methodPath) {
  const attributes = {
    [GEN_AI_SYSTEM_ATTRIBUTE]: "openai",
    [GEN_AI_OPERATION_NAME_ATTRIBUTE]: getOperationName(methodPath),
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.ai.openai"
  };
  if (args.length > 0 && typeof args[0] === "object" && args[0] !== null) {
    const params = args[0];
    const tools = Array.isArray(params.tools) ? params.tools : [];
    const hasWebSearchOptions = params.web_search_options && typeof params.web_search_options === "object";
    const webSearchOptions = hasWebSearchOptions ? [{ type: "web_search_options", ...params.web_search_options }] : [];
    const availableTools = [...tools, ...webSearchOptions];
    if (availableTools.length > 0) {
      attributes[GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE] = JSON.stringify(availableTools);
    }
  }
  if (args.length > 0 && typeof args[0] === "object" && args[0] !== null) {
    const params = args[0];
    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = params.model ?? "unknown";
    if ("temperature" in params)
      attributes[GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE] = params.temperature;
    if ("top_p" in params)
      attributes[GEN_AI_REQUEST_TOP_P_ATTRIBUTE] = params.top_p;
    if ("frequency_penalty" in params)
      attributes[GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE] = params.frequency_penalty;
    if ("presence_penalty" in params)
      attributes[GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE] = params.presence_penalty;
    if ("stream" in params)
      attributes[GEN_AI_REQUEST_STREAM_ATTRIBUTE] = params.stream;
  } else {
    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = "unknown";
  }
  return attributes;
}
function addChatCompletionAttributes(span, response, recordOutputs) {
  setCommonResponseAttributes(span, response.id, response.model, response.created);
  if (response.usage) {
    setTokenUsageAttributes(span, response.usage.prompt_tokens, response.usage.completion_tokens, response.usage.total_tokens);
  }
  if (Array.isArray(response.choices)) {
    const finishReasons = response.choices.map((choice) => choice.finish_reason).filter((reason) => reason !== null);
    if (finishReasons.length > 0) {
      span.setAttributes({
        [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(finishReasons)
      });
    }
    if (recordOutputs) {
      const toolCalls = response.choices.map((choice) => choice.message?.tool_calls).filter((calls) => Array.isArray(calls) && calls.length > 0).flat();
      if (toolCalls.length > 0) {
        span.setAttributes({
          [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(toolCalls)
        });
      }
    }
  }
}
function addResponsesApiAttributes(span, response, recordOutputs) {
  setCommonResponseAttributes(span, response.id, response.model, response.created_at);
  if (response.status) {
    span.setAttributes({
      [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify([response.status])
    });
  }
  if (response.usage) {
    setTokenUsageAttributes(span, response.usage.input_tokens, response.usage.output_tokens, response.usage.total_tokens);
  }
  if (recordOutputs) {
    const responseWithOutput = response;
    if (Array.isArray(responseWithOutput.output) && responseWithOutput.output.length > 0) {
      const functionCalls = responseWithOutput.output.filter((item) => typeof item === "object" && item !== null && item.type === "function_call");
      if (functionCalls.length > 0) {
        span.setAttributes({
          [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(functionCalls)
        });
      }
    }
  }
}
function addResponseAttributes(span, result, recordOutputs) {
  if (!result || typeof result !== "object")
    return;
  const response = result;
  if (isChatCompletionResponse(response)) {
    addChatCompletionAttributes(span, response, recordOutputs);
    if (recordOutputs && response.choices?.length) {
      const responseTexts = response.choices.map((choice) => choice.message?.content || "");
      span.setAttributes({ [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: JSON.stringify(responseTexts) });
    }
  } else if (isResponsesApiResponse(response)) {
    addResponsesApiAttributes(span, response, recordOutputs);
    if (recordOutputs && response.output_text) {
      span.setAttributes({ [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: response.output_text });
    }
  }
}
function addRequestAttributes(span, params) {
  if ("messages" in params) {
    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(params.messages) });
  }
  if ("input" in params) {
    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(params.input) });
  }
}
function getOptionsFromIntegration() {
  const scope = getCurrentScope();
  const client = scope.getClient();
  const integration = client?.getIntegrationByName(OPENAI_INTEGRATION_NAME);
  const shouldRecordInputsAndOutputs = integration ? Boolean(client?.getOptions().sendDefaultPii) : false;
  return {
    recordInputs: integration?.options?.recordInputs ?? shouldRecordInputsAndOutputs,
    recordOutputs: integration?.options?.recordOutputs ?? shouldRecordInputsAndOutputs
  };
}
function instrumentMethod(originalMethod, methodPath, context, options) {
  return async function instrumentedMethod(...args) {
    const finalOptions = options || getOptionsFromIntegration();
    const requestAttributes = extractRequestAttributes(args, methodPath);
    const model = requestAttributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] || "unknown";
    const operationName = getOperationName(methodPath);
    const params = args[0];
    const isStreamRequested = params && typeof params === "object" && params.stream === true;
    if (isStreamRequested) {
      return startSpanManual({
        name: `${operationName} ${model} stream-response`,
        op: getSpanOperation(methodPath),
        attributes: requestAttributes
      }, async (span) => {
        try {
          if (finalOptions.recordInputs && args[0] && typeof args[0] === "object") {
            addRequestAttributes(span, args[0]);
          }
          const result = await originalMethod.apply(context, args);
          return instrumentStream(result, span, finalOptions.recordOutputs ?? false);
        } catch (error2) {
          span.setStatus({ code: SPAN_STATUS_ERROR, message: "internal_error" });
          captureException(error2, {
            mechanism: {
              handled: false,
              type: "auto.ai.openai.stream",
              data: {
                function: methodPath
              }
            }
          });
          span.end();
          throw error2;
        }
      });
    } else {
      return startSpan({
        name: `${operationName} ${model}`,
        op: getSpanOperation(methodPath),
        attributes: requestAttributes
      }, async (span) => {
        try {
          if (finalOptions.recordInputs && args[0] && typeof args[0] === "object") {
            addRequestAttributes(span, args[0]);
          }
          const result = await originalMethod.apply(context, args);
          addResponseAttributes(span, result, finalOptions.recordOutputs);
          return result;
        } catch (error2) {
          captureException(error2, {
            mechanism: {
              handled: false,
              type: "auto.ai.openai",
              data: {
                function: methodPath
              }
            }
          });
          throw error2;
        }
      });
    }
  };
}
function createDeepProxy(target, currentPath = "", options) {
  return new Proxy(target, {
    get(obj, prop) {
      const value = obj[prop];
      const methodPath = buildMethodPath(currentPath, String(prop));
      if (typeof value === "function" && shouldInstrument(methodPath)) {
        return instrumentMethod(value, methodPath, obj, options);
      }
      if (typeof value === "function") {
        return value.bind(obj);
      }
      if (value && typeof value === "object") {
        return createDeepProxy(value, methodPath, options);
      }
      return value;
    }
  });
}
function instrumentOpenAiClient(client, options) {
  return createDeepProxy(client, "", options);
}
// ../../node_modules/@sentry/core/build/esm/utils/ai/utils.js
function getFinalOperationName(methodPath) {
  if (methodPath.includes("messages")) {
    return "messages";
  }
  if (methodPath.includes("completions")) {
    return "completions";
  }
  if (methodPath.includes("models")) {
    return "models";
  }
  return methodPath.split(".").pop() || "unknown";
}
function getSpanOperation2(methodPath) {
  return `gen_ai.${getFinalOperationName(methodPath)}`;
}
function buildMethodPath2(currentPath, prop) {
  return currentPath ? `${currentPath}.${prop}` : prop;
}
function setTokenUsageAttributes2(span, promptTokens, completionTokens, cachedInputTokens, cachedOutputTokens) {
  if (promptTokens !== undefined) {
    span.setAttributes({
      [GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]: promptTokens
    });
  }
  if (completionTokens !== undefined) {
    span.setAttributes({
      [GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE]: completionTokens
    });
  }
  if (promptTokens !== undefined || completionTokens !== undefined || cachedInputTokens !== undefined || cachedOutputTokens !== undefined) {
    const totalTokens = (promptTokens ?? 0) + (completionTokens ?? 0) + (cachedInputTokens ?? 0) + (cachedOutputTokens ?? 0);
    span.setAttributes({
      [GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE]: totalTokens
    });
  }
}

// ../../node_modules/@sentry/core/build/esm/utils/anthropic-ai/constants.js
var ANTHROPIC_AI_INTEGRATION_NAME = "Anthropic_AI";
var ANTHROPIC_AI_INSTRUMENTED_METHODS = [
  "messages.create",
  "messages.stream",
  "messages.countTokens",
  "models.get",
  "completions.create",
  "models.retrieve",
  "beta.messages.create"
];

// ../../node_modules/@sentry/core/build/esm/utils/anthropic-ai/streaming.js
function isErrorEvent3(event, span) {
  if ("type" in event && typeof event.type === "string") {
    if (event.type === "error") {
      span.setStatus({ code: SPAN_STATUS_ERROR, message: event.error?.type ?? "unknown_error" });
      captureException(event.error, {
        mechanism: {
          handled: false,
          type: "auto.ai.anthropic.anthropic_error"
        }
      });
      return true;
    }
  }
  return false;
}
function handleMessageMetadata(event, state) {
  if (event.type === "message_delta" && event.usage) {
    if ("output_tokens" in event.usage && typeof event.usage.output_tokens === "number") {
      state.completionTokens = event.usage.output_tokens;
    }
  }
  if (event.message) {
    const message = event.message;
    if (message.id)
      state.responseId = message.id;
    if (message.model)
      state.responseModel = message.model;
    if (message.stop_reason)
      state.finishReasons.push(message.stop_reason);
    if (message.usage) {
      if (typeof message.usage.input_tokens === "number")
        state.promptTokens = message.usage.input_tokens;
      if (typeof message.usage.cache_creation_input_tokens === "number")
        state.cacheCreationInputTokens = message.usage.cache_creation_input_tokens;
      if (typeof message.usage.cache_read_input_tokens === "number")
        state.cacheReadInputTokens = message.usage.cache_read_input_tokens;
    }
  }
}
function handleContentBlockStart(event, state) {
  if (event.type !== "content_block_start" || typeof event.index !== "number" || !event.content_block)
    return;
  if (event.content_block.type === "tool_use" || event.content_block.type === "server_tool_use") {
    state.activeToolBlocks[event.index] = {
      id: event.content_block.id,
      name: event.content_block.name,
      inputJsonParts: []
    };
  }
}
function handleContentBlockDelta(event, state, recordOutputs) {
  if (event.type !== "content_block_delta" || !event.delta)
    return;
  if (typeof event.index === "number" && "partial_json" in event.delta && typeof event.delta.partial_json === "string") {
    const active = state.activeToolBlocks[event.index];
    if (active) {
      active.inputJsonParts.push(event.delta.partial_json);
    }
  }
  if (recordOutputs && typeof event.delta.text === "string") {
    state.responseTexts.push(event.delta.text);
  }
}
function handleContentBlockStop(event, state) {
  if (event.type !== "content_block_stop" || typeof event.index !== "number")
    return;
  const active = state.activeToolBlocks[event.index];
  if (!active)
    return;
  const raw = active.inputJsonParts.join("");
  let parsedInput;
  try {
    parsedInput = raw ? JSON.parse(raw) : {};
  } catch {
    parsedInput = { __unparsed: raw };
  }
  state.toolCalls.push({
    type: "tool_use",
    id: active.id,
    name: active.name,
    input: parsedInput
  });
  delete state.activeToolBlocks[event.index];
}
function processEvent(event, state, recordOutputs, span) {
  if (!(event && typeof event === "object")) {
    return;
  }
  const isError2 = isErrorEvent3(event, span);
  if (isError2)
    return;
  handleMessageMetadata(event, state);
  handleContentBlockStart(event, state);
  handleContentBlockDelta(event, state, recordOutputs);
  handleContentBlockStop(event, state);
}
async function* instrumentStream2(stream, span, recordOutputs) {
  const state = {
    responseTexts: [],
    finishReasons: [],
    responseId: "",
    responseModel: "",
    promptTokens: undefined,
    completionTokens: undefined,
    cacheCreationInputTokens: undefined,
    cacheReadInputTokens: undefined,
    toolCalls: [],
    activeToolBlocks: {}
  };
  try {
    for await (const event of stream) {
      processEvent(event, state, recordOutputs, span);
      yield event;
    }
  } finally {
    if (state.responseId) {
      span.setAttributes({
        [GEN_AI_RESPONSE_ID_ATTRIBUTE]: state.responseId
      });
    }
    if (state.responseModel) {
      span.setAttributes({
        [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: state.responseModel
      });
    }
    setTokenUsageAttributes2(span, state.promptTokens, state.completionTokens, state.cacheCreationInputTokens, state.cacheReadInputTokens);
    span.setAttributes({
      [GEN_AI_RESPONSE_STREAMING_ATTRIBUTE]: true
    });
    if (state.finishReasons.length > 0) {
      span.setAttributes({
        [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(state.finishReasons)
      });
    }
    if (recordOutputs && state.responseTexts.length > 0) {
      span.setAttributes({
        [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: state.responseTexts.join("")
      });
    }
    if (recordOutputs && state.toolCalls.length > 0) {
      span.setAttributes({
        [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(state.toolCalls)
      });
    }
    span.end();
  }
}

// ../../node_modules/@sentry/core/build/esm/utils/anthropic-ai/utils.js
function shouldInstrument2(methodPath) {
  return ANTHROPIC_AI_INSTRUMENTED_METHODS.includes(methodPath);
}

// ../../node_modules/@sentry/core/build/esm/utils/anthropic-ai/index.js
function extractRequestAttributes2(args, methodPath) {
  const attributes = {
    [GEN_AI_SYSTEM_ATTRIBUTE]: "anthropic",
    [GEN_AI_OPERATION_NAME_ATTRIBUTE]: getFinalOperationName(methodPath),
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.ai.anthropic"
  };
  if (args.length > 0 && typeof args[0] === "object" && args[0] !== null) {
    const params = args[0];
    if (params.tools && Array.isArray(params.tools)) {
      attributes[GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE] = JSON.stringify(params.tools);
    }
    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = params.model ?? "unknown";
    if ("temperature" in params)
      attributes[GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE] = params.temperature;
    if ("top_p" in params)
      attributes[GEN_AI_REQUEST_TOP_P_ATTRIBUTE] = params.top_p;
    if ("stream" in params)
      attributes[GEN_AI_REQUEST_STREAM_ATTRIBUTE] = params.stream;
    if ("top_k" in params)
      attributes[GEN_AI_REQUEST_TOP_K_ATTRIBUTE] = params.top_k;
    if ("frequency_penalty" in params)
      attributes[GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE] = params.frequency_penalty;
    if ("max_tokens" in params)
      attributes[GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE] = params.max_tokens;
  } else {
    if (methodPath === "models.retrieve" || methodPath === "models.get") {
      attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = args[0];
    } else {
      attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = "unknown";
    }
  }
  return attributes;
}
function addPrivateRequestAttributes(span, params) {
  if ("messages" in params) {
    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(params.messages) });
  }
  if ("input" in params) {
    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(params.input) });
  }
  if ("prompt" in params) {
    span.setAttributes({ [GEN_AI_PROMPT_ATTRIBUTE]: JSON.stringify(params.prompt) });
  }
}
function handleResponseError(span, response) {
  if (response.error) {
    span.setStatus({ code: SPAN_STATUS_ERROR, message: response.error.type || "unknown_error" });
    captureException(response.error, {
      mechanism: {
        handled: false,
        type: "auto.ai.anthropic.anthropic_error"
      }
    });
  }
}
function addContentAttributes(span, response) {
  if ("content" in response) {
    if (Array.isArray(response.content)) {
      span.setAttributes({
        [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: response.content.map((item) => item.text).filter((text) => !!text).join("")
      });
      const toolCalls = [];
      for (const item of response.content) {
        if (item.type === "tool_use" || item.type === "server_tool_use") {
          toolCalls.push(item);
        }
      }
      if (toolCalls.length > 0) {
        span.setAttributes({ [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(toolCalls) });
      }
    }
  }
  if ("completion" in response) {
    span.setAttributes({ [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: response.completion });
  }
  if ("input_tokens" in response) {
    span.setAttributes({ [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: JSON.stringify(response.input_tokens) });
  }
}
function addMetadataAttributes(span, response) {
  if ("id" in response && "model" in response) {
    span.setAttributes({
      [GEN_AI_RESPONSE_ID_ATTRIBUTE]: response.id,
      [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: response.model
    });
    if ("created" in response && typeof response.created === "number") {
      span.setAttributes({
        [ANTHROPIC_AI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(response.created * 1000).toISOString()
      });
    }
    if ("created_at" in response && typeof response.created_at === "number") {
      span.setAttributes({
        [ANTHROPIC_AI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(response.created_at * 1000).toISOString()
      });
    }
    if ("usage" in response && response.usage) {
      setTokenUsageAttributes2(span, response.usage.input_tokens, response.usage.output_tokens, response.usage.cache_creation_input_tokens, response.usage.cache_read_input_tokens);
    }
  }
}
function addResponseAttributes2(span, response, recordOutputs) {
  if (!response || typeof response !== "object")
    return;
  if ("type" in response && response.type === "error") {
    handleResponseError(span, response);
    return;
  }
  if (recordOutputs) {
    addContentAttributes(span, response);
  }
  addMetadataAttributes(span, response);
}
function getRecordingOptionsFromIntegration() {
  const scope = getCurrentScope();
  const client = scope.getClient();
  const integration = client?.getIntegrationByName(ANTHROPIC_AI_INTEGRATION_NAME);
  const shouldRecordInputsAndOutputs = integration ? Boolean(client?.getOptions().sendDefaultPii) : false;
  return {
    recordInputs: integration?.options?.recordInputs ?? shouldRecordInputsAndOutputs,
    recordOutputs: integration?.options?.recordOutputs ?? shouldRecordInputsAndOutputs
  };
}
function instrumentMethod2(originalMethod, methodPath, context, options) {
  return async function instrumentedMethod(...args) {
    const finalOptions = options || getRecordingOptionsFromIntegration();
    const requestAttributes = extractRequestAttributes2(args, methodPath);
    const model = requestAttributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] ?? "unknown";
    const operationName = getFinalOperationName(methodPath);
    const params = typeof args[0] === "object" ? args[0] : undefined;
    const isStreamRequested = Boolean(params?.stream);
    const isStreamingMethod = methodPath === "messages.stream";
    if (isStreamRequested || isStreamingMethod) {
      return startSpanManual({
        name: `${operationName} ${model} stream-response`,
        op: getSpanOperation2(methodPath),
        attributes: requestAttributes
      }, async (span) => {
        try {
          if (finalOptions.recordInputs && params) {
            addPrivateRequestAttributes(span, params);
          }
          const result = await originalMethod.apply(context, args);
          return instrumentStream2(result, span, finalOptions.recordOutputs ?? false);
        } catch (error2) {
          span.setStatus({ code: SPAN_STATUS_ERROR, message: "internal_error" });
          captureException(error2, {
            mechanism: {
              handled: false,
              type: "auto.ai.anthropic",
              data: {
                function: methodPath
              }
            }
          });
          span.end();
          throw error2;
        }
      });
    }
    return startSpan({
      name: `${operationName} ${model}`,
      op: getSpanOperation2(methodPath),
      attributes: requestAttributes
    }, async (span) => {
      try {
        if (finalOptions.recordInputs && args[0] && typeof args[0] === "object") {
          addPrivateRequestAttributes(span, args[0]);
        }
        const result = await originalMethod.apply(context, args);
        addResponseAttributes2(span, result, finalOptions.recordOutputs);
        return result;
      } catch (error2) {
        captureException(error2, {
          mechanism: {
            handled: false,
            type: "auto.ai.anthropic",
            data: {
              function: methodPath
            }
          }
        });
        throw error2;
      }
    });
  };
}
function createDeepProxy2(target, currentPath = "", options) {
  return new Proxy(target, {
    get(obj, prop) {
      const value = obj[prop];
      const methodPath = buildMethodPath2(currentPath, String(prop));
      if (typeof value === "function" && shouldInstrument2(methodPath)) {
        return instrumentMethod2(value, methodPath, obj, options);
      }
      if (typeof value === "function") {
        return value.bind(obj);
      }
      if (value && typeof value === "object") {
        return createDeepProxy2(value, methodPath, options);
      }
      return value;
    }
  });
}
function instrumentAnthropicAiClient(client, options) {
  return createDeepProxy2(client, "", options);
}
// ../../node_modules/@sentry/core/build/esm/utils/breadcrumb-log-level.js
function getBreadcrumbLogLevelFromHttpStatusCode(statusCode) {
  if (statusCode === undefined) {
    return;
  } else if (statusCode >= 400 && statusCode < 500) {
    return "warning";
  } else if (statusCode >= 500) {
    return "error";
  } else {
    return;
  }
}
// ../../node_modules/@sentry/core/build/esm/utils/node-stack-trace.js
function filenameIsInApp(filename, isNative = false) {
  const isInternal = isNative || filename && !filename.startsWith("/") && !filename.match(/^[A-Z]:/) && !filename.startsWith(".") && !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//);
  return !isInternal && filename !== undefined && !filename.includes("node_modules/");
}
function node(getModule) {
  const FILENAME_MATCH = /^\s*[-]{4,}$/;
  const FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
  const DATA_URI_MATCH = /at (?:async )?(.+?) \(data:(.*?),/;
  return (line) => {
    const dataUriMatch = line.match(DATA_URI_MATCH);
    if (dataUriMatch) {
      return {
        filename: `<data:${dataUriMatch[2]}>`,
        function: dataUriMatch[1]
      };
    }
    const lineMatch = line.match(FULL_MATCH);
    if (lineMatch) {
      let object;
      let method;
      let functionName;
      let typeName;
      let methodName;
      if (lineMatch[1]) {
        functionName = lineMatch[1];
        let methodStart = functionName.lastIndexOf(".");
        if (functionName[methodStart - 1] === ".") {
          methodStart--;
        }
        if (methodStart > 0) {
          object = functionName.slice(0, methodStart);
          method = functionName.slice(methodStart + 1);
          const objectEnd = object.indexOf(".Module");
          if (objectEnd > 0) {
            functionName = functionName.slice(objectEnd + 1);
            object = object.slice(0, objectEnd);
          }
        }
        typeName = undefined;
      }
      if (method) {
        typeName = object;
        methodName = method;
      }
      if (method === "<anonymous>") {
        methodName = undefined;
        functionName = undefined;
      }
      if (functionName === undefined) {
        methodName = methodName || UNKNOWN_FUNCTION;
        functionName = typeName ? `${typeName}.${methodName}` : methodName;
      }
      let filename = lineMatch[2]?.startsWith("file://") ? lineMatch[2].slice(7) : lineMatch[2];
      const isNative = lineMatch[5] === "native";
      if (filename?.match(/\/[A-Z]:/)) {
        filename = filename.slice(1);
      }
      if (!filename && lineMatch[5] && !isNative) {
        filename = lineMatch[5];
      }
      return {
        filename: filename ? decodeURI(filename) : undefined,
        module: getModule ? getModule(filename) : undefined,
        function: functionName,
        lineno: _parseIntOrUndefined(lineMatch[3]),
        colno: _parseIntOrUndefined(lineMatch[4]),
        in_app: filenameIsInApp(filename || "", isNative)
      };
    }
    if (line.match(FILENAME_MATCH)) {
      return {
        filename: line
      };
    }
    return;
  };
}
function nodeStackLineParser(getModule) {
  return [90, node(getModule)];
}
function _parseIntOrUndefined(input) {
  return parseInt(input || "", 10) || undefined;
}
// ../../node_modules/@sentry/core/build/esm/utils/lru.js
class LRUMap {
  constructor(_maxSize) {
    this._maxSize = _maxSize;
    this._cache = new Map;
  }
  get size() {
    return this._cache.size;
  }
  get(key) {
    const value = this._cache.get(key);
    if (value === undefined) {
      return;
    }
    this._cache.delete(key);
    this._cache.set(key, value);
    return value;
  }
  set(key, value) {
    if (this._cache.size >= this._maxSize) {
      this._cache.delete(this._cache.keys().next().value);
    }
    this._cache.set(key, value);
  }
  remove(key) {
    const value = this._cache.get(key);
    if (value) {
      this._cache.delete(key);
    }
    return value;
  }
  clear() {
    this._cache.clear();
  }
  keys() {
    return Array.from(this._cache.keys());
  }
  values() {
    const values = [];
    this._cache.forEach((value) => values.push(value));
    return values;
  }
}
// ../../node_modules/@sentry/node-core/build/esm/otel/instrument.js
var import_instrumentation = __toESM(require_src6(), 1);
var INSTRUMENTED = {};
function generateInstrumentOnce(name, creatorOrClass, optionsCallback) {
  if (optionsCallback) {
    return _generateInstrumentOnceWithOptions(name, creatorOrClass, optionsCallback);
  }
  return _generateInstrumentOnce(name, creatorOrClass);
}
function _generateInstrumentOnce(name, creator) {
  return Object.assign((options) => {
    const instrumented2 = INSTRUMENTED[name];
    if (instrumented2) {
      if (options) {
        instrumented2.setConfig(options);
      }
      return instrumented2;
    }
    const instrumentation = creator(options);
    INSTRUMENTED[name] = instrumentation;
    import_instrumentation.registerInstrumentations({
      instrumentations: [instrumentation]
    });
    return instrumentation;
  }, { id: name });
}
function _generateInstrumentOnceWithOptions(name, instrumentationClass, optionsCallback) {
  return Object.assign((_options) => {
    const options = optionsCallback(_options);
    const instrumented2 = INSTRUMENTED[name];
    if (instrumented2) {
      instrumented2.setConfig(options);
      return instrumented2;
    }
    const instrumentation = new instrumentationClass(options);
    INSTRUMENTED[name] = instrumentation;
    import_instrumentation.registerInstrumentations({
      instrumentations: [instrumentation]
    });
    return instrumentation;
  }, { id: name });
}
function instrumentWhenWrapped(instrumentation) {
  let isWrapped = false;
  let callbacks = [];
  if (!hasWrap(instrumentation)) {
    isWrapped = true;
  } else {
    const originalWrap = instrumentation["_wrap"];
    instrumentation["_wrap"] = (...args) => {
      isWrapped = true;
      callbacks.forEach((callback) => callback());
      callbacks = [];
      return originalWrap(...args);
    };
  }
  const registerCallback = (callback) => {
    if (isWrapped) {
      callback();
    } else {
      callbacks.push(callback);
    }
  };
  return registerCallback;
}
function hasWrap(instrumentation) {
  return typeof instrumentation["_wrap"] === "function";
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/http/SentryHttpInstrumentation.js
var import_api4 = __toESM(require_src(), 1);
var import_core40 = __toESM(require_src3(), 1);
var import_instrumentation2 = __toESM(require_src6(), 1);
import { subscribe, unsubscribe } from "node:diagnostics_channel";

// ../../node_modules/@sentry/node-core/build/esm/debug-build.js
var DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../node_modules/@sentry/node-core/build/esm/utils/getRequestUrl.js
function getRequestUrl(requestOptions) {
  const protocol = requestOptions.protocol || "";
  const hostname = requestOptions.hostname || requestOptions.host || "";
  const port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 || /^(.*):(\d+)$/.test(hostname) ? "" : `:${requestOptions.port}`;
  const path7 = requestOptions.path ? requestOptions.path : "/";
  return `${protocol}//${hostname}${port}${path7}`;
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/http/constants.js
var INSTRUMENTATION_NAME = "@sentry/instrumentation-http";
var MAX_BODY_BYTE_LENGTH = 1024 * 1024;

// ../../node_modules/@sentry/node-core/build/esm/integrations/http/incoming-requests.js
var import_api2 = __toESM(require_src(), 1);
var import_core34 = __toESM(require_src3(), 1);
var import_semantic_conventions = __toESM(require_src2(), 1);
import { errorMonitor } from "events";
var HTTP_SERVER_INSTRUMENTED_KEY = import_api2.createContextKey("sentry_http_server_instrumented");
var clientToRequestSessionAggregatesMap = new Map;
var wrappedEmitFns = new WeakSet;
function instrumentServer(server, {
  ignoreIncomingRequestBody,
  ignoreSpansForIncomingRequests,
  maxIncomingRequestBodySize = "medium",
  trackIncomingRequestsAsSessions = true,
  spans,
  ignoreStaticAssets = true,
  sessionFlushingDelayMS,
  instrumentation,
  incomingRequestSpanHook
}) {
  const originalEmit = server.emit;
  if (wrappedEmitFns.has(originalEmit)) {
    DEBUG_BUILD2 && debug.log(INSTRUMENTATION_NAME, "Incoming requests already instrumented, not instrumenting again...");
    return;
  }
  const { requestHook, responseHook, applyCustomAttributesOnSpan } = instrumentation ?? {};
  const newEmit = new Proxy(originalEmit, {
    apply(target, thisArg, args) {
      if (args[0] !== "request") {
        return target.apply(thisArg, args);
      }
      if (import_api2.context.active().getValue(HTTP_SERVER_INSTRUMENTED_KEY)) {
        return target.apply(thisArg, args);
      }
      DEBUG_BUILD2 && debug.log(INSTRUMENTATION_NAME, "Handling incoming request");
      const client = getClient();
      const isolationScope = getIsolationScope().clone();
      const request = args[1];
      const response = args[2];
      const normalizedRequest = httpRequestToRequestData(request);
      const ipAddress = request.ip || request.socket?.remoteAddress;
      const url = request.url || "/";
      if (maxIncomingRequestBodySize !== "none" && !ignoreIncomingRequestBody?.(url, request)) {
        patchRequestToCaptureBody(request, isolationScope, maxIncomingRequestBodySize);
      }
      isolationScope.setSDKProcessingMetadata({ normalizedRequest, ipAddress });
      const httpMethod = (request.method || "GET").toUpperCase();
      const httpTargetWithoutQueryFragment = stripUrlQueryAndFragment(url);
      const bestEffortTransactionName = `${httpMethod} ${httpTargetWithoutQueryFragment}`;
      isolationScope.setTransactionName(bestEffortTransactionName);
      if (trackIncomingRequestsAsSessions !== false) {
        recordRequestSession({
          requestIsolationScope: isolationScope,
          response,
          sessionFlushingDelayMS: sessionFlushingDelayMS ?? 60000
        });
      }
      return withIsolationScope2(isolationScope, () => {
        getCurrentScope().getPropagationContext().propagationSpanId = generateSpanId();
        const ctx = import_api2.propagation.extract(import_api2.context.active(), normalizedRequest.headers).setValue(HTTP_SERVER_INSTRUMENTED_KEY, true);
        return import_api2.context.with(ctx, () => {
          if (typeof __SENTRY_TRACING__ !== "undefined" && !__SENTRY_TRACING__ || !spans || !client || shouldIgnoreSpansForIncomingRequest(request, {
            ignoreStaticAssets,
            ignoreSpansForIncomingRequests
          })) {
            DEBUG_BUILD2 && debug.log(INSTRUMENTATION_NAME, "Skipping span creation for incoming request");
            return target.apply(thisArg, args);
          }
          const fullUrl = normalizedRequest.url || url;
          const urlObj = parseStringToURLObject(fullUrl);
          const headers = request.headers;
          const userAgent = headers["user-agent"];
          const ips = headers["x-forwarded-for"];
          const httpVersion = request.httpVersion;
          const host = headers.host;
          const hostname = host?.replace(/^(.*)(:[0-9]{1,5})/, "$1") || "localhost";
          const tracer = client.tracer;
          const scheme = fullUrl.startsWith("https") ? "https" : "http";
          const shouldSendDefaultPii = client?.getOptions().sendDefaultPii ?? false;
          const span = tracer.startSpan(bestEffortTransactionName, {
            kind: import_api2.SpanKind.SERVER,
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: "http.server",
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.otel.http",
              "sentry.http.prefetch": isKnownPrefetchRequest(request) || undefined,
              "http.url": fullUrl,
              "http.method": httpMethod,
              "http.target": urlObj ? `${urlObj.pathname}${urlObj.search}` : httpTargetWithoutQueryFragment,
              "http.host": host,
              "net.host.name": hostname,
              "http.client_ip": typeof ips === "string" ? ips.split(",")[0] : undefined,
              "http.user_agent": userAgent,
              "http.scheme": scheme,
              "http.flavor": httpVersion,
              "net.transport": httpVersion?.toUpperCase() === "QUIC" ? "ip_udp" : "ip_tcp",
              ...getRequestContentLengthAttribute(request),
              ...httpHeadersToSpanAttributes(normalizedRequest.headers || {}, shouldSendDefaultPii)
            }
          });
          requestHook?.(span, request);
          responseHook?.(span, response);
          applyCustomAttributesOnSpan?.(span, request, response);
          incomingRequestSpanHook?.(span, request, response);
          const rpcMetadata = {
            type: import_core34.RPCType.HTTP,
            span
          };
          import_api2.context.with(import_core34.setRPCMetadata(import_api2.trace.setSpan(import_api2.context.active(), span), rpcMetadata), () => {
            import_api2.context.bind(import_api2.context.active(), request);
            import_api2.context.bind(import_api2.context.active(), response);
            let isEnded = false;
            function endSpan(status) {
              if (isEnded) {
                return;
              }
              isEnded = true;
              const newAttributes = getIncomingRequestAttributesOnResponse(request, response);
              span.setAttributes(newAttributes);
              span.setStatus(status);
              span.end();
              const route = newAttributes["http.route"];
              if (route) {
                getIsolationScope().setTransactionName(`${request.method?.toUpperCase() || "GET"} ${route}`);
              }
            }
            response.on("close", () => {
              endSpan(getSpanStatusFromHttpCode(response.statusCode));
            });
            response.on(errorMonitor, () => {
              const httpStatus = getSpanStatusFromHttpCode(response.statusCode);
              endSpan(httpStatus.code === SPAN_STATUS_ERROR ? httpStatus : { code: SPAN_STATUS_ERROR });
            });
            return target.apply(thisArg, args);
          });
        });
      });
    }
  });
  wrappedEmitFns.add(newEmit);
  server.emit = newEmit;
}
function recordRequestSession({
  requestIsolationScope,
  response,
  sessionFlushingDelayMS
}) {
  requestIsolationScope.setSDKProcessingMetadata({
    requestSession: { status: "ok" }
  });
  response.once("close", () => {
    const client = getClient();
    const requestSession = requestIsolationScope.getScopeData().sdkProcessingMetadata.requestSession;
    if (client && requestSession) {
      DEBUG_BUILD2 && debug.log(`Recorded request session with status: ${requestSession.status}`);
      const roundedDate = new Date;
      roundedDate.setSeconds(0, 0);
      const dateBucketKey = roundedDate.toISOString();
      const existingClientAggregate = clientToRequestSessionAggregatesMap.get(client);
      const bucket = existingClientAggregate?.[dateBucketKey] || { exited: 0, crashed: 0, errored: 0 };
      bucket[{ ok: "exited", crashed: "crashed", errored: "errored" }[requestSession.status]]++;
      if (existingClientAggregate) {
        existingClientAggregate[dateBucketKey] = bucket;
      } else {
        DEBUG_BUILD2 && debug.log("Opened new request session aggregate.");
        const newClientAggregate = { [dateBucketKey]: bucket };
        clientToRequestSessionAggregatesMap.set(client, newClientAggregate);
        const flushPendingClientAggregates = () => {
          clearTimeout(timeout);
          unregisterClientFlushHook();
          clientToRequestSessionAggregatesMap.delete(client);
          const aggregatePayload = Object.entries(newClientAggregate).map(([timestamp, value]) => ({
            started: timestamp,
            exited: value.exited,
            errored: value.errored,
            crashed: value.crashed
          }));
          client.sendSession({ aggregates: aggregatePayload });
        };
        const unregisterClientFlushHook = client.on("flush", () => {
          DEBUG_BUILD2 && debug.log("Sending request session aggregate due to client flush");
          flushPendingClientAggregates();
        });
        const timeout = setTimeout(() => {
          DEBUG_BUILD2 && debug.log("Sending request session aggregate due to flushing schedule");
          flushPendingClientAggregates();
        }, sessionFlushingDelayMS).unref();
      }
    }
  });
}
function patchRequestToCaptureBody(req, isolationScope, maxIncomingRequestBodySize) {
  let bodyByteLength = 0;
  const chunks = [];
  DEBUG_BUILD2 && debug.log(INSTRUMENTATION_NAME, "Patching request.on");
  const callbackMap = new WeakMap;
  const maxBodySize = maxIncomingRequestBodySize === "small" ? 1000 : maxIncomingRequestBodySize === "medium" ? 1e4 : MAX_BODY_BYTE_LENGTH;
  try {
    req.on = new Proxy(req.on, {
      apply: (target, thisArg, args) => {
        const [event, listener, ...restArgs] = args;
        if (event === "data") {
          DEBUG_BUILD2 && debug.log(INSTRUMENTATION_NAME, `Handling request.on("data") with maximum body size of ${maxBodySize}b`);
          const callback = new Proxy(listener, {
            apply: (target2, thisArg2, args2) => {
              try {
                const chunk = args2[0];
                const bufferifiedChunk = Buffer.from(chunk);
                if (bodyByteLength < maxBodySize) {
                  chunks.push(bufferifiedChunk);
                  bodyByteLength += bufferifiedChunk.byteLength;
                } else if (DEBUG_BUILD2) {
                  debug.log(INSTRUMENTATION_NAME, `Dropping request body chunk because maximum body length of ${maxBodySize}b is exceeded.`);
                }
              } catch (err) {
                DEBUG_BUILD2 && debug.error(INSTRUMENTATION_NAME, "Encountered error while storing body chunk.");
              }
              return Reflect.apply(target2, thisArg2, args2);
            }
          });
          callbackMap.set(listener, callback);
          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);
        }
        return Reflect.apply(target, thisArg, args);
      }
    });
    req.off = new Proxy(req.off, {
      apply: (target, thisArg, args) => {
        const [, listener] = args;
        const callback = callbackMap.get(listener);
        if (callback) {
          callbackMap.delete(listener);
          const modifiedArgs = args.slice();
          modifiedArgs[1] = callback;
          return Reflect.apply(target, thisArg, modifiedArgs);
        }
        return Reflect.apply(target, thisArg, args);
      }
    });
    req.on("end", () => {
      try {
        const body = Buffer.concat(chunks).toString("utf-8");
        if (body) {
          const bodyByteLength2 = Buffer.byteLength(body, "utf-8");
          const truncatedBody = bodyByteLength2 > maxBodySize ? `${Buffer.from(body).subarray(0, maxBodySize - 3).toString("utf-8")}...` : body;
          isolationScope.setSDKProcessingMetadata({ normalizedRequest: { data: truncatedBody } });
        }
      } catch (error2) {
        if (DEBUG_BUILD2) {
          debug.error(INSTRUMENTATION_NAME, "Error building captured request body", error2);
        }
      }
    });
  } catch (error2) {
    if (DEBUG_BUILD2) {
      debug.error(INSTRUMENTATION_NAME, "Error patching request to capture body", error2);
    }
  }
}
function getRequestContentLengthAttribute(request) {
  const length = getContentLength(request.headers);
  if (length == null) {
    return {};
  }
  if (isCompressed(request.headers)) {
    return {
      ["http.request_content_length"]: length
    };
  } else {
    return {
      ["http.request_content_length_uncompressed"]: length
    };
  }
}
function getContentLength(headers) {
  const contentLengthHeader = headers["content-length"];
  if (contentLengthHeader === undefined)
    return null;
  const contentLength = parseInt(contentLengthHeader, 10);
  if (isNaN(contentLength))
    return null;
  return contentLength;
}
function isCompressed(headers) {
  const encoding = headers["content-encoding"];
  return !!encoding && encoding !== "identity";
}
function getIncomingRequestAttributesOnResponse(request, response) {
  const { socket } = request;
  const { statusCode, statusMessage } = response;
  const newAttributes = {
    [import_semantic_conventions.ATTR_HTTP_RESPONSE_STATUS_CODE]: statusCode,
    [import_semantic_conventions.SEMATTRS_HTTP_STATUS_CODE]: statusCode,
    "http.status_text": statusMessage?.toUpperCase()
  };
  const rpcMetadata = import_core34.getRPCMetadata(import_api2.context.active());
  if (socket) {
    const { localAddress, localPort, remoteAddress, remotePort } = socket;
    newAttributes[import_semantic_conventions.SEMATTRS_NET_HOST_IP] = localAddress;
    newAttributes[import_semantic_conventions.SEMATTRS_NET_HOST_PORT] = localPort;
    newAttributes[import_semantic_conventions.SEMATTRS_NET_PEER_IP] = remoteAddress;
    newAttributes["net.peer.port"] = remotePort;
  }
  newAttributes[import_semantic_conventions.SEMATTRS_HTTP_STATUS_CODE] = statusCode;
  newAttributes["http.status_text"] = (statusMessage || "").toUpperCase();
  if (rpcMetadata?.type === import_core34.RPCType.HTTP && rpcMetadata.route !== undefined) {
    const routeName = rpcMetadata.route;
    newAttributes[import_semantic_conventions.ATTR_HTTP_ROUTE] = routeName;
  }
  return newAttributes;
}
function isKnownPrefetchRequest(req) {
  return req.headers["next-router-prefetch"] === "1";
}
function isStaticAssetRequest(urlPath) {
  const path7 = stripUrlQueryAndFragment(urlPath);
  if (path7.match(/\.(ico|png|jpg|jpeg|gif|svg|css|js|woff|woff2|ttf|eot|webp|avif)$/)) {
    return true;
  }
  if (path7.match(/^\/(robots\.txt|sitemap\.xml|manifest\.json|browserconfig\.xml)$/)) {
    return true;
  }
  return false;
}
function shouldIgnoreSpansForIncomingRequest(request, {
  ignoreStaticAssets,
  ignoreSpansForIncomingRequests
}) {
  if (import_core34.isTracingSuppressed(import_api2.context.active())) {
    return true;
  }
  const urlPath = request.url;
  const method = request.method?.toUpperCase();
  if (method === "OPTIONS" || method === "HEAD" || !urlPath) {
    return true;
  }
  if (ignoreStaticAssets && method === "GET" && isStaticAssetRequest(urlPath)) {
    return true;
  }
  if (ignoreSpansForIncomingRequests?.(urlPath, request)) {
    return true;
  }
  return false;
}

// ../../node_modules/@sentry/opentelemetry/build/esm/index.js
var import_semantic_conventions2 = __toESM(require_src2(), 1);
var api = __toESM(require_src(), 1);
var import_api3 = __toESM(require_src(), 1);
var import_core37 = __toESM(require_src3(), 1);
var import_sdk_trace_base = __toESM(require_src9(), 1);
var SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = "sentry.parentIsRemote";
var SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = "sentry.graphql.operation";
function getParentSpanId(span) {
  if ("parentSpanId" in span) {
    return span.parentSpanId;
  } else if ("parentSpanContext" in span) {
    return span.parentSpanContext?.spanId;
  }
  return;
}
function spanHasAttributes(span) {
  const castSpan = span;
  return !!castSpan.attributes && typeof castSpan.attributes === "object";
}
function spanHasKind(span) {
  const castSpan = span;
  return typeof castSpan.kind === "number";
}
function spanHasStatus(span) {
  const castSpan = span;
  return !!castSpan.status;
}
function spanHasName(span) {
  const castSpan = span;
  return !!castSpan.name;
}
function getRequestSpanData(span) {
  if (!spanHasAttributes(span)) {
    return {};
  }
  const maybeUrlAttribute = span.attributes[import_semantic_conventions2.ATTR_URL_FULL] || span.attributes[import_semantic_conventions2.SEMATTRS_HTTP_URL];
  const data = {
    url: maybeUrlAttribute,
    "http.method": span.attributes[import_semantic_conventions2.ATTR_HTTP_REQUEST_METHOD] || span.attributes[import_semantic_conventions2.SEMATTRS_HTTP_METHOD]
  };
  if (!data["http.method"] && data.url) {
    data["http.method"] = "GET";
  }
  try {
    if (typeof maybeUrlAttribute === "string") {
      const url = parseUrl(maybeUrlAttribute);
      data.url = getSanitizedUrlString(url);
      if (url.search) {
        data["http.query"] = url.search;
      }
      if (url.hash) {
        data["http.fragment"] = url.hash;
      }
    }
  } catch {}
  return data;
}
function getSpanKind(span) {
  if (spanHasKind(span)) {
    return span.kind;
  }
  return import_api3.SpanKind.INTERNAL;
}
var SENTRY_TRACE_HEADER = "sentry-trace";
var SENTRY_BAGGAGE_HEADER = "baggage";
var SENTRY_TRACE_STATE_DSC = "sentry.dsc";
var SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = "sentry.sampled_not_recording";
var SENTRY_TRACE_STATE_URL = "sentry.url";
var SENTRY_TRACE_STATE_SAMPLE_RAND = "sentry.sample_rand";
var SENTRY_TRACE_STATE_SAMPLE_RATE = "sentry.sample_rate";
var SENTRY_SCOPES_CONTEXT_KEY = import_api3.createContextKey("sentry_scopes");
var SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = import_api3.createContextKey("sentry_fork_isolation_scope");
var SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = import_api3.createContextKey("sentry_fork_set_scope");
var SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = import_api3.createContextKey("sentry_fork_set_isolation_scope");
var SCOPE_CONTEXT_FIELD = "_scopeContext";
function getScopesFromContext(context4) {
  return context4.getValue(SENTRY_SCOPES_CONTEXT_KEY);
}
function setScopesOnContext(context4, scopes) {
  return context4.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);
}
function setContextOnScope(scope, context4) {
  addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context4);
}
function getContextFromScope(scope) {
  return scope[SCOPE_CONTEXT_FIELD];
}
function getSamplingDecision(spanContext) {
  const { traceFlags, traceState } = spanContext;
  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === "1" : false;
  if (traceFlags === import_api3.TraceFlags.SAMPLED) {
    return true;
  }
  if (sampledNotRecording) {
    return false;
  }
  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;
  const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : undefined;
  if (dsc?.sampled === "true") {
    return true;
  }
  if (dsc?.sampled === "false") {
    return false;
  }
  return;
}
function inferSpanData(spanName, attributes, kind) {
  const httpMethod = attributes[import_semantic_conventions2.ATTR_HTTP_REQUEST_METHOD] || attributes[import_semantic_conventions2.SEMATTRS_HTTP_METHOD];
  if (httpMethod) {
    return descriptionForHttpMethod({ attributes, name: spanName, kind }, httpMethod);
  }
  const dbSystem = attributes[import_semantic_conventions2.SEMATTRS_DB_SYSTEM];
  const opIsCache = typeof attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] === "string" && attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith("cache.");
  if (dbSystem && !opIsCache) {
    return descriptionForDbSystem({ attributes, name: spanName });
  }
  const customSourceOrRoute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === "custom" ? "custom" : "route";
  const rpcService = attributes[import_semantic_conventions2.SEMATTRS_RPC_SERVICE];
  if (rpcService) {
    return {
      ...getUserUpdatedNameAndSource(spanName, attributes, "route"),
      op: "rpc"
    };
  }
  const messagingSystem = attributes[import_semantic_conventions2.SEMATTRS_MESSAGING_SYSTEM];
  if (messagingSystem) {
    return {
      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),
      op: "message"
    };
  }
  const faasTrigger = attributes[import_semantic_conventions2.SEMATTRS_FAAS_TRIGGER];
  if (faasTrigger) {
    return {
      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),
      op: faasTrigger.toString()
    };
  }
  return { op: undefined, description: spanName, source: "custom" };
}
function parseSpanDescription(span) {
  const attributes = spanHasAttributes(span) ? span.attributes : {};
  const name = spanHasName(span) ? span.name : "<unknown>";
  const kind = getSpanKind(span);
  return inferSpanData(name, attributes, kind);
}
function descriptionForDbSystem({ attributes, name }) {
  const userDefinedName = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
  if (typeof userDefinedName === "string") {
    return {
      op: "db",
      description: userDefinedName,
      source: attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] || "custom"
    };
  }
  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === "custom") {
    return { op: "db", description: name, source: "custom" };
  }
  const statement = attributes[import_semantic_conventions2.SEMATTRS_DB_STATEMENT];
  const description = statement ? statement.toString() : name;
  return { op: "db", description, source: "task" };
}
function descriptionForHttpMethod({ name, kind, attributes }, httpMethod) {
  const opParts = ["http"];
  switch (kind) {
    case import_api3.SpanKind.CLIENT:
      opParts.push("client");
      break;
    case import_api3.SpanKind.SERVER:
      opParts.push("server");
      break;
  }
  if (attributes["sentry.http.prefetch"]) {
    opParts.push("prefetch");
  }
  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);
  if (!urlPath) {
    return { ...getUserUpdatedNameAndSource(name, attributes), op: opParts.join(".") };
  }
  const graphqlOperationsAttribute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION];
  const baseDescription = `${httpMethod} ${urlPath}`;
  const inferredDescription = graphqlOperationsAttribute ? `${baseDescription} (${getGraphqlOperationNamesFromAttribute(graphqlOperationsAttribute)})` : baseDescription;
  const inferredSource = hasRoute || urlPath === "/" ? "route" : "url";
  const data = {};
  if (url) {
    data.url = url;
  }
  if (query) {
    data["http.query"] = query;
  }
  if (fragment) {
    data["http.fragment"] = fragment;
  }
  const isClientOrServerKind = kind === import_api3.SpanKind.CLIENT || kind === import_api3.SpanKind.SERVER;
  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || "manual";
  const isManualSpan = !`${origin}`.startsWith("auto");
  const alreadyHasCustomSource = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === "custom";
  const customSpanName = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
  const useInferredDescription = !alreadyHasCustomSource && customSpanName == null && (isClientOrServerKind || !isManualSpan);
  const { description, source } = useInferredDescription ? { description: inferredDescription, source: inferredSource } : getUserUpdatedNameAndSource(name, attributes);
  return {
    op: opParts.join("."),
    description,
    source,
    data
  };
}
function getGraphqlOperationNamesFromAttribute(attr) {
  if (Array.isArray(attr)) {
    const sorted = attr.slice().sort();
    if (sorted.length <= 5) {
      return sorted.join(", ");
    } else {
      return `${sorted.slice(0, 5).join(", ")}, +${sorted.length - 5}`;
    }
  }
  return `${attr}`;
}
function getSanitizedUrl(attributes, kind) {
  const httpTarget = attributes[import_semantic_conventions2.SEMATTRS_HTTP_TARGET];
  const httpUrl = attributes[import_semantic_conventions2.SEMATTRS_HTTP_URL] || attributes[import_semantic_conventions2.ATTR_URL_FULL];
  const httpRoute = attributes[import_semantic_conventions2.ATTR_HTTP_ROUTE];
  const parsedUrl = typeof httpUrl === "string" ? parseUrl(httpUrl) : undefined;
  const url = parsedUrl ? getSanitizedUrlString(parsedUrl) : undefined;
  const query = parsedUrl?.search || undefined;
  const fragment = parsedUrl?.hash || undefined;
  if (typeof httpRoute === "string") {
    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };
  }
  if (kind === import_api3.SpanKind.SERVER && typeof httpTarget === "string") {
    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };
  }
  if (parsedUrl) {
    return { urlPath: url, url, query, fragment, hasRoute: false };
  }
  if (typeof httpTarget === "string") {
    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };
  }
  return { urlPath: undefined, url, query, fragment, hasRoute: false };
}
function getUserUpdatedNameAndSource(originalName, attributes, fallbackSource = "custom") {
  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] || fallbackSource;
  const description = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
  if (description && typeof description === "string") {
    return {
      description,
      source
    };
  }
  return { description: originalName, source };
}
function enhanceDscWithOpenTelemetryRootSpanName(client) {
  client.on("createDsc", (dsc, rootSpan) => {
    if (!rootSpan) {
      return;
    }
    const jsonSpan = spanToJSON(rootSpan);
    const attributes = jsonSpan.data;
    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };
    if (source !== "url" && description) {
      dsc.transaction = description;
    }
    if (hasSpansEnabled()) {
      const sampled = getSamplingDecision(rootSpan.spanContext());
      dsc.sampled = sampled == undefined ? undefined : String(sampled);
    }
  });
}
function getActiveSpan2() {
  return import_api3.trace.getActiveSpan();
}
var DEBUG_BUILD3 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
function makeTraceState({
  dsc,
  sampled
}) {
  const dscString = dsc ? dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;
  const traceStateBase = new import_core37.TraceState;
  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;
  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, "1") : traceStateWithDsc;
}
var setupElements = new Set;
function openTelemetrySetupCheck() {
  return Array.from(setupElements);
}
function setIsSetup(element) {
  setupElements.add(element);
}

class SentryPropagator extends import_core37.W3CBaggagePropagator {
  constructor() {
    super();
    setIsSetup("SentryPropagator");
    this._urlMatchesTargetsMap = new LRUMap(100);
  }
  inject(context4, carrier, setter) {
    if (import_core37.isTracingSuppressed(context4)) {
      DEBUG_BUILD3 && debug.log("[Tracing] Not injecting trace data for url because tracing is suppressed.");
      return;
    }
    const activeSpan = import_api3.trace.getSpan(context4);
    const url = activeSpan && getCurrentURL(activeSpan);
    const tracePropagationTargets = getClient()?.getOptions()?.tracePropagationTargets;
    if (!shouldPropagateTraceForUrl(url, tracePropagationTargets, this._urlMatchesTargetsMap)) {
      DEBUG_BUILD3 && debug.log("[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:", url);
      return;
    }
    const existingBaggageHeader = getExistingBaggage(carrier);
    let baggage = import_api3.propagation.getBaggage(context4) || import_api3.propagation.createBaggage({});
    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context4);
    if (existingBaggageHeader) {
      const baggageEntries = parseBaggageHeader(existingBaggageHeader);
      if (baggageEntries) {
        Object.entries(baggageEntries).forEach(([key, value]) => {
          baggage = baggage.setEntry(key, { value });
        });
      }
    }
    if (dynamicSamplingContext) {
      baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {
        if (dscValue) {
          return b.setEntry(`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });
        }
        return b;
      }, baggage);
    }
    if (traceId && traceId !== import_api3.INVALID_TRACEID) {
      setter.set(carrier, SENTRY_TRACE_HEADER, generateSentryTraceHeader(traceId, spanId, sampled));
    }
    super.inject(import_api3.propagation.setBaggage(context4, baggage), carrier, setter);
  }
  extract(context4, carrier, getter) {
    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);
    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);
    const sentryTrace = maybeSentryTraceHeader ? Array.isArray(maybeSentryTraceHeader) ? maybeSentryTraceHeader[0] : maybeSentryTraceHeader : undefined;
    return ensureScopesOnContext(getContextWithRemoteActiveSpan(context4, { sentryTrace, baggage }));
  }
  fields() {
    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];
  }
}
var NOT_PROPAGATED_MESSAGE = "[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:";
function shouldPropagateTraceForUrl(url, tracePropagationTargets, decisionMap) {
  if (typeof url !== "string" || !tracePropagationTargets) {
    return true;
  }
  const cachedDecision = decisionMap?.get(url);
  if (cachedDecision !== undefined) {
    DEBUG_BUILD3 && !cachedDecision && debug.log(NOT_PROPAGATED_MESSAGE, url);
    return cachedDecision;
  }
  const decision = stringMatchesSomePattern(url, tracePropagationTargets);
  decisionMap?.set(url, decision);
  DEBUG_BUILD3 && !decision && debug.log(NOT_PROPAGATED_MESSAGE, url);
  return decision;
}
function getInjectionData(context4, options = {}) {
  const span = import_api3.trace.getSpan(context4);
  if (span?.spanContext().isRemote) {
    const spanContext = span.spanContext();
    const dynamicSamplingContext2 = getDynamicSamplingContextFromSpan(span);
    return {
      dynamicSamplingContext: dynamicSamplingContext2,
      traceId: spanContext.traceId,
      spanId: undefined,
      sampled: getSamplingDecision(spanContext)
    };
  }
  if (span) {
    const spanContext = span.spanContext();
    const dynamicSamplingContext2 = getDynamicSamplingContextFromSpan(span);
    return {
      dynamicSamplingContext: dynamicSamplingContext2,
      traceId: spanContext.traceId,
      spanId: spanContext.spanId,
      sampled: getSamplingDecision(spanContext)
    };
  }
  const scope = options.scope || getScopesFromContext(context4)?.scope || getCurrentScope();
  const client = options.client || getClient();
  const propagationContext = scope.getPropagationContext();
  const dynamicSamplingContext = client ? getDynamicSamplingContextFromScope(client, scope) : undefined;
  return {
    dynamicSamplingContext,
    traceId: propagationContext.traceId,
    spanId: propagationContext.propagationSpanId,
    sampled: propagationContext.sampled
  };
}
function getContextWithRemoteActiveSpan(ctx, { sentryTrace, baggage }) {
  const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);
  const { traceId, parentSpanId, sampled, dsc } = propagationContext;
  const client = getClient();
  const incomingDsc = baggageHeaderToDynamicSamplingContext(baggage);
  if (!parentSpanId || client && !shouldContinueTrace(client, incomingDsc?.org_id)) {
    return ctx;
  }
  const spanContext = generateRemoteSpanContext({
    traceId,
    spanId: parentSpanId,
    sampled,
    dsc
  });
  return import_api3.trace.setSpanContext(ctx, spanContext);
}
function continueTraceAsRemoteSpan(ctx, options, callback) {
  const ctxWithSpanContext = ensureScopesOnContext(getContextWithRemoteActiveSpan(ctx, options));
  return import_api3.context.with(ctxWithSpanContext, callback);
}
function ensureScopesOnContext(ctx) {
  const scopes = getScopesFromContext(ctx);
  const newScopes = {
    scope: scopes ? scopes.scope : getCurrentScope().clone(),
    isolationScope: scopes ? scopes.isolationScope : getIsolationScope()
  };
  return setScopesOnContext(ctx, newScopes);
}
function getExistingBaggage(carrier) {
  try {
    const baggage = carrier[SENTRY_BAGGAGE_HEADER];
    return Array.isArray(baggage) ? baggage.join(",") : baggage;
  } catch {
    return;
  }
}
function getCurrentURL(span) {
  const spanData = spanToJSON(span).data;
  const urlAttribute = spanData[import_semantic_conventions2.SEMATTRS_HTTP_URL] || spanData[import_semantic_conventions2.ATTR_URL_FULL];
  if (typeof urlAttribute === "string") {
    return urlAttribute;
  }
  const urlTraceState = span.spanContext().traceState?.get(SENTRY_TRACE_STATE_URL);
  if (urlTraceState) {
    return urlTraceState;
  }
  return;
}
function generateRemoteSpanContext({
  spanId,
  traceId,
  sampled,
  dsc
}) {
  const traceState = makeTraceState({
    dsc,
    sampled
  });
  const spanContext = {
    traceId,
    spanId,
    isRemote: true,
    traceFlags: sampled ? import_api3.TraceFlags.SAMPLED : import_api3.TraceFlags.NONE,
    traceState
  };
  return spanContext;
}
function startSpan2(options, callback) {
  const tracer = getTracer();
  const { name, parentSpan: customParentSpan } = options;
  const wrapper = getActiveSpanWrapper2(customParentSpan);
  return wrapper(() => {
    const activeCtx = getContext(options.scope, options.forceTransaction);
    const shouldSkipSpan = options.onlyIfParent && !import_api3.trace.getSpan(activeCtx);
    const ctx = shouldSkipSpan ? import_core37.suppressTracing(activeCtx) : activeCtx;
    const spanOptions = getSpanOptions(options);
    return tracer.startActiveSpan(name, spanOptions, ctx, (span) => {
      return handleCallbackErrors(() => callback(span), () => {
        if (spanToJSON(span).status === undefined) {
          span.setStatus({ code: import_api3.SpanStatusCode.ERROR });
        }
      }, () => span.end());
    });
  });
}
function startSpanManual2(options, callback) {
  const tracer = getTracer();
  const { name, parentSpan: customParentSpan } = options;
  const wrapper = getActiveSpanWrapper2(customParentSpan);
  return wrapper(() => {
    const activeCtx = getContext(options.scope, options.forceTransaction);
    const shouldSkipSpan = options.onlyIfParent && !import_api3.trace.getSpan(activeCtx);
    const ctx = shouldSkipSpan ? import_core37.suppressTracing(activeCtx) : activeCtx;
    const spanOptions = getSpanOptions(options);
    return tracer.startActiveSpan(name, spanOptions, ctx, (span) => {
      return handleCallbackErrors(() => callback(span, () => span.end()), () => {
        if (spanToJSON(span).status === undefined) {
          span.setStatus({ code: import_api3.SpanStatusCode.ERROR });
        }
      });
    });
  });
}
function startInactiveSpan2(options) {
  const tracer = getTracer();
  const { name, parentSpan: customParentSpan } = options;
  const wrapper = getActiveSpanWrapper2(customParentSpan);
  return wrapper(() => {
    const activeCtx = getContext(options.scope, options.forceTransaction);
    const shouldSkipSpan = options.onlyIfParent && !import_api3.trace.getSpan(activeCtx);
    const ctx = shouldSkipSpan ? import_core37.suppressTracing(activeCtx) : activeCtx;
    const spanOptions = getSpanOptions(options);
    const span = tracer.startSpan(name, spanOptions, ctx);
    return span;
  });
}
function withActiveSpan2(span, callback) {
  const newContextWithActiveSpan = span ? import_api3.trace.setSpan(import_api3.context.active(), span) : import_api3.trace.deleteSpan(import_api3.context.active());
  return import_api3.context.with(newContextWithActiveSpan, () => callback(getCurrentScope()));
}
function getTracer() {
  const client = getClient();
  return client?.tracer || import_api3.trace.getTracer("@sentry/opentelemetry", SDK_VERSION);
}
function getSpanOptions(options) {
  const { startTime, attributes, kind, op, links } = options;
  const fixedStartTime = typeof startTime === "number" ? ensureTimestampInMilliseconds(startTime) : startTime;
  return {
    attributes: op ? {
      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,
      ...attributes
    } : attributes,
    kind,
    links,
    startTime: fixedStartTime
  };
}
function ensureTimestampInMilliseconds(timestamp) {
  const isMs = timestamp < 9999999999;
  return isMs ? timestamp * 1000 : timestamp;
}
function getContext(scope, forceTransaction) {
  const ctx = getContextForScope(scope);
  const parentSpan = import_api3.trace.getSpan(ctx);
  if (!parentSpan) {
    return ctx;
  }
  if (!forceTransaction) {
    return ctx;
  }
  const ctxWithoutSpan = import_api3.trace.deleteSpan(ctx);
  const { spanId, traceId } = parentSpan.spanContext();
  const sampled = getSamplingDecision(parentSpan.spanContext());
  const rootSpan = getRootSpan(parentSpan);
  const dsc = getDynamicSamplingContextFromSpan(rootSpan);
  const traceState = makeTraceState({
    dsc,
    sampled
  });
  const spanOptions = {
    traceId,
    spanId,
    isRemote: true,
    traceFlags: sampled ? import_api3.TraceFlags.SAMPLED : import_api3.TraceFlags.NONE,
    traceState
  };
  const ctxWithSpanContext = import_api3.trace.setSpanContext(ctxWithoutSpan, spanOptions);
  return ctxWithSpanContext;
}
function getContextForScope(scope) {
  if (scope) {
    const ctx = getContextFromScope(scope);
    if (ctx) {
      return ctx;
    }
  }
  return import_api3.context.active();
}
function continueTrace2(options, callback) {
  return continueTraceAsRemoteSpan(import_api3.context.active(), options, callback);
}
function getTraceContextForScope(client, scope) {
  const ctx = getContextFromScope(scope);
  const span = ctx && import_api3.trace.getSpan(ctx);
  const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);
  const dynamicSamplingContext = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);
  return [dynamicSamplingContext, traceContext];
}
function getActiveSpanWrapper2(parentSpan) {
  return parentSpan !== undefined ? (callback) => {
    return withActiveSpan2(parentSpan, callback);
  } : (callback) => callback();
}
function suppressTracing2(callback) {
  const ctx = import_core37.suppressTracing(import_api3.context.active());
  return import_api3.context.with(ctx, callback);
}
function setupEventContextTrace(client) {
  client.on("preprocessEvent", (event) => {
    const span = getActiveSpan2();
    if (!span || event.type === "transaction") {
      return;
    }
    event.contexts = {
      trace: spanToTraceContext(span),
      ...event.contexts
    };
    const rootSpan = getRootSpan(span);
    event.sdkProcessingMetadata = {
      dynamicSamplingContext: getDynamicSamplingContextFromSpan(rootSpan),
      ...event.sdkProcessingMetadata
    };
    return event;
  });
}
function getTraceData2({
  span,
  scope,
  client
} = {}) {
  let ctx = (scope && getContextFromScope(scope)) ?? api.context.active();
  if (span) {
    const { scope: scope2 } = getCapturedScopesOnSpan(span);
    ctx = scope2 && getContextFromScope(scope2) || api.trace.setSpan(api.context.active(), span);
  }
  const { traceId, spanId, sampled, dynamicSamplingContext } = getInjectionData(ctx, { scope, client });
  return {
    "sentry-trace": generateSentryTraceHeader(traceId, spanId, sampled),
    baggage: dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext)
  };
}
function setOpenTelemetryContextAsyncContextStrategy() {
  function getScopes() {
    const ctx = api.context.active();
    const scopes = getScopesFromContext(ctx);
    if (scopes) {
      return scopes;
    }
    return {
      scope: getDefaultCurrentScope(),
      isolationScope: getDefaultIsolationScope()
    };
  }
  function withScope3(callback) {
    const ctx = api.context.active();
    return api.context.with(ctx, () => {
      return callback(getCurrentScope2());
    });
  }
  function withSetScope2(scope, callback) {
    const ctx = getContextFromScope(scope) || api.context.active();
    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {
      return callback(scope);
    });
  }
  function withIsolationScope3(callback) {
    const ctx = api.context.active();
    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {
      return callback(getIsolationScope2());
    });
  }
  function withSetIsolationScope(isolationScope, callback) {
    const ctx = api.context.active();
    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {
      return callback(getIsolationScope2());
    });
  }
  function getCurrentScope2() {
    return getScopes().scope;
  }
  function getIsolationScope2() {
    return getScopes().isolationScope;
  }
  setAsyncContextStrategy({
    withScope: withScope3,
    withSetScope: withSetScope2,
    withSetIsolationScope,
    withIsolationScope: withIsolationScope3,
    getCurrentScope: getCurrentScope2,
    getIsolationScope: getIsolationScope2,
    startSpan: startSpan2,
    startSpanManual: startSpanManual2,
    startInactiveSpan: startInactiveSpan2,
    getActiveSpan: getActiveSpan2,
    suppressTracing: suppressTracing2,
    getTraceData: getTraceData2,
    continueTrace: continueTrace2,
    withActiveSpan: withActiveSpan2
  });
}
function wrapContextManagerClass(ContextManagerClass) {

  class SentryContextManager extends ContextManagerClass {
    constructor(...args) {
      super(...args);
      setIsSetup("SentryContextManager");
    }
    with(context4, fn, thisArg, ...args) {
      const currentScopes = getScopesFromContext(context4);
      const currentScope = currentScopes?.scope || getCurrentScope();
      const currentIsolationScope = currentScopes?.isolationScope || getIsolationScope();
      const shouldForkIsolationScope = context4.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;
      const scope = context4.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY);
      const isolationScope = context4.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);
      const newCurrentScope = scope || currentScope.clone();
      const newIsolationScope = isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);
      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };
      const ctx1 = setScopesOnContext(context4, scopes);
      const ctx2 = ctx1.deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY).deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY).deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);
      setContextOnScope(newCurrentScope, ctx2);
      return super.with(ctx2, fn, thisArg, ...args);
    }
  }
  return SentryContextManager;
}
function groupSpansWithParents(spans) {
  const nodeMap = new Map;
  for (const span of spans) {
    createOrUpdateSpanNodeAndRefs(nodeMap, span);
  }
  return Array.from(nodeMap, function([_id, spanNode]) {
    return spanNode;
  });
}
function getLocalParentId(span) {
  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;
  return !parentIsRemote ? getParentSpanId(span) : undefined;
}
function createOrUpdateSpanNodeAndRefs(nodeMap, span) {
  const id = span.spanContext().spanId;
  const parentId = getLocalParentId(span);
  if (!parentId) {
    createOrUpdateNode(nodeMap, { id, span, children: [] });
    return;
  }
  const parentNode = createOrGetParentNode(nodeMap, parentId);
  const node2 = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });
  parentNode.children.push(node2);
}
function createOrGetParentNode(nodeMap, id) {
  const existing = nodeMap.get(id);
  if (existing) {
    return existing;
  }
  return createOrUpdateNode(nodeMap, { id, children: [] });
}
function createOrUpdateNode(nodeMap, spanNode) {
  const existing = nodeMap.get(spanNode.id);
  if (existing?.span) {
    return existing;
  }
  if (existing && !existing.span) {
    existing.span = spanNode.span;
    existing.parentNode = spanNode.parentNode;
    return existing;
  }
  nodeMap.set(spanNode.id, spanNode);
  return spanNode;
}
var canonicalGrpcErrorCodesMap = {
  "1": "cancelled",
  "2": "unknown_error",
  "3": "invalid_argument",
  "4": "deadline_exceeded",
  "5": "not_found",
  "6": "already_exists",
  "7": "permission_denied",
  "8": "resource_exhausted",
  "9": "failed_precondition",
  "10": "aborted",
  "11": "out_of_range",
  "12": "unimplemented",
  "13": "internal_error",
  "14": "unavailable",
  "15": "data_loss",
  "16": "unauthenticated"
};
var isStatusErrorMessageValid = (message) => {
  return Object.values(canonicalGrpcErrorCodesMap).includes(message);
};
function mapStatus(span) {
  const attributes = spanHasAttributes(span) ? span.attributes : {};
  const status = spanHasStatus(span) ? span.status : undefined;
  if (status) {
    if (status.code === import_api3.SpanStatusCode.OK) {
      return { code: SPAN_STATUS_OK };
    } else if (status.code === import_api3.SpanStatusCode.ERROR) {
      if (typeof status.message === "undefined") {
        const inferredStatus2 = inferStatusFromAttributes(attributes);
        if (inferredStatus2) {
          return inferredStatus2;
        }
      }
      if (status.message && isStatusErrorMessageValid(status.message)) {
        return { code: SPAN_STATUS_ERROR, message: status.message };
      } else {
        return { code: SPAN_STATUS_ERROR, message: "unknown_error" };
      }
    }
  }
  const inferredStatus = inferStatusFromAttributes(attributes);
  if (inferredStatus) {
    return inferredStatus;
  }
  if (status?.code === import_api3.SpanStatusCode.UNSET) {
    return { code: SPAN_STATUS_OK };
  } else {
    return { code: SPAN_STATUS_ERROR, message: "unknown_error" };
  }
}
function inferStatusFromAttributes(attributes) {
  const httpCodeAttribute = attributes[import_semantic_conventions2.ATTR_HTTP_RESPONSE_STATUS_CODE] || attributes[import_semantic_conventions2.SEMATTRS_HTTP_STATUS_CODE];
  const grpcCodeAttribute = attributes[import_semantic_conventions2.SEMATTRS_RPC_GRPC_STATUS_CODE];
  const numberHttpCode = typeof httpCodeAttribute === "number" ? httpCodeAttribute : typeof httpCodeAttribute === "string" ? parseInt(httpCodeAttribute) : undefined;
  if (typeof numberHttpCode === "number") {
    return getSpanStatusFromHttpCode(numberHttpCode);
  }
  if (typeof grpcCodeAttribute === "string") {
    return { code: SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || "unknown_error" };
  }
  return;
}
var MAX_SPAN_COUNT2 = 1000;
var DEFAULT_TIMEOUT = 300;

class SentrySpanExporter {
  constructor(options) {
    this._finishedSpanBucketSize = options?.timeout || DEFAULT_TIMEOUT;
    this._finishedSpanBuckets = new Array(this._finishedSpanBucketSize).fill(undefined);
    this._lastCleanupTimestampInS = Math.floor(Date.now() / 1000);
    this._spansToBucketEntry = new WeakMap;
    this._sentSpans = new Map;
    this._debouncedFlush = debounce(this.flush.bind(this), 1, { maxWait: 100 });
  }
  export(span) {
    const currentTimestampInS = Math.floor(Date.now() / 1000);
    if (this._lastCleanupTimestampInS !== currentTimestampInS) {
      let droppedSpanCount = 0;
      this._finishedSpanBuckets.forEach((bucket, i) => {
        if (bucket && bucket.timestampInS <= currentTimestampInS - this._finishedSpanBucketSize) {
          droppedSpanCount += bucket.spans.size;
          this._finishedSpanBuckets[i] = undefined;
        }
      });
      if (droppedSpanCount > 0) {
        DEBUG_BUILD3 && debug.log(`SpanExporter dropped ${droppedSpanCount} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`);
      }
      this._lastCleanupTimestampInS = currentTimestampInS;
    }
    const currentBucketIndex = currentTimestampInS % this._finishedSpanBucketSize;
    const currentBucket = this._finishedSpanBuckets[currentBucketIndex] || {
      timestampInS: currentTimestampInS,
      spans: new Set
    };
    this._finishedSpanBuckets[currentBucketIndex] = currentBucket;
    currentBucket.spans.add(span);
    this._spansToBucketEntry.set(span, currentBucket);
    const localParentId = getLocalParentId(span);
    if (!localParentId || this._sentSpans.has(localParentId)) {
      this._debouncedFlush();
    }
  }
  flush() {
    const finishedSpans = this._finishedSpanBuckets.flatMap((bucket) => bucket ? Array.from(bucket.spans) : []);
    this._flushSentSpanCache();
    const sentSpans = this._maybeSend(finishedSpans);
    const sentSpanCount = sentSpans.size;
    const remainingOpenSpanCount = finishedSpans.length - sentSpanCount;
    DEBUG_BUILD3 && debug.log(`SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} spans are waiting for their parent spans to finish`);
    const expirationDate = Date.now() + DEFAULT_TIMEOUT * 1000;
    for (const span of sentSpans) {
      this._sentSpans.set(span.spanContext().spanId, expirationDate);
      const bucketEntry = this._spansToBucketEntry.get(span);
      if (bucketEntry) {
        bucketEntry.spans.delete(span);
      }
    }
    this._debouncedFlush.cancel();
  }
  clear() {
    this._finishedSpanBuckets = this._finishedSpanBuckets.fill(undefined);
    this._sentSpans.clear();
    this._debouncedFlush.cancel();
  }
  _maybeSend(spans) {
    const grouped = groupSpansWithParents(spans);
    const sentSpans = new Set;
    const rootNodes = this._getCompletedRootNodes(grouped);
    for (const root of rootNodes) {
      const span = root.span;
      sentSpans.add(span);
      const transactionEvent = createTransactionForOtelSpan(span);
      if (root.parentNode && this._sentSpans.has(root.parentNode.id)) {
        const traceData = transactionEvent.contexts?.trace?.data;
        if (traceData) {
          traceData["sentry.parent_span_already_sent"] = true;
        }
      }
      const spans2 = transactionEvent.spans || [];
      for (const child of root.children) {
        createAndFinishSpanForOtelSpan(child, spans2, sentSpans);
      }
      transactionEvent.spans = spans2.length > MAX_SPAN_COUNT2 ? spans2.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT2) : spans2;
      const measurements = timedEventsToMeasurements(span.events);
      if (measurements) {
        transactionEvent.measurements = measurements;
      }
      captureEvent(transactionEvent);
    }
    return sentSpans;
  }
  _flushSentSpanCache() {
    const currentTimestamp = Date.now();
    for (const [spanId, expirationTime] of this._sentSpans.entries()) {
      if (expirationTime <= currentTimestamp) {
        this._sentSpans.delete(spanId);
      }
    }
  }
  _nodeIsCompletedRootNodeOrHasSentParent(node2) {
    return !!node2.span && (!node2.parentNode || this._sentSpans.has(node2.parentNode.id));
  }
  _getCompletedRootNodes(nodes) {
    return nodes.filter((node2) => this._nodeIsCompletedRootNodeOrHasSentParent(node2));
  }
}
function parseSpan(span) {
  const attributes = span.attributes;
  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN];
  const op = attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP];
  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
  return { origin, op, source };
}
function createTransactionForOtelSpan(span) {
  const { op, description, data, origin = "manual", source } = getSpanData(span);
  const capturedSpanScopes = getCapturedScopesOnSpan(span);
  const sampleRate = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  const attributes = {
    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,
    [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,
    ...data,
    ...removeSentryAttributes(span.attributes)
  };
  const { links } = span;
  const { traceId: trace_id, spanId: span_id } = span.spanContext();
  const parent_span_id = getParentSpanId(span);
  const status = mapStatus(span);
  const traceContext = {
    parent_span_id,
    span_id,
    trace_id,
    data: attributes,
    origin,
    op,
    status: getStatusMessage(status),
    links: convertSpanLinksForEnvelope(links)
  };
  const statusCode = attributes[import_semantic_conventions2.ATTR_HTTP_RESPONSE_STATUS_CODE];
  const responseContext = typeof statusCode === "number" ? { response: { status_code: statusCode } } : undefined;
  const transactionEvent = {
    contexts: {
      trace: traceContext,
      otel: {
        resource: span.resource.attributes
      },
      ...responseContext
    },
    spans: [],
    start_timestamp: spanTimeInputToSeconds(span.startTime),
    timestamp: spanTimeInputToSeconds(span.endTime),
    transaction: description,
    type: "transaction",
    sdkProcessingMetadata: {
      capturedSpanScope: capturedSpanScopes.scope,
      capturedSpanIsolationScope: capturedSpanScopes.isolationScope,
      sampleRate,
      dynamicSamplingContext: getDynamicSamplingContextFromSpan(span)
    },
    ...source && {
      transaction_info: {
        source
      }
    }
  };
  return transactionEvent;
}
function createAndFinishSpanForOtelSpan(node2, spans, sentSpans) {
  const span = node2.span;
  if (span) {
    sentSpans.add(span);
  }
  const shouldDrop = !span;
  if (shouldDrop) {
    node2.children.forEach((child) => {
      createAndFinishSpanForOtelSpan(child, spans, sentSpans);
    });
    return;
  }
  const span_id = span.spanContext().spanId;
  const trace_id = span.spanContext().traceId;
  const parentSpanId = getParentSpanId(span);
  const { attributes, startTime, endTime, links } = span;
  const { op, description, data, origin = "manual" } = getSpanData(span);
  const allData = {
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,
    ...removeSentryAttributes(attributes),
    ...data
  };
  const status = mapStatus(span);
  const spanJSON = {
    span_id,
    trace_id,
    data: allData,
    description,
    parent_span_id: parentSpanId,
    start_timestamp: spanTimeInputToSeconds(startTime),
    timestamp: spanTimeInputToSeconds(endTime) || undefined,
    status: getStatusMessage(status),
    op,
    origin,
    measurements: timedEventsToMeasurements(span.events),
    links: convertSpanLinksForEnvelope(links)
  };
  spans.push(spanJSON);
  node2.children.forEach((child) => {
    createAndFinishSpanForOtelSpan(child, spans, sentSpans);
  });
}
function getSpanData(span) {
  const { op: definedOp, source: definedSource, origin } = parseSpan(span);
  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);
  const op = definedOp || inferredOp;
  const source = definedSource || inferredSource;
  const data = { ...inferredData, ...getData(span) };
  return {
    op,
    description,
    source,
    origin,
    data
  };
}
function removeSentryAttributes(data) {
  const cleanedData = { ...data };
  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];
  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
  return cleanedData;
}
function getData(span) {
  const attributes = span.attributes;
  const data = {};
  if (span.kind !== import_api3.SpanKind.INTERNAL) {
    data["otel.kind"] = import_api3.SpanKind[span.kind];
  }
  const maybeHttpStatusCodeAttribute = attributes[import_semantic_conventions2.SEMATTRS_HTTP_STATUS_CODE];
  if (maybeHttpStatusCodeAttribute) {
    data[import_semantic_conventions2.ATTR_HTTP_RESPONSE_STATUS_CODE] = maybeHttpStatusCodeAttribute;
  }
  const requestData = getRequestSpanData(span);
  if (requestData.url) {
    data.url = requestData.url;
  }
  if (requestData["http.query"]) {
    data["http.query"] = requestData["http.query"].slice(1);
  }
  if (requestData["http.fragment"]) {
    data["http.fragment"] = requestData["http.fragment"].slice(1);
  }
  return data;
}
function onSpanStart(span, parentContext) {
  const parentSpan = import_api3.trace.getSpan(parentContext);
  let scopes = getScopesFromContext(parentContext);
  if (parentSpan && !parentSpan.spanContext().isRemote) {
    addChildSpanToSpan(parentSpan, span);
  }
  if (parentSpan?.spanContext().isRemote) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);
  }
  if (parentContext === import_api3.ROOT_CONTEXT) {
    scopes = {
      scope: getDefaultCurrentScope(),
      isolationScope: getDefaultIsolationScope()
    };
  }
  if (scopes) {
    setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);
  }
  logSpanStart(span);
  const client = getClient();
  client?.emit("spanStart", span);
}
function onSpanEnd(span) {
  logSpanEnd(span);
  const client = getClient();
  client?.emit("spanEnd", span);
}

class SentrySpanProcessor {
  constructor(options) {
    setIsSetup("SentrySpanProcessor");
    this._exporter = new SentrySpanExporter(options);
  }
  async forceFlush() {
    this._exporter.flush();
  }
  async shutdown() {
    this._exporter.clear();
  }
  onStart(span, parentContext) {
    onSpanStart(span, parentContext);
  }
  onEnd(span) {
    onSpanEnd(span);
    this._exporter.export(span);
  }
}

class SentrySampler {
  constructor(client) {
    this._client = client;
    setIsSetup("SentrySampler");
  }
  shouldSample(context4, traceId, spanName, spanKind, spanAttributes, _links) {
    const options = this._client.getOptions();
    const parentSpan = getValidSpan(context4);
    const parentContext = parentSpan?.spanContext();
    if (!hasSpansEnabled(options)) {
      return wrapSamplingDecision({ decision: undefined, context: context4, spanAttributes });
    }
    const maybeSpanHttpMethod = spanAttributes[import_semantic_conventions2.SEMATTRS_HTTP_METHOD] || spanAttributes[import_semantic_conventions2.ATTR_HTTP_REQUEST_METHOD];
    if (spanKind === import_api3.SpanKind.CLIENT && maybeSpanHttpMethod && (!parentSpan || parentContext?.isRemote)) {
      return wrapSamplingDecision({ decision: undefined, context: context4, spanAttributes });
    }
    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;
    const isRootSpan = !parentSpan || parentContext?.isRemote;
    if (!isRootSpan) {
      return wrapSamplingDecision({
        decision: parentSampled ? import_sdk_trace_base.SamplingDecision.RECORD_AND_SAMPLED : import_sdk_trace_base.SamplingDecision.NOT_RECORD,
        context: context4,
        spanAttributes
      });
    }
    const {
      description: inferredSpanName,
      data: inferredAttributes,
      op
    } = inferSpanData(spanName, spanAttributes, spanKind);
    const mergedAttributes = {
      ...inferredAttributes,
      ...spanAttributes
    };
    if (op) {
      mergedAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] = op;
    }
    const mutableSamplingDecision = { decision: true };
    this._client.emit("beforeSampling", {
      spanAttributes: mergedAttributes,
      spanName: inferredSpanName,
      parentSampled,
      parentContext
    }, mutableSamplingDecision);
    if (!mutableSamplingDecision.decision) {
      return wrapSamplingDecision({ decision: undefined, context: context4, spanAttributes });
    }
    const { isolationScope } = getScopesFromContext(context4) ?? {};
    const dscString = parentContext?.traceState ? parentContext.traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;
    const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : undefined;
    const sampleRand = parseSampleRate(dsc?.sample_rand) ?? Math.random();
    const [sampled, sampleRate, localSampleRateWasApplied] = sampleSpan(options, {
      name: inferredSpanName,
      attributes: mergedAttributes,
      normalizedRequest: isolationScope?.getScopeData().sdkProcessingMetadata.normalizedRequest,
      parentSampled,
      parentSampleRate: parseSampleRate(dsc?.sample_rate)
    }, sampleRand);
    const method = `${maybeSpanHttpMethod}`.toUpperCase();
    if (method === "OPTIONS" || method === "HEAD") {
      DEBUG_BUILD3 && debug.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);
      return wrapSamplingDecision({
        decision: import_sdk_trace_base.SamplingDecision.NOT_RECORD,
        context: context4,
        spanAttributes,
        sampleRand,
        downstreamTraceSampleRate: 0
      });
    }
    if (!sampled && parentSampled === undefined) {
      DEBUG_BUILD3 && debug.log("[Tracing] Discarding root span because its trace was not chosen to be sampled.");
      this._client.recordDroppedEvent("sample_rate", "transaction");
    }
    return {
      ...wrapSamplingDecision({
        decision: sampled ? import_sdk_trace_base.SamplingDecision.RECORD_AND_SAMPLED : import_sdk_trace_base.SamplingDecision.NOT_RECORD,
        context: context4,
        spanAttributes,
        sampleRand,
        downstreamTraceSampleRate: localSampleRateWasApplied ? sampleRate : undefined
      }),
      attributes: {
        [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: localSampleRateWasApplied ? sampleRate : undefined
      }
    };
  }
  toString() {
    return "SentrySampler";
  }
}
function getParentSampled(parentSpan, traceId, spanName) {
  const parentContext = parentSpan.spanContext();
  if (import_api3.isSpanContextValid(parentContext) && parentContext.traceId === traceId) {
    if (parentContext.isRemote) {
      const parentSampled2 = getSamplingDecision(parentSpan.spanContext());
      DEBUG_BUILD3 && debug.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled2}`);
      return parentSampled2;
    }
    const parentSampled = getSamplingDecision(parentContext);
    DEBUG_BUILD3 && debug.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);
    return parentSampled;
  }
  return;
}
function wrapSamplingDecision({
  decision,
  context: context4,
  spanAttributes,
  sampleRand,
  downstreamTraceSampleRate
}) {
  let traceState = getBaseTraceState(context4, spanAttributes);
  if (downstreamTraceSampleRate !== undefined) {
    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RATE, `${downstreamTraceSampleRate}`);
  }
  if (sampleRand !== undefined) {
    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RAND, `${sampleRand}`);
  }
  if (decision == undefined) {
    return { decision: import_sdk_trace_base.SamplingDecision.NOT_RECORD, traceState };
  }
  if (decision === import_sdk_trace_base.SamplingDecision.NOT_RECORD) {
    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, "1") };
  }
  return { decision, traceState };
}
function getBaseTraceState(context4, spanAttributes) {
  const parentSpan = import_api3.trace.getSpan(context4);
  const parentContext = parentSpan?.spanContext();
  let traceState = parentContext?.traceState || new import_core37.TraceState;
  const url = spanAttributes[import_semantic_conventions2.SEMATTRS_HTTP_URL] || spanAttributes[import_semantic_conventions2.ATTR_URL_FULL];
  if (url && typeof url === "string") {
    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);
  }
  return traceState;
}
function getValidSpan(context4) {
  const span = import_api3.trace.getSpan(context4);
  return span && import_api3.isSpanContextValid(span.spanContext()) ? span : undefined;
}

// ../../node_modules/@sentry/node-core/build/esm/utils/baggage.js
function mergeBaggageHeaders(existing, baggage) {
  if (!existing) {
    return baggage;
  }
  const existingBaggageEntries = parseBaggageHeader(existing);
  const newBaggageEntries = parseBaggageHeader(baggage);
  if (!newBaggageEntries) {
    return existing;
  }
  const mergedBaggageEntries = { ...existingBaggageEntries };
  Object.entries(newBaggageEntries).forEach(([key, value]) => {
    if (!mergedBaggageEntries[key]) {
      mergedBaggageEntries[key] = value;
    }
  });
  return objectToBaggageHeader(mergedBaggageEntries);
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/http/outgoing-requests.js
function addRequestBreadcrumb(request, response) {
  const data = getBreadcrumbData(request);
  const statusCode = response?.statusCode;
  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);
  addBreadcrumb({
    category: "http",
    data: {
      status_code: statusCode,
      ...data
    },
    type: "http",
    level
  }, {
    event: "response",
    request,
    response
  });
}
function addTracePropagationHeadersToOutgoingRequest(request, propagationDecisionMap) {
  const url = getRequestUrl2(request);
  const tracePropagationTargets = getClient()?.getOptions().tracePropagationTargets;
  const headersToAdd = shouldPropagateTraceForUrl(url, tracePropagationTargets, propagationDecisionMap) ? getTraceData() : undefined;
  if (!headersToAdd) {
    return;
  }
  const { "sentry-trace": sentryTrace, baggage } = headersToAdd;
  if (sentryTrace && !request.getHeader("sentry-trace")) {
    try {
      request.setHeader("sentry-trace", sentryTrace);
      DEBUG_BUILD2 && debug.log(INSTRUMENTATION_NAME, "Added sentry-trace header to outgoing request");
    } catch (error2) {
      DEBUG_BUILD2 && debug.error(INSTRUMENTATION_NAME, "Failed to add sentry-trace header to outgoing request:", isError(error2) ? error2.message : "Unknown error");
    }
  }
  if (baggage) {
    const newBaggage = mergeBaggageHeaders(request.getHeader("baggage"), baggage);
    if (newBaggage) {
      try {
        request.setHeader("baggage", newBaggage);
        DEBUG_BUILD2 && debug.log(INSTRUMENTATION_NAME, "Added baggage header to outgoing request");
      } catch (error2) {
        DEBUG_BUILD2 && debug.error(INSTRUMENTATION_NAME, "Failed to add baggage header to outgoing request:", isError(error2) ? error2.message : "Unknown error");
      }
    }
  }
}
function getBreadcrumbData(request) {
  try {
    const host = request.getHeader("host") || request.host;
    const url = new URL(request.path, `${request.protocol}//${host}`);
    const parsedUrl = parseUrl(url.toString());
    const data = {
      url: getSanitizedUrlString(parsedUrl),
      "http.method": request.method || "GET"
    };
    if (parsedUrl.search) {
      data["http.query"] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data["http.fragment"] = parsedUrl.hash;
    }
    return data;
  } catch {
    return {};
  }
}
function getRequestOptions(request) {
  return {
    method: request.method,
    protocol: request.protocol,
    host: request.host,
    hostname: request.host,
    path: request.path,
    headers: request.getHeaders()
  };
}
function getRequestUrl2(request) {
  const hostname = request.getHeader("host") || request.host;
  const protocol = request.protocol;
  const path7 = request.path;
  return `${protocol}//${hostname}${path7}`;
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/http/SentryHttpInstrumentation.js
class SentryHttpInstrumentation extends import_instrumentation2.InstrumentationBase {
  constructor(config = {}) {
    super(INSTRUMENTATION_NAME, SDK_VERSION, config);
    this._propagationDecisionMap = new LRUMap(100);
    this._ignoreOutgoingRequestsMap = new WeakMap;
  }
  init() {
    let hasRegisteredHandlers = false;
    const spansEnabled = this.getConfig().spans ?? true;
    const onHttpServerRequestStart = (_data) => {
      const data = _data;
      instrumentServer(data.server, {
        instrumentation: this.getConfig().instrumentation,
        ignoreIncomingRequestBody: this.getConfig().ignoreIncomingRequestBody,
        ignoreSpansForIncomingRequests: this.getConfig().ignoreSpansForIncomingRequests,
        incomingRequestSpanHook: this.getConfig().incomingRequestSpanHook,
        maxIncomingRequestBodySize: this.getConfig().maxIncomingRequestBodySize,
        trackIncomingRequestsAsSessions: this.getConfig().trackIncomingRequestsAsSessions,
        sessionFlushingDelayMS: this.getConfig().sessionFlushingDelayMS ?? 60000,
        ignoreStaticAssets: this.getConfig().ignoreStaticAssets,
        spans: spansEnabled && !this.getConfig().disableIncomingRequestSpans
      });
    };
    const onHttpClientResponseFinish = (_data) => {
      const data = _data;
      this._onOutgoingRequestFinish(data.request, data.response);
    };
    const onHttpClientRequestError = (_data) => {
      const data = _data;
      this._onOutgoingRequestFinish(data.request, undefined);
    };
    const onHttpClientRequestCreated = (_data) => {
      const data = _data;
      this._onOutgoingRequestCreated(data.request);
    };
    const wrap = (moduleExports) => {
      if (hasRegisteredHandlers) {
        return moduleExports;
      }
      hasRegisteredHandlers = true;
      subscribe("http.server.request.start", onHttpServerRequestStart);
      subscribe("http.client.response.finish", onHttpClientResponseFinish);
      subscribe("http.client.request.error", onHttpClientRequestError);
      if (this.getConfig().propagateTraceInOutgoingRequests) {
        subscribe("http.client.request.created", onHttpClientRequestCreated);
      }
      return moduleExports;
    };
    const unwrap = () => {
      unsubscribe("http.server.request.start", onHttpServerRequestStart);
      unsubscribe("http.client.response.finish", onHttpClientResponseFinish);
      unsubscribe("http.client.request.error", onHttpClientRequestError);
      unsubscribe("http.client.request.created", onHttpClientRequestCreated);
    };
    return [
      new import_instrumentation2.InstrumentationNodeModuleDefinition("http", ["*"], wrap, unwrap),
      new import_instrumentation2.InstrumentationNodeModuleDefinition("https", ["*"], wrap, unwrap)
    ];
  }
  _onOutgoingRequestFinish(request, response) {
    DEBUG_BUILD2 && debug.log(INSTRUMENTATION_NAME, "Handling finished outgoing request");
    const _breadcrumbs = this.getConfig().breadcrumbs;
    const breadCrumbsEnabled = typeof _breadcrumbs === "undefined" ? true : _breadcrumbs;
    const shouldIgnore = this._ignoreOutgoingRequestsMap.get(request) ?? this._shouldIgnoreOutgoingRequest(request);
    this._ignoreOutgoingRequestsMap.set(request, shouldIgnore);
    if (breadCrumbsEnabled && !shouldIgnore) {
      addRequestBreadcrumb(request, response);
    }
  }
  _onOutgoingRequestCreated(request) {
    const shouldIgnore = this._ignoreOutgoingRequestsMap.get(request) ?? this._shouldIgnoreOutgoingRequest(request);
    this._ignoreOutgoingRequestsMap.set(request, shouldIgnore);
    if (shouldIgnore) {
      return;
    }
    addTracePropagationHeadersToOutgoingRequest(request, this._propagationDecisionMap);
  }
  _shouldIgnoreOutgoingRequest(request) {
    if (import_core40.isTracingSuppressed(import_api4.context.active())) {
      return true;
    }
    const ignoreOutgoingRequests = this.getConfig().ignoreOutgoingRequests;
    if (!ignoreOutgoingRequests) {
      return false;
    }
    const options = getRequestOptions(request);
    const url = getRequestUrl(request);
    return ignoreOutgoingRequests(url, options);
  }
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/http/index.js
var INTEGRATION_NAME6 = "Http";
var instrumentSentryHttp = generateInstrumentOnce(`${INTEGRATION_NAME6}.sentry`, (options) => {
  return new SentryHttpInstrumentation(options);
});
var httpIntegration = defineIntegration((options = {}) => {
  const dropSpansForIncomingRequestStatusCodes = options.dropSpansForIncomingRequestStatusCodes ?? [
    [401, 404],
    [300, 399]
  ];
  return {
    name: INTEGRATION_NAME6,
    setupOnce() {
      instrumentSentryHttp({
        ...options,
        ignoreSpansForIncomingRequests: options.ignoreIncomingRequests,
        disableIncomingRequestSpans: true,
        propagateTraceInOutgoingRequests: true
      });
    },
    processEvent(event) {
      if (event.type === "transaction") {
        const statusCode = event.contexts?.trace?.data?.["http.response.status_code"];
        if (typeof statusCode === "number" && dropSpansForIncomingRequestStatusCodes.some((code) => {
          if (typeof code === "number") {
            return code === statusCode;
          }
          const [min, max] = code;
          return statusCode >= min && statusCode <= max;
        })) {
          return null;
        }
      }
      return event;
    }
  };
});
// ../../node_modules/@sentry/node-core/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js
var import_api5 = __toESM(require_src(), 1);
var import_core44 = __toESM(require_src3(), 1);
var import_instrumentation3 = __toESM(require_src6(), 1);
import * as diagch from "diagnostics_channel";

// ../../node_modules/@sentry/node-core/build/esm/nodeVersion.js
var NODE_VERSION = parseSemver(process.versions.node);
var NODE_MAJOR = NODE_VERSION.major;
var NODE_MINOR = NODE_VERSION.minor;

// ../../node_modules/@sentry/node-core/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js
var SENTRY_TRACE_HEADER2 = "sentry-trace";
var SENTRY_BAGGAGE_HEADER2 = "baggage";
var BAGGAGE_HEADER_REGEX = /baggage: (.*)\r\n/;

class SentryNodeFetchInstrumentation extends import_instrumentation3.InstrumentationBase {
  constructor(config = {}) {
    super("@sentry/instrumentation-node-fetch", SDK_VERSION, config);
    this._channelSubs = [];
    this._propagationDecisionMap = new LRUMap(100);
    this._ignoreOutgoingRequestsMap = new WeakMap;
  }
  init() {
    return;
  }
  disable() {
    super.disable();
    this._channelSubs.forEach((sub) => sub.unsubscribe());
    this._channelSubs = [];
  }
  enable() {
    super.enable();
    this._channelSubs = this._channelSubs || [];
    if (this._channelSubs.length > 0) {
      return;
    }
    this._subscribeToChannel("undici:request:create", this._onRequestCreated.bind(this));
    this._subscribeToChannel("undici:request:headers", this._onResponseHeaders.bind(this));
  }
  _onRequestCreated({ request }) {
    const config = this.getConfig();
    const enabled = config.enabled !== false;
    if (!enabled) {
      return;
    }
    const shouldIgnore = this._shouldIgnoreOutgoingRequest(request);
    this._ignoreOutgoingRequestsMap.set(request, shouldIgnore);
    if (shouldIgnore) {
      return;
    }
    const url = getAbsoluteUrl2(request.origin, request.path);
    const tracePropagationTargets = getClient()?.getOptions().tracePropagationTargets;
    const addedHeaders = shouldPropagateTraceForUrl(url, tracePropagationTargets, this._propagationDecisionMap) ? getTraceData() : undefined;
    if (!addedHeaders) {
      return;
    }
    const { "sentry-trace": sentryTrace, baggage } = addedHeaders;
    if (Array.isArray(request.headers)) {
      const requestHeaders = request.headers;
      if (sentryTrace && !requestHeaders.includes(SENTRY_TRACE_HEADER2)) {
        requestHeaders.push(SENTRY_TRACE_HEADER2, sentryTrace);
      }
      const existingBaggagePos = requestHeaders.findIndex((header) => header === SENTRY_BAGGAGE_HEADER2);
      if (baggage && existingBaggagePos === -1) {
        requestHeaders.push(SENTRY_BAGGAGE_HEADER2, baggage);
      } else if (baggage) {
        const existingBaggage = requestHeaders[existingBaggagePos + 1];
        const merged = mergeBaggageHeaders(existingBaggage, baggage);
        if (merged) {
          requestHeaders[existingBaggagePos + 1] = merged;
        }
      }
    } else {
      const requestHeaders = request.headers;
      if (sentryTrace && !requestHeaders.includes(`${SENTRY_TRACE_HEADER2}:`)) {
        request.headers += `${SENTRY_TRACE_HEADER2}: ${sentryTrace}\r
`;
      }
      const existingBaggage = request.headers.match(BAGGAGE_HEADER_REGEX)?.[1];
      if (baggage && !existingBaggage) {
        request.headers += `${SENTRY_BAGGAGE_HEADER2}: ${baggage}\r
`;
      } else if (baggage) {
        const merged = mergeBaggageHeaders(existingBaggage, baggage);
        if (merged) {
          request.headers = request.headers.replace(BAGGAGE_HEADER_REGEX, `baggage: ${merged}\r
`);
        }
      }
    }
  }
  _onResponseHeaders({ request, response }) {
    const config = this.getConfig();
    const enabled = config.enabled !== false;
    if (!enabled) {
      return;
    }
    const _breadcrumbs = config.breadcrumbs;
    const breadCrumbsEnabled = typeof _breadcrumbs === "undefined" ? true : _breadcrumbs;
    const shouldIgnore = this._ignoreOutgoingRequestsMap.get(request);
    if (breadCrumbsEnabled && !shouldIgnore) {
      addRequestBreadcrumb2(request, response);
    }
  }
  _subscribeToChannel(diagnosticChannel, onMessage) {
    const useNewSubscribe = NODE_MAJOR > 18 || NODE_MAJOR === 18 && NODE_MINOR >= 19;
    let unsubscribe3;
    if (useNewSubscribe) {
      diagch.subscribe?.(diagnosticChannel, onMessage);
      unsubscribe3 = () => diagch.unsubscribe?.(diagnosticChannel, onMessage);
    } else {
      const channel2 = diagch.channel(diagnosticChannel);
      channel2.subscribe(onMessage);
      unsubscribe3 = () => channel2.unsubscribe(onMessage);
    }
    this._channelSubs.push({
      name: diagnosticChannel,
      unsubscribe: unsubscribe3
    });
  }
  _shouldIgnoreOutgoingRequest(request) {
    if (import_core44.isTracingSuppressed(import_api5.context.active())) {
      return true;
    }
    const url = getAbsoluteUrl2(request.origin, request.path);
    const ignoreOutgoingRequests = this.getConfig().ignoreOutgoingRequests;
    if (typeof ignoreOutgoingRequests !== "function" || !url) {
      return false;
    }
    return ignoreOutgoingRequests(url);
  }
}
function addRequestBreadcrumb2(request, response) {
  const data = getBreadcrumbData2(request);
  const statusCode = response.statusCode;
  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);
  addBreadcrumb({
    category: "http",
    data: {
      status_code: statusCode,
      ...data
    },
    type: "http",
    level
  }, {
    event: "response",
    request,
    response
  });
}
function getBreadcrumbData2(request) {
  try {
    const url = getAbsoluteUrl2(request.origin, request.path);
    const parsedUrl = parseUrl(url);
    const data = {
      url: getSanitizedUrlString(parsedUrl),
      "http.method": request.method || "GET"
    };
    if (parsedUrl.search) {
      data["http.query"] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data["http.fragment"] = parsedUrl.hash;
    }
    return data;
  } catch {
    return {};
  }
}
function getAbsoluteUrl2(origin, path7 = "/") {
  try {
    const url = new URL(path7, origin);
    return url.toString();
  } catch {
    const url = `${origin}`;
    if (url.endsWith("/") && path7.startsWith("/")) {
      return `${url}${path7.slice(1)}`;
    }
    if (!url.endsWith("/") && !path7.startsWith("/")) {
      return `${url}/${path7.slice(1)}`;
    }
    return `${url}${path7}`;
  }
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/node-fetch/index.js
var INTEGRATION_NAME7 = "NodeFetch";
var instrumentSentryNodeFetch = generateInstrumentOnce(`${INTEGRATION_NAME7}.sentry`, SentryNodeFetchInstrumentation, (options) => {
  return options;
});
var _nativeNodeFetchIntegration = (options = {}) => {
  return {
    name: "NodeFetch",
    setupOnce() {
      instrumentSentryNodeFetch(options);
    }
  };
};
var nativeNodeFetchIntegration = defineIntegration(_nativeNodeFetchIntegration);
// ../../node_modules/@sentry/node-core/build/esm/integrations/context.js
import { execFile } from "node:child_process";
import { readFile, readdir } from "node:fs";
import * as os from "node:os";
import { join as join2 } from "node:path";
import { promisify } from "node:util";
var readFileAsync = promisify(readFile);
var readDirAsync = promisify(readdir);
var INTEGRATION_NAME8 = "Context";
var _nodeContextIntegration = (options = {}) => {
  let cachedContext;
  const _options = {
    app: true,
    os: true,
    device: true,
    culture: true,
    cloudResource: true,
    ...options
  };
  async function addContext(event) {
    if (cachedContext === undefined) {
      cachedContext = _getContexts();
    }
    const updatedContext = _updateContext(await cachedContext);
    event.contexts = {
      ...event.contexts,
      app: { ...updatedContext.app, ...event.contexts?.app },
      os: { ...updatedContext.os, ...event.contexts?.os },
      device: { ...updatedContext.device, ...event.contexts?.device },
      culture: { ...updatedContext.culture, ...event.contexts?.culture },
      cloud_resource: { ...updatedContext.cloud_resource, ...event.contexts?.cloud_resource }
    };
    return event;
  }
  async function _getContexts() {
    const contexts = {};
    if (_options.os) {
      contexts.os = await getOsContext();
    }
    if (_options.app) {
      contexts.app = getAppContext();
    }
    if (_options.device) {
      contexts.device = getDeviceContext(_options.device);
    }
    if (_options.culture) {
      const culture = getCultureContext();
      if (culture) {
        contexts.culture = culture;
      }
    }
    if (_options.cloudResource) {
      contexts.cloud_resource = getCloudResourceContext();
    }
    return contexts;
  }
  return {
    name: INTEGRATION_NAME8,
    processEvent(event) {
      return addContext(event);
    }
  };
};
var nodeContextIntegration = defineIntegration(_nodeContextIntegration);
function _updateContext(contexts) {
  if (contexts.app?.app_memory) {
    contexts.app.app_memory = process.memoryUsage().rss;
  }
  if (contexts.app?.free_memory && typeof process.availableMemory === "function") {
    const freeMemory = process.availableMemory?.();
    if (freeMemory != null) {
      contexts.app.free_memory = freeMemory;
    }
  }
  if (contexts.device?.free_memory) {
    contexts.device.free_memory = os.freemem();
  }
  return contexts;
}
async function getOsContext() {
  const platformId = os.platform();
  switch (platformId) {
    case "darwin":
      return getDarwinInfo();
    case "linux":
      return getLinuxInfo();
    default:
      return {
        name: PLATFORM_NAMES[platformId] || platformId,
        version: os.release()
      };
  }
}
function getCultureContext() {
  try {
    if (typeof process.versions.icu !== "string") {
      return;
    }
    const january = new Date(900000000);
    const spanish = new Intl.DateTimeFormat("es", { month: "long" });
    if (spanish.format(january) === "enero") {
      const options = Intl.DateTimeFormat().resolvedOptions();
      return {
        locale: options.locale,
        timezone: options.timeZone
      };
    }
  } catch {}
  return;
}
function getAppContext() {
  const app_memory = process.memoryUsage().rss;
  const app_start_time = new Date(Date.now() - process.uptime() * 1000).toISOString();
  const appContext = { app_start_time, app_memory };
  if (typeof process.availableMemory === "function") {
    const freeMemory = process.availableMemory?.();
    if (freeMemory != null) {
      appContext.free_memory = freeMemory;
    }
  }
  return appContext;
}
function getDeviceContext(deviceOpt) {
  const device = {};
  let uptime2;
  try {
    uptime2 = os.uptime();
  } catch {}
  if (typeof uptime2 === "number") {
    device.boot_time = new Date(Date.now() - uptime2 * 1000).toISOString();
  }
  device.arch = os.arch();
  if (deviceOpt === true || deviceOpt.memory) {
    device.memory_size = os.totalmem();
    device.free_memory = os.freemem();
  }
  if (deviceOpt === true || deviceOpt.cpu) {
    const cpuInfo = os.cpus();
    const firstCpu = cpuInfo?.[0];
    if (firstCpu) {
      device.processor_count = cpuInfo.length;
      device.cpu_description = firstCpu.model;
      device.processor_frequency = firstCpu.speed;
    }
  }
  return device;
}
var PLATFORM_NAMES = {
  aix: "IBM AIX",
  freebsd: "FreeBSD",
  openbsd: "OpenBSD",
  sunos: "SunOS",
  win32: "Windows"
};
var LINUX_DISTROS = [
  { name: "fedora-release", distros: ["Fedora"] },
  { name: "redhat-release", distros: ["Red Hat Linux", "Centos"] },
  { name: "redhat_version", distros: ["Red Hat Linux"] },
  { name: "SuSE-release", distros: ["SUSE Linux"] },
  { name: "lsb-release", distros: ["Ubuntu Linux", "Arch Linux"] },
  { name: "debian_version", distros: ["Debian"] },
  { name: "debian_release", distros: ["Debian"] },
  { name: "arch-release", distros: ["Arch Linux"] },
  { name: "gentoo-release", distros: ["Gentoo Linux"] },
  { name: "novell-release", distros: ["SUSE Linux"] },
  { name: "alpine-release", distros: ["Alpine Linux"] }
];
var LINUX_VERSIONS = {
  alpine: (content) => content,
  arch: (content) => matchFirst(/distrib_release=(.*)/, content),
  centos: (content) => matchFirst(/release ([^ ]+)/, content),
  debian: (content) => content,
  fedora: (content) => matchFirst(/release (..)/, content),
  mint: (content) => matchFirst(/distrib_release=(.*)/, content),
  red: (content) => matchFirst(/release ([^ ]+)/, content),
  suse: (content) => matchFirst(/VERSION = (.*)\n/, content),
  ubuntu: (content) => matchFirst(/distrib_release=(.*)/, content)
};
function matchFirst(regex, text) {
  const match2 = regex.exec(text);
  return match2 ? match2[1] : undefined;
}
async function getDarwinInfo() {
  const darwinInfo = {
    kernel_version: os.release(),
    name: "Mac OS X",
    version: `10.${Number(os.release().split(".")[0]) - 4}`
  };
  try {
    const output = await new Promise((resolve2, reject) => {
      execFile("/usr/bin/sw_vers", (error2, stdout) => {
        if (error2) {
          reject(error2);
          return;
        }
        resolve2(stdout);
      });
    });
    darwinInfo.name = matchFirst(/^ProductName:\s+(.*)$/m, output);
    darwinInfo.version = matchFirst(/^ProductVersion:\s+(.*)$/m, output);
    darwinInfo.build = matchFirst(/^BuildVersion:\s+(.*)$/m, output);
  } catch {}
  return darwinInfo;
}
function getLinuxDistroId(name) {
  return name.split(" ")[0].toLowerCase();
}
async function getLinuxInfo() {
  const linuxInfo = {
    kernel_version: os.release(),
    name: "Linux"
  };
  try {
    const etcFiles = await readDirAsync("/etc");
    const distroFile = LINUX_DISTROS.find((file) => etcFiles.includes(file.name));
    if (!distroFile) {
      return linuxInfo;
    }
    const distroPath = join2("/etc", distroFile.name);
    const contents = (await readFileAsync(distroPath, { encoding: "utf-8" })).toLowerCase();
    const { distros } = distroFile;
    linuxInfo.name = distros.find((d) => contents.indexOf(getLinuxDistroId(d)) >= 0) || distros[0];
    const id = getLinuxDistroId(linuxInfo.name);
    linuxInfo.version = LINUX_VERSIONS[id]?.(contents);
  } catch {}
  return linuxInfo;
}
function getCloudResourceContext() {
  if (process.env.VERCEL) {
    return {
      "cloud.provider": "vercel",
      "cloud.region": process.env.VERCEL_REGION
    };
  } else if (process.env.AWS_REGION) {
    return {
      "cloud.provider": "aws",
      "cloud.region": process.env.AWS_REGION,
      "cloud.platform": process.env.AWS_EXECUTION_ENV
    };
  } else if (process.env.GCP_PROJECT) {
    return {
      "cloud.provider": "gcp"
    };
  } else if (process.env.ALIYUN_REGION_ID) {
    return {
      "cloud.provider": "alibaba_cloud",
      "cloud.region": process.env.ALIYUN_REGION_ID
    };
  } else if (process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME) {
    return {
      "cloud.provider": "azure",
      "cloud.region": process.env.REGION_NAME
    };
  } else if (process.env.IBM_CLOUD_REGION) {
    return {
      "cloud.provider": "ibm_cloud",
      "cloud.region": process.env.IBM_CLOUD_REGION
    };
  } else if (process.env.TENCENTCLOUD_REGION) {
    return {
      "cloud.provider": "tencent_cloud",
      "cloud.region": process.env.TENCENTCLOUD_REGION,
      "cloud.account.id": process.env.TENCENTCLOUD_APPID,
      "cloud.availability_zone": process.env.TENCENTCLOUD_ZONE
    };
  } else if (process.env.NETLIFY) {
    return {
      "cloud.provider": "netlify"
    };
  } else if (process.env.FLY_REGION) {
    return {
      "cloud.provider": "fly.io",
      "cloud.region": process.env.FLY_REGION
    };
  } else if (process.env.DYNO) {
    return {
      "cloud.provider": "heroku"
    };
  } else {
    return;
  }
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/contextlines.js
import { createReadStream } from "node:fs";
import { createInterface } from "node:readline";
var LRU_FILE_CONTENTS_CACHE = new LRUMap(10);
var LRU_FILE_CONTENTS_FS_READ_FAILED = new LRUMap(20);
var DEFAULT_LINES_OF_CONTEXT = 7;
var INTEGRATION_NAME9 = "ContextLines";
var MAX_CONTEXTLINES_COLNO = 1000;
var MAX_CONTEXTLINES_LINENO = 1e4;
function emplace(map, key, contents) {
  const value = map.get(key);
  if (value === undefined) {
    map.set(key, contents);
    return contents;
  }
  return value;
}
function shouldSkipContextLinesForFile(path7) {
  if (path7.startsWith("node:"))
    return true;
  if (path7.endsWith(".min.js"))
    return true;
  if (path7.endsWith(".min.cjs"))
    return true;
  if (path7.endsWith(".min.mjs"))
    return true;
  if (path7.startsWith("data:"))
    return true;
  return false;
}
function shouldSkipContextLinesForFrame(frame) {
  if (frame.lineno !== undefined && frame.lineno > MAX_CONTEXTLINES_LINENO)
    return true;
  if (frame.colno !== undefined && frame.colno > MAX_CONTEXTLINES_COLNO)
    return true;
  return false;
}
function rangeExistsInContentCache(file, range) {
  const contents = LRU_FILE_CONTENTS_CACHE.get(file);
  if (contents === undefined)
    return false;
  for (let i = range[0];i <= range[1]; i++) {
    if (contents[i] === undefined) {
      return false;
    }
  }
  return true;
}
function makeLineReaderRanges(lines, linecontext) {
  if (!lines.length) {
    return [];
  }
  let i = 0;
  const line = lines[0];
  if (typeof line !== "number") {
    return [];
  }
  let current = makeContextRange(line, linecontext);
  const out = [];
  while (true) {
    if (i === lines.length - 1) {
      out.push(current);
      break;
    }
    const next = lines[i + 1];
    if (typeof next !== "number") {
      break;
    }
    if (next <= current[1]) {
      current[1] = next + linecontext;
    } else {
      out.push(current);
      current = makeContextRange(next, linecontext);
    }
    i++;
  }
  return out;
}
function getContextLinesFromFile(path7, ranges, output) {
  return new Promise((resolve2, _reject) => {
    const stream = createReadStream(path7);
    const lineReaded = createInterface({
      input: stream
    });
    function destroyStreamAndResolve() {
      stream.destroy();
      resolve2();
    }
    let lineNumber = 0;
    let currentRangeIndex = 0;
    const range = ranges[currentRangeIndex];
    if (range === undefined) {
      destroyStreamAndResolve();
      return;
    }
    let rangeStart = range[0];
    let rangeEnd = range[1];
    function onStreamError(e) {
      LRU_FILE_CONTENTS_FS_READ_FAILED.set(path7, 1);
      DEBUG_BUILD2 && debug.error(`Failed to read file: ${path7}. Error: ${e}`);
      lineReaded.close();
      lineReaded.removeAllListeners();
      destroyStreamAndResolve();
    }
    stream.on("error", onStreamError);
    lineReaded.on("error", onStreamError);
    lineReaded.on("close", destroyStreamAndResolve);
    lineReaded.on("line", (line) => {
      lineNumber++;
      if (lineNumber < rangeStart)
        return;
      output[lineNumber] = snipLine(line, 0);
      if (lineNumber >= rangeEnd) {
        if (currentRangeIndex === ranges.length - 1) {
          lineReaded.close();
          lineReaded.removeAllListeners();
          return;
        }
        currentRangeIndex++;
        const range2 = ranges[currentRangeIndex];
        if (range2 === undefined) {
          lineReaded.close();
          lineReaded.removeAllListeners();
          return;
        }
        rangeStart = range2[0];
        rangeEnd = range2[1];
      }
    });
  });
}
async function addSourceContext(event, contextLines) {
  const filesToLines = {};
  if (contextLines > 0 && event.exception?.values) {
    for (const exception of event.exception.values) {
      if (!exception.stacktrace?.frames?.length) {
        continue;
      }
      for (let i = exception.stacktrace.frames.length - 1;i >= 0; i--) {
        const frame = exception.stacktrace.frames[i];
        const filename = frame?.filename;
        if (!frame || typeof filename !== "string" || typeof frame.lineno !== "number" || shouldSkipContextLinesForFile(filename) || shouldSkipContextLinesForFrame(frame)) {
          continue;
        }
        const filesToLinesOutput = filesToLines[filename];
        if (!filesToLinesOutput)
          filesToLines[filename] = [];
        filesToLines[filename].push(frame.lineno);
      }
    }
  }
  const files = Object.keys(filesToLines);
  if (files.length == 0) {
    return event;
  }
  const readlinePromises = [];
  for (const file of files) {
    if (LRU_FILE_CONTENTS_FS_READ_FAILED.get(file)) {
      continue;
    }
    const filesToLineRanges = filesToLines[file];
    if (!filesToLineRanges) {
      continue;
    }
    filesToLineRanges.sort((a, b) => a - b);
    const ranges = makeLineReaderRanges(filesToLineRanges, contextLines);
    if (ranges.every((r) => rangeExistsInContentCache(file, r))) {
      continue;
    }
    const cache = emplace(LRU_FILE_CONTENTS_CACHE, file, {});
    readlinePromises.push(getContextLinesFromFile(file, ranges, cache));
  }
  await Promise.all(readlinePromises).catch(() => {
    DEBUG_BUILD2 && debug.log("Failed to read one or more source files and resolve context lines");
  });
  if (contextLines > 0 && event.exception?.values) {
    for (const exception of event.exception.values) {
      if (exception.stacktrace?.frames && exception.stacktrace.frames.length > 0) {
        addSourceContextToFrames(exception.stacktrace.frames, contextLines, LRU_FILE_CONTENTS_CACHE);
      }
    }
  }
  return event;
}
function addSourceContextToFrames(frames, contextLines, cache) {
  for (const frame of frames) {
    if (frame.filename && frame.context_line === undefined && typeof frame.lineno === "number") {
      const contents = cache.get(frame.filename);
      if (contents === undefined) {
        continue;
      }
      addContextToFrame2(frame.lineno, frame, contextLines, contents);
    }
  }
}
function clearLineContext(frame) {
  delete frame.pre_context;
  delete frame.context_line;
  delete frame.post_context;
}
function addContextToFrame2(lineno, frame, contextLines, contents) {
  if (frame.lineno === undefined || contents === undefined) {
    DEBUG_BUILD2 && debug.error("Cannot resolve context for frame with no lineno or file contents");
    return;
  }
  frame.pre_context = [];
  for (let i = makeRangeStart(lineno, contextLines);i < lineno; i++) {
    const line = contents[i];
    if (line === undefined) {
      clearLineContext(frame);
      DEBUG_BUILD2 && debug.error(`Could not find line ${i} in file ${frame.filename}`);
      return;
    }
    frame.pre_context.push(line);
  }
  if (contents[lineno] === undefined) {
    clearLineContext(frame);
    DEBUG_BUILD2 && debug.error(`Could not find line ${lineno} in file ${frame.filename}`);
    return;
  }
  frame.context_line = contents[lineno];
  const end = makeRangeEnd(lineno, contextLines);
  frame.post_context = [];
  for (let i = lineno + 1;i <= end; i++) {
    const line = contents[i];
    if (line === undefined) {
      break;
    }
    frame.post_context.push(line);
  }
}
function makeRangeStart(line, linecontext) {
  return Math.max(1, line - linecontext);
}
function makeRangeEnd(line, linecontext) {
  return line + linecontext;
}
function makeContextRange(line, linecontext) {
  return [makeRangeStart(line, linecontext), makeRangeEnd(line, linecontext)];
}
var _contextLinesIntegration = (options = {}) => {
  const contextLines = options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
  return {
    name: INTEGRATION_NAME9,
    processEvent(event) {
      return addSourceContext(event, contextLines);
    }
  };
};
var contextLinesIntegration = defineIntegration(_contextLinesIntegration);

// ../../node_modules/@sentry/node-core/build/esm/integrations/local-variables/local-variables-async.js
import { Worker } from "node:worker_threads";

// ../../node_modules/@sentry/node-core/build/esm/utils/debug.js
var cachedDebuggerEnabled;
async function isDebuggerEnabled() {
  if (cachedDebuggerEnabled === undefined) {
    try {
      const inspector = await import("node:inspector");
      cachedDebuggerEnabled = !!inspector.url();
    } catch {
      cachedDebuggerEnabled = false;
    }
  }
  return cachedDebuggerEnabled;
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/local-variables/common.js
var LOCAL_VARIABLES_KEY = "__SENTRY_ERROR_LOCAL_VARIABLES__";
function createRateLimiter(maxPerSecond, enable2, disable2) {
  let count = 0;
  let retrySeconds = 5;
  let disabledTimeout = 0;
  setInterval(() => {
    if (disabledTimeout === 0) {
      if (count > maxPerSecond) {
        retrySeconds *= 2;
        disable2(retrySeconds);
        if (retrySeconds > 86400) {
          retrySeconds = 86400;
        }
        disabledTimeout = retrySeconds;
      }
    } else {
      disabledTimeout -= 1;
      if (disabledTimeout === 0) {
        enable2();
      }
    }
    count = 0;
  }, 1000).unref();
  return () => {
    count += 1;
  };
}
function isAnonymous(name) {
  return name !== undefined && (name.length === 0 || name === "?" || name === "<anonymous>");
}
function functionNamesMatch(a, b) {
  return a === b || `Object.${a}` === b || a === `Object.${b}` || isAnonymous(a) && isAnonymous(b);
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/local-variables/local-variables-async.js
var base64WorkerScript = "LyohIEBzZW50cnkvbm9kZS1jb3JlIDEwLjEyLjAgKGEzYTA3MGIpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyBlfWZyb20ibm9kZTppbnNwZWN0b3IvcHJvbWlzZXMiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIHR9ZnJvbSJub2RlOndvcmtlcl90aHJlYWRzIjtjb25zdCBuPWdsb2JhbFRoaXMsaT17fTtjb25zdCBvPSJfX1NFTlRSWV9FUlJPUl9MT0NBTF9WQVJJQUJMRVNfXyI7Y29uc3QgYT10O2Z1bmN0aW9uIHMoLi4uZSl7YS5kZWJ1ZyYmZnVuY3Rpb24oZSl7aWYoISgiY29uc29sZSJpbiBuKSlyZXR1cm4gZSgpO2NvbnN0IHQ9bi5jb25zb2xlLG89e30sYT1PYmplY3Qua2V5cyhpKTthLmZvckVhY2goZT0+e2NvbnN0IG49aVtlXTtvW2VdPXRbZV0sdFtlXT1ufSk7dHJ5e3JldHVybiBlKCl9ZmluYWxseXthLmZvckVhY2goZT0+e3RbZV09b1tlXX0pfX0oKCk9PmNvbnNvbGUubG9nKCJbTG9jYWxWYXJpYWJsZXMgV29ya2VyXSIsLi4uZSkpfWFzeW5jIGZ1bmN0aW9uIGMoZSx0LG4saSl7Y29uc3Qgbz1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pO2lbbl09by5yZXN1bHQuZmlsdGVyKGU9PiJsZW5ndGgiIT09ZS5uYW1lJiYhaXNOYU4ocGFyc2VJbnQoZS5uYW1lLDEwKSkpLnNvcnQoKGUsdCk9PnBhcnNlSW50KGUubmFtZSwxMCktcGFyc2VJbnQodC5uYW1lLDEwKSkubWFwKGU9PmUudmFsdWU/LnZhbHVlKX1hc3luYyBmdW5jdGlvbiByKGUsdCxuLGkpe2NvbnN0IG89YXdhaXQgZS5wb3N0KCJSdW50aW1lLmdldFByb3BlcnRpZXMiLHtvYmplY3RJZDp0LG93blByb3BlcnRpZXM6ITB9KTtpW25dPW8ucmVzdWx0Lm1hcChlPT5bZS5uYW1lLGUudmFsdWU/LnZhbHVlXSkucmVkdWNlKChlLFt0LG5dKT0+KGVbdF09bixlKSx7fSl9ZnVuY3Rpb24gdShlLHQpe2UudmFsdWUmJigidmFsdWUiaW4gZS52YWx1ZT92b2lkIDA9PT1lLnZhbHVlLnZhbHVlfHxudWxsPT09ZS52YWx1ZS52YWx1ZT90W2UubmFtZV09YDwke2UudmFsdWUudmFsdWV9PmA6dFtlLm5hbWVdPWUudmFsdWUudmFsdWU6ImRlc2NyaXB0aW9uImluIGUudmFsdWUmJiJmdW5jdGlvbiIhPT1lLnZhbHVlLnR5cGU/dFtlLm5hbWVdPWA8JHtlLnZhbHVlLmRlc2NyaXB0aW9ufT5gOiJ1bmRlZmluZWQiPT09ZS52YWx1ZS50eXBlJiYodFtlLm5hbWVdPSI8dW5kZWZpbmVkPiIpKX1hc3luYyBmdW5jdGlvbiBsKGUsdCl7Y29uc3Qgbj1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pLGk9e307Zm9yKGNvbnN0IHQgb2Ygbi5yZXN1bHQpaWYodC52YWx1ZT8ub2JqZWN0SWQmJiJBcnJheSI9PT10LnZhbHVlLmNsYXNzTmFtZSl7Y29uc3Qgbj10LnZhbHVlLm9iamVjdElkO2F3YWl0IGMoZSxuLHQubmFtZSxpKX1lbHNlIGlmKHQudmFsdWU/Lm9iamVjdElkJiYiT2JqZWN0Ij09PXQudmFsdWUuY2xhc3NOYW1lKXtjb25zdCBuPXQudmFsdWUub2JqZWN0SWQ7YXdhaXQgcihlLG4sdC5uYW1lLGkpfWVsc2UgdC52YWx1ZSYmdSh0LGkpO3JldHVybiBpfWxldCBmOyhhc3luYyBmdW5jdGlvbigpe2NvbnN0IHQ9bmV3IGU7dC5jb25uZWN0VG9NYWluVGhyZWFkKCkscygiQ29ubmVjdGVkIHRvIG1haW4gdGhyZWFkIik7bGV0IG49ITE7dC5vbigiRGVidWdnZXIucmVzdW1lZCIsKCk9PntuPSExfSksdC5vbigiRGVidWdnZXIucGF1c2VkIixlPT57bj0hMCxhc3luYyBmdW5jdGlvbihlLHtyZWFzb246dCxkYXRhOntvYmplY3RJZDpufSxjYWxsRnJhbWVzOml9KXtpZigiZXhjZXB0aW9uIiE9PXQmJiJwcm9taXNlUmVqZWN0aW9uIiE9PXQpcmV0dXJuO2lmKGY/LigpLG51bGw9PW4pcmV0dXJuO2NvbnN0IGE9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kyspe2NvbnN0e3Njb3BlQ2hhaW46bixmdW5jdGlvbk5hbWU6byx0aGlzOnN9PWlbdF0sYz1uLmZpbmQoZT0+ImxvY2FsIj09PWUudHlwZSkscj0iZ2xvYmFsIiE9PXMuY2xhc3NOYW1lJiZzLmNsYXNzTmFtZT9gJHtzLmNsYXNzTmFtZX0uJHtvfWA6bztpZih2b2lkIDA9PT1jPy5vYmplY3Qub2JqZWN0SWQpYVt0XT17ZnVuY3Rpb246cn07ZWxzZXtjb25zdCBuPWF3YWl0IGwoZSxjLm9iamVjdC5vYmplY3RJZCk7YVt0XT17ZnVuY3Rpb246cix2YXJzOm59fX1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuY2FsbEZ1bmN0aW9uT24iLHtmdW5jdGlvbkRlY2xhcmF0aW9uOmBmdW5jdGlvbigpIHsgdGhpcy4ke299ID0gdGhpcy4ke299IHx8ICR7SlNPTi5zdHJpbmdpZnkoYSl9OyB9YCxzaWxlbnQ6ITAsb2JqZWN0SWQ6bn0pLGF3YWl0IGUucG9zdCgiUnVudGltZS5yZWxlYXNlT2JqZWN0Iix7b2JqZWN0SWQ6bn0pfSh0LGUucGFyYW1zKS50aGVuKGFzeW5jKCk9PntuJiZhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpfSxhc3luYyBlPT57biYmYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKX0pfSksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiKTtjb25zdCBpPSExIT09YS5jYXB0dXJlQWxsRXhjZXB0aW9ucztpZihhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6aT8iYWxsIjoidW5jYXVnaHQifSksaSl7Y29uc3QgZT1hLm1heEV4Y2VwdGlvbnNQZXJTZWNvbmR8fDUwO2Y9ZnVuY3Rpb24oZSx0LG4pe2xldCBpPTAsbz01LGE9MDtyZXR1cm4gc2V0SW50ZXJ2YWwoKCk9PnswPT09YT9pPmUmJihvKj0yLG4obyksbz44NjQwMCYmKG89ODY0MDApLGE9byk6KGEtPTEsMD09PWEmJnQoKSksaT0wfSwxZTMpLnVucmVmKCksKCk9PntpKz0xfX0oZSxhc3luYygpPT57cygiUmF0ZS1saW1pdCBsaWZ0ZWQuIiksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJhbGwifSl9LGFzeW5jIGU9PntzKGBSYXRlLWxpbWl0IGV4Y2VlZGVkLiBEaXNhYmxpbmcgY2FwdHVyaW5nIG9mIGNhdWdodCBleGNlcHRpb25zIGZvciAke2V9IHNlY29uZHMuYCksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJ1bmNhdWdodCJ9KX0pfX0pKCkuY2F0Y2goZT0+e3MoIkZhaWxlZCB0byBzdGFydCBkZWJ1Z2dlciIsZSl9KSxzZXRJbnRlcnZhbCgoKT0+e30sMWU0KTs=";
function log2(...args) {
  debug.log("[LocalVariables]", ...args);
}
var localVariablesAsyncIntegration = defineIntegration((integrationOptions = {}) => {
  function addLocalVariablesToException(exception, localVariables) {
    const frames = (exception.stacktrace?.frames || []).filter((frame) => frame.function !== "new Promise");
    for (let i = 0;i < frames.length; i++) {
      const frameIndex = frames.length - i - 1;
      const frameLocalVariables = localVariables[i];
      const frame = frames[frameIndex];
      if (!frame || !frameLocalVariables) {
        break;
      }
      if (frameLocalVariables.vars === undefined || frame.in_app === false || !functionNamesMatch(frame.function, frameLocalVariables.function)) {
        continue;
      }
      frame.vars = frameLocalVariables.vars;
    }
  }
  function addLocalVariablesToEvent(event, hint) {
    if (hint.originalException && typeof hint.originalException === "object" && LOCAL_VARIABLES_KEY in hint.originalException && Array.isArray(hint.originalException[LOCAL_VARIABLES_KEY])) {
      for (const exception of event.exception?.values || []) {
        addLocalVariablesToException(exception, hint.originalException[LOCAL_VARIABLES_KEY]);
      }
      hint.originalException[LOCAL_VARIABLES_KEY] = undefined;
    }
    return event;
  }
  async function startInspector() {
    const inspector = await import("node:inspector");
    if (!inspector.url()) {
      inspector.open(0);
    }
  }
  function startWorker(options) {
    const worker = new Worker(new URL(`data:application/javascript;base64,${base64WorkerScript}`), {
      workerData: options,
      execArgv: [],
      env: { ...process.env, NODE_OPTIONS: undefined }
    });
    process.on("exit", () => {
      worker.terminate();
    });
    worker.once("error", (err) => {
      log2("Worker error", err);
    });
    worker.once("exit", (code) => {
      log2("Worker exit", code);
    });
    worker.unref();
  }
  return {
    name: "LocalVariablesAsync",
    async setup(client) {
      const clientOptions = client.getOptions();
      if (!clientOptions.includeLocalVariables) {
        return;
      }
      if (await isDebuggerEnabled()) {
        debug.warn("Local variables capture has been disabled because the debugger was already enabled");
        return;
      }
      const options = {
        ...integrationOptions,
        debug: debug.isEnabled()
      };
      startInspector().then(() => {
        try {
          startWorker(options);
        } catch (e) {
          debug.error("Failed to start worker", e);
        }
      }, (e) => {
        debug.error("Failed to start inspector", e);
      });
    },
    processEvent(event, hint) {
      return addLocalVariablesToEvent(event, hint);
    }
  };
});

// ../../node_modules/@sentry/node-core/build/esm/integrations/local-variables/local-variables-sync.js
function hashFrames(frames) {
  if (frames === undefined) {
    return;
  }
  return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, "");
}
function hashFromStack(stackParser, stack) {
  if (stack === undefined) {
    return;
  }
  return hashFrames(stackParser(stack, 1));
}
function createCallbackList(complete) {
  let callbacks = [];
  let completedCalled = false;
  function checkedComplete(result) {
    callbacks = [];
    if (completedCalled) {
      return;
    }
    completedCalled = true;
    complete(result);
  }
  callbacks.push(checkedComplete);
  function add(fn) {
    callbacks.push(fn);
  }
  function next(result) {
    const popped = callbacks.pop() || checkedComplete;
    try {
      popped(result);
    } catch {
      checkedComplete(result);
    }
  }
  return { add, next };
}

class AsyncSession {
  constructor(_session) {
    this._session = _session;
  }
  static async create(orDefault) {
    if (orDefault) {
      return orDefault;
    }
    const inspector = await import("node:inspector");
    return new AsyncSession(new inspector.Session);
  }
  configureAndConnect(onPause, captureAll) {
    this._session.connect();
    this._session.on("Debugger.paused", (event) => {
      onPause(event, () => {
        this._session.post("Debugger.resume");
      });
    });
    this._session.post("Debugger.enable");
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  setPauseOnExceptions(captureAll) {
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  getLocalVariables(objectId, complete) {
    this._getProperties(objectId, (props) => {
      const { add, next } = createCallbackList(complete);
      for (const prop of props) {
        if (prop.value?.objectId && prop.value.className === "Array") {
          const id = prop.value.objectId;
          add((vars) => this._unrollArray(id, prop.name, vars, next));
        } else if (prop.value?.objectId && prop.value.className === "Object") {
          const id = prop.value.objectId;
          add((vars) => this._unrollObject(id, prop.name, vars, next));
        } else if (prop.value) {
          add((vars) => this._unrollOther(prop, vars, next));
        }
      }
      next({});
    });
  }
  _getProperties(objectId, next) {
    this._session.post("Runtime.getProperties", {
      objectId,
      ownProperties: true
    }, (err, params) => {
      if (err) {
        next([]);
      } else {
        next(params.result);
      }
    });
  }
  _unrollArray(objectId, name, vars, next) {
    this._getProperties(objectId, (props) => {
      vars[name] = props.filter((v) => v.name !== "length" && !isNaN(parseInt(v.name, 10))).sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10)).map((v) => v.value?.value);
      next(vars);
    });
  }
  _unrollObject(objectId, name, vars, next) {
    this._getProperties(objectId, (props) => {
      vars[name] = props.map((v) => [v.name, v.value?.value]).reduce((obj, [key, val]) => {
        obj[key] = val;
        return obj;
      }, {});
      next(vars);
    });
  }
  _unrollOther(prop, vars, next) {
    if (prop.value) {
      if ("value" in prop.value) {
        if (prop.value.value === undefined || prop.value.value === null) {
          vars[prop.name] = `<${prop.value.value}>`;
        } else {
          vars[prop.name] = prop.value.value;
        }
      } else if ("description" in prop.value && prop.value.type !== "function") {
        vars[prop.name] = `<${prop.value.description}>`;
      } else if (prop.value.type === "undefined") {
        vars[prop.name] = "<undefined>";
      }
    }
    next(vars);
  }
}
var INTEGRATION_NAME10 = "LocalVariables";
var _localVariablesSyncIntegration = (options = {}, sessionOverride) => {
  const cachedFrames = new LRUMap(20);
  let rateLimiter;
  let shouldProcessEvent = false;
  function addLocalVariablesToException(exception) {
    const hash = hashFrames(exception.stacktrace?.frames);
    if (hash === undefined) {
      return;
    }
    const cachedFrame = cachedFrames.remove(hash);
    if (cachedFrame === undefined) {
      return;
    }
    const frames = (exception.stacktrace?.frames || []).filter((frame) => frame.function !== "new Promise");
    for (let i = 0;i < frames.length; i++) {
      const frameIndex = frames.length - i - 1;
      const cachedFrameVariable = cachedFrame[i];
      const frameVariable = frames[frameIndex];
      if (!frameVariable || !cachedFrameVariable) {
        break;
      }
      if (cachedFrameVariable.vars === undefined || frameVariable.in_app === false || !functionNamesMatch(frameVariable.function, cachedFrameVariable.function)) {
        continue;
      }
      frameVariable.vars = cachedFrameVariable.vars;
    }
  }
  function addLocalVariablesToEvent(event) {
    for (const exception of event.exception?.values || []) {
      addLocalVariablesToException(exception);
    }
    return event;
  }
  return {
    name: INTEGRATION_NAME10,
    async setupOnce() {
      const client = getClient();
      const clientOptions = client?.getOptions();
      if (!clientOptions?.includeLocalVariables) {
        return;
      }
      const unsupportedNodeVersion = NODE_MAJOR < 18;
      if (unsupportedNodeVersion) {
        debug.log("The `LocalVariables` integration is only supported on Node >= v18.");
        return;
      }
      if (await isDebuggerEnabled()) {
        debug.warn("Local variables capture has been disabled because the debugger was already enabled");
        return;
      }
      AsyncSession.create(sessionOverride).then((session) => {
        function handlePaused(stackParser, { params: { reason, data, callFrames } }, complete) {
          if (reason !== "exception" && reason !== "promiseRejection") {
            complete();
            return;
          }
          rateLimiter?.();
          const exceptionHash = hashFromStack(stackParser, data.description);
          if (exceptionHash == undefined) {
            complete();
            return;
          }
          const { add, next } = createCallbackList((frames) => {
            cachedFrames.set(exceptionHash, frames);
            complete();
          });
          for (let i = 0;i < Math.min(callFrames.length, 5); i++) {
            const { scopeChain, functionName, this: obj } = callFrames[i];
            const localScope = scopeChain.find((scope) => scope.type === "local");
            const fn = obj.className === "global" || !obj.className ? functionName : `${obj.className}.${functionName}`;
            if (localScope?.object.objectId === undefined) {
              add((frames) => {
                frames[i] = { function: fn };
                next(frames);
              });
            } else {
              const id = localScope.object.objectId;
              add((frames) => session.getLocalVariables(id, (vars) => {
                frames[i] = { function: fn, vars };
                next(frames);
              }));
            }
          }
          next([]);
        }
        const captureAll = options.captureAllExceptions !== false;
        session.configureAndConnect((ev, complete) => handlePaused(clientOptions.stackParser, ev, complete), captureAll);
        if (captureAll) {
          const max = options.maxExceptionsPerSecond || 50;
          rateLimiter = createRateLimiter(max, () => {
            debug.log("Local variables rate-limit lifted.");
            session.setPauseOnExceptions(true);
          }, (seconds) => {
            debug.log(`Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`);
            session.setPauseOnExceptions(false);
          });
        }
        shouldProcessEvent = true;
      }, (error2) => {
        debug.log("The `LocalVariables` integration failed to start.", error2);
      });
    },
    processEvent(event) {
      if (shouldProcessEvent) {
        return addLocalVariablesToEvent(event);
      }
      return event;
    },
    _getCachedFramesCount() {
      return cachedFrames.size;
    },
    _getFirstCachedFrame() {
      return cachedFrames.values()[0];
    }
  };
};
var localVariablesSyncIntegration = defineIntegration(_localVariablesSyncIntegration);

// ../../node_modules/@sentry/node-core/build/esm/integrations/local-variables/index.js
var localVariablesIntegration = (options = {}) => {
  return NODE_VERSION.major < 19 ? localVariablesSyncIntegration(options) : localVariablesAsyncIntegration(options);
};

// ../../node_modules/@sentry/node-core/build/esm/integrations/modules.js
import { existsSync as existsSync2, readFileSync } from "node:fs";
import { dirname as dirname2, join as join3 } from "node:path";

// ../../node_modules/@sentry/node-core/build/esm/utils/detection.js
function isCjs() {
  try {
    return typeof module_detection !== "undefined" && typeof exports_detection !== "undefined";
  } catch {
    return false;
  }
}
var hasWarnedAboutNodeVersion;
function supportsEsmLoaderHooks() {
  if (isCjs()) {
    return false;
  }
  if (NODE_MAJOR >= 21 || NODE_MAJOR === 20 && NODE_MINOR >= 6 || NODE_MAJOR === 18 && NODE_MINOR >= 19) {
    return true;
  }
  if (!hasWarnedAboutNodeVersion) {
    hasWarnedAboutNodeVersion = true;
    consoleSandbox(() => {
      console.warn(`[Sentry] You are using Node.js v${process.versions.node} in ESM mode ("import syntax"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS ("require() syntax"), or upgrade your Node.js version.`);
    });
  }
  return false;
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/modules.js
var moduleCache;
var INTEGRATION_NAME11 = "Modules";
var SERVER_MODULES = typeof __SENTRY_SERVER_MODULES__ === "undefined" ? {} : __SENTRY_SERVER_MODULES__;
var _modulesIntegration = () => {
  return {
    name: INTEGRATION_NAME11,
    processEvent(event) {
      event.modules = {
        ...event.modules,
        ..._getModules()
      };
      return event;
    },
    getModules: _getModules
  };
};
var modulesIntegration = _modulesIntegration;
function getRequireCachePaths() {
  try {
    return __require.cache ? Object.keys(__require.cache) : [];
  } catch {
    return [];
  }
}
function collectModules() {
  return {
    ...SERVER_MODULES,
    ...getModulesFromPackageJson(),
    ...isCjs() ? collectRequireModules() : {}
  };
}
function collectRequireModules() {
  const mainPaths = __require.main?.paths || [];
  const paths = getRequireCachePaths();
  const infos = {};
  const seen = new Set;
  paths.forEach((path7) => {
    let dir = path7;
    const updir = () => {
      const orig = dir;
      dir = dirname2(orig);
      if (!dir || orig === dir || seen.has(orig)) {
        return;
      }
      if (mainPaths.indexOf(dir) < 0) {
        return updir();
      }
      const pkgfile = join3(orig, "package.json");
      seen.add(orig);
      if (!existsSync2(pkgfile)) {
        return updir();
      }
      try {
        const info = JSON.parse(readFileSync(pkgfile, "utf8"));
        infos[info.name] = info.version;
      } catch {}
    };
    updir();
  });
  return infos;
}
function _getModules() {
  if (!moduleCache) {
    moduleCache = collectModules();
  }
  return moduleCache;
}
function getPackageJson() {
  try {
    const filePath = join3(process.cwd(), "package.json");
    const packageJson = JSON.parse(readFileSync(filePath, "utf8"));
    return packageJson;
  } catch {
    return {};
  }
}
function getModulesFromPackageJson() {
  const packageJson = getPackageJson();
  return {
    ...packageJson.dependencies,
    ...packageJson.devDependencies
  };
}

// ../../node_modules/@sentry/node-core/build/esm/utils/errorhandling.js
var DEFAULT_SHUTDOWN_TIMEOUT = 2000;
function logAndExitProcess(error2) {
  consoleSandbox(() => {
    console.error(error2);
  });
  const client = getClient();
  if (client === undefined) {
    DEBUG_BUILD2 && debug.warn("No NodeClient was defined, we are exiting the process now.");
    global.process.exit(1);
    return;
  }
  const options = client.getOptions();
  const timeout = options?.shutdownTimeout && options.shutdownTimeout > 0 ? options.shutdownTimeout : DEFAULT_SHUTDOWN_TIMEOUT;
  client.close(timeout).then((result) => {
    if (!result) {
      DEBUG_BUILD2 && debug.warn("We reached the timeout for emptying the request buffer, still exiting now!");
    }
    global.process.exit(1);
  }, (error3) => {
    DEBUG_BUILD2 && debug.error(error3);
  });
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/onuncaughtexception.js
var INTEGRATION_NAME12 = "OnUncaughtException";
var onUncaughtExceptionIntegration = defineIntegration((options = {}) => {
  const optionsWithDefaults = {
    exitEvenIfOtherHandlersAreRegistered: false,
    ...options
  };
  return {
    name: INTEGRATION_NAME12,
    setup(client) {
      global.process.on("uncaughtException", makeErrorHandler(client, optionsWithDefaults));
    }
  };
});
function makeErrorHandler(client, options) {
  const timeout = 2000;
  let caughtFirstError = false;
  let caughtSecondError = false;
  let calledFatalError = false;
  let firstError;
  const clientOptions = client.getOptions();
  return Object.assign((error2) => {
    let onFatalError = logAndExitProcess;
    if (options.onFatalError) {
      onFatalError = options.onFatalError;
    } else if (clientOptions.onFatalError) {
      onFatalError = clientOptions.onFatalError;
    }
    const userProvidedListenersCount = global.process.listeners("uncaughtException").filter((listener) => {
      return listener.name !== "domainUncaughtExceptionClear" && listener.tag !== "sentry_tracingErrorCallback" && listener._errorHandler !== true;
    }).length;
    const processWouldExit = userProvidedListenersCount === 0;
    const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;
    if (!caughtFirstError) {
      firstError = error2;
      caughtFirstError = true;
      if (getClient() === client) {
        captureException(error2, {
          originalException: error2,
          captureContext: {
            level: "fatal"
          },
          mechanism: {
            handled: false,
            type: "auto.node.onuncaughtexception"
          }
        });
      }
      if (!calledFatalError && shouldApplyFatalHandlingLogic) {
        calledFatalError = true;
        onFatalError(error2);
      }
    } else {
      if (shouldApplyFatalHandlingLogic) {
        if (calledFatalError) {
          DEBUG_BUILD2 && debug.warn("uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown");
          logAndExitProcess(error2);
        } else if (!caughtSecondError) {
          caughtSecondError = true;
          setTimeout(() => {
            if (!calledFatalError) {
              calledFatalError = true;
              onFatalError(firstError, error2);
            }
          }, timeout);
        }
      }
    }
  }, { _errorHandler: true });
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/onunhandledrejection.js
var INTEGRATION_NAME13 = "OnUnhandledRejection";
var _onUnhandledRejectionIntegration = (options = {}) => {
  const opts = {
    mode: "warn",
    ...options
  };
  return {
    name: INTEGRATION_NAME13,
    setup(client) {
      global.process.on("unhandledRejection", makeUnhandledPromiseHandler(client, opts));
    }
  };
};
var onUnhandledRejectionIntegration = defineIntegration(_onUnhandledRejectionIntegration);
function makeUnhandledPromiseHandler(client, options) {
  return function sendUnhandledPromise(reason, promise) {
    if (getClient() !== client) {
      return;
    }
    const level = options.mode === "strict" ? "fatal" : "error";
    const activeSpanForError = reason && typeof reason === "object" ? reason._sentry_active_span : undefined;
    const activeSpanWrapper = activeSpanForError ? (fn) => withActiveSpan(activeSpanForError, fn) : (fn) => fn();
    activeSpanWrapper(() => {
      captureException(reason, {
        originalException: promise,
        captureContext: {
          extra: { unhandledPromiseRejection: true },
          level
        },
        mechanism: {
          handled: false,
          type: "auto.node.onunhandledrejection"
        }
      });
    });
    handleRejection(reason, options.mode);
  };
}
function handleRejection(reason, mode) {
  const rejectionWarning = "This error originated either by " + "throwing inside of an async function without a catch block, " + "or by rejecting a promise which was not handled with .catch()." + " The promise rejected with the reason:";
  if (mode === "warn") {
    consoleSandbox(() => {
      console.warn(rejectionWarning);
      console.error(reason && typeof reason === "object" && "stack" in reason ? reason.stack : reason);
    });
  } else if (mode === "strict") {
    consoleSandbox(() => {
      console.warn(rejectionWarning);
    });
    logAndExitProcess(reason);
  }
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/spotlight.js
import * as http from "node:http";
var INTEGRATION_NAME14 = "Spotlight";
var _spotlightIntegration = (options = {}) => {
  const _options = {
    sidecarUrl: options.sidecarUrl || "http://localhost:8969/stream"
  };
  return {
    name: INTEGRATION_NAME14,
    setup(client) {
      try {
        if (false) {}
      } catch {}
      connectToSpotlight(client, _options);
    }
  };
};
var spotlightIntegration = defineIntegration(_spotlightIntegration);
function connectToSpotlight(client, options) {
  const spotlightUrl = parseSidecarUrl(options.sidecarUrl);
  if (!spotlightUrl) {
    return;
  }
  let failedRequests = 0;
  client.on("beforeEnvelope", (envelope) => {
    if (failedRequests > 3) {
      debug.warn("[Spotlight] Disabled Sentry -> Spotlight integration due to too many failed requests");
      return;
    }
    const serializedEnvelope = serializeEnvelope(envelope);
    suppressTracing(() => {
      const req = http.request({
        method: "POST",
        path: spotlightUrl.pathname,
        hostname: spotlightUrl.hostname,
        port: spotlightUrl.port,
        headers: {
          "Content-Type": "application/x-sentry-envelope"
        }
      }, (res) => {
        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 400) {
          failedRequests = 0;
        }
        res.on("data", () => {});
        res.on("end", () => {});
        res.setEncoding("utf8");
      });
      req.on("error", () => {
        failedRequests++;
        debug.warn("[Spotlight] Failed to send envelope to Spotlight Sidecar");
      });
      req.write(serializedEnvelope);
      req.end();
    });
  });
}
function parseSidecarUrl(url) {
  try {
    return new URL(`${url}`);
  } catch {
    debug.warn(`[Spotlight] Invalid sidecar URL: ${url}`);
    return;
  }
}

// ../../node_modules/@sentry/node-core/build/esm/integrations/systemError.js
import * as util from "node:util";
var INTEGRATION_NAME15 = "NodeSystemError";
function isSystemError(error2) {
  if (!(error2 instanceof Error)) {
    return false;
  }
  if (!("errno" in error2) || typeof error2.errno !== "number") {
    return false;
  }
  return util.getSystemErrorMap().has(error2.errno);
}
var systemErrorIntegration = defineIntegration((options = {}) => {
  return {
    name: INTEGRATION_NAME15,
    processEvent: (event, hint, client) => {
      if (!isSystemError(hint.originalException)) {
        return event;
      }
      const error2 = hint.originalException;
      const errorContext = {
        ...error2
      };
      if (!client.getOptions().sendDefaultPii && options.includePaths !== true) {
        delete errorContext.path;
        delete errorContext.dest;
      }
      event.contexts = {
        ...event.contexts,
        node_system_error: errorContext
      };
      for (const exception of event.exception?.values || []) {
        if (exception.value) {
          if (error2.path && exception.value.includes(error2.path)) {
            exception.value = exception.value.replace(`'${error2.path}'`, "").trim();
          }
          if (error2.dest && exception.value.includes(error2.dest)) {
            exception.value = exception.value.replace(`'${error2.dest}'`, "").trim();
          }
        }
      }
      return event;
    }
  };
});

// ../../node_modules/@sentry/node-core/build/esm/integrations/childProcess.js
import * as diagnosticsChannel from "node:diagnostics_channel";
var INTEGRATION_NAME16 = "ChildProcess";
var childProcessIntegration = defineIntegration((options = {}) => {
  return {
    name: INTEGRATION_NAME16,
    setup() {
      diagnosticsChannel.channel("child_process").subscribe((event) => {
        if (event && typeof event === "object" && "process" in event) {
          captureChildProcessEvents(event.process, options);
        }
      });
      diagnosticsChannel.channel("worker_threads").subscribe((event) => {
        if (event && typeof event === "object" && "worker" in event) {
          captureWorkerThreadEvents(event.worker, options);
        }
      });
    }
  };
});
function captureChildProcessEvents(child, options) {
  let hasExited = false;
  let data;
  child.on("spawn", () => {
    if (child.spawnfile === "/usr/bin/sw_vers") {
      hasExited = true;
      return;
    }
    data = { spawnfile: child.spawnfile };
    if (options.includeChildProcessArgs) {
      data.spawnargs = child.spawnargs;
    }
  }).on("exit", (code) => {
    if (!hasExited) {
      hasExited = true;
      if (code !== null && code !== 0) {
        addBreadcrumb({
          category: "child_process",
          message: `Child process exited with code '${code}'`,
          level: code === 0 ? "info" : "warning",
          data
        });
      }
    }
  }).on("error", (error2) => {
    if (!hasExited) {
      hasExited = true;
      addBreadcrumb({
        category: "child_process",
        message: `Child process errored with '${error2.message}'`,
        level: "error",
        data
      });
    }
  });
}
function captureWorkerThreadEvents(worker, options) {
  let threadId;
  worker.on("online", () => {
    threadId = worker.threadId;
  }).on("error", (error2) => {
    if (options.captureWorkerErrors !== false) {
      captureException(error2, {
        mechanism: { type: "auto.child_process.worker_thread", handled: false, data: { threadId: String(threadId) } }
      });
    } else {
      addBreadcrumb({
        category: "worker_thread",
        message: `Worker thread errored with '${error2.message}'`,
        level: "error",
        data: { threadId }
      });
    }
  });
}

// ../../node_modules/@sentry/node-core/build/esm/otel/contextManager.js
var import_context_async_hooks = __toESM(require_src10(), 1);
var SentryContextManager = wrapContextManagerClass(import_context_async_hooks.AsyncLocalStorageContextManager);
// ../../node_modules/@sentry/node-core/build/esm/otel/logger.js
var import_api6 = __toESM(require_src(), 1);
function setupOpenTelemetryLogger() {
  import_api6.diag.disable();
  import_api6.diag.setLogger({
    error: debug.error,
    warn: debug.warn,
    info: debug.log,
    debug: debug.log,
    verbose: debug.log
  }, import_api6.DiagLogLevel.DEBUG);
}
// ../../node_modules/@sentry/node-core/build/esm/integrations/processSession.js
var INTEGRATION_NAME17 = "ProcessSession";
var processSessionIntegration = defineIntegration(() => {
  return {
    name: INTEGRATION_NAME17,
    setupOnce() {
      startSession();
      process.on("beforeExit", () => {
        const session = getIsolationScope().getSession();
        if (session?.status !== "ok") {
          endSession();
        }
      });
    }
  };
});

// ../../node_modules/@sentry/node-core/build/esm/transports/http.js
import * as http3 from "node:http";
import * as https from "node:https";
import { Readable as Readable2 } from "node:stream";
import { createGzip } from "node:zlib";

// ../../node_modules/@sentry/node-core/build/esm/proxy/index.js
import * as net from "node:net";
import * as tls from "node:tls";

// ../../node_modules/@sentry/node-core/build/esm/proxy/base.js
import * as http2 from "node:http";
var INTERNAL = Symbol("AgentBaseInternalState");

class Agent2 extends http2.Agent {
  constructor(opts) {
    super(opts);
    this[INTERNAL] = {};
  }
  isSecureEndpoint(options) {
    if (options) {
      if (typeof options.secureEndpoint === "boolean") {
        return options.secureEndpoint;
      }
      if (typeof options.protocol === "string") {
        return options.protocol === "https:";
      }
    }
    const { stack } = new Error;
    if (typeof stack !== "string")
      return false;
    return stack.split(`
`).some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  createSocket(req, options, cb) {
    const connectOpts = {
      ...options,
      secureEndpoint: this.isSecureEndpoint(options)
    };
    Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
      if (socket instanceof http2.Agent) {
        return socket.addRequest(req, connectOpts);
      }
      this[INTERNAL].currentSocket = socket;
      super.createSocket(req, options, cb);
    }, cb);
  }
  createConnection() {
    const socket = this[INTERNAL].currentSocket;
    this[INTERNAL].currentSocket = undefined;
    if (!socket) {
      throw new Error("No socket was returned in the `connect()` function");
    }
    return socket;
  }
  get defaultPort() {
    return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
  }
  set defaultPort(v) {
    if (this[INTERNAL]) {
      this[INTERNAL].defaultPort = v;
    }
  }
  get protocol() {
    return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
  }
  set protocol(v) {
    if (this[INTERNAL]) {
      this[INTERNAL].protocol = v;
    }
  }
}

// ../../node_modules/@sentry/node-core/build/esm/proxy/parse-proxy-response.js
function debugLog(...args) {
  debug.log("[https-proxy-agent:parse-proxy-response]", ...args);
}
function parseProxyResponse(socket) {
  return new Promise((resolve2, reject) => {
    let buffersLength = 0;
    const buffers = [];
    function read() {
      const b = socket.read();
      if (b)
        ondata(b);
      else
        socket.once("readable", read);
    }
    function cleanup() {
      socket.removeListener("end", onend);
      socket.removeListener("error", onerror);
      socket.removeListener("readable", read);
    }
    function onend() {
      cleanup();
      debugLog("onend");
      reject(new Error("Proxy connection ended before receiving CONNECT response"));
    }
    function onerror(err) {
      cleanup();
      debugLog("onerror %o", err);
      reject(err);
    }
    function ondata(b) {
      buffers.push(b);
      buffersLength += b.length;
      const buffered = Buffer.concat(buffers, buffersLength);
      const endOfHeaders = buffered.indexOf(`\r
\r
`);
      if (endOfHeaders === -1) {
        debugLog("have not received end of HTTP headers yet...");
        read();
        return;
      }
      const headerParts = buffered.subarray(0, endOfHeaders).toString("ascii").split(`\r
`);
      const firstLine = headerParts.shift();
      if (!firstLine) {
        socket.destroy();
        return reject(new Error("No header received from proxy CONNECT response"));
      }
      const firstLineParts = firstLine.split(" ");
      const statusCode = +(firstLineParts[1] || 0);
      const statusText = firstLineParts.slice(2).join(" ");
      const headers = {};
      for (const header of headerParts) {
        if (!header)
          continue;
        const firstColon = header.indexOf(":");
        if (firstColon === -1) {
          socket.destroy();
          return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
        }
        const key = header.slice(0, firstColon).toLowerCase();
        const value = header.slice(firstColon + 1).trimStart();
        const current = headers[key];
        if (typeof current === "string") {
          headers[key] = [current, value];
        } else if (Array.isArray(current)) {
          current.push(value);
        } else {
          headers[key] = value;
        }
      }
      debugLog("got proxy server response: %o %o", firstLine, headers);
      cleanup();
      resolve2({
        connect: {
          statusCode,
          statusText,
          headers
        },
        buffered
      });
    }
    socket.on("error", onerror);
    socket.on("end", onend);
    read();
  });
}

// ../../node_modules/@sentry/node-core/build/esm/proxy/index.js
function debugLog2(...args) {
  debug.log("[https-proxy-agent]", ...args);
}

class HttpsProxyAgent extends Agent2 {
  static __initStatic() {
    this.protocols = ["http", "https"];
  }
  constructor(proxy, opts) {
    super(opts);
    this.options = {};
    this.proxy = typeof proxy === "string" ? new URL(proxy) : proxy;
    this.proxyHeaders = opts?.headers ?? {};
    debugLog2("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      ALPNProtocols: ["http/1.1"],
      ...opts ? omit(opts, "headers") : null,
      host,
      port
    };
  }
  async connect(req, opts) {
    const { proxy } = this;
    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }
    let socket;
    if (proxy.protocol === "https:") {
      debugLog2("Creating `tls.Socket`: %o", this.connectOpts);
      const servername = this.connectOpts.servername || this.connectOpts.host;
      socket = tls.connect({
        ...this.connectOpts,
        servername: servername && net.isIP(servername) ? undefined : servername
      });
    } else {
      debugLog2("Creating `net.Socket`: %o", this.connectOpts);
      socket = net.connect(this.connectOpts);
    }
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    headers.Host = `${host}:${opts.port}`;
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name of Object.keys(headers)) {
      payload += `${name}: ${headers[name]}\r
`;
    }
    const proxyResponsePromise = parseProxyResponse(socket);
    socket.write(`${payload}\r
`);
    const { connect: connect3, buffered } = await proxyResponsePromise;
    req.emit("proxyConnect", connect3);
    this.emit("proxyConnect", connect3, req);
    if (connect3.statusCode === 200) {
      req.once("socket", resume);
      if (opts.secureEndpoint) {
        debugLog2("Upgrading socket connection to TLS");
        const servername = opts.servername || opts.host;
        return tls.connect({
          ...omit(opts, "host", "path", "port"),
          socket,
          servername: net.isIP(servername) ? undefined : servername
        });
      }
      return socket;
    }
    socket.destroy();
    const fakeSocket = new net.Socket({ writable: false });
    fakeSocket.readable = true;
    req.once("socket", (s) => {
      debugLog2("Replaying proxy buffer for failed request");
      s.push(buffered);
      s.push(null);
    });
    return fakeSocket;
  }
}
HttpsProxyAgent.__initStatic();
function resume(socket) {
  socket.resume();
}
function omit(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}

// ../../node_modules/@sentry/node-core/build/esm/transports/http.js
var GZIP_THRESHOLD = 1024 * 32;
function streamFromBody(body) {
  return new Readable2({
    read() {
      this.push(body);
      this.push(null);
    }
  });
}
function makeNodeTransport(options) {
  let urlSegments;
  try {
    urlSegments = new URL(options.url);
  } catch (e) {
    consoleSandbox(() => {
      console.warn("[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.");
    });
    return createTransport(options, () => Promise.resolve({}));
  }
  const isHttps = urlSegments.protocol === "https:";
  const proxy = applyNoProxyOption(urlSegments, options.proxy || (isHttps ? process.env.https_proxy : undefined) || process.env.http_proxy);
  const nativeHttpModule = isHttps ? https : http3;
  const keepAlive = options.keepAlive === undefined ? false : options.keepAlive;
  const agent = proxy ? new HttpsProxyAgent(proxy) : new nativeHttpModule.Agent({ keepAlive, maxSockets: 30, timeout: 2000 });
  const requestExecutor = createRequestExecutor(options, options.httpModule ?? nativeHttpModule, agent);
  return createTransport(options, requestExecutor);
}
function applyNoProxyOption(transportUrlSegments, proxy) {
  const { no_proxy } = process.env;
  const urlIsExemptFromProxy = no_proxy?.split(",").some((exemption) => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption));
  if (urlIsExemptFromProxy) {
    return;
  } else {
    return proxy;
  }
}
function createRequestExecutor(options, httpModule, agent) {
  const { hostname, pathname, port, protocol, search } = new URL(options.url);
  return function makeRequest(request2) {
    return new Promise((resolve2, reject) => {
      suppressTracing(() => {
        let body = streamFromBody(request2.body);
        const headers = { ...options.headers };
        if (request2.body.length > GZIP_THRESHOLD) {
          headers["content-encoding"] = "gzip";
          body = body.pipe(createGzip());
        }
        const req = httpModule.request({
          method: "POST",
          agent,
          headers,
          hostname,
          path: `${pathname}${search}`,
          port,
          protocol,
          ca: options.caCerts
        }, (res) => {
          res.on("data", () => {});
          res.on("end", () => {});
          res.setEncoding("utf8");
          const retryAfterHeader = res.headers["retry-after"] ?? null;
          const rateLimitsHeader = res.headers["x-sentry-rate-limits"] ?? null;
          resolve2({
            statusCode: res.statusCode,
            headers: {
              "retry-after": retryAfterHeader,
              "x-sentry-rate-limits": Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] || null : rateLimitsHeader
            }
          });
        });
        req.on("error", reject);
        body.pipe(req);
      });
    });
  };
}

// ../../node_modules/@sentry/node-core/build/esm/utils/envToBool.js
var FALSY_ENV_VALUES = new Set(["false", "f", "n", "no", "off", "0"]);
var TRUTHY_ENV_VALUES = new Set(["true", "t", "y", "yes", "on", "1"]);
function envToBool(value, options) {
  const normalized = String(value).toLowerCase();
  if (FALSY_ENV_VALUES.has(normalized)) {
    return false;
  }
  if (TRUTHY_ENV_VALUES.has(normalized)) {
    return true;
  }
  return options?.strict ? null : Boolean(value);
}

// ../../node_modules/@sentry/node-core/build/esm/utils/module.js
import { posix, sep } from "node:path";
function normalizeWindowsPath(path7) {
  return path7.replace(/^[A-Z]:/, "").replace(/\\/g, "/");
}
function createGetModuleFromFilename(basePath = process.argv[1] ? dirname(process.argv[1]) : process.cwd(), isWindows = sep === "\\") {
  const normalizedBase = isWindows ? normalizeWindowsPath(basePath) : basePath;
  return (filename) => {
    if (!filename) {
      return;
    }
    const normalizedFilename = isWindows ? normalizeWindowsPath(filename) : filename;
    let { dir, base: file, ext } = posix.parse(normalizedFilename);
    if (ext === ".js" || ext === ".mjs" || ext === ".cjs") {
      file = file.slice(0, ext.length * -1);
    }
    const decodedFile = decodeURIComponent(file);
    if (!dir) {
      dir = ".";
    }
    const n = dir.lastIndexOf("/node_modules");
    if (n > -1) {
      return `${dir.slice(n + 14).replace(/\//g, ".")}:${decodedFile}`;
    }
    if (dir.startsWith(normalizedBase)) {
      const moduleName = dir.slice(normalizedBase.length + 1).replace(/\//g, ".");
      return moduleName ? `${moduleName}:${decodedFile}` : decodedFile;
    }
    return decodedFile;
  };
}

// ../../node_modules/@sentry/node-core/build/esm/sdk/api.js
function getSentryRelease(fallback) {
  if (process.env.SENTRY_RELEASE) {
    return process.env.SENTRY_RELEASE;
  }
  if (GLOBAL_OBJ.SENTRY_RELEASE?.id) {
    return GLOBAL_OBJ.SENTRY_RELEASE.id;
  }
  const possibleReleaseNameOfGitProvider = process.env["GITHUB_SHA"] || process.env["CI_MERGE_REQUEST_SOURCE_BRANCH_SHA"] || process.env["CI_BUILD_REF"] || process.env["CI_COMMIT_SHA"] || process.env["BITBUCKET_COMMIT"];
  const possibleReleaseNameOfCiProvidersWithSpecificEnvVar = process.env["APPVEYOR_PULL_REQUEST_HEAD_COMMIT"] || process.env["APPVEYOR_REPO_COMMIT"] || process.env["CODEBUILD_RESOLVED_SOURCE_VERSION"] || process.env["AWS_COMMIT_ID"] || process.env["BUILD_SOURCEVERSION"] || process.env["GIT_CLONE_COMMIT_HASH"] || process.env["BUDDY_EXECUTION_REVISION"] || process.env["BUILDKITE_COMMIT"] || process.env["CIRCLE_SHA1"] || process.env["CIRRUS_CHANGE_IN_REPO"] || process.env["CF_REVISION"] || process.env["CM_COMMIT"] || process.env["CF_PAGES_COMMIT_SHA"] || process.env["DRONE_COMMIT_SHA"] || process.env["FC_GIT_COMMIT_SHA"] || process.env["HEROKU_TEST_RUN_COMMIT_VERSION"] || process.env["HEROKU_SLUG_COMMIT"] || process.env["RAILWAY_GIT_COMMIT_SHA"] || process.env["RENDER_GIT_COMMIT"] || process.env["SEMAPHORE_GIT_SHA"] || process.env["TRAVIS_PULL_REQUEST_SHA"] || process.env["VERCEL_GIT_COMMIT_SHA"] || process.env["VERCEL_GITHUB_COMMIT_SHA"] || process.env["VERCEL_GITLAB_COMMIT_SHA"] || process.env["VERCEL_BITBUCKET_COMMIT_SHA"] || process.env["ZEIT_GITHUB_COMMIT_SHA"] || process.env["ZEIT_GITLAB_COMMIT_SHA"] || process.env["ZEIT_BITBUCKET_COMMIT_SHA"];
  const possibleReleaseNameOfCiProvidersWithGenericEnvVar = process.env["CI_COMMIT_ID"] || process.env["SOURCE_COMMIT"] || process.env["SOURCE_VERSION"] || process.env["GIT_COMMIT"] || process.env["COMMIT_REF"] || process.env["BUILD_VCS_NUMBER"] || process.env["CI_COMMIT_SHA"];
  return possibleReleaseNameOfGitProvider || possibleReleaseNameOfCiProvidersWithSpecificEnvVar || possibleReleaseNameOfCiProvidersWithGenericEnvVar || fallback;
}
var defaultStackParser = createStackParser(nodeStackLineParser(createGetModuleFromFilename()));

// ../../node_modules/@sentry/node-core/build/esm/sdk/client.js
var import_api7 = __toESM(require_src(), 1);
var import_instrumentation4 = __toESM(require_src6(), 1);
import * as os2 from "node:os";
import { threadId, isMainThread } from "worker_threads";
var DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS = 60000;

class NodeClient extends ServerRuntimeClient {
  constructor(options) {
    const serverName = options.includeServerName === false ? undefined : options.serverName || global.process.env.SENTRY_NAME || os2.hostname();
    const clientOptions = {
      ...options,
      platform: "node",
      runtime: { name: "node", version: global.process.version },
      serverName
    };
    if (options.openTelemetryInstrumentations) {
      import_instrumentation4.registerInstrumentations({
        instrumentations: options.openTelemetryInstrumentations
      });
    }
    applySdkMetadata(clientOptions, "node");
    debug.log(`Initializing Sentry: process: ${process.pid}, thread: ${isMainThread ? "main" : `worker-${threadId}`}.`);
    super(clientOptions);
    if (this.getOptions().enableLogs) {
      this._logOnExitFlushListener = () => {
        _INTERNAL_flushLogsBuffer(this);
      };
      if (serverName) {
        this.on("beforeCaptureLog", (log3) => {
          log3.attributes = {
            ...log3.attributes,
            "server.address": serverName
          };
        });
      }
      process.on("beforeExit", this._logOnExitFlushListener);
    }
  }
  get tracer() {
    if (this._tracer) {
      return this._tracer;
    }
    const name = "@sentry/node";
    const version = SDK_VERSION;
    const tracer = import_api7.trace.getTracer(name, version);
    this._tracer = tracer;
    return tracer;
  }
  async flush(timeout) {
    await this.traceProvider?.forceFlush();
    if (this.getOptions().sendClientReports) {
      this._flushOutcomes();
    }
    return super.flush(timeout);
  }
  close(timeout) {
    if (this._clientReportInterval) {
      clearInterval(this._clientReportInterval);
    }
    if (this._clientReportOnExitFlushListener) {
      process.off("beforeExit", this._clientReportOnExitFlushListener);
    }
    if (this._logOnExitFlushListener) {
      process.off("beforeExit", this._logOnExitFlushListener);
    }
    return super.close(timeout).then((allEventsSent) => this.traceProvider ? this.traceProvider.shutdown().then(() => allEventsSent) : allEventsSent);
  }
  startClientReportTracking() {
    const clientOptions = this.getOptions();
    if (clientOptions.sendClientReports) {
      this._clientReportOnExitFlushListener = () => {
        this._flushOutcomes();
      };
      this._clientReportInterval = setInterval(() => {
        DEBUG_BUILD2 && debug.log("Flushing client reports based on interval.");
        this._flushOutcomes();
      }, clientOptions.clientReportFlushInterval ?? DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS).unref();
      process.on("beforeExit", this._clientReportOnExitFlushListener);
    }
  }
  _getTraceInfoFromScope(scope) {
    if (!scope) {
      return [undefined, undefined];
    }
    return getTraceContextForScope(this, scope);
  }
}

// ../../node_modules/@sentry/node-core/build/esm/sdk/esmLoader.js
var import_import_in_the_middle = __toESM(require_import_in_the_middle(), 1);
import * as moduleModule from "module";
function initializeEsmLoader() {
  if (!supportsEsmLoaderHooks()) {
    return;
  }
  if (!GLOBAL_OBJ._sentryEsmLoaderHookRegistered) {
    GLOBAL_OBJ._sentryEsmLoaderHookRegistered = true;
    try {
      const { addHookMessagePort } = import_import_in_the_middle.createAddHookMessageChannel();
      moduleModule.register("import-in-the-middle/hook.mjs", import.meta.url, {
        data: { addHookMessagePort, include: [] },
        transferList: [addHookMessagePort]
      });
    } catch (error2) {
      debug.warn("Failed to register 'import-in-the-middle' hook", error2);
    }
  }
}

// ../../node_modules/@sentry/node-core/build/esm/sdk/index.js
function getDefaultIntegrations() {
  return [
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    linkedErrorsIntegration(),
    requestDataIntegration(),
    systemErrorIntegration(),
    consoleIntegration(),
    httpIntegration(),
    nativeNodeFetchIntegration(),
    onUncaughtExceptionIntegration(),
    onUnhandledRejectionIntegration(),
    contextLinesIntegration(),
    localVariablesIntegration(),
    nodeContextIntegration(),
    childProcessIntegration(),
    processSessionIntegration(),
    modulesIntegration()
  ];
}
function init(options = {}) {
  return _init(options, getDefaultIntegrations);
}
function _init(_options = {}, getDefaultIntegrationsImpl) {
  const options = getClientOptions(_options, getDefaultIntegrationsImpl);
  if (options.debug === true) {
    if (DEBUG_BUILD2) {
      debug.enable();
    } else {
      consoleSandbox(() => {
        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
      });
    }
  }
  if (options.registerEsmLoaderHooks !== false) {
    initializeEsmLoader();
  }
  setOpenTelemetryContextAsyncContextStrategy();
  const scope = getCurrentScope();
  scope.update(options.initialScope);
  if (options.spotlight && !options.integrations.some(({ name }) => name === INTEGRATION_NAME14)) {
    options.integrations.push(spotlightIntegration({
      sidecarUrl: typeof options.spotlight === "string" ? options.spotlight : undefined
    }));
  }
  applySdkMetadata(options, "node-core");
  const client = new NodeClient(options);
  getCurrentScope().setClient(client);
  client.init();
  debug.log(`SDK initialized from ${isCjs() ? "CommonJS" : "ESM"}`);
  client.startClientReportTracking();
  updateScopeFromEnvVariables();
  enhanceDscWithOpenTelemetryRootSpanName(client);
  setupEventContextTrace(client);
  return client;
}
function validateOpenTelemetrySetup() {
  if (!DEBUG_BUILD2) {
    return;
  }
  const setup = openTelemetrySetupCheck();
  const required = ["SentryContextManager", "SentryPropagator"];
  if (hasSpansEnabled()) {
    required.push("SentrySpanProcessor");
  }
  for (const k of required) {
    if (!setup.includes(k)) {
      debug.error(`You have to set up the ${k}. Without this, the OpenTelemetry & Sentry integration will not work properly.`);
    }
  }
  if (!setup.includes("SentrySampler")) {
    debug.warn("You have to set up the SentrySampler. Without this, the OpenTelemetry & Sentry integration may still work, but sample rates set for the Sentry SDK will not be respected. If you use a custom sampler, make sure to use `wrapSamplingDecision`.");
  }
}
function getClientOptions(options, getDefaultIntegrationsImpl) {
  const release2 = getRelease(options.release);
  const spotlight = options.spotlight ?? envToBool(process.env.SENTRY_SPOTLIGHT, { strict: true }) ?? process.env.SENTRY_SPOTLIGHT;
  const tracesSampleRate = getTracesSampleRate(options.tracesSampleRate);
  const mergedOptions = {
    ...options,
    dsn: options.dsn ?? process.env.SENTRY_DSN,
    environment: options.environment ?? process.env.SENTRY_ENVIRONMENT,
    sendClientReports: options.sendClientReports ?? true,
    transport: options.transport ?? makeNodeTransport,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    release: release2,
    tracesSampleRate,
    spotlight,
    debug: envToBool(options.debug ?? process.env.SENTRY_DEBUG)
  };
  const integrations = options.integrations;
  const defaultIntegrations = options.defaultIntegrations ?? getDefaultIntegrationsImpl(mergedOptions);
  return {
    ...mergedOptions,
    integrations: getIntegrationsToSetup({
      defaultIntegrations,
      integrations
    })
  };
}
function getRelease(release2) {
  if (release2 !== undefined) {
    return release2;
  }
  const detectedRelease = getSentryRelease();
  if (detectedRelease !== undefined) {
    return detectedRelease;
  }
  return;
}
function getTracesSampleRate(tracesSampleRate) {
  if (tracesSampleRate !== undefined) {
    return tracesSampleRate;
  }
  const sampleRateFromEnv = process.env.SENTRY_TRACES_SAMPLE_RATE;
  if (!sampleRateFromEnv) {
    return;
  }
  const parsed = parseFloat(sampleRateFromEnv);
  return isFinite(parsed) ? parsed : undefined;
}
function updateScopeFromEnvVariables() {
  if (envToBool(process.env.SENTRY_USE_ENVIRONMENT) !== false) {
    const sentryTraceEnv = process.env.SENTRY_TRACE;
    const baggageEnv = process.env.SENTRY_BAGGAGE;
    const propagationContext = propagationContextFromHeaders(sentryTraceEnv, baggageEnv);
    getCurrentScope().setPropagationContext(propagationContext);
  }
}
// ../../node_modules/@sentry/node-core/build/esm/utils/addOriginToSpan.js
function addOriginToSpan2(span, origin) {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);
}
// ../../node_modules/@sentry/node/build/esm/integrations/http.js
var INTEGRATION_NAME18 = "Http";
var INSTRUMENTATION_NAME2 = "@opentelemetry_sentry-patched/instrumentation-http";
var instrumentSentryHttp2 = generateInstrumentOnce(`${INTEGRATION_NAME18}.sentry`, (options) => {
  return new SentryHttpInstrumentation(options);
});
var instrumentOtelHttp = generateInstrumentOnce(INTEGRATION_NAME18, (config) => {
  const instrumentation = new import_instrumentation_http.HttpInstrumentation({
    ...config,
    disableIncomingRequestInstrumentation: true
  });
  try {
    instrumentation["_diag"] = import_api9.diag.createComponentLogger({
      namespace: INSTRUMENTATION_NAME2
    });
    instrumentation.instrumentationName = INSTRUMENTATION_NAME2;
  } catch {}
  return instrumentation;
});
function _shouldUseOtelHttpInstrumentation(options, clientOptions = {}) {
  if (typeof options.spans === "boolean") {
    return options.spans;
  }
  if (clientOptions.skipOpenTelemetrySetup) {
    return false;
  }
  if (!hasSpansEnabled(clientOptions) && NODE_VERSION.major >= 22) {
    return false;
  }
  return true;
}
var httpIntegration2 = defineIntegration((options = {}) => {
  const dropSpansForIncomingRequestStatusCodes = options.dropSpansForIncomingRequestStatusCodes ?? [
    [401, 404],
    [300, 399]
  ];
  return {
    name: INTEGRATION_NAME18,
    setupOnce() {
      const clientOptions = getClient()?.getOptions() || {};
      const useOtelHttpInstrumentation = _shouldUseOtelHttpInstrumentation(options, clientOptions);
      const disableIncomingRequestSpans = options.disableIncomingRequestSpans ?? !hasSpansEnabled(clientOptions);
      instrumentSentryHttp2({
        ...options,
        disableIncomingRequestSpans,
        ignoreSpansForIncomingRequests: options.ignoreIncomingRequests,
        propagateTraceInOutgoingRequests: !useOtelHttpInstrumentation
      });
      if (useOtelHttpInstrumentation) {
        const instrumentationConfig = getConfigWithDefaults(options);
        instrumentOtelHttp(instrumentationConfig);
      }
    },
    processEvent(event) {
      if (event.type === "transaction") {
        const statusCode = event.contexts?.trace?.data?.["http.response.status_code"];
        if (typeof statusCode === "number" && dropSpansForIncomingRequestStatusCodes.some((code) => {
          if (typeof code === "number") {
            return code === statusCode;
          }
          const [min, max] = code;
          return statusCode >= min && statusCode <= max;
        })) {
          return null;
        }
      }
      return event;
    }
  };
});
function getConfigWithDefaults(options = {}) {
  const instrumentationConfig = {
    ignoreOutgoingRequestHook: (request2) => {
      const url = getRequestUrl(request2);
      if (!url) {
        return false;
      }
      const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;
      if (_ignoreOutgoingRequests?.(url, request2)) {
        return true;
      }
      return false;
    },
    requireParentforOutgoingSpans: false,
    requestHook: (span, req) => {
      addOriginToSpan2(span, "auto.http.otel.http");
      options.instrumentation?.requestHook?.(span, req);
    },
    responseHook: (span, res) => {
      options.instrumentation?.responseHook?.(span, res);
    },
    applyCustomAttributesOnSpan: (span, request2, response) => {
      options.instrumentation?.applyCustomAttributesOnSpan?.(span, request2, response);
    }
  };
  return instrumentationConfig;
}

// ../../node_modules/@sentry/node/build/esm/integrations/node-fetch.js
var import_instrumentation_undici = __toESM(require_src11(), 1);
var INTEGRATION_NAME19 = "NodeFetch";
var instrumentOtelNodeFetch = generateInstrumentOnce(INTEGRATION_NAME19, import_instrumentation_undici.UndiciInstrumentation, (options) => {
  return getConfigWithDefaults2(options);
});
var instrumentSentryNodeFetch2 = generateInstrumentOnce(`${INTEGRATION_NAME19}.sentry`, SentryNodeFetchInstrumentation, (options) => {
  return options;
});
var _nativeNodeFetchIntegration2 = (options = {}) => {
  return {
    name: "NodeFetch",
    setupOnce() {
      const instrumentSpans = _shouldInstrumentSpans(options, getClient()?.getOptions());
      if (instrumentSpans) {
        instrumentOtelNodeFetch(options);
      }
      instrumentSentryNodeFetch2(options);
    }
  };
};
var nativeNodeFetchIntegration2 = defineIntegration(_nativeNodeFetchIntegration2);
function getAbsoluteUrl3(origin, path7 = "/") {
  const url = `${origin}`;
  if (url.endsWith("/") && path7.startsWith("/")) {
    return `${url}${path7.slice(1)}`;
  }
  if (!url.endsWith("/") && !path7.startsWith("/")) {
    return `${url}/${path7.slice(1)}`;
  }
  return `${url}${path7}`;
}
function _shouldInstrumentSpans(options, clientOptions = {}) {
  return typeof options.spans === "boolean" ? options.spans : !clientOptions.skipOpenTelemetrySetup && hasSpansEnabled(clientOptions);
}
function getConfigWithDefaults2(options = {}) {
  const instrumentationConfig = {
    requireParentforSpans: false,
    ignoreRequestHook: (request2) => {
      const url = getAbsoluteUrl3(request2.origin, request2.path);
      const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;
      const shouldIgnore = _ignoreOutgoingRequests && url && _ignoreOutgoingRequests(url);
      return !!shouldIgnore;
    },
    startSpanHook: () => {
      return {
        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.otel.node_fetch"
      };
    }
  };
  return instrumentationConfig;
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/express.js
var import_instrumentation_express = __toESM(require_src12(), 1);

// ../../node_modules/@sentry/node/build/esm/debug-build.js
var DEBUG_BUILD4 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/express.js
var INTEGRATION_NAME20 = "Express";
function requestHook(span) {
  addOriginToSpan2(span, "auto.http.otel.express");
  const attributes = spanToJSON(span).data;
  const type = attributes["express.type"];
  if (type) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, `${type}.express`);
  }
  const name = attributes["express.name"];
  if (typeof name === "string") {
    span.updateName(name);
  }
}
function spanNameHook(info, defaultName) {
  if (getIsolationScope() === getDefaultIsolationScope()) {
    DEBUG_BUILD4 && debug.warn("Isolation scope is still default isolation scope - skipping setting transactionName");
    return defaultName;
  }
  if (info.layerType === "request_handler") {
    const req = info.request;
    const method = req.method ? req.method.toUpperCase() : "GET";
    getIsolationScope().setTransactionName(`${method} ${info.route}`);
  }
  return defaultName;
}
var instrumentExpress = generateInstrumentOnce(INTEGRATION_NAME20, () => new import_instrumentation_express.ExpressInstrumentation({
  requestHook: (span) => requestHook(span),
  spanNameHook: (info, defaultName) => spanNameHook(info, defaultName)
}));
var _expressIntegration = () => {
  return {
    name: INTEGRATION_NAME20,
    setupOnce() {
      instrumentExpress();
    }
  };
};
var expressIntegration = defineIntegration(_expressIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify/index.js
import * as dc from "node:diagnostics_channel";

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify/fastify-otel/index.js
var import_api10 = __toESM(require_src(), 1);
var import_core72 = __toESM(require_src3(), 1);
var import_instrumentation5 = __toESM(require_src6(), 1);
var import_semantic_conventions3 = __toESM(require_src2(), 1);
import dc__default from "node:diagnostics_channel";

// ../../node_modules/@sentry/node/node_modules/minimatch/dist/esm/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// ../../node_modules/@sentry/node/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// ../../node_modules/@sentry/node/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x" + "00-\\x" + "7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i < glob.length) {
      const c = glob.charAt(i);
      if ((c === "!" || c === "^") && i === pos + 1) {
        negate = true;
        i++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      sawStart = true;
      if (c === "\\") {
        if (!escaping) {
          escaping = true;
          i++;
          continue;
        }
      }
      if (c === "[" && !escaping) {
        for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos, true];
            }
            i += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
        } else if (c === rangeStart) {
          ranges.push(braceEscape(c));
        }
        rangeStart = "";
        i++;
        continue;
      }
      if (glob.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c + "-"));
        i += 2;
        continue;
      }
      if (glob.startsWith("-", i + 1)) {
        rangeStart = c;
        i += 2;
        continue;
      }
      ranges.push(braceEscape(c));
      i++;
    }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// ../../node_modules/@sentry/node/node_modules/minimatch/dist/esm/unescape.js
var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// ../../node_modules/@sentry/node/node_modules/minimatch/dist/esm/ast.js
var types = new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = new Set(["[", "."]);
var justDots = new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";

class AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== undefined)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  toString() {
    if (this.#toString !== undefined)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n;
    while (n = this.#negs.pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = p.#parent;
      while (pp) {
        for (let i = p.#parentIndex + 1;!pp.type && i < pp.#parts.length; i++) {
          for (const part of n.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i]);
          }
        }
        p = pp;
        pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i = 0;i < this.#parentIndex; i++) {
      const pp = p.#parts[i];
      if (!(pp instanceof AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new AST(this.type, parent);
    for (const p of this.#parts) {
      c.copyIn(p);
    }
    return c;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str.length) {
        const c = str.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext = new AST(c, ast);
          i2 = AST.#parseAST(str, ext, i2, opt);
          ast.push(ext);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str.length) {
      const c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext = new AST(c, part);
        part.push(ext);
        i = AST.#parseAST(str, ext, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    ast.#hasMagic = undefined;
    ast.#parts = [str.substring(pos - 1)];
    return i;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new AST(null, undefined, options);
    AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  get options() {
    return this.#options;
  }
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p) => {
        const [re, _, hasMagic, uflag] = typeof p === "string" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4));
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      this.#parts = [s];
      this.type = null;
      this.#hasMagic = undefined;
      return [s, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close2 = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close2;
    }
    return [
      final,
      unescape(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob, hasMagic, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0;i < glob.length; i++) {
      const c = glob.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic = hasMagic || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape(glob), !!hasMagic, uflag];
  }
}

// ../../node_modules/@sentry/node/node_modules/minimatch/dist/esm/escape.js
var escape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// ../../node_modules/@sentry/node/node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext) => (f) => !f.startsWith(".") && f.endsWith(ext);
var starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
var starDotExtTestNocase = (ext) => {
  ext = ext.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext);
};
var starDotExtTestNocaseDot = (ext) => {
  ext = ext.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext)
    return noext;
  ext = ext.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
var qmarksTestNocaseDot = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext)
    return noext;
  ext = ext.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
var qmarksTestDot = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
var qmarksTest = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path7 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep2 = defaultPlatform === "win32" ? path7.win32.sep : path7.posix.sep;
minimatch.sep = sep2;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST2 extends orig.AST {
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return import_brace_expansion.default(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match2 = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match2;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");

class Minimatch {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {}
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0;i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0;i < globParts.length; i++) {
        for (let j = 0;j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1;i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1;i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  secondPhasePreProcess(globParts) {
    for (let i = 0;i < globParts.length - 1; i++) {
      for (let j = i + 1;j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0;i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (;fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug(`
globstar while`, file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug(`
>>> no match, partial?`, file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === undefined) {
          if (next !== undefined && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === undefined) {
          pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close2] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close2 + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2;!filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0;i < set.length; i++) {
      const pattern = set[i];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
}
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify/fastify-otel/index.js
var PACKAGE_NAME = "@fastify/otel";
var PACKAGE_VERSION = "0.8.0";
var SUPPORTED_VERSIONS = ">=4.0.0 <6";
var FASTIFY_HOOKS = [
  "onRequest",
  "preParsing",
  "preValidation",
  "preHandler",
  "preSerialization",
  "onSend",
  "onResponse",
  "onError"
];
var ATTRIBUTE_NAMES = {
  HOOK_NAME: "hook.name",
  FASTIFY_TYPE: "fastify.type",
  HOOK_CALLBACK_NAME: "hook.callback.name",
  ROOT: "fastify.root"
};
var HOOK_TYPES = {
  ROUTE: "route-hook",
  INSTANCE: "hook",
  HANDLER: "request-handler"
};
var ANONYMOUS_FUNCTION_NAME = "anonymous";
var kInstrumentation = Symbol("fastify otel instance");
var kRequestSpan = Symbol("fastify otel request spans");
var kRequestContext = Symbol("fastify otel request context");
var kAddHookOriginal = Symbol("fastify otel addhook original");
var kSetNotFoundOriginal = Symbol("fastify otel setnotfound original");
var kIgnorePaths = Symbol("fastify otel ignore path");

class FastifyOtelInstrumentation extends import_instrumentation5.InstrumentationBase {
  constructor(config) {
    super(PACKAGE_NAME, PACKAGE_VERSION, config);
    this.servername = config?.servername ?? process.env.OTEL_SERVICE_NAME ?? "fastify";
    this[kIgnorePaths] = null;
    this._logger = import_api10.diag.createComponentLogger({ namespace: PACKAGE_NAME });
    if (config?.ignorePaths != null || process.env.OTEL_FASTIFY_IGNORE_PATHS != null) {
      const ignorePaths = config?.ignorePaths ?? process.env.OTEL_FASTIFY_IGNORE_PATHS;
      if ((typeof ignorePaths !== "string" || ignorePaths.length === 0) && typeof ignorePaths !== "function") {
        throw new TypeError("ignorePaths must be a string or a function");
      }
      const globMatcher = minimatch;
      this[kIgnorePaths] = (routeOptions) => {
        if (typeof ignorePaths === "function") {
          return ignorePaths(routeOptions);
        } else {
          return globMatcher(routeOptions.url, ignorePaths);
        }
      };
    }
  }
  enable() {
    if (this._handleInitialization === undefined && this.getConfig().registerOnInitialization) {
      const FastifyInstrumentationPlugin = this.plugin();
      this._handleInitialization = (message) => {
        message.fastify.register(FastifyInstrumentationPlugin);
      };
      dc__default.subscribe("fastify.initialization", this._handleInitialization);
    }
    return super.enable();
  }
  disable() {
    if (this._handleInitialization) {
      dc__default.unsubscribe("fastify.initialization", this._handleInitialization);
      this._handleInitialization = undefined;
    }
    return super.disable();
  }
  init() {
    return [];
  }
  plugin() {
    const instrumentation = this;
    FastifyInstrumentationPlugin[Symbol.for("skip-override")] = true;
    FastifyInstrumentationPlugin[Symbol.for("fastify.display-name")] = "@fastify/otel";
    FastifyInstrumentationPlugin[Symbol.for("plugin-meta")] = {
      fastify: SUPPORTED_VERSIONS,
      name: "@fastify/otel"
    };
    return FastifyInstrumentationPlugin;
    function FastifyInstrumentationPlugin(instance, opts, done) {
      instance.decorate(kInstrumentation, instrumentation);
      instance.decorate(kAddHookOriginal, instance.addHook);
      instance.decorate(kSetNotFoundOriginal, instance.setNotFoundHandler);
      instance.decorateRequest("opentelemetry", function openetelemetry() {
        const ctx = this[kRequestContext];
        const span = this[kRequestSpan];
        return {
          span,
          tracer: instrumentation.tracer,
          context: ctx,
          inject: (carrier, setter) => {
            return import_api10.propagation.inject(ctx, carrier, setter);
          },
          extract: (carrier, getter) => {
            return import_api10.propagation.extract(ctx, carrier, getter);
          }
        };
      });
      instance.decorateRequest(kRequestSpan, null);
      instance.decorateRequest(kRequestContext, null);
      instance.addHook("onRoute", function(routeOptions) {
        if (instrumentation[kIgnorePaths]?.(routeOptions) === true) {
          instrumentation._logger.debug(`Ignoring route instrumentation ${routeOptions.method} ${routeOptions.url} because it matches the ignore path`);
          return;
        }
        for (const hook of FASTIFY_HOOKS) {
          if (routeOptions[hook] != null) {
            const handlerLike = routeOptions[hook];
            if (typeof handlerLike === "function") {
              routeOptions[hook] = handlerWrapper(handlerLike, {
                [import_semantic_conventions3.ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,
                [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - route -> ${hook}`,
                [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.ROUTE,
                [import_semantic_conventions3.ATTR_HTTP_ROUTE]: routeOptions.url,
                [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]: handlerLike.name?.length > 0 ? handlerLike.name : ANONYMOUS_FUNCTION_NAME
              });
            } else if (Array.isArray(handlerLike)) {
              const wrappedHandlers = [];
              for (const handler of handlerLike) {
                wrappedHandlers.push(handlerWrapper(handler, {
                  [import_semantic_conventions3.ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,
                  [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - route -> ${hook}`,
                  [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.ROUTE,
                  [import_semantic_conventions3.ATTR_HTTP_ROUTE]: routeOptions.url,
                  [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]: handler.name?.length > 0 ? handler.name : ANONYMOUS_FUNCTION_NAME
                }));
              }
              routeOptions[hook] = wrappedHandlers;
            }
          }
        }
        if (routeOptions.onSend != null) {
          routeOptions.onSend = Array.isArray(routeOptions.onSend) ? [...routeOptions.onSend, onSendHook] : [routeOptions.onSend, onSendHook];
        } else {
          routeOptions.onSend = onSendHook;
        }
        if (routeOptions.onError != null) {
          routeOptions.onError = Array.isArray(routeOptions.onError) ? [...routeOptions.onError, onErrorHook] : [routeOptions.onError, onErrorHook];
        } else {
          routeOptions.onError = onErrorHook;
        }
        routeOptions.handler = handlerWrapper(routeOptions.handler, {
          [import_semantic_conventions3.ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,
          [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - route-handler`,
          [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.HANDLER,
          [import_semantic_conventions3.ATTR_HTTP_ROUTE]: routeOptions.url,
          [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]: routeOptions.handler.name.length > 0 ? routeOptions.handler.name : ANONYMOUS_FUNCTION_NAME
        });
      });
      instance.addHook("onRequest", function(request2, _reply, hookDone) {
        if (this[kInstrumentation].isEnabled() === false) {
          return hookDone();
        } else if (this[kInstrumentation][kIgnorePaths]?.({
          url: request2.url,
          method: request2.method
        }) === true) {
          this[kInstrumentation]._logger.debug(`Ignoring request ${request2.method} ${request2.url} because it matches the ignore path`);
          return hookDone();
        }
        let ctx = import_api10.context.active();
        if (import_api10.trace.getSpan(ctx) == null) {
          ctx = import_api10.propagation.extract(ctx, request2.headers);
        }
        const rpcMetadata = import_core72.getRPCMetadata(ctx);
        if (request2.routeOptions.url != null && rpcMetadata?.type === import_core72.RPCType.HTTP) {
          rpcMetadata.route = request2.routeOptions.url;
        }
        const span = this[kInstrumentation].tracer.startSpan("request", {
          attributes: {
            [import_semantic_conventions3.ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,
            [ATTRIBUTE_NAMES.ROOT]: "@fastify/otel",
            [import_semantic_conventions3.ATTR_HTTP_ROUTE]: request2.url,
            [import_semantic_conventions3.ATTR_HTTP_REQUEST_METHOD]: request2.method
          }
        }, ctx);
        request2[kRequestContext] = import_api10.trace.setSpan(ctx, span);
        request2[kRequestSpan] = span;
        import_api10.context.with(request2[kRequestContext], () => {
          hookDone();
        });
      });
      instance.addHook("onResponse", function(request2, reply, hookDone) {
        const span = request2[kRequestSpan];
        if (span != null) {
          span.setStatus({
            code: import_api10.SpanStatusCode.OK,
            message: "OK"
          });
          span.setAttributes({
            [import_semantic_conventions3.ATTR_HTTP_RESPONSE_STATUS_CODE]: 404
          });
          span.end();
        }
        request2[kRequestSpan] = null;
        hookDone();
      });
      instance.addHook = addHookPatched;
      instance.setNotFoundHandler = setNotFoundHandlerPatched;
      done();
      function onSendHook(request2, reply, payload, hookDone) {
        const span = request2[kRequestSpan];
        if (span != null) {
          if (reply.statusCode < 500) {
            span.setStatus({
              code: import_api10.SpanStatusCode.OK,
              message: "OK"
            });
          }
          span.setAttributes({
            [import_semantic_conventions3.ATTR_HTTP_RESPONSE_STATUS_CODE]: reply.statusCode
          });
          span.end();
        }
        request2[kRequestSpan] = null;
        hookDone(null, payload);
      }
      function onErrorHook(request2, reply, error2, hookDone) {
        const span = request2[kRequestSpan];
        if (span != null) {
          span.setStatus({
            code: import_api10.SpanStatusCode.ERROR,
            message: error2.message
          });
          span.recordException(error2);
        }
        hookDone();
      }
      function addHookPatched(name, hook) {
        const addHookOriginal = this[kAddHookOriginal];
        if (FASTIFY_HOOKS.includes(name)) {
          return addHookOriginal.call(this, name, handlerWrapper(hook, {
            [import_semantic_conventions3.ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,
            [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - ${name}`,
            [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.INSTANCE,
            [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]: hook.name?.length > 0 ? hook.name : ANONYMOUS_FUNCTION_NAME
          }));
        } else {
          return addHookOriginal.call(this, name, hook);
        }
      }
      function setNotFoundHandlerPatched(hooks, handler) {
        const setNotFoundHandlerOriginal = this[kSetNotFoundOriginal];
        if (typeof hooks === "function") {
          handler = handlerWrapper(hooks, {
            [import_semantic_conventions3.ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,
            [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - not-found-handler`,
            [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.INSTANCE,
            [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]: hooks.name?.length > 0 ? hooks.name : ANONYMOUS_FUNCTION_NAME
          });
          setNotFoundHandlerOriginal.call(this, handler);
        } else {
          if (hooks.preValidation != null) {
            hooks.preValidation = handlerWrapper(hooks.preValidation, {
              [import_semantic_conventions3.ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,
              [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - not-found-handler - preValidation`,
              [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.INSTANCE,
              [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]: hooks.preValidation.name?.length > 0 ? hooks.preValidation.name : ANONYMOUS_FUNCTION_NAME
            });
          }
          if (hooks.preHandler != null) {
            hooks.preHandler = handlerWrapper(hooks.preHandler, {
              [import_semantic_conventions3.ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,
              [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - not-found-handler - preHandler`,
              [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.INSTANCE,
              [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]: hooks.preHandler.name?.length > 0 ? hooks.preHandler.name : ANONYMOUS_FUNCTION_NAME
            });
          }
          handler = handlerWrapper(handler, {
            [import_semantic_conventions3.ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,
            [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - not-found-handler`,
            [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.INSTANCE,
            [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]: handler.name?.length > 0 ? handler.name : ANONYMOUS_FUNCTION_NAME
          });
          setNotFoundHandlerOriginal.call(this, hooks, handler);
        }
      }
      function handlerWrapper(handler, spanAttributes = {}) {
        return function handlerWrapped(...args) {
          const instrumentation2 = this[kInstrumentation];
          const [request2] = args;
          if (instrumentation2.isEnabled() === false) {
            return handler.call(this, ...args);
          }
          const ctx = request2[kRequestContext] ?? import_api10.context.active();
          const span = instrumentation2.tracer.startSpan(`handler - ${handler.name?.length > 0 ? handler.name : this.pluginName ?? ANONYMOUS_FUNCTION_NAME}`, {
            attributes: spanAttributes
          }, ctx);
          return import_api10.context.with(import_api10.trace.setSpan(ctx, span), function() {
            try {
              const res = handler.call(this, ...args);
              if (typeof res?.then === "function") {
                return res.then((result) => {
                  span.end();
                  return result;
                }, (error2) => {
                  span.setStatus({
                    code: import_api10.SpanStatusCode.ERROR,
                    message: error2.message
                  });
                  span.recordException(error2);
                  span.end();
                  return Promise.reject(error2);
                });
              }
              span.end();
              return res;
            } catch (error2) {
              span.setStatus({
                code: import_api10.SpanStatusCode.ERROR,
                message: error2.message
              });
              span.recordException(error2);
              span.end();
              throw error2;
            }
          }, this);
        };
      }
    }
  }
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify/v3/instrumentation.js
var import_api12 = __toESM(require_src(), 1);
var import_core73 = __toESM(require_src3(), 1);
var import_instrumentation6 = __toESM(require_src6(), 1);
var import_semantic_conventions4 = __toESM(require_src2(), 1);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify/v3/enums/AttributeNames.js
var AttributeNames;
(function(AttributeNames2) {
  const FASTIFY_NAME = "fastify.name";
  AttributeNames2["FASTIFY_NAME"] = FASTIFY_NAME;
  const FASTIFY_TYPE = "fastify.type";
  AttributeNames2["FASTIFY_TYPE"] = FASTIFY_TYPE;
  const HOOK_NAME = "hook.name";
  AttributeNames2["HOOK_NAME"] = HOOK_NAME;
  const PLUGIN_NAME = "plugin.name";
  AttributeNames2["PLUGIN_NAME"] = PLUGIN_NAME;
})(AttributeNames || (AttributeNames = {}));
var FastifyTypes;
(function(FastifyTypes2) {
  const MIDDLEWARE = "middleware";
  FastifyTypes2["MIDDLEWARE"] = MIDDLEWARE;
  const REQUEST_HANDLER = "request_handler";
  FastifyTypes2["REQUEST_HANDLER"] = REQUEST_HANDLER;
})(FastifyTypes || (FastifyTypes = {}));
var FastifyNames;
(function(FastifyNames2) {
  const MIDDLEWARE = "middleware";
  FastifyNames2["MIDDLEWARE"] = MIDDLEWARE;
  const REQUEST_HANDLER = "request handler";
  FastifyNames2["REQUEST_HANDLER"] = REQUEST_HANDLER;
})(FastifyNames || (FastifyNames = {}));

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify/v3/utils.js
var import_api11 = __toESM(require_src(), 1);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify/v3/constants.js
var spanRequestSymbol = Symbol("opentelemetry.instrumentation.fastify.request_active_span");

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify/v3/utils.js
function startSpan3(reply, tracer, spanName, spanAttributes = {}) {
  const span = tracer.startSpan(spanName, { attributes: spanAttributes });
  const spans = reply[spanRequestSymbol] || [];
  spans.push(span);
  Object.defineProperty(reply, spanRequestSymbol, {
    enumerable: false,
    configurable: true,
    value: spans
  });
  return span;
}
function endSpan(reply, err) {
  const spans = reply[spanRequestSymbol] || [];
  if (!spans.length) {
    return;
  }
  spans.forEach((span) => {
    if (err) {
      span.setStatus({
        code: import_api11.SpanStatusCode.ERROR,
        message: err.message
      });
      span.recordException(err);
    }
    span.end();
  });
  delete reply[spanRequestSymbol];
}
function safeExecuteInTheMiddleMaybePromise(execute, onFinish, preventThrowingError) {
  let error2;
  let result = undefined;
  try {
    result = execute();
    if (isPromise(result)) {
      result.then((res) => onFinish(undefined, res), (err) => onFinish(err));
    }
  } catch (e) {
    error2 = e;
  } finally {
    if (!isPromise(result)) {
      onFinish(error2, result);
      if (error2 && true) {
        throw error2;
      }
    }
    return result;
  }
}
function isPromise(val) {
  return typeof val === "object" && val && typeof Object.getOwnPropertyDescriptor(val, "then")?.value === "function" || false;
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify/v3/instrumentation.js
var PACKAGE_VERSION2 = "0.1.0";
var PACKAGE_NAME2 = "@sentry/instrumentation-fastify-v3";
var ANONYMOUS_NAME = "anonymous";
var hooksNamesToWrap = new Set([
  "onTimeout",
  "onRequest",
  "preParsing",
  "preValidation",
  "preSerialization",
  "preHandler",
  "onSend",
  "onResponse",
  "onError"
]);

class FastifyInstrumentationV3 extends import_instrumentation6.InstrumentationBase {
  constructor(config = {}) {
    super(PACKAGE_NAME2, PACKAGE_VERSION2, config);
  }
  init() {
    return [
      new import_instrumentation6.InstrumentationNodeModuleDefinition("fastify", [">=3.0.0 <4"], (moduleExports) => {
        return this._patchConstructor(moduleExports);
      })
    ];
  }
  _hookOnRequest() {
    const instrumentation = this;
    return function onRequest(request2, reply, done) {
      if (!instrumentation.isEnabled()) {
        return done();
      }
      instrumentation._wrap(reply, "send", instrumentation._patchSend());
      const anyRequest = request2;
      const rpcMetadata = import_core73.getRPCMetadata(import_api12.context.active());
      const routeName = anyRequest.routeOptions ? anyRequest.routeOptions.url : request2.routerPath;
      if (routeName && rpcMetadata?.type === import_core73.RPCType.HTTP) {
        rpcMetadata.route = routeName;
      }
      const method = request2.method || "GET";
      getIsolationScope().setTransactionName(`${method} ${routeName}`);
      done();
    };
  }
  _wrapHandler(pluginName, hookName, original, syncFunctionWithDone) {
    const instrumentation = this;
    this._diag.debug("Patching fastify route.handler function");
    return function(...args) {
      if (!instrumentation.isEnabled()) {
        return original.apply(this, args);
      }
      const name = original.name || pluginName || ANONYMOUS_NAME;
      const spanName = `${FastifyNames.MIDDLEWARE} - ${name}`;
      const reply = args[1];
      const span = startSpan3(reply, instrumentation.tracer, spanName, {
        [AttributeNames.FASTIFY_TYPE]: FastifyTypes.MIDDLEWARE,
        [AttributeNames.PLUGIN_NAME]: pluginName,
        [AttributeNames.HOOK_NAME]: hookName
      });
      const origDone = syncFunctionWithDone && args[args.length - 1];
      if (origDone) {
        args[args.length - 1] = function(...doneArgs) {
          endSpan(reply);
          origDone.apply(this, doneArgs);
        };
      }
      return import_api12.context.with(import_api12.trace.setSpan(import_api12.context.active(), span), () => {
        return safeExecuteInTheMiddleMaybePromise(() => {
          return original.apply(this, args);
        }, (err) => {
          if (err instanceof Error) {
            span.setStatus({
              code: import_api12.SpanStatusCode.ERROR,
              message: err.message
            });
            span.recordException(err);
          }
          if (!syncFunctionWithDone) {
            endSpan(reply);
          }
        });
      });
    };
  }
  _wrapAddHook() {
    const instrumentation = this;
    this._diag.debug("Patching fastify server.addHook function");
    return function(original) {
      return function wrappedAddHook(...args) {
        const name = args[0];
        const handler = args[1];
        const pluginName = this.pluginName;
        if (!hooksNamesToWrap.has(name)) {
          return original.apply(this, args);
        }
        const syncFunctionWithDone = typeof args[args.length - 1] === "function" && handler.constructor.name !== "AsyncFunction";
        return original.apply(this, [
          name,
          instrumentation._wrapHandler(pluginName, name, handler, syncFunctionWithDone)
        ]);
      };
    };
  }
  _patchConstructor(moduleExports) {
    const instrumentation = this;
    function fastify(...args) {
      const app = moduleExports.fastify.apply(this, args);
      app.addHook("onRequest", instrumentation._hookOnRequest());
      app.addHook("preHandler", instrumentation._hookPreHandler());
      instrumentClient();
      instrumentation._wrap(app, "addHook", instrumentation._wrapAddHook());
      return app;
    }
    if (moduleExports.errorCodes !== undefined) {
      fastify.errorCodes = moduleExports.errorCodes;
    }
    fastify.fastify = fastify;
    fastify.default = fastify;
    return fastify;
  }
  _patchSend() {
    const instrumentation = this;
    this._diag.debug("Patching fastify reply.send function");
    return function patchSend(original) {
      return function send(...args) {
        const maybeError = args[0];
        if (!instrumentation.isEnabled()) {
          return original.apply(this, args);
        }
        return import_instrumentation6.safeExecuteInTheMiddle(() => {
          return original.apply(this, args);
        }, (err) => {
          if (!err && maybeError instanceof Error) {
            err = maybeError;
          }
          endSpan(this, err);
        });
      };
    };
  }
  _hookPreHandler() {
    const instrumentation = this;
    this._diag.debug("Patching fastify preHandler function");
    return function preHandler(request2, reply, done) {
      if (!instrumentation.isEnabled()) {
        return done();
      }
      const anyRequest = request2;
      const handler = anyRequest.routeOptions?.handler || anyRequest.context?.handler;
      const handlerName = handler?.name.startsWith("bound ") ? handler.name.substring(6) : handler?.name;
      const spanName = `${FastifyNames.REQUEST_HANDLER} - ${handlerName || this.pluginName || ANONYMOUS_NAME}`;
      const spanAttributes = {
        [AttributeNames.PLUGIN_NAME]: this.pluginName,
        [AttributeNames.FASTIFY_TYPE]: FastifyTypes.REQUEST_HANDLER,
        [import_semantic_conventions4.SEMATTRS_HTTP_ROUTE]: anyRequest.routeOptions ? anyRequest.routeOptions.url : request2.routerPath
      };
      if (handlerName) {
        spanAttributes[AttributeNames.FASTIFY_NAME] = handlerName;
      }
      const span = startSpan3(reply, instrumentation.tracer, spanName, spanAttributes);
      addFastifyV3SpanAttributes(span);
      const { requestHook: requestHook2 } = instrumentation.getConfig();
      if (requestHook2) {
        import_instrumentation6.safeExecuteInTheMiddle(() => requestHook2(span, { request: request2 }), (e) => {
          if (e) {
            instrumentation._diag.error("request hook failed", e);
          }
        }, true);
      }
      return import_api12.context.with(import_api12.trace.setSpan(import_api12.context.active(), span), () => {
        done();
      });
    };
  }
}
function instrumentClient() {
  const client = getClient();
  if (client) {
    client.on("spanStart", (span) => {
      addFastifyV3SpanAttributes(span);
    });
  }
}
function addFastifyV3SpanAttributes(span) {
  const attributes = spanToJSON(span).data;
  const type = attributes["fastify.type"];
  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || !type) {
    return;
  }
  span.setAttributes({
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.otel.fastify",
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${type}.fastify`
  });
  const name = attributes["fastify.name"] || attributes["plugin.name"] || attributes["hook.name"];
  if (typeof name === "string") {
    const updatedName = name.replace(/^fastify -> /, "").replace(/^@fastify\/otel -> /, "");
    span.updateName(updatedName);
  }
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify/index.js
var INTEGRATION_NAME21 = "Fastify";
var instrumentFastifyV3 = generateInstrumentOnce(`${INTEGRATION_NAME21}.v3`, () => new FastifyInstrumentationV3);
function getFastifyIntegration() {
  const client = getClient();
  if (!client) {
    return;
  } else {
    return client.getIntegrationByName(INTEGRATION_NAME21);
  }
}
function handleFastifyError(error2, request2, reply, handlerOrigin) {
  const shouldHandleError = getFastifyIntegration()?.getShouldHandleError() || defaultShouldHandleError;
  if (handlerOrigin === "diagnostics-channel") {
    this.diagnosticsChannelExists = true;
  }
  if (this.diagnosticsChannelExists && handlerOrigin === "onError-hook") {
    DEBUG_BUILD4 && debug.warn("Fastify error handler was already registered via diagnostics channel.", "You can safely remove `setupFastifyErrorHandler` call and set `shouldHandleError` on the integration options.");
    return;
  }
  if (shouldHandleError(error2, request2, reply)) {
    captureException(error2, { mechanism: { handled: false, type: "auto.function.fastify" } });
  }
}
var instrumentFastify = generateInstrumentOnce(`${INTEGRATION_NAME21}.v5`, () => {
  const fastifyOtelInstrumentationInstance = new FastifyOtelInstrumentation;
  const plugin = fastifyOtelInstrumentationInstance.plugin();
  dc.subscribe("fastify.initialization", (message) => {
    const fastifyInstance = message.fastify;
    fastifyInstance?.register(plugin).after((err) => {
      if (err) {
        DEBUG_BUILD4 && debug.error("Failed to setup Fastify instrumentation", err);
      } else {
        instrumentClient2();
        if (fastifyInstance) {
          instrumentOnRequest(fastifyInstance);
        }
      }
    });
  });
  dc.subscribe("tracing:fastify.request.handler:error", (message) => {
    const { error: error2, request: request2, reply } = message;
    handleFastifyError.call(handleFastifyError, error2, request2, reply, "diagnostics-channel");
  });
  return fastifyOtelInstrumentationInstance;
});
var _fastifyIntegration = ({ shouldHandleError }) => {
  let _shouldHandleError;
  return {
    name: INTEGRATION_NAME21,
    setupOnce() {
      _shouldHandleError = shouldHandleError || defaultShouldHandleError;
      instrumentFastifyV3();
      instrumentFastify();
    },
    getShouldHandleError() {
      return _shouldHandleError;
    },
    setShouldHandleError(fn) {
      _shouldHandleError = fn;
    }
  };
};
var fastifyIntegration = defineIntegration((options = {}) => _fastifyIntegration(options));
function defaultShouldHandleError(_error, _request, reply) {
  const statusCode = reply.statusCode;
  return statusCode >= 500 || statusCode <= 299;
}
function addFastifySpanAttributes(span) {
  const spanJSON = spanToJSON(span);
  const spanName = spanJSON.description;
  const attributes = spanJSON.data;
  const type = attributes["fastify.type"];
  const isHook = type === "hook";
  const isHandler = type === spanName?.startsWith("handler -");
  const isRequestHandler = spanName === "request" || type === "request-handler";
  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || !isHandler && !isRequestHandler && !isHook) {
    return;
  }
  const opPrefix = isHook ? "hook" : isHandler ? "middleware" : isRequestHandler ? "request-handler" : "<unknown>";
  span.setAttributes({
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.otel.fastify",
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${opPrefix}.fastify`
  });
  const attrName = attributes["fastify.name"] || attributes["plugin.name"] || attributes["hook.name"];
  if (typeof attrName === "string") {
    const updatedName = attrName.replace(/^fastify -> /, "").replace(/^@fastify\/otel -> /, "");
    span.updateName(updatedName);
  }
}
function instrumentClient2() {
  const client = getClient();
  if (client) {
    client.on("spanStart", (span) => {
      addFastifySpanAttributes(span);
    });
  }
}
function instrumentOnRequest(fastify) {
  fastify.addHook("onRequest", async (request2, _reply) => {
    if (request2.opentelemetry) {
      const { span } = request2.opentelemetry();
      if (span) {
        addFastifySpanAttributes(span);
      }
    }
    const routeName = request2.routeOptions?.url;
    const method = request2.method || "GET";
    getIsolationScope().setTransactionName(`${method} ${routeName}`);
  });
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/graphql.js
var import_api13 = __toESM(require_src(), 1);
var import_instrumentation_graphql = __toESM(require_src13(), 1);
var INTEGRATION_NAME22 = "Graphql";
var instrumentGraphql = generateInstrumentOnce(INTEGRATION_NAME22, import_instrumentation_graphql.GraphQLInstrumentation, (_options) => {
  const options = getOptionsWithDefaults(_options);
  return {
    ...options,
    responseHook(span, result) {
      addOriginToSpan2(span, "auto.graphql.otel.graphql");
      const resultWithMaybeError = result;
      if (resultWithMaybeError.errors?.length && !spanToJSON(span).status) {
        span.setStatus({ code: import_api13.SpanStatusCode.ERROR });
      }
      const attributes = spanToJSON(span).data;
      const operationType = attributes["graphql.operation.type"];
      const operationName = attributes["graphql.operation.name"];
      if (options.useOperationNameForRootSpan && operationType) {
        const rootSpan = getRootSpan(span);
        const rootSpanAttributes = spanToJSON(rootSpan).data;
        const existingOperations = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION] || [];
        const newOperation = operationName ? `${operationType} ${operationName}` : `${operationType}`;
        if (Array.isArray(existingOperations)) {
          existingOperations.push(newOperation);
          rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, existingOperations);
        } else if (typeof existingOperations === "string") {
          rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, [existingOperations, newOperation]);
        } else {
          rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, newOperation);
        }
        if (!spanToJSON(rootSpan).data["original-description"]) {
          rootSpan.setAttribute("original-description", spanToJSON(rootSpan).description);
        }
        rootSpan.updateName(`${spanToJSON(rootSpan).data["original-description"]} (${getGraphqlOperationNamesFromAttribute2(existingOperations)})`);
      }
    }
  };
});
var _graphqlIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME22,
    setupOnce() {
      instrumentGraphql(getOptionsWithDefaults(options));
    }
  };
};
var graphqlIntegration = defineIntegration(_graphqlIntegration);
function getOptionsWithDefaults(options) {
  return {
    ignoreResolveSpans: true,
    ignoreTrivialResolveSpans: true,
    useOperationNameForRootSpan: true,
    ...options
  };
}
function getGraphqlOperationNamesFromAttribute2(attr) {
  if (Array.isArray(attr)) {
    const sorted = attr.slice().sort();
    if (sorted.length <= 5) {
      return sorted.join(", ");
    } else {
      return `${sorted.slice(0, 5).join(", ")}, +${sorted.length - 5}`;
    }
  }
  return `${attr}`;
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/kafka.js
var import_instrumentation_kafkajs = __toESM(require_src14(), 1);
var INTEGRATION_NAME23 = "Kafka";
var instrumentKafka = generateInstrumentOnce(INTEGRATION_NAME23, () => new import_instrumentation_kafkajs.KafkaJsInstrumentation({
  consumerHook(span) {
    addOriginToSpan2(span, "auto.kafkajs.otel.consumer");
  },
  producerHook(span) {
    addOriginToSpan2(span, "auto.kafkajs.otel.producer");
  }
}));
var _kafkaIntegration = () => {
  return {
    name: INTEGRATION_NAME23,
    setupOnce() {
      instrumentKafka();
    }
  };
};
var kafkaIntegration = defineIntegration(_kafkaIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/lrumemoizer.js
var import_instrumentation_lru_memoizer = __toESM(require_src15(), 1);
var INTEGRATION_NAME24 = "LruMemoizer";
var instrumentLruMemoizer = generateInstrumentOnce(INTEGRATION_NAME24, () => new import_instrumentation_lru_memoizer.LruMemoizerInstrumentation);
var _lruMemoizerIntegration = () => {
  return {
    name: INTEGRATION_NAME24,
    setupOnce() {
      instrumentLruMemoizer();
    }
  };
};
var lruMemoizerIntegration = defineIntegration(_lruMemoizerIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/mongo.js
var import_instrumentation_mongodb = __toESM(require_src16(), 1);
var INTEGRATION_NAME25 = "Mongo";
var instrumentMongo = generateInstrumentOnce(INTEGRATION_NAME25, () => new import_instrumentation_mongodb.MongoDBInstrumentation({
  dbStatementSerializer: _defaultDbStatementSerializer,
  responseHook(span) {
    addOriginToSpan2(span, "auto.db.otel.mongo");
  }
}));
function _defaultDbStatementSerializer(commandObj) {
  const resultObj = _scrubStatement(commandObj);
  return JSON.stringify(resultObj);
}
function _scrubStatement(value) {
  if (Array.isArray(value)) {
    return value.map((element) => _scrubStatement(element));
  }
  if (isCommandObj(value)) {
    const initial = {};
    return Object.entries(value).map(([key, element]) => [key, _scrubStatement(element)]).reduce((prev, current) => {
      if (isCommandEntry(current)) {
        prev[current[0]] = current[1];
      }
      return prev;
    }, initial);
  }
  return "?";
}
function isCommandObj(value) {
  return typeof value === "object" && value !== null && !isBuffer(value);
}
function isBuffer(value) {
  let isBuffer2 = false;
  if (typeof Buffer !== "undefined") {
    isBuffer2 = Buffer.isBuffer(value);
  }
  return isBuffer2;
}
function isCommandEntry(value) {
  return Array.isArray(value);
}
var _mongoIntegration = () => {
  return {
    name: INTEGRATION_NAME25,
    setupOnce() {
      instrumentMongo();
    }
  };
};
var mongoIntegration = defineIntegration(_mongoIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/mongoose.js
var import_instrumentation_mongoose = __toESM(require_src17(), 1);
var INTEGRATION_NAME26 = "Mongoose";
var instrumentMongoose = generateInstrumentOnce(INTEGRATION_NAME26, () => new import_instrumentation_mongoose.MongooseInstrumentation({
  responseHook(span) {
    addOriginToSpan2(span, "auto.db.otel.mongoose");
  }
}));
var _mongooseIntegration = () => {
  return {
    name: INTEGRATION_NAME26,
    setupOnce() {
      instrumentMongoose();
    }
  };
};
var mongooseIntegration = defineIntegration(_mongooseIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/mysql.js
var import_instrumentation_mysql = __toESM(require_src18(), 1);
var INTEGRATION_NAME27 = "Mysql";
var instrumentMysql = generateInstrumentOnce(INTEGRATION_NAME27, () => new import_instrumentation_mysql.MySQLInstrumentation({}));
var _mysqlIntegration = () => {
  return {
    name: INTEGRATION_NAME27,
    setupOnce() {
      instrumentMysql();
    }
  };
};
var mysqlIntegration = defineIntegration(_mysqlIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/mysql2.js
var import_instrumentation_mysql2 = __toESM(require_src20(), 1);
var INTEGRATION_NAME28 = "Mysql2";
var instrumentMysql2 = generateInstrumentOnce(INTEGRATION_NAME28, () => new import_instrumentation_mysql2.MySQL2Instrumentation({
  responseHook(span) {
    addOriginToSpan2(span, "auto.db.otel.mysql2");
  }
}));
var _mysql2Integration = () => {
  return {
    name: INTEGRATION_NAME28,
    setupOnce() {
      instrumentMysql2();
    }
  };
};
var mysql2Integration = defineIntegration(_mysql2Integration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/redis.js
var import_instrumentation_ioredis = __toESM(require_src22(), 1);
var import_instrumentation_redis = __toESM(require_src23(), 1);

// ../../node_modules/@sentry/node/build/esm/utils/redisCache.js
var SINGLE_ARG_COMMANDS = ["get", "set", "setex"];
var GET_COMMANDS = ["get", "mget"];
var SET_COMMANDS = ["set", "setex"];
function isInCommands(redisCommands, command) {
  return redisCommands.includes(command.toLowerCase());
}
function getCacheOperation(command) {
  if (isInCommands(GET_COMMANDS, command)) {
    return "cache.get";
  } else if (isInCommands(SET_COMMANDS, command)) {
    return "cache.put";
  } else {
    return;
  }
}
function keyHasPrefix(key, prefixes) {
  return prefixes.some((prefix) => key.startsWith(prefix));
}
function getCacheKeySafely(redisCommand, cmdArgs) {
  try {
    if (cmdArgs.length === 0) {
      return;
    }
    const processArg = (arg) => {
      if (typeof arg === "string" || typeof arg === "number" || Buffer.isBuffer(arg)) {
        return [arg.toString()];
      } else if (Array.isArray(arg)) {
        return flatten(arg.map((arg2) => processArg(arg2)));
      } else {
        return ["<unknown>"];
      }
    };
    const firstArg = cmdArgs[0];
    if (isInCommands(SINGLE_ARG_COMMANDS, redisCommand) && firstArg != null) {
      return processArg(firstArg);
    }
    return flatten(cmdArgs.map((arg) => processArg(arg)));
  } catch {
    return;
  }
}
function shouldConsiderForCache(redisCommand, keys, prefixes) {
  if (!getCacheOperation(redisCommand)) {
    return false;
  }
  for (const key of keys) {
    if (keyHasPrefix(key, prefixes)) {
      return true;
    }
  }
  return false;
}
function calculateCacheItemSize(response) {
  const getSize = (value) => {
    try {
      if (Buffer.isBuffer(value))
        return value.byteLength;
      else if (typeof value === "string")
        return value.length;
      else if (typeof value === "number")
        return value.toString().length;
      else if (value === null || value === undefined)
        return 0;
      return JSON.stringify(value).length;
    } catch {
      return;
    }
  };
  return Array.isArray(response) ? response.reduce((acc, curr) => {
    const size = getSize(curr);
    return typeof size === "number" ? acc !== undefined ? acc + size : size : acc;
  }, 0) : getSize(response);
}
function flatten(input) {
  const result = [];
  const flattenHelper = (input2) => {
    input2.forEach((el) => {
      if (Array.isArray(el)) {
        flattenHelper(el);
      } else {
        result.push(el);
      }
    });
  };
  flattenHelper(input);
  return result;
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/redis.js
var INTEGRATION_NAME29 = "Redis";
var _redisOptions = {};
var cacheResponseHook = (span, redisCommand, cmdArgs, response) => {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.redis");
  const safeKey = getCacheKeySafely(redisCommand, cmdArgs);
  const cacheOperation = getCacheOperation(redisCommand);
  if (!safeKey || !cacheOperation || !_redisOptions.cachePrefixes || !shouldConsiderForCache(redisCommand, safeKey, _redisOptions.cachePrefixes)) {
    return;
  }
  const networkPeerAddress = spanToJSON(span).data["net.peer.name"];
  const networkPeerPort = spanToJSON(span).data["net.peer.port"];
  if (networkPeerPort && networkPeerAddress) {
    span.setAttributes({ "network.peer.address": networkPeerAddress, "network.peer.port": networkPeerPort });
  }
  const cacheItemSize = calculateCacheItemSize(response);
  if (cacheItemSize) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE, cacheItemSize);
  }
  if (isInCommands(GET_COMMANDS, redisCommand) && cacheItemSize !== undefined) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_HIT, cacheItemSize > 0);
  }
  span.setAttributes({
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: cacheOperation,
    [SEMANTIC_ATTRIBUTE_CACHE_KEY]: safeKey
  });
  const spanDescription = safeKey.join(", ");
  span.updateName(truncate(spanDescription, 1024));
};
var instrumentIORedis = generateInstrumentOnce(`${INTEGRATION_NAME29}.IORedis`, () => {
  return new import_instrumentation_ioredis.IORedisInstrumentation({
    responseHook: cacheResponseHook
  });
});
var instrumentRedisModule = generateInstrumentOnce(`${INTEGRATION_NAME29}.Redis`, () => {
  return new import_instrumentation_redis.RedisInstrumentation({
    responseHook: cacheResponseHook
  });
});
var instrumentRedis = Object.assign(() => {
  instrumentIORedis();
  instrumentRedisModule();
}, { id: INTEGRATION_NAME29 });
var _redisIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME29,
    setupOnce() {
      _redisOptions = options;
      instrumentRedis();
    }
  };
};
var redisIntegration = defineIntegration(_redisIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/postgres.js
var import_instrumentation_pg = __toESM(require_src24(), 1);
var INTEGRATION_NAME30 = "Postgres";
var instrumentPostgres = generateInstrumentOnce(INTEGRATION_NAME30, () => new import_instrumentation_pg.PgInstrumentation({
  requireParentSpan: true,
  requestHook(span) {
    addOriginToSpan2(span, "auto.db.otel.postgres");
  }
}));
var _postgresIntegration = () => {
  return {
    name: INTEGRATION_NAME30,
    setupOnce() {
      instrumentPostgres();
    }
  };
};
var postgresIntegration = defineIntegration(_postgresIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/postgresjs.js
var import_api14 = __toESM(require_src(), 1);
var import_instrumentation8 = __toESM(require_src6(), 1);
var import_semantic_conventions5 = __toESM(require_src2(), 1);
var INTEGRATION_NAME31 = "PostgresJs";
var SUPPORTED_VERSIONS2 = [">=3.0.0 <4"];
var instrumentPostgresJs = generateInstrumentOnce(INTEGRATION_NAME31, (options) => new PostgresJsInstrumentation({
  requireParentSpan: options?.requireParentSpan ?? true,
  requestHook: options?.requestHook
}));

class PostgresJsInstrumentation extends import_instrumentation8.InstrumentationBase {
  constructor(config) {
    super("sentry-postgres-js", SDK_VERSION, config);
  }
  init() {
    const instrumentationModule = new import_instrumentation8.InstrumentationNodeModuleDefinition("postgres", SUPPORTED_VERSIONS2);
    ["src", "cf/src", "cjs/src"].forEach((path8) => {
      instrumentationModule.files.push(new import_instrumentation8.InstrumentationNodeModuleFile(`postgres/${path8}/connection.js`, ["*"], this._patchConnection.bind(this), this._unwrap.bind(this)));
      instrumentationModule.files.push(new import_instrumentation8.InstrumentationNodeModuleFile(`postgres/${path8}/query.js`, SUPPORTED_VERSIONS2, this._patchQuery.bind(this), this._unwrap.bind(this)));
    });
    return [instrumentationModule];
  }
  _shouldCreateSpans() {
    const config = this.getConfig();
    const hasParentSpan = import_api14.trace.getSpan(import_api14.context.active()) !== undefined;
    return hasParentSpan || !config.requireParentSpan;
  }
  _patchReject(rejectTarget, span) {
    return new Proxy(rejectTarget, {
      apply: (rejectTarget2, rejectThisArg, rejectArgs) => {
        span.setStatus({
          code: SPAN_STATUS_ERROR,
          message: rejectArgs?.[0]?.message || "unknown_error"
        });
        const result = Reflect.apply(rejectTarget2, rejectThisArg, rejectArgs);
        span.setAttribute(import_semantic_conventions5.ATTR_DB_RESPONSE_STATUS_CODE, rejectArgs?.[0]?.code || "Unknown error");
        span.setAttribute(import_semantic_conventions5.ATTR_ERROR_TYPE, rejectArgs?.[0]?.name || "Unknown error");
        span.end();
        return result;
      }
    });
  }
  _patchResolve(resolveTarget, span) {
    return new Proxy(resolveTarget, {
      apply: (resolveTarget2, resolveThisArg, resolveArgs) => {
        const result = Reflect.apply(resolveTarget2, resolveThisArg, resolveArgs);
        const sqlCommand = resolveArgs?.[0]?.command;
        if (sqlCommand) {
          span.setAttribute(import_semantic_conventions5.ATTR_DB_OPERATION_NAME, sqlCommand);
        }
        span.end();
        return result;
      }
    });
  }
  _patchQuery(moduleExports) {
    moduleExports.Query.prototype.handle = new Proxy(moduleExports.Query.prototype.handle, {
      apply: async (handleTarget, handleThisArg, handleArgs) => {
        if (!this._shouldCreateSpans()) {
          return Reflect.apply(handleTarget, handleThisArg, handleArgs);
        }
        const sanitizedSqlQuery = this._sanitizeSqlQuery(handleThisArg.strings?.[0]);
        return startSpanManual({
          name: sanitizedSqlQuery || "postgresjs.query",
          op: "db"
        }, (span) => {
          const scope = getCurrentScope();
          const postgresConnectionContext = scope.getScopeData().contexts["postgresjsConnection"];
          addOriginToSpan2(span, "auto.db.otel.postgres");
          const { requestHook: requestHook2 } = this.getConfig();
          if (requestHook2) {
            import_instrumentation8.safeExecuteInTheMiddle(() => requestHook2(span, sanitizedSqlQuery, postgresConnectionContext), (error2) => {
              if (error2) {
                debug.error(`Error in requestHook for ${INTEGRATION_NAME31} integration:`, error2);
              }
            });
          }
          const databaseName = postgresConnectionContext?.ATTR_DB_NAMESPACE || "<unknown database>";
          const databaseHost = postgresConnectionContext?.ATTR_SERVER_ADDRESS || "<unknown host>";
          const databasePort = postgresConnectionContext?.ATTR_SERVER_PORT || "<unknown port>";
          span.setAttribute(import_semantic_conventions5.ATTR_DB_SYSTEM_NAME, "postgres");
          span.setAttribute(import_semantic_conventions5.ATTR_DB_NAMESPACE, databaseName);
          span.setAttribute(import_semantic_conventions5.ATTR_SERVER_ADDRESS, databaseHost);
          span.setAttribute(import_semantic_conventions5.ATTR_SERVER_PORT, databasePort);
          span.setAttribute(import_semantic_conventions5.ATTR_DB_QUERY_TEXT, sanitizedSqlQuery);
          handleThisArg.resolve = this._patchResolve(handleThisArg.resolve, span);
          handleThisArg.reject = this._patchReject(handleThisArg.reject, span);
          try {
            return Reflect.apply(handleTarget, handleThisArg, handleArgs);
          } catch (error2) {
            span.setStatus({
              code: SPAN_STATUS_ERROR
            });
            span.end();
            throw error2;
          }
        });
      }
    });
    return moduleExports;
  }
  _patchConnection(Connection) {
    return new Proxy(Connection, {
      apply: (connectionTarget, thisArg, connectionArgs) => {
        const databaseName = connectionArgs[0]?.database || "<unknown database>";
        const databaseHost = connectionArgs[0]?.host?.[0] || "<unknown host>";
        const databasePort = connectionArgs[0]?.port?.[0] || "<unknown port>";
        const scope = getCurrentScope();
        scope.setContext("postgresjsConnection", {
          ATTR_DB_NAMESPACE: databaseName,
          ATTR_SERVER_ADDRESS: databaseHost,
          ATTR_SERVER_PORT: databasePort
        });
        return Reflect.apply(connectionTarget, thisArg, connectionArgs);
      }
    });
  }
  _sanitizeSqlQuery(sqlQuery) {
    if (!sqlQuery) {
      return "Unknown SQL Query";
    }
    return sqlQuery.replace(/\s+/g, " ").trim().substring(0, 1024).replace(/--.*?(\r?\n|$)/g, "").replace(/\/\*[\s\S]*?\*\//g, "").replace(/;\s*$/, "").replace(/\b\d+\b/g, "?").replace(/\s+/g, " ").replace(/\bIN\b\s*\(\s*\?(?:\s*,\s*\?)*\s*\)/g, "IN (?)");
  }
}
var _postgresJsIntegration = () => {
  return {
    name: INTEGRATION_NAME31,
    setupOnce() {
      instrumentPostgresJs();
    }
  };
};
var postgresJsIntegration = defineIntegration(_postgresJsIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/prisma.js
var import_api17 = __toESM(require_src(), 1);

// ../../node_modules/@prisma/instrumentation/dist/index.mjs
var import_api15 = __toESM(require_src(), 1);
var import_instrumentation9 = __toESM(require_src26(), 1);
var import_api16 = __toESM(require_src(), 1);
var showAllTraces = process.env.PRISMA_SHOW_ALL_TRACES === "true";
var nonSampledTraceParent = `00-10-10-00`;
function engineSpanKindToOtelSpanKind(engineSpanKind) {
  switch (engineSpanKind) {
    case "client":
      return import_api16.SpanKind.CLIENT;
    case "internal":
    default:
      return import_api16.SpanKind.INTERNAL;
  }
}
var ActiveTracingHelper = class {
  tracerProvider;
  ignoreSpanTypes;
  constructor({ tracerProvider, ignoreSpanTypes }) {
    this.tracerProvider = tracerProvider;
    this.ignoreSpanTypes = ignoreSpanTypes;
  }
  isEnabled() {
    return true;
  }
  getTraceParent(context9) {
    const span = import_api16.trace.getSpanContext(context9 ?? import_api16.context.active());
    if (span) {
      return `00-${span.traceId}-${span.spanId}-0${span.traceFlags}`;
    }
    return nonSampledTraceParent;
  }
  dispatchEngineSpans(spans) {
    const tracer = this.tracerProvider.getTracer("prisma");
    const linkIds = /* @__PURE__ */ new Map;
    const roots = spans.filter((span) => span.parentId === null);
    for (const root of roots) {
      dispatchEngineSpan(tracer, root, spans, linkIds, this.ignoreSpanTypes);
    }
  }
  getActiveContext() {
    return import_api16.context.active();
  }
  runInChildSpan(options, callback) {
    if (typeof options === "string") {
      options = { name: options };
    }
    if (options.internal && !showAllTraces) {
      return callback();
    }
    const tracer = this.tracerProvider.getTracer("prisma");
    const context9 = options.context ?? this.getActiveContext();
    const name = `prisma:client:${options.name}`;
    if (shouldIgnoreSpan2(name, this.ignoreSpanTypes)) {
      return callback();
    }
    if (options.active === false) {
      const span = tracer.startSpan(name, options, context9);
      return endSpan2(span, callback(span, context9));
    }
    return tracer.startActiveSpan(name, options, (span) => endSpan2(span, callback(span, context9)));
  }
};
function dispatchEngineSpan(tracer, engineSpan, allSpans, linkIds, ignoreSpanTypes) {
  if (shouldIgnoreSpan2(engineSpan.name, ignoreSpanTypes))
    return;
  const spanOptions = {
    attributes: engineSpan.attributes,
    kind: engineSpanKindToOtelSpanKind(engineSpan.kind),
    startTime: engineSpan.startTime
  };
  tracer.startActiveSpan(engineSpan.name, spanOptions, (span) => {
    linkIds.set(engineSpan.id, span.spanContext().spanId);
    if (engineSpan.links) {
      span.addLinks(engineSpan.links.flatMap((link) => {
        const linkedId = linkIds.get(link);
        if (!linkedId) {
          return [];
        }
        return {
          context: {
            spanId: linkedId,
            traceId: span.spanContext().traceId,
            traceFlags: span.spanContext().traceFlags
          }
        };
      }));
    }
    const children = allSpans.filter((s) => s.parentId === engineSpan.id);
    for (const child of children) {
      dispatchEngineSpan(tracer, child, allSpans, linkIds, ignoreSpanTypes);
    }
    span.end(engineSpan.endTime);
  });
}
function endSpan2(span, result) {
  if (isPromiseLike(result)) {
    return result.then((value) => {
      span.end();
      return value;
    }, (reason) => {
      span.end();
      throw reason;
    });
  }
  span.end();
  return result;
}
function isPromiseLike(value) {
  return value != null && typeof value["then"] === "function";
}
function shouldIgnoreSpan2(spanName, ignoreSpanTypes) {
  return ignoreSpanTypes.some((pattern) => typeof pattern === "string" ? pattern === spanName : pattern.test(spanName));
}
var package_default2 = {
  name: "@prisma/instrumentation",
  version: "6.15.0",
  description: "OpenTelemetry compliant instrumentation for Prisma Client",
  main: "dist/index.js",
  module: "dist/index.mjs",
  types: "dist/index.d.ts",
  exports: {
    ".": {
      require: {
        types: "./dist/index.d.ts",
        default: "./dist/index.js"
      },
      import: {
        types: "./dist/index.d.ts",
        default: "./dist/index.mjs"
      }
    }
  },
  license: "Apache-2.0",
  homepage: "https://www.prisma.io",
  repository: {
    type: "git",
    url: "https://github.com/prisma/prisma.git",
    directory: "packages/instrumentation"
  },
  bugs: "https://github.com/prisma/prisma/issues",
  devDependencies: {
    "@prisma/internals": "workspace:*",
    "@swc/core": "1.11.5",
    "@types/jest": "29.5.14",
    "@types/node": "18.19.76",
    "@opentelemetry/api": "1.9.0",
    jest: "29.7.0",
    "jest-junit": "16.0.0",
    typescript: "5.4.5"
  },
  dependencies: {
    "@opentelemetry/instrumentation": "^0.52.0 || ^0.53.0 || ^0.54.0 || ^0.55.0 || ^0.56.0 || ^0.57.0"
  },
  peerDependencies: {
    "@opentelemetry/api": "^1.8"
  },
  files: [
    "dist"
  ],
  keywords: [
    "prisma",
    "instrumentation",
    "opentelemetry",
    "otel"
  ],
  scripts: {
    dev: "DEV=true tsx helpers/build.ts",
    build: "tsx helpers/build.ts",
    prepublishOnly: "pnpm run build",
    test: "jest"
  },
  sideEffects: false
};
var VERSION = package_default2.version;
var majorVersion = VERSION.split(".")[0];
var GLOBAL_INSTRUMENTATION_ACCESSOR_KEY = "PRISMA_INSTRUMENTATION";
var GLOBAL_VERSIONED_INSTRUMENTATION_ACCESSOR_KEY = `V${majorVersion}_PRISMA_INSTRUMENTATION`;
var NAME = package_default2.name;
var MODULE_NAME = "@prisma/client";
var PrismaInstrumentation = class extends import_instrumentation9.InstrumentationBase {
  tracerProvider;
  constructor(config = {}) {
    super(NAME, VERSION, config);
  }
  setTracerProvider(tracerProvider) {
    this.tracerProvider = tracerProvider;
  }
  init() {
    const module = new import_instrumentation9.InstrumentationNodeModuleDefinition(MODULE_NAME, [VERSION]);
    return [module];
  }
  enable() {
    const config = this._config;
    const globalValue = {
      helper: new ActiveTracingHelper({
        tracerProvider: this.tracerProvider ?? import_api15.trace.getTracerProvider(),
        ignoreSpanTypes: config.ignoreSpanTypes ?? []
      })
    };
    global[GLOBAL_INSTRUMENTATION_ACCESSOR_KEY] = globalValue;
    global[GLOBAL_VERSIONED_INSTRUMENTATION_ACCESSOR_KEY] = globalValue;
  }
  disable() {
    delete global[GLOBAL_INSTRUMENTATION_ACCESSOR_KEY];
    delete global[GLOBAL_VERSIONED_INSTRUMENTATION_ACCESSOR_KEY];
  }
  isEnabled() {
    return Boolean(global[GLOBAL_VERSIONED_INSTRUMENTATION_ACCESSOR_KEY]);
  }
};

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/prisma.js
var INTEGRATION_NAME32 = "Prisma";
function isPrismaV6TracingHelper(helper) {
  return !!helper && typeof helper === "object" && "dispatchEngineSpans" in helper;
}
function getPrismaTracingHelper() {
  const prismaInstrumentationObject = globalThis.PRISMA_INSTRUMENTATION;
  const prismaTracingHelper = prismaInstrumentationObject && typeof prismaInstrumentationObject === "object" && "helper" in prismaInstrumentationObject ? prismaInstrumentationObject.helper : undefined;
  return prismaTracingHelper;
}

class SentryPrismaInteropInstrumentation extends PrismaInstrumentation {
  constructor() {
    super();
  }
  enable() {
    super.enable();
    const prismaTracingHelper = getPrismaTracingHelper();
    if (isPrismaV6TracingHelper(prismaTracingHelper)) {
      prismaTracingHelper.createEngineSpan = (engineSpanEvent) => {
        const tracer = import_api17.trace.getTracer("prismaV5Compatibility");
        const initialIdGenerator = tracer._idGenerator;
        if (!initialIdGenerator) {
          consoleSandbox(() => {
            console.warn("[Sentry] Could not find _idGenerator on tracer, skipping Prisma v5 compatibility - some Prisma spans may be missing!");
          });
          return;
        }
        try {
          engineSpanEvent.spans.forEach((engineSpan) => {
            const kind = engineSpanKindToOTELSpanKind(engineSpan.kind);
            const parentSpanId = engineSpan.parent_span_id;
            const spanId = engineSpan.span_id;
            const traceId = engineSpan.trace_id;
            const links = engineSpan.links?.map((link) => {
              return {
                context: {
                  traceId: link.trace_id,
                  spanId: link.span_id,
                  traceFlags: import_api17.TraceFlags.SAMPLED
                }
              };
            });
            const ctx = import_api17.trace.setSpanContext(import_api17.context.active(), {
              traceId,
              spanId: parentSpanId,
              traceFlags: import_api17.TraceFlags.SAMPLED
            });
            import_api17.context.with(ctx, () => {
              const temporaryIdGenerator = {
                generateTraceId: () => {
                  return traceId;
                },
                generateSpanId: () => {
                  return spanId;
                }
              };
              tracer._idGenerator = temporaryIdGenerator;
              const span = tracer.startSpan(engineSpan.name, {
                kind,
                links,
                startTime: engineSpan.start_time,
                attributes: engineSpan.attributes
              });
              span.end(engineSpan.end_time);
              tracer._idGenerator = initialIdGenerator;
            });
          });
        } finally {
          tracer._idGenerator = initialIdGenerator;
        }
      };
    }
  }
}
function engineSpanKindToOTELSpanKind(engineSpanKind) {
  switch (engineSpanKind) {
    case "client":
      return import_api17.SpanKind.CLIENT;
    case "internal":
    default:
      return import_api17.SpanKind.INTERNAL;
  }
}
var instrumentPrisma = generateInstrumentOnce(INTEGRATION_NAME32, (_options) => {
  return new SentryPrismaInteropInstrumentation;
});
var prismaIntegration = defineIntegration((_options) => {
  return {
    name: INTEGRATION_NAME32,
    setupOnce() {
      instrumentPrisma();
    },
    setup(client) {
      if (!getPrismaTracingHelper()) {
        return;
      }
      client.on("spanStart", (span) => {
        const spanJSON = spanToJSON(span);
        if (spanJSON.description?.startsWith("prisma:")) {
          span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.prisma");
        }
        if (spanJSON.description === "prisma:engine:db_query" && spanJSON.data["db.query.text"]) {
          span.updateName(spanJSON.data["db.query.text"]);
        }
        if (spanJSON.description === "prisma:engine:db_query" && !spanJSON.data["db.system"]) {
          span.setAttribute("db.system", "prisma");
        }
      });
    }
  };
});

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/hapi/index.js
var import_instrumentation_hapi = __toESM(require_src27(), 1);
var INTEGRATION_NAME33 = "Hapi";
var instrumentHapi = generateInstrumentOnce(INTEGRATION_NAME33, () => new import_instrumentation_hapi.HapiInstrumentation);
var _hapiIntegration = () => {
  return {
    name: INTEGRATION_NAME33,
    setupOnce() {
      instrumentHapi();
    }
  };
};
var hapiIntegration = defineIntegration(_hapiIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/koa.js
var import_instrumentation_koa = __toESM(require_src28(), 1);
var import_semantic_conventions6 = __toESM(require_src2(), 1);
var INTEGRATION_NAME34 = "Koa";
var instrumentKoa = generateInstrumentOnce(INTEGRATION_NAME34, import_instrumentation_koa.KoaInstrumentation, (options = {}) => {
  return {
    ignoreLayersType: options.ignoreLayersType,
    requestHook(span, info) {
      addOriginToSpan2(span, "auto.http.otel.koa");
      const attributes = spanToJSON(span).data;
      const type = attributes["koa.type"];
      if (type) {
        span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, `${type}.koa`);
      }
      const name = attributes["koa.name"];
      if (typeof name === "string") {
        span.updateName(name || "< unknown >");
      }
      if (getIsolationScope() === getDefaultIsolationScope()) {
        DEBUG_BUILD4 && debug.warn("Isolation scope is default isolation scope - skipping setting transactionName");
        return;
      }
      const route = attributes[import_semantic_conventions6.ATTR_HTTP_ROUTE];
      const method = info.context?.request?.method?.toUpperCase() || "GET";
      if (route) {
        getIsolationScope().setTransactionName(`${method} ${route}`);
      }
    }
  };
});
var _koaIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME34,
    setupOnce() {
      instrumentKoa(options);
    }
  };
};
var koaIntegration = defineIntegration(_koaIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/connect.js
var import_instrumentation_connect = __toESM(require_src29(), 1);
var INTEGRATION_NAME35 = "Connect";
var instrumentConnect = generateInstrumentOnce(INTEGRATION_NAME35, () => new import_instrumentation_connect.ConnectInstrumentation);
var _connectIntegration = () => {
  return {
    name: INTEGRATION_NAME35,
    setupOnce() {
      instrumentConnect();
    }
  };
};
var connectIntegration = defineIntegration(_connectIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/tedious.js
var import_instrumentation_tedious = __toESM(require_src30(), 1);
var TEDIUS_INSTRUMENTED_METHODS = new Set([
  "callProcedure",
  "execSql",
  "execSqlBatch",
  "execBulkLoad",
  "prepare",
  "execute"
]);
var INTEGRATION_NAME36 = "Tedious";
var instrumentTedious = generateInstrumentOnce(INTEGRATION_NAME36, () => new import_instrumentation_tedious.TediousInstrumentation({}));
var _tediousIntegration = () => {
  let instrumentationWrappedCallback;
  return {
    name: INTEGRATION_NAME36,
    setupOnce() {
      const instrumentation = instrumentTedious();
      instrumentationWrappedCallback = instrumentWhenWrapped(instrumentation);
    },
    setup(client) {
      instrumentationWrappedCallback?.(() => client.on("spanStart", (span) => {
        const { description, data } = spanToJSON(span);
        if (!description || data["db.system"] !== "mssql") {
          return;
        }
        const operation = description.split(" ")[0] || "";
        if (TEDIUS_INSTRUMENTED_METHODS.has(operation)) {
          span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.tedious");
        }
      }));
    }
  };
};
var tediousIntegration = defineIntegration(_tediousIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/genericPool.js
var import_instrumentation_generic_pool = __toESM(require_src31(), 1);
var INTEGRATION_NAME37 = "GenericPool";
var instrumentGenericPool = generateInstrumentOnce(INTEGRATION_NAME37, () => new import_instrumentation_generic_pool.GenericPoolInstrumentation({}));
var _genericPoolIntegration = () => {
  let instrumentationWrappedCallback;
  return {
    name: INTEGRATION_NAME37,
    setupOnce() {
      const instrumentation = instrumentGenericPool();
      instrumentationWrappedCallback = instrumentWhenWrapped(instrumentation);
    },
    setup(client) {
      instrumentationWrappedCallback?.(() => client.on("spanStart", (span) => {
        const spanJSON = spanToJSON(span);
        const spanDescription = spanJSON.description;
        const isGenericPoolSpan = spanDescription === "generic-pool.aquire" || spanDescription === "generic-pool.acquire";
        if (isGenericPoolSpan) {
          span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.generic_pool");
        }
      }));
    }
  };
};
var genericPoolIntegration = defineIntegration(_genericPoolIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/amqplib.js
var import_instrumentation_amqplib = __toESM(require_src32(), 1);
var INTEGRATION_NAME38 = "Amqplib";
var config = {
  consumeEndHook: (span) => {
    addOriginToSpan2(span, "auto.amqplib.otel.consumer");
  },
  publishHook: (span) => {
    addOriginToSpan2(span, "auto.amqplib.otel.publisher");
  }
};
var instrumentAmqplib = generateInstrumentOnce(INTEGRATION_NAME38, () => new import_instrumentation_amqplib.AmqplibInstrumentation(config));
var _amqplibIntegration = () => {
  return {
    name: INTEGRATION_NAME38,
    setupOnce() {
      instrumentAmqplib();
    }
  };
};
var amqplibIntegration = defineIntegration(_amqplibIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/vercelai/constants.js
var INTEGRATION_NAME39 = "VercelAI";

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/vercelai/instrumentation.js
var import_instrumentation11 = __toESM(require_src6(), 1);
var INSTRUMENTED_METHODS2 = [
  "generateText",
  "streamText",
  "generateObject",
  "streamObject",
  "embed",
  "embedMany"
];
function isToolError(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const candidate = obj;
  return "type" in candidate && "error" in candidate && "toolName" in candidate && "toolCallId" in candidate && candidate.type === "tool-error" && candidate.error instanceof Error;
}
function checkResultForToolErrors(result) {
  if (typeof result !== "object" || result === null || !("content" in result)) {
    return;
  }
  const resultObj = result;
  if (!Array.isArray(resultObj.content)) {
    return;
  }
  for (const item of resultObj.content) {
    if (isToolError(item)) {
      const associatedSpan = _INTERNAL_getSpanForToolCallId(item.toolCallId);
      if (associatedSpan) {
        const spanContext = associatedSpan.spanContext();
        withScope2((scope) => {
          scope.setContext("trace", {
            trace_id: spanContext.traceId,
            span_id: spanContext.spanId
          });
          scope.setTag("vercel.ai.tool.name", item.toolName);
          scope.setTag("vercel.ai.tool.callId", item.toolCallId);
          scope.setLevel("error");
          captureException(item.error, {
            mechanism: {
              type: "auto.vercelai.otel",
              handled: false
            }
          });
        });
        _INTERNAL_cleanupToolCallSpan(item.toolCallId);
      } else {
        withScope2((scope) => {
          scope.setTag("vercel.ai.tool.name", item.toolName);
          scope.setTag("vercel.ai.tool.callId", item.toolCallId);
          scope.setLevel("error");
          captureException(item.error, {
            mechanism: {
              type: "auto.vercelai.otel",
              handled: false
            }
          });
        });
      }
    }
  }
}
function determineRecordingSettings(integrationRecordingOptions, methodTelemetryOptions, telemetryExplicitlyEnabled, defaultRecordingEnabled) {
  const recordInputs = integrationRecordingOptions?.recordInputs !== undefined ? integrationRecordingOptions.recordInputs : methodTelemetryOptions.recordInputs !== undefined ? methodTelemetryOptions.recordInputs : telemetryExplicitlyEnabled === true ? true : defaultRecordingEnabled;
  const recordOutputs = integrationRecordingOptions?.recordOutputs !== undefined ? integrationRecordingOptions.recordOutputs : methodTelemetryOptions.recordOutputs !== undefined ? methodTelemetryOptions.recordOutputs : telemetryExplicitlyEnabled === true ? true : defaultRecordingEnabled;
  return { recordInputs, recordOutputs };
}

class SentryVercelAiInstrumentation extends import_instrumentation11.InstrumentationBase {
  __init() {
    this._isPatched = false;
  }
  __init2() {
    this._callbacks = [];
  }
  constructor(config2 = {}) {
    super("@sentry/instrumentation-vercel-ai", SDK_VERSION, config2);
    SentryVercelAiInstrumentation.prototype.__init.call(this);
    SentryVercelAiInstrumentation.prototype.__init2.call(this);
  }
  init() {
    const module = new import_instrumentation11.InstrumentationNodeModuleDefinition("ai", [">=3.0.0 <6"], this._patch.bind(this));
    return module;
  }
  callWhenPatched(callback) {
    if (this._isPatched) {
      callback();
    } else {
      this._callbacks.push(callback);
    }
  }
  _patch(moduleExports) {
    this._isPatched = true;
    this._callbacks.forEach((callback) => callback());
    this._callbacks = [];
    function generatePatch(originalMethod) {
      return (...args) => {
        const existingExperimentalTelemetry = args[0].experimental_telemetry || {};
        const isEnabled3 = existingExperimentalTelemetry.isEnabled;
        const client = getCurrentScope().getClient();
        const integration = client?.getIntegrationByName(INTEGRATION_NAME39);
        const integrationOptions = integration?.options;
        const shouldRecordInputsAndOutputs = integration ? Boolean(client?.getOptions().sendDefaultPii) : false;
        const { recordInputs, recordOutputs } = determineRecordingSettings(integrationOptions, existingExperimentalTelemetry, isEnabled3, shouldRecordInputsAndOutputs);
        args[0].experimental_telemetry = {
          ...existingExperimentalTelemetry,
          isEnabled: isEnabled3 !== undefined ? isEnabled3 : true,
          recordInputs,
          recordOutputs
        };
        return handleCallbackErrors(() => {
          const result = originalMethod.apply(this, args);
          if (isThenable(result)) {
            result.then(checkResultForToolErrors, () => {});
            return result;
          }
          checkResultForToolErrors(result);
          return result;
        }, (error2) => {
          if (error2 && typeof error2 === "object") {
            addNonEnumerableProperty(error2, "_sentry_active_span", getActiveSpan());
          }
        });
      };
    }
    if (Object.prototype.toString.call(moduleExports) === "[object Module]") {
      for (const method of INSTRUMENTED_METHODS2) {
        moduleExports[method] = generatePatch(moduleExports[method]);
      }
      return moduleExports;
    } else {
      const patchedModuleExports = INSTRUMENTED_METHODS2.reduce((acc, curr) => {
        acc[curr] = generatePatch(moduleExports[curr]);
        return acc;
      }, {});
      return { ...moduleExports, ...patchedModuleExports };
    }
  }
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/vercelai/index.js
var instrumentVercelAi = generateInstrumentOnce(INTEGRATION_NAME39, () => new SentryVercelAiInstrumentation({}));
function shouldForceIntegration(client) {
  const modules = client.getIntegrationByName("Modules");
  return !!modules?.getModules?.()?.ai;
}
var _vercelAIIntegration = (options = {}) => {
  let instrumentation;
  return {
    name: INTEGRATION_NAME39,
    options,
    setupOnce() {
      instrumentation = instrumentVercelAi();
    },
    afterAllSetup(client) {
      const shouldForce = options.force ?? shouldForceIntegration(client);
      if (shouldForce) {
        addVercelAiProcessors(client);
      } else {
        instrumentation?.callWhenPatched(() => addVercelAiProcessors(client));
      }
    }
  };
};
var vercelAIIntegration = defineIntegration(_vercelAIIntegration);
// ../../node_modules/@sentry/node/build/esm/integrations/tracing/openai/instrumentation.js
var import_instrumentation13 = __toESM(require_src6(), 1);
var supportedVersions = [">=4.0.0 <6"];
function determineRecordingSettings2(integrationOptions, defaultEnabled) {
  const recordInputs = integrationOptions?.recordInputs ?? defaultEnabled;
  const recordOutputs = integrationOptions?.recordOutputs ?? defaultEnabled;
  return { recordInputs, recordOutputs };
}

class SentryOpenAiInstrumentation extends import_instrumentation13.InstrumentationBase {
  constructor(config2 = {}) {
    super("@sentry/instrumentation-openai", SDK_VERSION, config2);
  }
  init() {
    const module = new import_instrumentation13.InstrumentationNodeModuleDefinition("openai", supportedVersions, this._patch.bind(this));
    return module;
  }
  _patch(exports) {
    const Original = exports.OpenAI;
    const WrappedOpenAI = function(...args) {
      const instance = Reflect.construct(Original, args);
      const scopeClient = getCurrentScope().getClient();
      const integration = scopeClient?.getIntegrationByName(OPENAI_INTEGRATION_NAME);
      const integrationOpts = integration?.options;
      const defaultPii = Boolean(scopeClient?.getOptions().sendDefaultPii);
      const { recordInputs, recordOutputs } = determineRecordingSettings2(integrationOpts, defaultPii);
      return instrumentOpenAiClient(instance, {
        recordInputs,
        recordOutputs
      });
    };
    Object.setPrototypeOf(WrappedOpenAI, Original);
    Object.setPrototypeOf(WrappedOpenAI.prototype, Original.prototype);
    for (const key of Object.getOwnPropertyNames(Original)) {
      if (!["length", "name", "prototype"].includes(key)) {
        const descriptor = Object.getOwnPropertyDescriptor(Original, key);
        if (descriptor) {
          Object.defineProperty(WrappedOpenAI, key, descriptor);
        }
      }
    }
    try {
      exports.OpenAI = WrappedOpenAI;
    } catch (error2) {
      Object.defineProperty(exports, "OpenAI", {
        value: WrappedOpenAI,
        writable: true,
        configurable: true,
        enumerable: true
      });
    }
    if (exports.default === Original) {
      try {
        exports.default = WrappedOpenAI;
      } catch (error2) {
        Object.defineProperty(exports, "default", {
          value: WrappedOpenAI,
          writable: true,
          configurable: true,
          enumerable: true
        });
      }
    }
    return exports;
  }
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/openai/index.js
var instrumentOpenAi = generateInstrumentOnce(OPENAI_INTEGRATION_NAME, () => new SentryOpenAiInstrumentation({}));
var _openAiIntegration = (options = {}) => {
  return {
    name: OPENAI_INTEGRATION_NAME,
    options,
    setupOnce() {
      instrumentOpenAi();
    }
  };
};
var openAIIntegration = defineIntegration(_openAiIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/anthropic-ai/instrumentation.js
var import_instrumentation15 = __toESM(require_src6(), 1);
var supportedVersions2 = [">=0.19.2 <1.0.0"];
function determineRecordingSettings3(integrationOptions, defaultEnabled) {
  const recordInputs = integrationOptions?.recordInputs ?? defaultEnabled;
  const recordOutputs = integrationOptions?.recordOutputs ?? defaultEnabled;
  return { recordInputs, recordOutputs };
}

class SentryAnthropicAiInstrumentation extends import_instrumentation15.InstrumentationBase {
  constructor(config2 = {}) {
    super("@sentry/instrumentation-anthropic-ai", SDK_VERSION, config2);
  }
  init() {
    const module = new import_instrumentation15.InstrumentationNodeModuleDefinition("@anthropic-ai/sdk", supportedVersions2, this._patch.bind(this));
    return module;
  }
  _patch(exports) {
    const Original = exports.Anthropic;
    const WrappedAnthropic = function(...args) {
      const instance = Reflect.construct(Original, args);
      const scopeClient = getCurrentScope().getClient();
      const integration = scopeClient?.getIntegrationByName(ANTHROPIC_AI_INTEGRATION_NAME);
      const integrationOpts = integration?.options;
      const defaultPii = Boolean(scopeClient?.getOptions().sendDefaultPii);
      const { recordInputs, recordOutputs } = determineRecordingSettings3(integrationOpts, defaultPii);
      return instrumentAnthropicAiClient(instance, {
        recordInputs,
        recordOutputs
      });
    };
    Object.setPrototypeOf(WrappedAnthropic, Original);
    Object.setPrototypeOf(WrappedAnthropic.prototype, Original.prototype);
    for (const key of Object.getOwnPropertyNames(Original)) {
      if (!["length", "name", "prototype"].includes(key)) {
        const descriptor = Object.getOwnPropertyDescriptor(Original, key);
        if (descriptor) {
          Object.defineProperty(WrappedAnthropic, key, descriptor);
        }
      }
    }
    try {
      exports.Anthropic = WrappedAnthropic;
    } catch (error2) {
      Object.defineProperty(exports, "Anthropic", {
        value: WrappedAnthropic,
        writable: true,
        configurable: true,
        enumerable: true
      });
    }
    if (exports.default === Original) {
      try {
        exports.default = WrappedAnthropic;
      } catch (error2) {
        Object.defineProperty(exports, "default", {
          value: WrappedAnthropic,
          writable: true,
          configurable: true,
          enumerable: true
        });
      }
    }
    return exports;
  }
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/anthropic-ai/index.js
var instrumentAnthropicAi = generateInstrumentOnce(ANTHROPIC_AI_INTEGRATION_NAME, () => new SentryAnthropicAiInstrumentation({}));
var _anthropicAIIntegration = (options = {}) => {
  return {
    name: ANTHROPIC_AI_INTEGRATION_NAME,
    options,
    setupOnce() {
      instrumentAnthropicAi();
    }
  };
};
var anthropicAIIntegration = defineIntegration(_anthropicAIIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/firebase/otel/firebaseInstrumentation.js
var import_instrumentation18 = __toESM(require_src6(), 1);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/firebase/otel/patches/firestore.js
var import_api18 = __toESM(require_src(), 1);
var import_instrumentation17 = __toESM(require_src6(), 1);
var import_semantic_conventions7 = __toESM(require_src2(), 1);
import * as net2 from "node:net";
function patchFirestore(tracer, firestoreSupportedVersions, wrap, unwrap, config2) {
  const defaultFirestoreSpanCreationHook = () => {};
  let firestoreSpanCreationHook = defaultFirestoreSpanCreationHook;
  const configFirestoreSpanCreationHook = config2.firestoreSpanCreationHook;
  if (typeof configFirestoreSpanCreationHook === "function") {
    firestoreSpanCreationHook = (span) => {
      import_instrumentation17.safeExecuteInTheMiddle(() => configFirestoreSpanCreationHook(span), (error2) => {
        if (!error2) {
          return;
        }
        import_api18.diag.error(error2?.message);
      }, true);
    };
  }
  const moduleFirestoreCJS = new import_instrumentation17.InstrumentationNodeModuleDefinition("@firebase/firestore", firestoreSupportedVersions, (moduleExports) => wrapMethods(moduleExports, wrap, unwrap, tracer, firestoreSpanCreationHook));
  const files = [
    "@firebase/firestore/dist/lite/index.node.cjs.js",
    "@firebase/firestore/dist/lite/index.node.mjs.js",
    "@firebase/firestore/dist/lite/index.rn.esm2017.js",
    "@firebase/firestore/dist/lite/index.cjs.js"
  ];
  for (const file of files) {
    moduleFirestoreCJS.files.push(new import_instrumentation17.InstrumentationNodeModuleFile(file, firestoreSupportedVersions, (moduleExports) => wrapMethods(moduleExports, wrap, unwrap, tracer, firestoreSpanCreationHook), (moduleExports) => unwrapMethods(moduleExports, unwrap)));
  }
  return moduleFirestoreCJS;
}
function wrapMethods(moduleExports, wrap, unwrap, tracer, firestoreSpanCreationHook) {
  unwrapMethods(moduleExports, unwrap);
  wrap(moduleExports, "addDoc", patchAddDoc(tracer, firestoreSpanCreationHook));
  wrap(moduleExports, "getDocs", patchGetDocs(tracer, firestoreSpanCreationHook));
  wrap(moduleExports, "setDoc", patchSetDoc(tracer, firestoreSpanCreationHook));
  wrap(moduleExports, "deleteDoc", patchDeleteDoc(tracer, firestoreSpanCreationHook));
  return moduleExports;
}
function unwrapMethods(moduleExports, unwrap) {
  for (const method of ["addDoc", "getDocs", "setDoc", "deleteDoc"]) {
    if (import_instrumentation17.isWrapped(moduleExports[method])) {
      unwrap(moduleExports, method);
    }
  }
  return moduleExports;
}
function patchAddDoc(tracer, firestoreSpanCreationHook) {
  return function addDoc(original) {
    return function(reference, data) {
      const span = startDBSpan(tracer, "addDoc", reference);
      firestoreSpanCreationHook(span);
      return executeContextWithSpan(span, () => {
        return original(reference, data);
      });
    };
  };
}
function patchDeleteDoc(tracer, firestoreSpanCreationHook) {
  return function deleteDoc(original) {
    return function(reference) {
      const span = startDBSpan(tracer, "deleteDoc", reference.parent || reference);
      firestoreSpanCreationHook(span);
      return executeContextWithSpan(span, () => {
        return original(reference);
      });
    };
  };
}
function patchGetDocs(tracer, firestoreSpanCreationHook) {
  return function getDocs(original) {
    return function(reference) {
      const span = startDBSpan(tracer, "getDocs", reference);
      firestoreSpanCreationHook(span);
      return executeContextWithSpan(span, () => {
        return original(reference);
      });
    };
  };
}
function patchSetDoc(tracer, firestoreSpanCreationHook) {
  return function setDoc(original) {
    return function(reference, data, options) {
      const span = startDBSpan(tracer, "setDoc", reference.parent || reference);
      firestoreSpanCreationHook(span);
      return executeContextWithSpan(span, () => {
        return typeof options !== "undefined" ? original(reference, data, options) : original(reference, data);
      });
    };
  };
}
function executeContextWithSpan(span, callback) {
  return import_api18.context.with(import_api18.trace.setSpan(import_api18.context.active(), span), () => {
    return import_instrumentation17.safeExecuteInTheMiddle(() => {
      return callback();
    }, (err) => {
      if (err) {
        span.recordException(err);
      }
      span.end();
    }, true);
  });
}
function startDBSpan(tracer, spanName, reference) {
  const span = tracer.startSpan(`${spanName} ${reference.path}`, { kind: import_api18.SpanKind.CLIENT });
  addAttributes(span, reference);
  span.setAttribute(import_semantic_conventions7.ATTR_DB_OPERATION_NAME, spanName);
  return span;
}
function getPortAndAddress(settings) {
  let address;
  let port;
  if (typeof settings.host === "string") {
    if (settings.host.startsWith("[")) {
      if (settings.host.endsWith("]")) {
        address = settings.host.replace(/^\[|\]$/g, "");
      } else if (settings.host.includes("]:")) {
        const lastColonIndex = settings.host.lastIndexOf(":");
        if (lastColonIndex !== -1) {
          address = settings.host.slice(1, lastColonIndex).replace(/^\[|\]$/g, "");
          port = settings.host.slice(lastColonIndex + 1);
        }
      }
    } else {
      if (net2.isIPv6(settings.host)) {
        address = settings.host;
      } else {
        const lastColonIndex = settings.host.lastIndexOf(":");
        if (lastColonIndex !== -1) {
          address = settings.host.slice(0, lastColonIndex);
          port = settings.host.slice(lastColonIndex + 1);
        } else {
          address = settings.host;
        }
      }
    }
  }
  return {
    address,
    port: port ? parseInt(port, 10) : undefined
  };
}
function addAttributes(span, reference) {
  const firestoreApp = reference.firestore.app;
  const firestoreOptions = firestoreApp.options;
  const json = reference.firestore.toJSON() || {};
  const settings = json.settings || {};
  const attributes = {
    [import_semantic_conventions7.ATTR_DB_COLLECTION_NAME]: reference.path,
    [import_semantic_conventions7.ATTR_DB_NAMESPACE]: firestoreApp.name,
    [import_semantic_conventions7.ATTR_DB_SYSTEM_NAME]: "firebase.firestore",
    "firebase.firestore.type": reference.type,
    "firebase.firestore.options.projectId": firestoreOptions.projectId,
    "firebase.firestore.options.appId": firestoreOptions.appId,
    "firebase.firestore.options.messagingSenderId": firestoreOptions.messagingSenderId,
    "firebase.firestore.options.storageBucket": firestoreOptions.storageBucket
  };
  const { address, port } = getPortAndAddress(settings);
  if (address) {
    attributes[import_semantic_conventions7.ATTR_SERVER_ADDRESS] = address;
  }
  if (port) {
    attributes[import_semantic_conventions7.ATTR_SERVER_PORT] = port;
  }
  span.setAttributes(attributes);
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/firebase/otel/firebaseInstrumentation.js
var DefaultFirebaseInstrumentationConfig = {};
var firestoreSupportedVersions = [">=3.0.0 <5"];

class FirebaseInstrumentation extends import_instrumentation18.InstrumentationBase {
  constructor(config2 = DefaultFirebaseInstrumentationConfig) {
    super("@sentry/instrumentation-firebase", SDK_VERSION, config2);
  }
  setConfig(config2 = {}) {
    super.setConfig({ ...DefaultFirebaseInstrumentationConfig, ...config2 });
  }
  init() {
    const modules = [];
    modules.push(patchFirestore(this.tracer, firestoreSupportedVersions, this._wrap, this._unwrap, this.getConfig()));
    return modules;
  }
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/firebase/firebase.js
var INTEGRATION_NAME40 = "Firebase";
var config2 = {
  firestoreSpanCreationHook: (span) => {
    addOriginToSpan2(span, "auto.firebase.otel.firestore");
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "db.query");
  }
};
var instrumentFirebase = generateInstrumentOnce(INTEGRATION_NAME40, () => new FirebaseInstrumentation(config2));
var _firebaseIntegration = () => {
  return {
    name: INTEGRATION_NAME40,
    setupOnce() {
      instrumentFirebase();
    }
  };
};
var firebaseIntegration = defineIntegration(_firebaseIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/index.js
function getAutoPerformanceIntegrations() {
  return [
    expressIntegration(),
    fastifyIntegration(),
    graphqlIntegration(),
    mongoIntegration(),
    mongooseIntegration(),
    mysqlIntegration(),
    mysql2Integration(),
    redisIntegration(),
    postgresIntegration(),
    prismaIntegration(),
    hapiIntegration(),
    koaIntegration(),
    connectIntegration(),
    tediousIntegration(),
    genericPoolIntegration(),
    kafkaIntegration(),
    amqplibIntegration(),
    lruMemoizerIntegration(),
    vercelAIIntegration(),
    openAIIntegration(),
    postgresJsIntegration(),
    firebaseIntegration(),
    anthropicAIIntegration()
  ];
}

// ../../node_modules/@sentry/node/build/esm/sdk/initOtel.js
var import_api19 = __toESM(require_src(), 1);
var import_resources = __toESM(require_src8(), 1);
var import_sdk_trace_base2 = __toESM(require_src9(), 1);
var import_semantic_conventions8 = __toESM(require_src2(), 1);
var MAX_MAX_SPAN_WAIT_DURATION = 1e6;
function initOpenTelemetry(client, options = {}) {
  if (client.getOptions().debug) {
    setupOpenTelemetryLogger();
  }
  const provider = setupOtel(client, options);
  client.traceProvider = provider;
}
function setupOtel(client, options = {}) {
  const provider = new import_sdk_trace_base2.BasicTracerProvider({
    sampler: new SentrySampler(client),
    resource: import_resources.defaultResource().merge(import_resources.resourceFromAttributes({
      [import_semantic_conventions8.ATTR_SERVICE_NAME]: "node",
      [import_semantic_conventions8.SEMRESATTRS_SERVICE_NAMESPACE]: "sentry",
      [import_semantic_conventions8.ATTR_SERVICE_VERSION]: SDK_VERSION
    })),
    forceFlushTimeoutMillis: 500,
    spanProcessors: [
      new SentrySpanProcessor({
        timeout: _clampSpanProcessorTimeout(client.getOptions().maxSpanWaitDuration)
      }),
      ...options.spanProcessors || []
    ]
  });
  import_api19.trace.setGlobalTracerProvider(provider);
  import_api19.propagation.setGlobalPropagator(new SentryPropagator);
  import_api19.context.setGlobalContextManager(new SentryContextManager);
  return provider;
}
function _clampSpanProcessorTimeout(maxSpanWaitDuration) {
  if (maxSpanWaitDuration == null) {
    return;
  }
  if (maxSpanWaitDuration > MAX_MAX_SPAN_WAIT_DURATION) {
    DEBUG_BUILD4 && debug.warn(`\`maxSpanWaitDuration\` is too high, using the maximum value of ${MAX_MAX_SPAN_WAIT_DURATION}`);
    return MAX_MAX_SPAN_WAIT_DURATION;
  } else if (maxSpanWaitDuration <= 0 || Number.isNaN(maxSpanWaitDuration)) {
    DEBUG_BUILD4 && debug.warn("`maxSpanWaitDuration` must be a positive number, using default value instead.");
    return;
  }
  return maxSpanWaitDuration;
}

// ../../node_modules/@sentry/node/build/esm/sdk/index.js
function getDefaultIntegrationsWithoutPerformance() {
  const nodeCoreIntegrations = getDefaultIntegrations();
  return nodeCoreIntegrations.filter((integration) => integration.name !== "Http" && integration.name !== "NodeFetch").concat(httpIntegration2(), nativeNodeFetchIntegration2());
}
function getDefaultIntegrations2(options) {
  return [
    ...getDefaultIntegrationsWithoutPerformance(),
    ...hasSpansEnabled(options) ? getAutoPerformanceIntegrations() : []
  ];
}
function init2(options = {}) {
  return _init2(options, getDefaultIntegrations2);
}
function _init2(options = {}, getDefaultIntegrationsImpl) {
  applySdkMetadata(options, "node");
  const client = init({
    ...options,
    defaultIntegrations: options.defaultIntegrations ?? getDefaultIntegrationsImpl(options)
  });
  if (client && !options.skipOpenTelemetrySetup) {
    initOpenTelemetry(client, {
      spanProcessors: options.openTelemetrySpanProcessors
    });
    validateOpenTelemetrySetup();
  }
  return client;
}
// src/index.ts
import sqlPlugin, { createDatabaseAdapter, DatabaseMigrationService } from "@elizaos/plugin-sql";
import { existsSync as existsSync4 } from "node:fs";
var import_dotenv2 = __toESM(require_main(), 1);
function expandTildePath(filepath) {
  if (!filepath) {
    return filepath;
  }
  if (filepath.startsWith("~")) {
    if (filepath === "~") {
      return process.cwd();
    } else if (filepath.startsWith("~/")) {
      return path8.join(process.cwd(), filepath.slice(2));
    } else if (filepath.startsWith("~~")) {
      return filepath;
    } else {
      return path8.join(process.cwd(), filepath.slice(1));
    }
  }
  return filepath;
}
function resolvePgliteDir(dir, fallbackDir) {
  const envPath = resolveEnvFile();
  if (existsSync4(envPath)) {
    import_dotenv2.default.config({ path: envPath });
  }
  if (dir) {
    const resolved2 = expandTildePath(dir);
    process.env.PGLITE_DATA_DIR = resolved2;
    return resolved2;
  }
  if (fallbackDir && !process.env.PGLITE_DATA_DIR && !process.env.ELIZA_DATABASE_DIR) {
    const resolved2 = expandTildePath(fallbackDir);
    process.env.PGLITE_DATA_DIR = resolved2;
    return resolved2;
  }
  const resolved = getDatabaseDir();
  process.env.PGLITE_DATA_DIR = resolved;
  return resolved;
}
var __dirname3 = dirname3(fileURLToPath2(import.meta.url));
var DEFAULT_SERVER_ID6 = "00000000-0000-0000-0000-000000000000";
function isWebUIEnabled() {
  const isProduction = false;
  const uiEnabledEnv = process.env.ELIZA_UI_ENABLE;
  if (uiEnabledEnv !== undefined && uiEnabledEnv.trim() !== "") {
    return parseBooleanFromText(uiEnabledEnv);
  }
  return !isProduction;
}

class AgentServer {
  app;
  agents;
  server;
  socketIO;
  isInitialized = false;
  isWebUIEnabled = true;
  clientPath;
  database;
  startAgent;
  stopAgent;
  loadCharacterTryPath;
  jsonToCharacter;
  constructor() {
    try {
      logger30.debug("Initializing AgentServer (constructor)...");
      this.agents = new Map;
      this.loadCharacterTryPath = loadCharacterTryPath;
      this.jsonToCharacter = jsonToCharacter;
      this.registerSignalHandlers();
    } catch (error2) {
      logger30.error({ error: error2 }, "Failed to initialize AgentServer (constructor):");
      throw error2;
    }
  }
  async initialize(options) {
    if (this.isInitialized) {
      logger30.warn("AgentServer is already initialized, skipping initialization");
      return;
    }
    try {
      logger30.debug("Initializing AgentServer (async operations)...");
      const agentDataDir = resolvePgliteDir(options?.dataDir);
      logger30.info(`[INIT] Database Dir for SQL plugin: ${agentDataDir}`);
      this.database = createDatabaseAdapter({
        dataDir: agentDataDir,
        postgresUrl: options?.postgresUrl
      }, "00000000-0000-0000-0000-000000000002");
      await this.database.init();
      logger30.success("Consolidated database initialized successfully");
      logger30.info("[INIT] Running database migrations for messaging tables...");
      try {
        const migrationService = new DatabaseMigrationService;
        const db = this.database.getDatabase();
        await migrationService.initializeWithDatabase(db);
        migrationService.discoverAndRegisterPluginSchemas([sqlPlugin]);
        await migrationService.runAllPluginMigrations();
        logger30.success("[INIT] Database migrations completed successfully");
      } catch (migrationError) {
        logger30.error({ error: migrationError }, "[INIT] Failed to run database migrations:");
        throw new Error(`Database migration failed: ${migrationError instanceof Error ? migrationError.message : String(migrationError)}`);
      }
      await new Promise((resolve2) => setTimeout(resolve2, 500));
      logger30.info("[INIT] Ensuring default server exists...");
      await this.ensureDefaultServer();
      logger30.success("[INIT] Default server setup complete");
      await this.initializeServer(options);
      await new Promise((resolve2) => setTimeout(resolve2, 250));
      this.isInitialized = true;
    } catch (error2) {
      logger30.error({ error: error2 }, "Failed to initialize AgentServer (async operations):");
      console.trace(error2);
      throw error2;
    }
  }
  async ensureDefaultServer() {
    try {
      logger30.info("[AgentServer] Checking for default server...");
      const servers = await this.database.getMessageServers();
      logger30.debug(`[AgentServer] Found ${servers.length} existing servers`);
      servers.forEach((s) => {
        logger30.debug(`[AgentServer] Existing server: ID=${s.id}, Name=${s.name}`);
      });
      const defaultServer = servers.find((s) => s.id === "00000000-0000-0000-0000-000000000000");
      if (!defaultServer) {
        logger30.info("[AgentServer] Creating default server with UUID 00000000-0000-0000-0000-000000000000...");
        try {
          await this.database.db.execute(`
            INSERT INTO message_servers (id, name, source_type, created_at, updated_at)
            VALUES ('00000000-0000-0000-0000-000000000000', 'Default Server', 'eliza_default', NOW(), NOW())
            ON CONFLICT (id) DO NOTHING
          `);
          logger30.success("[AgentServer] Default server created via raw SQL");
          const checkResult = await this.database.db.execute("SELECT id, name FROM message_servers WHERE id = '00000000-0000-0000-0000-000000000000'");
          logger30.debug("[AgentServer] Raw SQL check result:", checkResult);
        } catch (sqlError) {
          logger30.error("[AgentServer] Raw SQL insert failed:", sqlError);
          try {
            const server = await this.database.createMessageServer({
              id: "00000000-0000-0000-0000-000000000000",
              name: "Default Server",
              sourceType: "eliza_default"
            });
            logger30.success("[AgentServer] Default server created via ORM with ID:", server.id);
          } catch (ormError) {
            logger30.error("[AgentServer] Both SQL and ORM creation failed:", ormError);
            throw new Error(`Failed to create default server: ${ormError.message}`);
          }
        }
        const verifyServers = await this.database.getMessageServers();
        logger30.debug(`[AgentServer] After creation attempt, found ${verifyServers.length} servers`);
        verifyServers.forEach((s) => {
          logger30.debug(`[AgentServer] Server after creation: ID=${s.id}, Name=${s.name}`);
        });
        const verifyDefault = verifyServers.find((s) => s.id === "00000000-0000-0000-0000-000000000000");
        if (!verifyDefault) {
          throw new Error(`Failed to create or verify default server with ID ${DEFAULT_SERVER_ID6}`);
        } else {
          logger30.success("[AgentServer] Default server creation verified successfully");
        }
      } else {
        logger30.info("[AgentServer] Default server already exists with ID:", defaultServer.id);
      }
    } catch (error2) {
      logger30.error({ error: error2 }, "[AgentServer] Error ensuring default server:");
      throw error2;
    }
  }
  async initializeServer(options) {
    try {
      if (options?.clientPath) {
        this.clientPath = options.clientPath;
      }
      this.app = express33();
      const DEFAULT_SENTRY_DSN = "https://c20e2d51b66c14a783b0689d536f7e5c@o4509349865259008.ingest.us.sentry.io/4509352524120064";
      const sentryDsn = process.env.SENTRY_DSN && process.env.SENTRY_DSN.trim() || DEFAULT_SENTRY_DSN;
      const sentryEnabled = Boolean(sentryDsn);
      if (sentryEnabled) {
        try {
          init2({
            dsn: sentryDsn,
            environment: process.env.SENTRY_ENVIRONMENT || "development",
            integrations: [vercelAIIntegration({ force: sentryEnabled })],
            tracesSampleRate: Number(process.env.SENTRY_TRACES_SAMPLE_RATE || 0)
          });
          logger30.info("[Sentry] Initialized Sentry for @elizaos/server");
        } catch (sentryInitError) {
          logger30.error({ error: sentryInitError }, "[Sentry] Failed to initialize Sentry");
        }
      }
      const isProd = false;
      logger30.debug("Setting up security headers...");
      if (!isProd) {
        logger30.debug(`NODE_ENV: ${"development"}`);
        logger30.debug(`CSP will be: ${isProd ? "ENABLED" : "MINIMAL_DEV"}`);
      }
      this.app.use(helmet({
        contentSecurityPolicy: isProd ? {
          directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'", "https:"],
            scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
            imgSrc: ["'self'", "data:", "blob:", "https:", "http:"],
            fontSrc: ["'self'", "https:", "data:"],
            connectSrc: ["'self'", "ws:", "wss:", "https:", "http:"],
            mediaSrc: ["'self'", "blob:", "data:"],
            objectSrc: ["'none'"],
            frameSrc: [this.isWebUIEnabled ? "'self'" : "'none'"],
            baseUri: ["'self'"],
            formAction: ["'self'"]
          },
          useDefaults: true
        } : {
          directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'", "https:", "http:"],
            scriptSrc: ["*", "'unsafe-inline'", "'unsafe-eval'"],
            imgSrc: ["'self'", "data:", "blob:", "https:", "http:"],
            fontSrc: ["'self'", "https:", "http:", "data:"],
            connectSrc: ["'self'", "ws:", "wss:", "https:", "http:"],
            mediaSrc: ["'self'", "blob:", "data:"],
            objectSrc: ["'none'"],
            frameSrc: ["'self'", "data:"],
            baseUri: ["'self'"],
            formAction: ["'self'"]
          },
          useDefaults: false
        },
        crossOriginEmbedderPolicy: false,
        crossOriginResourcePolicy: { policy: "cross-origin" },
        frameguard: { action: "sameorigin" },
        hidePoweredBy: true,
        hsts: isProd ? {
          maxAge: 31536000,
          includeSubDomains: true,
          preload: true
        } : false,
        noSniff: true,
        referrerPolicy: { policy: "no-referrer-when-downgrade" },
        xssFilter: true
      }));
      if (options?.middlewares) {
        logger30.debug("Applying custom middlewares...");
        for (const middleware2 of options.middlewares) {
          this.app.use(middleware2);
        }
      }
      logger30.debug("Setting up standard middlewares...");
      this.app.use(cors2({
        origin: process.env.CORS_ORIGIN || true,
        credentials: true,
        methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
        allowedHeaders: ["Content-Type", "Authorization", "X-API-KEY"]
      }));
      this.app.use(express33.json({
        limit: process.env.EXPRESS_MAX_PAYLOAD || "2mb"
      }));
      const serverAuthToken = process.env.ELIZA_SERVER_AUTH_TOKEN;
      if (serverAuthToken) {
        logger30.info("Server authentication enabled. Requires X-API-KEY header for /api routes.");
        this.app.use("/api", (req, res, next) => {
          apiKeyAuthMiddleware(req, res, next);
        });
      } else {
        logger30.warn("Server authentication is disabled. Set ELIZA_SERVER_AUTH_TOKEN environment variable to enable.");
      }
      this.isWebUIEnabled = isWebUIEnabled();
      if (this.isWebUIEnabled) {
        logger30.info("Web UI enabled");
      } else {
        const uiEnabledEnv = process.env.ELIZA_UI_ENABLE;
        if (uiEnabledEnv !== undefined && uiEnabledEnv.trim() !== "") {
          logger30.info(`Web UI disabled by environment variable (ELIZA_UI_ENABLE=${uiEnabledEnv})`);
        } else {
          logger30.info("Web UI disabled for security (production mode)");
        }
      }
      const uploadsBasePath = getUploadsAgentsDir4();
      const generatedBasePath = getGeneratedDir2();
      fs6.mkdirSync(uploadsBasePath, { recursive: true });
      fs6.mkdirSync(generatedBasePath, { recursive: true });
      this.app.get("/media/uploads/agents/:agentId/:filename", (req, res) => {
        const agentId = req.params.agentId;
        const filename = req.params.filename;
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        if (!uuidRegex.test(agentId)) {
          res.status(400).json({ error: "Invalid agent ID format" });
          return;
        }
        const sanitizedFilename = basename2(filename);
        const agentUploadsPath = join4(uploadsBasePath, agentId);
        const filePath = join4(agentUploadsPath, sanitizedFilename);
        if (!filePath.startsWith(agentUploadsPath)) {
          res.status(403).json({ error: "Access denied" });
          return;
        }
        if (!fs6.existsSync(filePath)) {
          res.status(404).json({ error: "File does not exist!!!!!!!" });
          return;
        }
        res.sendFile(sanitizedFilename, { root: agentUploadsPath }, (err) => {
          if (err) {
            if (err.message === "Request aborted") {
              logger30.warn(`[MEDIA] Download aborted: ${req.originalUrl}`);
            } else if (!res.headersSent) {
              logger30.warn(`[MEDIA] File not found: ${agentUploadsPath}/${sanitizedFilename}`);
              res.status(404).json({ error: "File not found" });
            }
          } else {
            logger30.debug(`[MEDIA] Successfully served: ${sanitizedFilename}`);
          }
        });
      });
      this.app.get("/media/generated/:agentId/:filename", (req, res) => {
        const agentId = req.params.agentId;
        const filename = req.params.filename;
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        if (!uuidRegex.test(agentId)) {
          res.status(400).json({ error: "Invalid agent ID format" });
          return;
        }
        const sanitizedFilename = basename2(filename);
        const agentGeneratedPath = join4(generatedBasePath, agentId);
        const filePath = join4(agentGeneratedPath, sanitizedFilename);
        if (!filePath.startsWith(agentGeneratedPath)) {
          res.status(403).json({ error: "Access denied" });
          return;
        }
        if (!existsSync4(filePath)) {
          res.status(404).json({ error: "File not found" });
          return;
        }
        const absolutePath = path8.resolve(filePath);
        const options2 = {
          dotfiles: "deny"
        };
        res.sendFile(absolutePath, options2, (err) => {
          if (err) {
            const ext2 = extname(filename).toLowerCase();
            const mimeType = ext2 === ".png" ? "image/png" : ext2 === ".jpg" || ext2 === ".jpeg" ? "image/jpeg" : "application/octet-stream";
            res.setHeader("Content-Type", mimeType);
            const stream = fs6.createReadStream(absolutePath);
            stream.on("error", () => res.status(404).json({ error: "File not found" }));
            stream.pipe(res);
          }
        });
      });
      this.app.get("/media/uploads/channels/:channelId/:filename", (req, res) => {
        const channelId = req.params.channelId;
        const filename = req.params.filename;
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        if (!uuidRegex.test(channelId)) {
          res.status(400).json({ error: "Invalid channel ID format" });
          return;
        }
        const sanitizedFilename = basename2(filename);
        const channelUploadsPath = join4(uploadsBasePath, "channels", channelId);
        const filePath = join4(channelUploadsPath, sanitizedFilename);
        if (!filePath.startsWith(channelUploadsPath)) {
          res.status(403).json({ error: "Access denied" });
          return;
        }
        res.sendFile(filePath, (err) => {
          if (err) {
            logger30.warn({ err, filePath }, `[STATIC] Channel media file not found: ${filePath}`);
            if (!res.headersSent) {
              res.status(404).json({ error: "File not found" });
            }
          } else {
            logger30.debug(`[STATIC] Served channel media file: ${filePath}`);
          }
        });
      });
      this.app.use((_req, res, next) => {
        const ext2 = extname(_req.path).toLowerCase();
        if (ext2 === ".js" || ext2 === ".mjs") {
          res.setHeader("Content-Type", "application/javascript");
        } else if (ext2 === ".css") {
          res.setHeader("Content-Type", "text/css");
        } else if (ext2 === ".svg") {
          res.setHeader("Content-Type", "image/svg+xml");
        } else if (ext2 === ".png") {
          res.setHeader("Content-Type", "image/png");
        } else if (ext2 === ".jpg" || ext2 === ".jpeg") {
          res.setHeader("Content-Type", "image/jpeg");
        }
        next();
      });
      const staticOptions = {
        etag: true,
        lastModified: true,
        fallthrough: true,
        setHeaders: (res, filePath) => {
          const ext2 = extname(filePath).toLowerCase();
          if (ext2 === ".css") {
            res.setHeader("Content-Type", "text/css");
          } else if (ext2 === ".js") {
            res.setHeader("Content-Type", "application/javascript");
          } else if (ext2 === ".html") {
            res.setHeader("Content-Type", "text/html");
          } else if (ext2 === ".png") {
            res.setHeader("Content-Type", "image/png");
          } else if (ext2 === ".jpg" || ext2 === ".jpeg") {
            res.setHeader("Content-Type", "image/jpeg");
          } else if (ext2 === ".svg") {
            res.setHeader("Content-Type", "image/svg+xml");
          }
        }
      };
      let clientPath = null;
      if (this.isWebUIEnabled) {
        const possiblePaths = [
          this.clientPath,
          path8.resolve(__dirname3, "client"),
          path8.resolve(__dirname3, "../../client/dist"),
          (() => {
            try {
              return path8.resolve(path8.dirname(__require.resolve("@elizaos/client/package.json")), "dist");
            } catch {
              return null;
            }
          })(),
          (() => {
            try {
              if (process.argv[1]) {
                const serverPath = path8.dirname(process.argv[1]);
                const possibleClientPath = path8.join(serverPath, "client");
                if (existsSync4(path8.join(possibleClientPath, "index.html"))) {
                  return possibleClientPath;
                }
                if (existsSync4(path8.join(serverPath, "index.html"))) {
                  return serverPath;
                }
              }
            } catch {}
            return null;
          })(),
          (() => {
            try {
              const bunGlobalPath = path8.join(os3.homedir(), ".bun/install/global/node_modules/@elizaos/server/dist/client");
              if (existsSync4(path8.join(bunGlobalPath, "index.html"))) {
                return bunGlobalPath;
              }
              try {
                const proc = Bun.spawnSync(["npm", "root", "-g"], {
                  stdout: "pipe",
                  stderr: "pipe"
                });
                if (proc.exitCode === 0 && proc.stdout) {
                  const npmRoot = new TextDecoder().decode(proc.stdout).trim();
                  const globalServerPath = path8.join(npmRoot, "@elizaos/server/dist/client");
                  if (existsSync4(path8.join(globalServerPath, "index.html"))) {
                    return globalServerPath;
                  }
                }
              } catch {}
            } catch {}
            return null;
          })(),
          ...[
            "/usr/local/lib/node_modules/@elizaos/server/dist/client",
            "/usr/lib/node_modules/@elizaos/server/dist/client",
            path8.join(os3.homedir(), ".npm-global/lib/node_modules/@elizaos/server/dist/client"),
            (() => {
              try {
                const nvmPath = path8.join(os3.homedir(), ".nvm/versions/node");
                if (existsSync4(nvmPath)) {
                  const versions = fs6.readdirSync(nvmPath);
                  for (const version of versions) {
                    const cliPath = path8.join(nvmPath, version, "lib/node_modules/@elizaos/server/dist/client");
                    if (existsSync4(path8.join(cliPath, "index.html"))) {
                      return cliPath;
                    }
                  }
                }
              } catch {}
              return null;
            })()
          ].filter(Boolean)
        ].filter(Boolean);
        logger30.debug(`[STATIC] process.argv[0]: ${process.argv[0]}`);
        logger30.debug(`[STATIC] process.argv[1]: ${process.argv[1]}`);
        logger30.debug(`[STATIC] __dirname: ${__dirname3}`);
        for (const possiblePath of possiblePaths) {
          if (possiblePath && existsSync4(path8.join(possiblePath, "index.html"))) {
            clientPath = possiblePath;
            logger30.info(`[STATIC] Found client files at: ${clientPath}`);
            break;
          }
        }
        if (clientPath) {
          this.clientPath = clientPath;
          this.app.use(express33.static(clientPath, staticOptions));
          logger30.info(`[STATIC] Serving static files from: ${clientPath}`);
        } else {
          logger30.warn("[STATIC] Client dist path not found. Searched locations:");
          possiblePaths.forEach((p) => {
            if (p)
              logger30.warn(`[STATIC]   - ${p}`);
          });
          logger30.warn("[STATIC] The web UI will not be available.");
          logger30.warn("[STATIC] To fix this, ensure the client is built: cd packages/client && bun run build");
          logger30.warn("[STATIC] Then rebuild the server: cd packages/server && bun run build");
        }
      }
      const pluginRouteHandler = createPluginRouteHandler(this.agents);
      this.app.use(pluginRouteHandler);
      const apiRouter = createApiRouter(this.agents, this);
      this.app.use("/api", (req, _res, next) => {
        if (req.path !== "/ping") {
          logger30.debug(`API request: ${req.method} ${req.path}`);
        }
        next();
      }, apiRouter, (err, req, res, _next) => {
        if (sentryDsn) {
          captureException(err, (scope) => {
            scope.setTag("route", req.path);
            scope.setContext("request", {
              method: req.method,
              path: req.path,
              query: req.query
            });
            return scope;
          });
        }
        logger30.error({ err }, `API error: ${req.method} ${req.path}`);
        res.status(500).json({
          success: false,
          error: {
            message: err.message || "Internal Server Error",
            code: err.code || 500
          }
        });
      });
      if (sentryDsn) {
        process.on("uncaughtException", (error2) => {
          try {
            captureException(error2, (scope) => {
              scope.setTag("type", "uncaughtException");
              return scope;
            });
          } catch {}
        });
        process.on("unhandledRejection", (reason) => {
          try {
            captureException(reason instanceof Error ? reason : new Error(String(reason)), (scope) => {
              scope.setTag("type", "unhandledRejection");
              return scope;
            });
          } catch {}
        });
      }
      this.app.use((_req, res, next) => {
        if (_req.path.startsWith("/api/")) {
          res.status(404).json({
            success: false,
            error: {
              message: "API endpoint not found",
              code: 404
            }
          });
        } else {
          next();
        }
      });
      if (this.isWebUIEnabled) {
        this.app.use((req, res) => {
          if (req.path.endsWith(".js") || req.path.includes(".js?") || req.path.match(/\/[a-zA-Z0-9_-]+-[A-Za-z0-9]{8}\.js/)) {
            res.setHeader("Content-Type", "application/javascript");
            return res.status(404).send(`// JavaScript module not found: ${req.path}`);
          }
          const resolvedClientPath = clientPath || this.clientPath;
          if (resolvedClientPath) {
            const indexFilePath = path8.join(resolvedClientPath, "index.html");
            if (!existsSync4(indexFilePath)) {
              logger30.error(`[STATIC] index.html not found at expected path: ${indexFilePath}`);
              logger30.error(`[STATIC] Client path was: ${resolvedClientPath}`);
              res.status(404).send("Client application not found");
              return;
            }
            res.sendFile("index.html", { root: resolvedClientPath }, (err) => {
              if (err) {
                logger30.warn(`[STATIC] Failed to serve index.html: ${err.message}`);
                logger30.warn(`[STATIC] Attempted root: ${resolvedClientPath}`);
                logger30.warn(`[STATIC] Full path was: ${indexFilePath}`);
                logger30.warn(`[STATIC] Error code: ${err.code || "unknown"}`);
                if (!res.headersSent) {
                  res.status(404).send("Client application not found");
                }
              } else {
                logger30.debug(`[STATIC] Successfully served index.html for route: ${req.path}`);
              }
            });
          } else {
            logger30.warn("[STATIC] Client dist path not found in SPA fallback");
            logger30.warn("[STATIC] Neither local nor instance clientPath variables are set");
            res.status(404).send("Client application not found");
          }
        });
      } else {
        this.app.use((_req, res) => {
          res.sendStatus(403);
        });
      }
      this.server = http4.createServer(this.app);
      this.socketIO = setupSocketIO(this.server, this.agents, this);
      logger30.success("AgentServer HTTP server and Socket.IO initialized");
    } catch (error2) {
      logger30.error({ error: error2 }, "Failed to complete server initialization:");
      throw error2;
    }
  }
  async registerAgent(runtime) {
    try {
      if (!runtime) {
        throw new Error("Attempted to register null/undefined runtime");
      }
      if (!runtime.agentId) {
        throw new Error("Runtime missing agentId");
      }
      if (!runtime.character) {
        throw new Error("Runtime missing character configuration");
      }
      this.agents.set(runtime.agentId, runtime);
      logger30.debug(`Agent ${runtime.character.name} (${runtime.agentId}) added to agents map`);
      try {
        if (messageBusConnectorPlugin) {
          await runtime.registerPlugin(messageBusConnectorPlugin);
          logger30.info(`[AgentServer] Automatically registered MessageBusConnector for agent ${runtime.character.name}`);
        } else {
          logger30.error(`[AgentServer] CRITICAL: MessageBusConnector plugin definition not found.`);
        }
      } catch (e) {
        logger30.error({ error: e }, `[AgentServer] CRITICAL: Failed to register MessageBusConnector for agent ${runtime.character.name}`);
      }
      const teePlugin = runtime.plugins.find((p) => p.name === "phala-tee-plugin");
      if (teePlugin) {
        logger30.debug(`Found TEE plugin for agent ${runtime.agentId}`);
        if (teePlugin.providers) {
          for (const provider of teePlugin.providers) {
            runtime.registerProvider(provider);
            logger30.debug(`Registered TEE provider: ${provider.name}`);
          }
        }
        if (teePlugin.actions) {
          for (const action of teePlugin.actions) {
            runtime.registerAction(action);
            logger30.debug(`Registered TEE action: ${action.name}`);
          }
        }
      }
      logger30.success(`Successfully registered agent ${runtime.character.name} (${runtime.agentId}) with core services.`);
      await this.addAgentToServer(DEFAULT_SERVER_ID6, runtime.agentId);
      logger30.info(`[AgentServer] Auto-associated agent ${runtime.character.name} with server ID: ${DEFAULT_SERVER_ID6}`);
    } catch (error2) {
      logger30.error({ error: error2 }, "Failed to register agent:");
      throw error2;
    }
  }
  unregisterAgent(agentId) {
    if (!agentId) {
      logger30.warn("[AGENT UNREGISTER] Attempted to unregister undefined or invalid agent runtime");
      return;
    }
    try {
      const agent = this.agents.get(agentId);
      if (agent) {
        try {
          agent.stop().catch((stopError) => {
            logger30.error({ error: stopError, agentId }, `[AGENT UNREGISTER] Error stopping agent services for ${agentId}:`);
          });
          logger30.debug(`[AGENT UNREGISTER] Stopping services for agent ${agentId}`);
        } catch (stopError) {
          logger30.error({ error: stopError, agentId }, `[AGENT UNREGISTER] Error initiating stop for agent ${agentId}:`);
        }
      }
      this.agents.delete(agentId);
      logger30.debug(`Agent ${agentId} removed from agents map`);
    } catch (error2) {
      logger30.error({ error: error2, agentId }, `Error removing agent ${agentId}:`);
    }
  }
  registerMiddleware(middleware2) {
    this.app.use(middleware2);
  }
  start(port) {
    return new Promise((resolve2, reject) => {
      try {
        if (!port || typeof port !== "number") {
          throw new Error(`Invalid port number: ${port}`);
        }
        logger30.debug(`Starting server on port ${port}...`);
        logger30.debug(`Current agents count: ${this.agents.size}`);
        logger30.debug(`Environment: ${"development"}`);
        const host = process.env.SERVER_HOST || "0.0.0.0";
        this.server.listen(port, host, () => {
          if (this.isWebUIEnabled && false) {} else if (!this.isWebUIEnabled) {
            const actualHost = host === "0.0.0.0" ? "localhost" : host;
            const baseUrl = `http://${actualHost}:${port}`;
            console.log(`\x1B[32mStartup successful!\x1B[0m
` + `\x1B[33mWeb UI disabled.\x1B[0m \x1B[32mAPI endpoints available at:\x1B[0m
` + `  \x1B[1m${baseUrl}/api/server/ping\x1B[22m\x1B[0m
` + `  \x1B[1m${baseUrl}/api/agents\x1B[22m\x1B[0m
` + `  \x1B[1m${baseUrl}/api/messaging\x1B[22m\x1B[0m`);
          }
          console.log(`AgentServer is listening on port ${port}`);
          logger30.success(`REST API bound to ${host}:${port}. If running locally, access it at http://localhost:${port}.`);
          logger30.debug(`Active agents: ${this.agents.size}`);
          this.agents.forEach((agent, id) => {
            logger30.debug(`- Agent ${id}: ${agent.character.name}`);
          });
          resolve2();
        }).on("error", (error2) => {
          logger30.error({ error: error2, host, port }, `Failed to bind server to ${host}:${port}:`);
          if (error2.code === "EADDRINUSE") {
            logger30.error(`Port ${port} is already in use. Please try a different port or stop the process using that port.`);
          } else if (error2.code === "EACCES") {
            logger30.error(`Permission denied to bind to port ${port}. Try using a port above 1024 or running with appropriate permissions.`);
          } else if (error2.code === "EADDRNOTAVAIL") {
            logger30.error(`Cannot bind to ${host}:${port} - address not available. Check if the host address is correct.`);
          }
          reject(error2);
        });
      } catch (error2) {
        logger30.error({ error: error2 }, "Failed to start server:");
        reject(error2);
      }
    });
  }
  async stop() {
    if (this.server) {
      this.server.close(() => {
        logger30.success("Server stopped");
      });
    }
  }
  async createServer(data) {
    return this.database.createMessageServer(data);
  }
  async getServers() {
    return this.database.getMessageServers();
  }
  async getServerById(serverId) {
    return this.database.getMessageServerById(serverId);
  }
  async getServerBySourceType(sourceType) {
    const servers = await this.database.getMessageServers();
    const filtered = servers.filter((s) => s.sourceType === sourceType);
    return filtered.length > 0 ? filtered[0] : null;
  }
  async createChannel(data, participantIds) {
    return this.database.createChannel(data, participantIds);
  }
  async addParticipantsToChannel(channelId, userIds) {
    return this.database.addChannelParticipants(channelId, userIds);
  }
  async getChannelsForServer(serverId) {
    return this.database.getChannelsForServer(serverId);
  }
  async getChannelDetails(channelId) {
    return this.database.getChannelDetails(channelId);
  }
  async getChannelParticipants(channelId) {
    return this.database.getChannelParticipants(channelId);
  }
  async deleteMessage(messageId) {
    return this.database.deleteMessage(messageId);
  }
  async updateChannel(channelId, updates) {
    return this.database.updateChannel(channelId, updates);
  }
  async deleteChannel(channelId) {
    return this.database.deleteChannel(channelId);
  }
  async clearChannelMessages(channelId) {
    const messages = await this.database.getMessagesForChannel(channelId, 1000);
    for (const message of messages) {
      await this.database.deleteMessage(message.id);
    }
    logger30.info(`[AgentServer] Cleared all messages for central channel: ${channelId}`);
  }
  async findOrCreateCentralDmChannel(user1Id, user2Id, messageServerId) {
    return this.database.findOrCreateDmChannel(user1Id, user2Id, messageServerId);
  }
  async createMessage(data) {
    const createdMessage = await this.database.createMessage(data);
    const channel3 = await this.getChannelDetails(createdMessage.channelId);
    if (channel3) {
      const messageForBus = {
        id: createdMessage.id,
        channel_id: createdMessage.channelId,
        server_id: channel3.messageServerId,
        author_id: createdMessage.authorId,
        content: createdMessage.content,
        raw_message: createdMessage.rawMessage,
        source_id: createdMessage.sourceId,
        source_type: createdMessage.sourceType,
        in_reply_to_message_id: createdMessage.inReplyToRootMessageId,
        created_at: createdMessage.createdAt.getTime(),
        metadata: createdMessage.metadata
      };
      bus_default.emit("new_message", messageForBus);
      logger30.info(`[AgentServer] Published message ${createdMessage.id} to internal message bus`);
    }
    return createdMessage;
  }
  async getMessagesForChannel(channelId, limit = 50, beforeTimestamp) {
    return this.database.getMessagesForChannel(channelId, limit, beforeTimestamp);
  }
  async updateMessage(messageId, patch) {
    return this.database.updateMessage(messageId, patch);
  }
  async removeParticipantFromChannel() {
    logger30.warn(`[AgentServer] Remove participant operation not directly supported in database adapter`);
  }
  async addAgentToServer(serverId, agentId) {
    const server = await this.getServerById(serverId);
    if (!server) {
      throw new Error(`Server ${serverId} not found`);
    }
    return this.database.addAgentToServer(serverId, agentId);
  }
  async removeAgentFromServer(serverId, agentId) {
    return this.database.removeAgentFromServer(serverId, agentId);
  }
  async getAgentsForServer(serverId) {
    return this.database.getAgentsForServer(serverId);
  }
  async getServersForAgent(agentId) {
    const servers = await this.database.getMessageServers();
    const serverIds = [];
    for (const server of servers) {
      const agents = await this.database.getAgentsForServer(server.id);
      if (agents.includes(agentId)) {
        serverIds.push(server.id);
      }
    }
    return serverIds;
  }
  registerSignalHandlers() {
    const gracefulShutdown = async () => {
      logger30.info("Received shutdown signal, initiating graceful shutdown...");
      logger30.debug("Stopping all agents...");
      for (const [id, agent] of this.agents.entries()) {
        try {
          await agent.stop();
          logger30.debug(`Stopped agent ${id}`);
        } catch (error2) {
          logger30.error({ error: error2, agentId: id }, `Error stopping agent ${id}:`);
        }
      }
      if (this.database) {
        try {
          await this.database.close();
          logger30.info("Database closed.");
        } catch (error2) {
          logger30.error({ error: error2 }, "Error closing database:");
        }
      }
      if (this.server) {
        this.server.close(() => {
          logger30.success("Server closed successfully");
          process.exit(0);
        });
        setTimeout(() => {
          logger30.error("Could not close connections in time, forcing shutdown");
          process.exit(1);
        }, 5000);
      } else {
        process.exit(0);
      }
    };
    process.on("SIGTERM", gracefulShutdown);
    process.on("SIGINT", gracefulShutdown);
    logger30.debug("Shutdown handlers registered");
  }
}
export {
  tryLoadFile,
  resolvePgliteDir,
  loadCharactersFromUrl,
  loadCharacters,
  loadCharacterTryPath,
  loadCharacter,
  jsonToCharacter,
  isWebUIEnabled,
  hasValidRemoteUrls,
  expandTildePath,
  AgentServer
};
