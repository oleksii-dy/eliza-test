import { type Character, DatabaseAdapter, type IAgentRuntime, type UUID } from '@elizaos/core';
import express from 'express';
import http from 'node:http';
import { Server as SocketIOServer } from 'socket.io';
import type { CentralRootMessage, MessageChannel, MessageServer } from './types.js';
/**
 * Expands a file path starting with `~` to the project directory.
 *
 * @param filepath - The path to expand.
 * @returns The expanded path.
 */
export declare function expandTildePath(filepath: string): string;
export declare function resolvePgliteDir(dir?: string, fallbackDir?: string): string;
/**
 * Represents a function that acts as a server middleware.
 * @param {express.Request} req - The request object.
 * @param {express.Response} res - The response object.
 * @param {express.NextFunction} next - The next function to be called in the middleware chain.
 * @returns {void}
 */
export type ServerMiddleware = (req: express.Request, res: express.Response, next: express.NextFunction) => void;
/**
 * Interface for defining server configuration options.
 * @typedef {Object} ServerOptions
 * @property {ServerMiddleware[]} [middlewares] - Optional array of server middlewares.
 * @property {string} [dataDir] - Optional directory for storing server data.
 * @property {string} [postgresUrl] - Optional URL for connecting to a PostgreSQL database.
 */
export interface ServerOptions {
    middlewares?: ServerMiddleware[];
    dataDir?: string;
    postgresUrl?: string;
    clientPath?: string;
}
/**
 * Determines if the web UI should be enabled based on environment variables.
 *
 * @returns {boolean} - Returns true if UI should be enabled, false otherwise
 */
export declare function isWebUIEnabled(): boolean;
/**
 * Class representing an agent server.
 */ /**
* Represents an agent server which handles agents, database, and server functionalities.
*/
export declare class AgentServer {
    app: express.Application;
    private agents;
    server: http.Server;
    socketIO: SocketIOServer;
    isInitialized: boolean;
    private isWebUIEnabled;
    private clientPath?;
    database: DatabaseAdapter;
    startAgent: (character: Character) => Promise<IAgentRuntime>;
    stopAgent: (runtime: IAgentRuntime) => void;
    loadCharacterTryPath: (characterPath: string) => Promise<Character>;
    jsonToCharacter: (character: unknown) => Promise<Character>;
    /**
     * Constructor for AgentServer class.
     *
     * @constructor
     */
    constructor();
    /**
     * Initializes the database and server.
     *
     * @param {ServerOptions} [options] - Optional server options.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    initialize(options?: ServerOptions): Promise<void>;
    private ensureDefaultServer;
    /**
     * Initializes the server with the provided options.
     *
     * @param {ServerOptions} [options] - Optional server options.
     * @returns {Promise<void>} - A promise that resolves once the server is initialized.
     */
    private initializeServer;
    /**
     * Registers an agent with the provided runtime.
     *
     * @param {IAgentRuntime} runtime - The runtime object containing agent information.
     * @throws {Error} if the runtime is null/undefined, if agentId is missing, if character configuration is missing,
     * or if there are any errors during registration.
     */
    registerAgent(runtime: IAgentRuntime): Promise<void>;
    /**
     * Unregisters an agent from the system.
     *
     * @param {UUID} agentId - The unique identifier of the agent to unregister.
     * @returns {void}
     */
    unregisterAgent(agentId: UUID): void;
    /**
     * Add middleware to the server's request handling pipeline
     * @param {ServerMiddleware} middleware - The middleware function to be registered
     */
    registerMiddleware(middleware: ServerMiddleware): void;
    /**
     * Starts the server on the specified port.
     *
     * @param {number} port - The port number on which the server should listen.
     * @returns {Promise<void>} A promise that resolves when the server is listening.
     * @throws {Error} If the port is invalid or if there is an error while starting the server.
     */
    start(port: number): Promise<void>;
    /**
     * Stops the server if it is running. Closes the server connection,
     * stops the database connection, and logs a success message.
     */
    stop(): Promise<void>;
    createServer(data: Omit<MessageServer, 'id' | 'createdAt' | 'updatedAt'>): Promise<MessageServer>;
    getServers(): Promise<MessageServer[]>;
    getServerById(serverId: UUID): Promise<MessageServer | null>;
    getServerBySourceType(sourceType: string): Promise<MessageServer | null>;
    createChannel(data: Omit<MessageChannel, 'id' | 'createdAt' | 'updatedAt'> & {
        id?: UUID;
    }, participantIds?: UUID[]): Promise<MessageChannel>;
    addParticipantsToChannel(channelId: UUID, userIds: UUID[]): Promise<void>;
    getChannelsForServer(serverId: UUID): Promise<MessageChannel[]>;
    getChannelDetails(channelId: UUID): Promise<MessageChannel | null>;
    getChannelParticipants(channelId: UUID): Promise<UUID[]>;
    deleteMessage(messageId: UUID): Promise<void>;
    updateChannel(channelId: UUID, updates: {
        name?: string;
        participantCentralUserIds?: UUID[];
        metadata?: any;
    }): Promise<MessageChannel>;
    deleteChannel(channelId: UUID): Promise<void>;
    clearChannelMessages(channelId: UUID): Promise<void>;
    findOrCreateCentralDmChannel(user1Id: UUID, user2Id: UUID, messageServerId: UUID): Promise<MessageChannel>;
    createMessage(data: Omit<CentralRootMessage, 'id' | 'createdAt' | 'updatedAt'>): Promise<CentralRootMessage>;
    getMessagesForChannel(channelId: UUID, limit?: number, beforeTimestamp?: Date): Promise<CentralRootMessage[]>;
    updateMessage(messageId: UUID, patch: {
        content?: string;
        rawMessage?: any;
        sourceType?: string;
        sourceId?: string;
        metadata?: any;
        inReplyToRootMessageId?: UUID;
    }): Promise<CentralRootMessage | null>;
    removeParticipantFromChannel(): Promise<void>;
    /**
     * Add an agent to a server
     * @param {UUID} serverId - The server ID
     * @param {UUID} agentId - The agent ID to add
     */
    addAgentToServer(serverId: UUID, agentId: UUID): Promise<void>;
    /**
     * Remove an agent from a server
     * @param {UUID} serverId - The server ID
     * @param {UUID} agentId - The agent ID to remove
     */
    removeAgentFromServer(serverId: UUID, agentId: UUID): Promise<void>;
    /**
     * Get all agents associated with a server
     * @param {UUID} serverId - The server ID
     * @returns {Promise<UUID[]>} Array of agent IDs
     */
    getAgentsForServer(serverId: UUID): Promise<UUID[]>;
    /**
     * Get all servers an agent belongs to
     * @param {UUID} agentId - The agent ID
     * @returns {Promise<UUID[]>} Array of server IDs
     */
    getServersForAgent(agentId: UUID): Promise<UUID[]>;
    /**
     * Registers signal handlers for graceful shutdown.
     * This is called once in the constructor to prevent handler accumulation.
     */
    private registerSignalHandlers;
}
export { tryLoadFile, loadCharactersFromUrl, jsonToCharacter, loadCharacter, loadCharacterTryPath, hasValidRemoteUrls, loadCharacters, } from './loader';
export * from './types';
