{
  "version": 3,
  "sources": ["../src/lib/base-client.ts", "../src/services/agents.ts", "../src/services/messaging.ts", "../src/services/memory.ts", "../src/services/audio.ts", "../src/services/media.ts", "../src/services/server.ts", "../src/services/system.ts", "../src/services/sessions.ts", "../src/client.ts", "../src/services/runs.ts"],
  "sourcesContent": [
    "import { ApiResponse, ApiClientConfig, RequestConfig } from '../types/base';\n\ndeclare const window: any;\n\nexport class ApiError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public details?: string,\n    public status?: number\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nexport abstract class BaseApiClient {\n  protected baseUrl: string;\n  protected apiKey?: string;\n  protected timeout: number;\n  protected defaultHeaders: Record<string, string>;\n\n  constructor(config: ApiClientConfig) {\n    this.baseUrl = config.baseUrl.replace(/\\/$/, ''); // Remove trailing slash\n    this.apiKey = config.apiKey;\n    this.timeout = config.timeout || 30000; // 30 seconds default\n    this.defaultHeaders = {\n      'Content-Type': 'application/json',\n      ...config.headers,\n    };\n\n    if (this.apiKey) {\n      // Server expects X-API-KEY header; keep backward compatibility\n      this.defaultHeaders['X-API-KEY'] = this.apiKey;\n    }\n  }\n\n  /**\n   * Creates a safe response for no-content scenarios (204 responses)\n   * Returns a sensible default based on common API patterns\n   */\n  private createNoContentResponse<T>(): T {\n    // For most delete/update operations, return a success indicator\n    // This handles the common case of { success: boolean } return types\n    return { success: true } as T;\n  }\n\n  protected async request<T>(\n    method: string,\n    path: string,\n    options?: {\n      body?: any;\n      params?: Record<string, any>;\n      headers?: Record<string, string>;\n      config?: RequestConfig;\n    }\n  ): Promise<T> {\n    // Handle empty baseUrl for relative URLs\n    let url: URL;\n    if (this.baseUrl) {\n      url = new URL(`${this.baseUrl}${path}`);\n    } else if (typeof window !== 'undefined' && window.location) {\n      url = new URL(path, window.location.origin);\n    } else {\n      // Fallback for non-browser environments\n      url = new URL(path, 'http://localhost:3000');\n    }\n\n    // Add query parameters\n    if (options?.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const headers = {\n        ...this.defaultHeaders,\n        ...options?.config?.headers,\n        ...options?.headers,\n      };\n\n      // Remove Content-Type header if body is FormData\n      if (options?.body instanceof FormData) {\n        delete headers['Content-Type'];\n      }\n\n      const response = await fetch(url.toString(), {\n        method,\n        headers,\n        body:\n          options?.body instanceof FormData\n            ? options.body\n            : options?.body\n              ? JSON.stringify(options.body)\n              : undefined,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      // Handle empty responses (204 No Content)\n      if (response.status === 204 || response.headers.get('content-length') === '0') {\n        // For 204 No Content, create a synthetic success response\n        return this.createNoContentResponse<T>();\n      }\n\n      // Parse JSON response\n      let jsonData: any;\n      try {\n        jsonData = await response.json();\n      } catch (error) {\n        // If JSON parsing fails, treat as success for 2xx responses\n        if (response.ok) {\n          return this.createNoContentResponse<T>();\n        } else {\n          throw new ApiError(\n            'PARSE_ERROR',\n            'Failed to parse response as JSON',\n            undefined,\n            response.status\n          );\n        }\n      }\n\n      // Handle error responses\n      if (!response.ok) {\n        // Try to extract error information from response\n        const error = jsonData?.error || {\n          code: 'HTTP_ERROR',\n          message: `HTTP ${response.status}: ${response.statusText}`,\n        };\n        throw new ApiError(error.code, error.message, error.details, response.status);\n      }\n\n      // Handle successful responses\n      // Check if response is wrapped in { success: true, data: ... } format\n      if (jsonData && typeof jsonData === 'object' && 'success' in jsonData) {\n        const apiResponse = jsonData as ApiResponse<T>;\n        if (!apiResponse.success) {\n          const error =\n            'error' in apiResponse\n              ? apiResponse.error\n              : {\n                  code: 'UNKNOWN_ERROR',\n                  message: 'An unknown error occurred',\n                };\n          throw new ApiError(error.code, error.message, error.details, response.status);\n        }\n        return apiResponse.data;\n      } else {\n        // Response is not wrapped - return the data directly\n        // This handles server endpoints like /health, /ping, /status\n        return jsonData as T;\n      }\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof ApiError) {\n        throw error;\n      }\n\n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          throw new ApiError('TIMEOUT', 'Request timed out');\n        }\n        throw new ApiError('NETWORK_ERROR', error.message);\n      }\n\n      throw new ApiError('UNKNOWN_ERROR', 'An unknown error occurred');\n    }\n  }\n\n  protected async get<T>(\n    path: string,\n    options?: Omit<Parameters<typeof this.request>[2], 'body'>\n  ): Promise<T> {\n    return this.request<T>('GET', path, options);\n  }\n\n  protected async post<T>(\n    path: string,\n    body?: any,\n    options?: Parameters<typeof this.request>[2]\n  ): Promise<T> {\n    return this.request<T>('POST', path, { ...options, body });\n  }\n\n  protected async put<T>(\n    path: string,\n    body?: any,\n    options?: Parameters<typeof this.request>[2]\n  ): Promise<T> {\n    return this.request<T>('PUT', path, { ...options, body });\n  }\n\n  protected async patch<T>(\n    path: string,\n    body?: any,\n    options?: Parameters<typeof this.request>[2]\n  ): Promise<T> {\n    return this.request<T>('PATCH', path, { ...options, body });\n  }\n\n  protected async delete<T>(\n    path: string,\n    options?: Omit<Parameters<typeof this.request>[2], 'body'>\n  ): Promise<T> {\n    return this.request<T>('DELETE', path, options);\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  Agent,\n  AgentCreateParams,\n  AgentLog,\n  AgentLogsParams,\n  AgentPanel,\n  AgentUpdateParams,\n  AgentWorld,\n  AgentWorldSettings,\n} from '../types/agents';\n\nexport class AgentsService extends BaseApiClient {\n  /**\n   * List all agents with minimal details\n   */\n  async listAgents(): Promise<{ agents: Agent[] }> {\n    return this.get<{ agents: Agent[] }>('/api/agents');\n  }\n\n  /**\n   * Get specific agent details\n   */\n  async getAgent(agentId: UUID): Promise<Agent> {\n    return this.get<Agent>(`/api/agents/${agentId}`);\n  }\n\n  /**\n   * Create a new agent\n   */\n  async createAgent(params: AgentCreateParams): Promise<Agent> {\n    return this.post<Agent>('/api/agents', params);\n  }\n\n  /**\n   * Update an existing agent\n   */\n  async updateAgent(agentId: UUID, params: AgentUpdateParams): Promise<Agent> {\n    return this.patch<Agent>(`/api/agents/${agentId}`, params);\n  }\n\n  /**\n   * Delete an agent\n   */\n  async deleteAgent(agentId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/agents/${agentId}`);\n  }\n\n  /**\n   * Start an existing agent\n   */\n  async startAgent(agentId: UUID): Promise<{ status: string }> {\n    return this.post<{ status: string }>(`/api/agents/${agentId}/start`);\n  }\n\n  /**\n   * Stop a running agent\n   */\n  async stopAgent(agentId: UUID): Promise<{ status: string }> {\n    return this.post<{ status: string }>(`/api/agents/${agentId}/stop`);\n  }\n\n  /**\n   * Get all available worlds\n   */\n  async getWorlds(): Promise<{ worlds: AgentWorld[] }> {\n    return this.get<{ worlds: AgentWorld[] }>('/api/agents/worlds');\n  }\n\n  /**\n   * Add agent to a world\n   */\n  async addAgentToWorld(agentId: UUID, worldId: UUID): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>(`/api/agents/${agentId}/worlds`, { worldId });\n  }\n\n  /**\n   * Update agent's world settings\n   */\n  async updateAgentWorldSettings(\n    agentId: UUID,\n    worldId: UUID,\n    settings: Record<string, any>\n  ): Promise<AgentWorldSettings> {\n    return this.patch<AgentWorldSettings>(`/api/agents/${agentId}/worlds/${worldId}`, { settings });\n  }\n\n  /**\n   * Get agent's plugin panels\n   */\n  async getAgentPanels(agentId: UUID): Promise<{ panels: AgentPanel[] }> {\n    const response = await this.get<Array<{ name: string; path: string }>>(\n      `/api/agents/${agentId}/panels`\n    );\n\n    const panels: AgentPanel[] = (Array.isArray(response) ? response : []).map((panel, index) => ({\n      id: `${panel.name}-${index}`, // Generate an ID since server doesn't send one\n      name: panel.name,\n      url: panel.path,\n      type: 'plugin',\n    }));\n\n    return { panels };\n  }\n\n  /**\n   * Get agent logs\n   */\n  async getAgentLogs(agentId: UUID, params?: AgentLogsParams): Promise<AgentLog[]> {\n    return this.get<AgentLog[]>(`/api/agents/${agentId}/logs`, { params });\n  }\n\n  /**\n   * Delete a specific log entry\n   */\n  async deleteAgentLog(agentId: UUID, logId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/agents/${agentId}/logs/${logId}`);\n  }\n\n  /**\n   * Get agents associated with a server\n   */\n  async getAgentsForServer(\n    serverId: UUID\n  ): Promise<{ success: boolean; data: { serverId: UUID; agents: UUID[] } }> {\n    return this.get<{ success: boolean; data: { serverId: UUID; agents: UUID[] } }>(\n      `/api/messaging/servers/${serverId}/agents`\n    );\n  }\n\n  async addAgentToServer(\n    serverId: UUID,\n    agentId: UUID\n  ): Promise<{ success: boolean; data: { serverId: UUID; agentId: UUID; message: string } }> {\n    return this.post<{\n      success: boolean;\n      data: { serverId: UUID; agentId: UUID; message: string };\n    }>(`/api/messaging/servers/${serverId}/agents`, { agentId });\n  }\n\n  async removeAgentFromServer(\n    serverId: UUID,\n    agentId: UUID\n  ): Promise<{ success: boolean; data: { serverId: UUID; agentId: UUID; message: string } }> {\n    return this.delete<{\n      success: boolean;\n      data: { serverId: UUID; agentId: UUID; message: string };\n    }>(`/api/messaging/servers/${serverId}/agents/${agentId}`);\n  }\n\n  async getServersForAgent(\n    agentId: UUID\n  ): Promise<{ success: boolean; data: { agentId: UUID; servers: UUID[] } }> {\n    return this.get<{ success: boolean; data: { agentId: UUID; servers: UUID[] } }>(\n      `/api/messaging/agents/${agentId}/servers`\n    );\n  }\n}\n",
    "import { UUID, ChannelType } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  Message,\n  MessageServer,\n  MessageChannel,\n  MessageSubmitParams,\n  MessageCompleteParams,\n  ExternalMessageParams,\n  ChannelCreateParams,\n  GroupChannelCreateParams,\n  DmChannelParams,\n  ChannelParticipant,\n  MessageSearchParams,\n  ServerCreateParams,\n  ServerSyncParams,\n  ChannelUpdateParams,\n  ChannelMetadata,\n  MessageMetadata,\n} from '../types/messaging';\nimport { PaginationParams } from '../types/base';\n\n// Internal payload interfaces for API requests\ninterface ChannelCreatePayload {\n  name: string;\n  type: ChannelType;\n  server_id: UUID;\n  metadata?: ChannelMetadata;\n}\n\ninterface GroupChannelCreatePayload {\n  name: string;\n  server_id: UUID;\n  participantCentralUserIds: UUID[];\n  type?: ChannelType;\n  metadata?: ChannelMetadata;\n}\n\ninterface DmChannelQuery {\n  currentUserId: UUID;\n  targetUserId: UUID;\n  dmServerId: UUID;\n}\n\nexport class MessagingService extends BaseApiClient {\n  /**\n   * Submit agent replies or system messages\n   */\n  async submitMessage(params: MessageSubmitParams): Promise<Message> {\n    return this.post<Message>('/api/messaging/submit', params);\n  }\n\n  /**\n   * Notify message completion\n   */\n  async completeMessage(params: MessageCompleteParams): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>('/api/messaging/complete', params);\n  }\n\n  /**\n   * Ingest messages from external platforms\n   */\n  async ingestExternalMessages(params: ExternalMessageParams): Promise<{ processed: number }> {\n    return this.post<{ processed: number }>('/api/messaging/ingest-external', params);\n  }\n\n  /**\n   * Create a new channel\n   */\n  async createChannel(params: ChannelCreateParams): Promise<MessageChannel> {\n    // Server expects: { name, type, server_id, metadata }\n    const payload: ChannelCreatePayload = {\n      name: params.name,\n      type: params.type,\n      server_id: params.serverId || ('00000000-0000-0000-0000-000000000000' as UUID),\n      metadata: params.metadata,\n    };\n    return this.post<MessageChannel>('/api/messaging/central-channels', payload);\n  }\n\n  /**\n   * Create a group channel\n   */\n  async createGroupChannel(params: GroupChannelCreateParams): Promise<MessageChannel> {\n    // Server expects: { name, server_id, participantCentralUserIds, type?, metadata? }\n    // The client currently provides participantIds and may include server_id/type in metadata.\n    const DEFAULT_SERVER_ID = '00000000-0000-0000-0000-000000000000' as UUID;\n\n    // Extract and clean metadata - handle legacy fields that might be in metadata\n    let cleanedMetadata: ChannelMetadata | undefined;\n    let serverIdFromMeta: UUID | undefined;\n    let typeFromMeta: ChannelType | undefined;\n\n    if (params.metadata) {\n      // Create a new metadata object without the hoisted fields\n      const metadataCopy: ChannelMetadata = { ...params.metadata };\n\n      // Extract hoisted fields safely using bracket notation (ChannelMetadata allows [key: string]: unknown)\n      if ('server_id' in metadataCopy) {\n        serverIdFromMeta = metadataCopy['server_id'] as UUID | undefined;\n        delete metadataCopy['server_id'];\n      }\n\n      if ('type' in metadataCopy) {\n        typeFromMeta = metadataCopy['type'] as ChannelType | undefined;\n        delete metadataCopy['type'];\n      }\n\n      // Only include metadata if there are remaining properties\n      if (Object.keys(metadataCopy).length > 0) {\n        cleanedMetadata = metadataCopy;\n      }\n    }\n\n    const payload: GroupChannelCreatePayload = {\n      name: params.name,\n      server_id: serverIdFromMeta || DEFAULT_SERVER_ID,\n      participantCentralUserIds: params.participantIds,\n      // If caller intended DM, allow type override\n      ...(typeFromMeta ? { type: typeFromMeta } : {}),\n      ...(cleanedMetadata ? { metadata: cleanedMetadata } : {}),\n    };\n\n    return this.post<MessageChannel>('/api/messaging/central-channels', payload);\n  }\n\n  /**\n   * Find or create a DM channel\n   */\n  async getOrCreateDmChannel(params: DmChannelParams): Promise<MessageChannel> {\n    // Map participantIds -> { currentUserId, targetUserId }\n    const [userA, userB] = params.participantIds;\n    // Arbitrarily treat the first as current and second as target; callers pass [current, target]\n    const query: DmChannelQuery = {\n      currentUserId: userA,\n      targetUserId: userB,\n      dmServerId: '00000000-0000-0000-0000-000000000000' as UUID,\n    };\n    return this.get<MessageChannel>('/api/messaging/dm-channel', { params: query });\n  }\n\n  /**\n   * Get channel details\n   */\n  async getChannelDetails(channelId: UUID): Promise<MessageChannel> {\n    return this.get<MessageChannel>(`/api/messaging/central-channels/${channelId}/details`);\n  }\n\n  /**\n   * Get channel participants\n   */\n  async getChannelParticipants(channelId: UUID): Promise<{ participants: ChannelParticipant[] }> {\n    return this.get<{ participants: ChannelParticipant[] }>(\n      `/api/messaging/central-channels/${channelId}/participants`\n    );\n  }\n\n  /**\n   * Add agent to channel\n   */\n  async addAgentToChannel(channelId: UUID, agentId: UUID): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>(`/api/messaging/central-channels/${channelId}/agents`, {\n      agentId,\n    });\n  }\n\n  /**\n   * Remove agent from channel\n   */\n  async removeAgentFromChannel(channelId: UUID, agentId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/central-channels/${channelId}/agents/${agentId}`\n    );\n  }\n\n  /**\n   * Delete a channel\n   */\n  async deleteChannel(channelId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/messaging/central-channels/${channelId}`);\n  }\n\n  /**\n   * Clear channel history\n   */\n  async clearChannelHistory(channelId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(\n      `/api/messaging/central-channels/${channelId}/messages`\n    );\n  }\n\n  /**\n   * Post a new message to a channel\n   */\n  async postMessage(\n    channelId: UUID,\n    content: string,\n    metadata?: MessageMetadata\n  ): Promise<Message> {\n    return this.post<Message>(`/api/messaging/central-channels/${channelId}/messages`, {\n      content,\n      metadata,\n    });\n  }\n\n  /**\n   * Get channel messages\n   */\n  async getChannelMessages(\n    channelId: UUID,\n    params?: PaginationParams & { before?: Date | string; after?: Date | string }\n  ): Promise<{ messages: Message[] }> {\n    return this.get<{ messages: Message[] }>(\n      `/api/messaging/central-channels/${channelId}/messages`,\n      { params }\n    );\n  }\n\n  /**\n   * Get a specific message\n   */\n  async getMessage(messageId: UUID): Promise<Message> {\n    return this.get<Message>(`/api/messaging/messages/${messageId}`);\n  }\n\n  /**\n   * Delete a message from a channel\n   */\n  async deleteMessage(channelId: UUID, messageId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/central-channels/${channelId}/messages/${messageId}`\n    );\n  }\n\n  /**\n   * Update a message\n   */\n  async updateMessage(messageId: UUID, content: string): Promise<Message> {\n    return this.patch<Message>(`/api/messaging/messages/${messageId}`, { content });\n  }\n\n  /**\n   * Search messages\n   */\n  async searchMessages(params: MessageSearchParams): Promise<{ messages: Message[] }> {\n    return this.post<{ messages: Message[] }>('/api/messaging/messages/search', params);\n  }\n\n  /**\n   * List all message servers\n   */\n  async listServers(): Promise<{ servers: MessageServer[] }> {\n    return this.get<{ servers: MessageServer[] }>('/api/messaging/central-servers');\n  }\n\n  /**\n   * Get server channels\n   */\n  async getServerChannels(serverId: UUID): Promise<{ channels: MessageChannel[] }> {\n    return this.get<{ channels: MessageChannel[] }>(\n      `/api/messaging/central-servers/${serverId}/channels`\n    );\n  }\n\n  /**\n   * Create a new server\n   */\n  async createServer(params: ServerCreateParams): Promise<MessageServer> {\n    return this.post<MessageServer>('/api/messaging/servers', params);\n  }\n\n  /**\n   * Sync server channels\n   */\n  async syncServerChannels(serverId: UUID, params: ServerSyncParams): Promise<{ synced: number }> {\n    return this.post<{ synced: number }>(\n      `/api/messaging/servers/${serverId}/sync-channels`,\n      params\n    );\n  }\n\n  /**\n   * Delete a server\n   */\n  async deleteServer(serverId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/messaging/servers/${serverId}`);\n  }\n\n  /**\n   * Update a channel\n   */\n  async updateChannel(\n    channelId: UUID,\n    params: ChannelUpdateParams\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    return this.patch<{ success: boolean; data: MessageChannel }>(\n      `/api/messaging/central-channels/${channelId}`,\n      params\n    );\n  }\n\n  /**\n   * Generate channel title\n   */\n  async generateChannelTitle(channelId: UUID, agentId: UUID): Promise<{ title: string }> {\n    return this.post<{ title: string }>(\n      `/api/messaging/central-channels/${channelId}/generate-title`,\n      { agentId }\n    );\n  }\n\n  /**\n   * Add user to channel participants (implemented via updateChannel)\n   */\n  async addUserToChannel(\n    channelId: UUID,\n    userId: UUID\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    // First get current participants\n    const channel = await this.getChannelDetails(channelId);\n    const currentParticipants: UUID[] = channel.metadata?.participantCentralUserIds || [];\n\n    // Add new user if not already present\n    if (!currentParticipants.includes(userId)) {\n      const updatedParticipants: UUID[] = [...currentParticipants, userId];\n      return this.updateChannel(channelId, {\n        participantCentralUserIds: updatedParticipants,\n      });\n    }\n\n    return { success: true, data: channel };\n  }\n\n  /**\n   * Add multiple users to channel participants (implemented via updateChannel)\n   */\n  async addUsersToChannel(\n    channelId: UUID,\n    userIds: UUID[]\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    // First get current participants\n    const channel = await this.getChannelDetails(channelId);\n    const currentParticipants: UUID[] = channel.metadata?.participantCentralUserIds || [];\n\n    // Add new users that aren't already present\n    const newParticipants: UUID[] = [...currentParticipants];\n    for (const userId of userIds) {\n      if (!newParticipants.includes(userId)) {\n        newParticipants.push(userId);\n      }\n    }\n\n    return this.updateChannel(channelId, {\n      participantCentralUserIds: newParticipants,\n    });\n  }\n\n  /**\n   * Remove user from channel participants (implemented via updateChannel)\n   */\n  async removeUserFromChannel(\n    channelId: UUID,\n    userId: UUID\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    // First get current participants\n    const channel = await this.getChannelDetails(channelId);\n    const currentParticipants: UUID[] = channel.metadata?.participantCentralUserIds || [];\n\n    // Remove user from participants\n    const updatedParticipants: UUID[] = currentParticipants.filter((id) => id !== userId);\n\n    return this.updateChannel(channelId, {\n      participantCentralUserIds: updatedParticipants,\n    });\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  Memory,\n  Room,\n  MemoryParams,\n  MemoryUpdateParams,\n  RoomCreateParams,\n  WorldCreateParams,\n} from '../types/memory';\n\nexport class MemoryService extends BaseApiClient {\n  /**\n   * Get agent memories\n   */\n  async getAgentMemories(agentId: UUID, params?: MemoryParams): Promise<{ memories: Memory[] }> {\n    return this.get<{ memories: Memory[] }>(`/api/memory/${agentId}/memories`, { params });\n  }\n\n  /**\n   * Get room-specific memories\n   */\n  async getRoomMemories(\n    agentId: UUID,\n    roomId: UUID,\n    params?: MemoryParams\n  ): Promise<{ memories: Memory[] }> {\n    return this.get<{ memories: Memory[] }>(`/api/memory/${agentId}/rooms/${roomId}/memories`, {\n      params,\n    });\n  }\n\n  /**\n   * Update a memory\n   */\n  async updateMemory(agentId: UUID, memoryId: UUID, params: MemoryUpdateParams): Promise<Memory> {\n    return this.patch<Memory>(`/api/memory/${agentId}/memories/${memoryId}`, params);\n  }\n\n  /**\n   * Clear all agent memories\n   */\n  async clearAgentMemories(agentId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(`/api/memory/${agentId}/memories`);\n  }\n\n  /**\n   * Clear room memories\n   */\n  async clearRoomMemories(agentId: UUID, roomId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(`/api/memory/${agentId}/memories/all/${roomId}`);\n  }\n\n  /**\n   * List agent's rooms\n   */\n  async listAgentRooms(agentId: UUID): Promise<{ rooms: Room[] }> {\n    return this.get<{ rooms: Room[] }>(`/api/memory/${agentId}/rooms`);\n  }\n\n  /**\n   * Get room details\n   */\n  async getRoom(agentId: UUID, roomId: UUID): Promise<Room> {\n    return this.get<Room>(`/api/memory/${agentId}/rooms/${roomId}`);\n  }\n\n  /**\n   * Create a room\n   */\n  async createRoom(agentId: UUID, params: RoomCreateParams): Promise<Room> {\n    return this.post<Room>(`/api/memory/${agentId}/rooms`, params);\n  }\n\n  /**\n   * Create world from server\n   */\n  async createWorldFromServer(\n    serverId: UUID,\n    params: WorldCreateParams\n  ): Promise<{ worldId: UUID }> {\n    return this.post<{ worldId: UUID }>(`/api/memory/groups/${serverId}`, params);\n  }\n\n  /**\n   * Delete a world\n   */\n  async deleteWorld(serverId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/memory/groups/${serverId}`);\n  }\n\n  /**\n   * Clear world memories\n   */\n  async clearWorldMemories(serverId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(`/api/memory/groups/${serverId}/memories`);\n  }\n\n  /**\n   * Delete a specific memory\n   */\n  async deleteMemory(agentId: UUID, memoryId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/memory/${agentId}/memories/${memoryId}`);\n  }\n\n  /**\n   * Get agent internal memories\n   */\n  async getAgentInternalMemories(\n    agentId: UUID,\n    agentPerspectiveRoomId: UUID,\n    includeEmbedding?: boolean\n  ): Promise<{ success: boolean; data: any[] }> {\n    return this.get<{ success: boolean; data: any[] }>(\n      `/api/memory/${agentId}/rooms/${agentPerspectiveRoomId}/memories`,\n      { params: { includeEmbedding } }\n    );\n  }\n\n  /**\n   * Delete agent internal memory\n   */\n  async deleteAgentInternalMemory(agentId: UUID, memoryId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/memory/${agentId}/memories/${memoryId}`);\n  }\n\n  /**\n   * Delete all agent internal memories\n   */\n  async deleteAllAgentInternalMemories(\n    agentId: UUID,\n    agentPerspectiveRoomId: UUID\n  ): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/memory/${agentId}/memories/all/${agentPerspectiveRoomId}`\n    );\n  }\n\n  /**\n   * Update agent internal memory\n   */\n  async updateAgentInternalMemory(agentId: UUID, memoryId: UUID, memoryData: any): Promise<any> {\n    return this.patch<any>(`/api/memory/${agentId}/memories/${memoryId}`, memoryData);\n  }\n\n  /**\n   * Delete group memory (implemented via messaging channel message deletion)\n   */\n  async deleteGroupMemory(serverId: UUID, memoryId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/central-channels/${serverId}/messages/${memoryId}`\n    );\n  }\n\n  /**\n   * Clear group chat (implemented via messaging channel history clearing)\n   */\n  async clearGroupChat(serverId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/central-channels/${serverId}/messages`\n    );\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  AudioSynthesizeParams,\n  SpeechConversationParams,\n  SpeechGenerateParams,\n  SpeechResponse,\n  TranscribeParams,\n  TranscriptionResponse,\n} from '../types/audio';\n\ndeclare const window: any;\n\nexport class AudioService extends BaseApiClient {\n  /**\n   * Make a binary request using BaseApiClient infrastructure\n   */\n  private async requestBinary(\n    method: string,\n    path: string,\n    options?: {\n      body?: any;\n      params?: Record<string, any>;\n      headers?: Record<string, string>;\n    }\n  ): Promise<ArrayBuffer> {\n    // Handle empty baseUrl for relative URLs\n    let url: URL;\n    if (this.baseUrl) {\n      url = new URL(`${this.baseUrl}${path}`);\n    } else if (typeof window !== 'undefined' && window.location) {\n      url = new URL(path, window.location.origin);\n    } else {\n      // Fallback for non-browser environments\n      url = new URL(path, 'http://localhost:3000');\n    }\n\n    // Add query parameters\n    if (options?.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const headers = {\n        ...this.defaultHeaders,\n        ...options?.headers,\n      };\n\n      // Remove Content-Type header if body is FormData\n      if (options?.body instanceof FormData) {\n        delete headers['Content-Type'];\n      }\n\n      const response = await fetch(url.toString(), {\n        method,\n        headers,\n        body:\n          options?.body instanceof FormData\n            ? options.body\n            : options?.body\n              ? JSON.stringify(options.body)\n              : undefined,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.arrayBuffer();\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          throw new Error('Request timed out');\n        }\n        throw error;\n      }\n\n      throw new Error('An unknown error occurred');\n    }\n  }\n\n  /**\n   * Convert audio input to appropriate FormData value\n   */\n  private processAudioInput(audio: Blob | Buffer | string): Blob | string {\n    if (audio instanceof Blob) {\n      return audio;\n    }\n\n    if (typeof audio === 'string') {\n      // Handle base64 data URLs (e.g., \"data:audio/mp3;base64,...\")\n      if (audio.startsWith('data:')) {\n        try {\n          const [header, base64Data] = audio.split(',');\n          const mimeMatch = header.match(/data:([^;]+)/);\n          const mimeType = mimeMatch ? mimeMatch[1] : 'audio/wav';\n\n          const binaryString = atob(base64Data);\n          const bytes = new Uint8Array(binaryString.length);\n          for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n          }\n          return new Blob([bytes], { type: mimeType });\n        } catch (error) {\n          throw new Error(\n            `Invalid base64 data URL: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n        }\n      }\n\n      // Handle plain base64 strings (try to decode)\n      if (this.isBase64String(audio)) {\n        try {\n          const binaryString = atob(audio);\n          const bytes = new Uint8Array(binaryString.length);\n          for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n          }\n          return new Blob([bytes], { type: 'audio/wav' });\n        } catch (error) {\n          // If base64 decoding fails, treat as file path or other string\n          return audio;\n        }\n      }\n\n      // For file paths or other strings, return as-is (server will handle file reading)\n      return audio;\n    }\n\n    // Handle Buffer and ArrayBuffer types\n    if (this.isBuffer(audio)) {\n      return new Blob([new Uint8Array(audio)], { type: 'audio/wav' });\n    }\n\n    // Cast to any for runtime type checking since TypeScript can't narrow the union type properly\n    const audioAsAny = audio as any;\n\n    if (audioAsAny instanceof ArrayBuffer) {\n      return new Blob([audioAsAny], { type: 'audio/wav' });\n    }\n\n    if (\n      audioAsAny &&\n      typeof audioAsAny === 'object' &&\n      'buffer' in audioAsAny &&\n      audioAsAny.buffer instanceof ArrayBuffer\n    ) {\n      // Handle typed arrays like Uint8Array\n      return new Blob([audioAsAny.buffer], { type: 'audio/wav' });\n    }\n\n    throw new Error(\n      `Unsupported audio input type: ${typeof audio}. Expected Blob, Buffer, ArrayBuffer, or string.`\n    );\n  }\n\n  /**\n   * Check if a string appears to be base64 encoded\n   */\n  private isBase64String(str: string): boolean {\n    // Basic base64 pattern check (allows padding)\n    const base64Pattern = /^[A-Za-z0-9+/]*={0,2}$/;\n\n    // Must be at least 4 characters and divisible by 4 (with padding)\n    if (str.length < 4 || str.length % 4 !== 0) {\n      return false;\n    }\n\n    return base64Pattern.test(str);\n  }\n\n  /**\n   * Safe check for Buffer type (works in both Node.js and browser environments)\n   */\n  private isBuffer(obj: any): obj is Buffer {\n    return (\n      obj != null &&\n      typeof obj === 'object' &&\n      typeof obj.constructor === 'function' &&\n      obj.constructor.name === 'Buffer' &&\n      typeof obj.readUInt8 === 'function'\n    );\n  }\n\n  /**\n   * Handle speech conversation\n   */\n  async speechConversation(\n    agentId: UUID,\n    params: SpeechConversationParams\n  ): Promise<SpeechResponse> {\n    const formData = new FormData();\n\n    const processedAudio = this.processAudioInput(params.audio);\n    if (processedAudio instanceof Blob) {\n      formData.append('file', processedAudio);\n    } else {\n      // String (file path or other string identifier)\n      formData.append('file', processedAudio);\n    }\n\n    if (params.format) formData.append('format', params.format);\n    if (params.language) formData.append('language', params.language);\n    if (params.metadata) formData.append('metadata', JSON.stringify(params.metadata));\n\n    return this.request<SpeechResponse>('POST', `/api/audio/${agentId}/speech/conversation`, {\n      body: formData,\n    });\n  }\n\n  /**\n   * Generate speech from text\n   */\n  async generateSpeech(\n    agentId: UUID,\n    params: SpeechGenerateParams\n  ): Promise<{ audio: string; format: string }> {\n    // Get the binary audio data using BaseApiClient infrastructure\n    const audioBuffer = await this.requestBinary('POST', `/api/audio/${agentId}/speech/generate`, {\n      body: params,\n    });\n\n    // Convert to base64\n    const bytes = new Uint8Array(audioBuffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    const base64Audio = btoa(binary);\n\n    // Default format (server should ideally return this in a header)\n    const format = 'mpeg';\n\n    return {\n      audio: base64Audio,\n      format: format,\n    };\n  }\n\n  /**\n   * Synthesize audio message\n   */\n  async synthesizeAudioMessage(\n    agentId: UUID,\n    params: AudioSynthesizeParams\n  ): Promise<{ audio: string; format: string }> {\n    return this.post<{ audio: string; format: string }>(\n      `/api/audio/${agentId}/audio-messages/synthesize`,\n      params\n    );\n  }\n\n  /**\n   * Transcribe audio to text\n   */\n  async transcribe(agentId: UUID, params: TranscribeParams): Promise<TranscriptionResponse> {\n    const formData = new FormData();\n\n    const processedAudio = this.processAudioInput(params.audio);\n    if (processedAudio instanceof Blob) {\n      formData.append('file', processedAudio);\n    } else {\n      // String (file path or other string identifier)\n      formData.append('file', processedAudio);\n    }\n\n    if (params.format) formData.append('format', params.format);\n    if (params.language) formData.append('language', params.language);\n\n    return this.request<TranscriptionResponse>('POST', `/api/audio/${agentId}/transcriptions`, {\n      body: formData,\n    });\n  }\n\n  /**\n   * Process speech input\n   */\n  async processSpeech(\n    agentId: UUID,\n    audio: Blob | Buffer | string,\n    metadata?: Record<string, any>\n  ): Promise<SpeechResponse> {\n    const formData = new FormData();\n\n    const processedAudio = this.processAudioInput(audio);\n    if (processedAudio instanceof Blob) {\n      formData.append('file', processedAudio);\n    } else {\n      // String (file path or other string identifier)\n      formData.append('file', processedAudio);\n    }\n\n    if (metadata) formData.append('metadata', JSON.stringify(metadata));\n\n    return this.request<SpeechResponse>('POST', `/api/audio/${agentId}/speech`, {\n      body: formData,\n    });\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport { MediaUploadParams, MediaUploadResponse, ChannelUploadResponse } from '../types/media';\n\nexport class MediaService extends BaseApiClient {\n  /**\n   * Upload media for an agent\n   */\n  async uploadAgentMedia(agentId: UUID, params: MediaUploadParams): Promise<MediaUploadResponse> {\n    const formData = new FormData();\n\n    formData.append('file', params.file, params.filename);\n\n    if (params.contentType) formData.append('contentType', params.contentType);\n    if (params.metadata) formData.append('metadata', JSON.stringify(params.metadata));\n\n    return this.request<MediaUploadResponse>('POST', `/api/media/agents/${agentId}/upload-media`, {\n      body: formData,\n    });\n  }\n\n  /**\n   * Upload file to a channel\n   */\n  async uploadChannelMedia(channelId: UUID, file: File): Promise<ChannelUploadResponse> {\n    const formData = new FormData();\n\n    formData.append('file', file);\n\n    return this.request<ChannelUploadResponse>(\n      'POST',\n      `/api/messaging/central-channels/${channelId}/upload-media`,\n      {\n        body: formData,\n      }\n    );\n  }\n}\n",
    "import { BaseApiClient } from '../lib/base-client';\nimport { ServerHealth, ServerStatus, ServerDebugInfo, LogSubmitParams } from '../types/server';\n\nexport class ServerService extends BaseApiClient {\n  /**\n   * Health check\n   */\n  async checkHealth(): Promise<ServerHealth> {\n    return this.get<ServerHealth>('/api/server/health');\n  }\n\n  /**\n   * Simple ping\n   */\n  async ping(): Promise<{ pong: boolean }> {\n    return this.get<{ pong: boolean }>('/api/server/ping');\n  }\n\n  /**\n   * Hello endpoint\n   */\n  async hello(): Promise<{ message: string }> {\n    return this.get<{ message: string }>('/api/server/hello');\n  }\n\n  /**\n   * Get server status\n   */\n  async getStatus(): Promise<ServerStatus> {\n    return this.get<ServerStatus>('/api/server/status');\n  }\n\n  /**\n   * Stop the server\n   */\n  async stopServer(): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>('/api/server/stop');\n  }\n\n  /**\n   * Get runtime debug info\n   */\n  async getDebugInfo(): Promise<ServerDebugInfo> {\n    return this.get<ServerDebugInfo>('/api/server/debug/servers');\n  }\n\n  /**\n   * Submit logs\n   */\n  async submitLogs(logs: LogSubmitParams[]): Promise<{ received: number }> {\n    return this.post<{ received: number }>('/api/server/logs', { logs });\n  }\n\n  /**\n   * Clear logs\n   */\n  async clearLogs(): Promise<{ cleared: number }> {\n    return this.delete<{ cleared: number }>('/api/server/logs');\n  }\n}\n",
    "import { BaseApiClient } from '../lib/base-client';\nimport { LocalEnvironmentUpdateParams } from '../types/system';\n\nexport class SystemService extends BaseApiClient {\n  /**\n   * Retrieve the local environment variables from the ElizaOS server.\n   *\n   * Server route (packages/server/src/api/system):\n   *   GET /api/system/env/local  ->  { success: true, data: Record<string,string> }\n   */\n  async getEnvironment(): Promise<Record<string, string>> {\n    return this.get<Record<string, string>>('/api/system/env/local');\n  }\n\n  /**\n   * Update (overwrite or merge) the local .env file on the ElizaOS server.\n   *\n   * Server route (packages/server/src/api/system):\n   *   POST /api/system/env/local  ->  { success: true, message: string }\n   *   Body: { content: Record<string,string> }\n   *\n   * For developer-ergonomics we accept several shapes:\n   *   1. { variables: Record<string,string>; merge?: boolean }\n   *   2. { content:   Record<string,string> }      (server-native)\n   *   3. Record<string,string>                      (shorthand)\n   */\n  async updateLocalEnvironment(\n    params:\n      | LocalEnvironmentUpdateParams\n      | { content: Record<string, string> }\n      | Record<string, string>\n  ): Promise<{ success: boolean; message: string }> {\n    if (!params || typeof params !== 'object') {\n      throw new Error('updateLocalEnvironment requires a configuration object');\n    }\n\n    let body: { content: Record<string, string> };\n\n    if ('variables' in params) {\n      body = { content: (params as LocalEnvironmentUpdateParams).variables };\n    } else if ('content' in params) {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      body = { content: (params as { content: Record<string, string> }).content };\n    } else {\n      // Treat params itself as record of env vars\n      body = { content: params as unknown as Record<string, string> };\n    }\n\n    return this.post<{ success: boolean; message: string }>('/api/system/env/local', body);\n  }\n\n  /**\n   * Global logs functionality - implementing via system endpoints\n   */\n  async getGlobalLogs(params?: { level?: string; agentName?: string; agentId?: string }): Promise<{\n    logs: Array<{\n      level: number;\n      time: number;\n      msg: string;\n      [key: string]: string | number | boolean | null | undefined;\n    }>;\n    count: number;\n    total: number;\n    level: string;\n    levels: string[];\n  }> {\n    // Special handling for logs endpoint that returns data directly without wrapper\n    const response = await fetch(this.buildUrl('/api/server/logs', { params }), {\n      method: 'GET',\n      headers: this.getHeaders(),\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as {\n      logs?: Array<{\n        level: number;\n        time: number;\n        msg: string;\n        [key: string]: string | number | boolean | null | undefined;\n      }>;\n      count?: number;\n      total?: number;\n      requestedLevel?: string;\n      level?: string;\n      levels?: string[];\n    };\n\n    // The logs endpoint returns data directly, not wrapped in { success, data }\n    // Map the response to expected format\n    return {\n      logs: data.logs || [],\n      count: data.count || 0,\n      total: data.total || 0,\n      level: data.requestedLevel || data.level || 'all',\n      levels: data.levels || [],\n    };\n  }\n\n  private buildUrl(path: string, options?: { params?: Record<string, any> }): string {\n    const url = new URL(`${this.baseUrl}${path}`);\n    if (options?.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n    return url.toString();\n  }\n\n  private getHeaders(): Record<string, string> {\n    return {\n      ...this.defaultHeaders,\n    };\n  }\n\n  async deleteGlobalLogs(): Promise<{ status: string; message: string }> {\n    return this.delete<{ status: string; message: string }>('/api/server/logs');\n  }\n\n  async deleteLog(logId: string): Promise<void> {\n    // Note: Individual log deletion is not supported by the server\n    // The server only supports bulk deletion via deleteGlobalLogs()\n    throw new Error(\n      'Individual log deletion is not supported. Use deleteGlobalLogs() to clear all logs.'\n    );\n  }\n}\n",
    "import { BaseApiClient } from '../lib/base-client';\nimport type {\n  CreateSessionParams,\n  CreateSessionResponse,\n  SendMessageParams,\n  GetMessagesParams,\n  GetMessagesResponse,\n  SessionInfoResponse,\n  SessionsHealthResponse,\n  ListSessionsResponse,\n  MessageResponse,\n} from '../types/sessions';\n\n/**\n * Query parameters for session messages API\n */\ninterface SessionMessageQueryParams {\n  limit?: string;\n  before?: string;\n  after?: string;\n}\n\n/**\n * Validates and converts a date parameter to timestamp string\n * @param value Date, string, or number to convert\n * @param paramName Name of the parameter for error messages\n * @returns Timestamp string or undefined if value is invalid\n */\nfunction toTimestampString(\n  value: Date | string | number | undefined,\n  paramName: string\n): string | undefined {\n  if (!value) return undefined;\n\n  let timestamp: number;\n\n  if (value instanceof Date) {\n    timestamp = value.getTime();\n  } else if (typeof value === 'string') {\n    const date = new Date(value);\n    timestamp = date.getTime();\n\n    // Check for invalid date\n    if (isNaN(timestamp)) {\n      console.warn(`Invalid date string for ${paramName}: ${value}`);\n      return undefined;\n    }\n  } else if (typeof value === 'number') {\n    timestamp = value;\n  } else {\n    console.warn(`Invalid type for ${paramName}: ${typeof value}`);\n    return undefined;\n  }\n\n  return timestamp.toString();\n}\n\n/**\n * Validates required parameters\n * @param value Parameter value to validate\n * @param paramName Name of the parameter for error messages\n * @throws Error if the parameter is invalid\n */\nfunction validateRequiredParam(\n  value: string | undefined | null,\n  paramName: string\n): asserts value is string {\n  if (!value || value.trim() === '') {\n    throw new Error(`${paramName} is required and cannot be empty`);\n  }\n}\n\n/**\n * Service for managing messaging sessions between users and agents\n */\nexport class SessionsService extends BaseApiClient {\n  /**\n   * Get health status of the sessions service\n   * @returns Health check response\n   */\n  async checkHealth(): Promise<SessionsHealthResponse> {\n    return this.get<SessionsHealthResponse>('/api/messaging/sessions/health');\n  }\n\n  /**\n   * Create a new messaging session\n   * @param params Session creation parameters\n   * @returns Created session response\n   */\n  async createSession(params: CreateSessionParams): Promise<CreateSessionResponse> {\n    return this.post<CreateSessionResponse>('/api/messaging/sessions', params);\n  }\n\n  /**\n   * Get session details\n   * @param sessionId Session ID\n   * @returns Session information\n   */\n  async getSession(sessionId: string): Promise<SessionInfoResponse> {\n    validateRequiredParam(sessionId, 'sessionId');\n    return this.get<SessionInfoResponse>(`/api/messaging/sessions/${sessionId}`);\n  }\n\n  /**\n   * Send a message in a session\n   * @param sessionId Session ID\n   * @param params Message parameters\n   * @returns Message response\n   */\n  async sendMessage(sessionId: string, params: SendMessageParams): Promise<MessageResponse> {\n    validateRequiredParam(sessionId, 'sessionId');\n    validateRequiredParam(params?.content, 'content');\n    return this.post<MessageResponse>(`/api/messaging/sessions/${sessionId}/messages`, params);\n  }\n\n  /**\n   * Get messages from a session\n   * @param sessionId Session ID\n   * @param params Query parameters for pagination and filtering\n   * @returns Messages response\n   */\n  async getMessages(sessionId: string, params?: GetMessagesParams): Promise<GetMessagesResponse> {\n    validateRequiredParam(sessionId, 'sessionId');\n\n    const queryParams: SessionMessageQueryParams = {};\n\n    if (params?.limit) {\n      queryParams.limit = params.limit.toString();\n    }\n\n    // Convert date parameters with validation\n    const beforeTimestamp = toTimestampString(params?.before, 'before');\n    if (beforeTimestamp) {\n      queryParams.before = beforeTimestamp;\n    }\n\n    const afterTimestamp = toTimestampString(params?.after, 'after');\n    if (afterTimestamp) {\n      queryParams.after = afterTimestamp;\n    }\n\n    return this.get<GetMessagesResponse>(`/api/messaging/sessions/${sessionId}/messages`, {\n      params: queryParams,\n    });\n  }\n\n  /**\n   * Delete a session\n   * @param sessionId Session ID\n   * @returns Success response\n   */\n  async deleteSession(sessionId: string): Promise<{ success: boolean }> {\n    validateRequiredParam(sessionId, 'sessionId');\n    return this.delete<{ success: boolean }>(`/api/messaging/sessions/${sessionId}`);\n  }\n\n  /**\n   * List all active sessions (admin endpoint)\n   * @returns List of active sessions\n   */\n  async listSessions(): Promise<ListSessionsResponse> {\n    return this.get<ListSessionsResponse>('/api/messaging/sessions');\n  }\n}\n",
    "import { ApiClientConfig } from './types/base';\nimport { AgentsService } from './services/agents';\nimport { MessagingService } from './services/messaging';\nimport { MemoryService } from './services/memory';\nimport { AudioService } from './services/audio';\nimport { MediaService } from './services/media';\nimport { ServerService } from './services/server';\nimport { SystemService } from './services/system';\nimport { SessionsService } from './services/sessions';\n\nexport class ElizaClient {\n  public readonly agents: AgentsService;\n  public readonly messaging: MessagingService;\n  public readonly memory: MemoryService;\n  public readonly audio: AudioService;\n  public readonly media: MediaService;\n  public readonly server: ServerService;\n  public readonly system: SystemService;\n  public readonly sessions: SessionsService;\n\n  constructor(config: ApiClientConfig) {\n    // Initialize all services with the same config\n    this.agents = new AgentsService(config);\n    this.messaging = new MessagingService(config);\n    this.memory = new MemoryService(config);\n    this.audio = new AudioService(config);\n    this.media = new MediaService(config);\n    this.server = new ServerService(config);\n    this.system = new SystemService(config);\n    this.sessions = new SessionsService(config);\n  }\n\n  /**\n   * Create a new ElizaClient instance\n   */\n  static create(config: ApiClientConfig): ElizaClient {\n    return new ElizaClient(config);\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport { ListRunsParams, RunDetail, RunSummary } from '../types/runs';\n\nexport class RunsService extends BaseApiClient {\n  async listRuns(\n    agentId: UUID,\n    params?: ListRunsParams\n  ): Promise<{ runs: RunSummary[]; total: number; hasMore: boolean }> {\n    return this.get<{ runs: RunSummary[]; total: number; hasMore: boolean }>(\n      `/api/agents/${agentId}/runs`,\n      { params }\n    );\n  }\n\n  async getRun(agentId: UUID, runId: UUID, roomId?: UUID): Promise<RunDetail> {\n    return this.get<RunDetail>(`/api/agents/${agentId}/runs/${runId}`, {\n      params: roomId ? { roomId } : undefined,\n    });\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "65D7855F09637C0064756E2164756E21",
  "names": []
}