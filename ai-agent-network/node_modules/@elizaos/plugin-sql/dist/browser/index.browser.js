var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// src/index.browser.ts
import {
  logger as logger5
} from "@elizaos/core/browser";

// src/pglite/adapter.ts
import { logger as logger2 } from "@elizaos/core";
import { drizzle } from "drizzle-orm/pglite";

// src/base.ts
import {
  ChannelType,
  DatabaseAdapter,
  logger
} from "@elizaos/core";
import {
  and,
  cosineDistance,
  count,
  desc,
  eq,
  gte,
  inArray,
  lt,
  lte,
  or,
  sql as sql16
} from "drizzle-orm";

// ../../node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0;i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// ../../node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// ../../node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// ../../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0;i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;
// src/schema/embedding.ts
import { sql as sql5 } from "drizzle-orm";
import { check as check2, foreignKey as foreignKey2, index as index2, pgTable as pgTable5, timestamp as timestamp5, uuid as uuid5, vector } from "drizzle-orm/pg-core";
import { VECTOR_DIMS } from "@elizaos/core";

// src/schema/memory.ts
import { relations, sql as sql4 } from "drizzle-orm";
import {
  boolean as boolean2,
  check,
  foreignKey,
  index,
  jsonb as jsonb4,
  pgTable as pgTable4,
  text as text4,
  timestamp as timestamp4,
  uuid as uuid4
} from "drizzle-orm/pg-core";

// src/schema/agent.ts
import { sql } from "drizzle-orm";
import { boolean, jsonb, pgTable, text, timestamp, unique, uuid } from "drizzle-orm/pg-core";
var agentTable = pgTable("agents", {
  id: uuid("id").primaryKey().defaultRandom(),
  enabled: boolean("enabled").default(true).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).default(sql`now()`).notNull(),
  name: text("name").notNull(),
  username: text("username"),
  system: text("system").default(""),
  bio: jsonb("bio").$type().default(sql`'[]'::jsonb`),
  messageExamples: jsonb("message_examples").$type().default(sql`'[]'::jsonb`).notNull(),
  postExamples: jsonb("post_examples").$type().default(sql`'[]'::jsonb`).notNull(),
  topics: jsonb("topics").$type().default(sql`'[]'::jsonb`).notNull(),
  adjectives: jsonb("adjectives").$type().default(sql`'[]'::jsonb`).notNull(),
  knowledge: jsonb("knowledge").$type().default(sql`'[]'::jsonb`).notNull(),
  plugins: jsonb("plugins").$type().default(sql`'[]'::jsonb`).notNull(),
  settings: jsonb("settings").$type().default(sql`'{}'::jsonb`).notNull(),
  style: jsonb("style").$type().default(sql`'{}'::jsonb`).notNull()
}, (table) => {
  return {
    nameUnique: unique("name_unique").on(table.name)
  };
});

// src/schema/entity.ts
import { sql as sql2 } from "drizzle-orm";
import { jsonb as jsonb2, pgTable as pgTable2, text as text2, timestamp as timestamp2, unique as unique2, uuid as uuid2 } from "drizzle-orm/pg-core";
var entityTable = pgTable2("entities", {
  id: uuid2("id").notNull().primaryKey(),
  agentId: uuid2("agent_id").notNull().references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  createdAt: timestamp2("created_at").default(sql2`now()`).notNull(),
  names: text2("names").array().default(sql2`'{}'::text[]`).notNull(),
  metadata: jsonb2("metadata").default(sql2`'{}'::jsonb`).notNull()
}, (table) => {
  return {
    idAgentIdUnique: unique2("id_agent_id_unique").on(table.id, table.agentId)
  };
});

// src/schema/room.ts
import { sql as sql3 } from "drizzle-orm";
import { jsonb as jsonb3, pgTable as pgTable3, text as text3, timestamp as timestamp3, uuid as uuid3 } from "drizzle-orm/pg-core";
var roomTable = pgTable3("rooms", {
  id: uuid3("id").notNull().primaryKey().default(sql3`gen_random_uuid()`),
  agentId: uuid3("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  source: text3("source").notNull(),
  type: text3("type").notNull(),
  serverId: text3("serverId"),
  worldId: uuid3("worldId"),
  name: text3("name"),
  metadata: jsonb3("metadata"),
  channelId: text3("channelId"),
  createdAt: timestamp3("createdAt").default(sql3`now()`).notNull()
});

// src/schema/memory.ts
var memoryTable = pgTable4("memories", {
  id: uuid4("id").primaryKey().notNull(),
  type: text4("type").notNull(),
  createdAt: timestamp4("createdAt").default(sql4`now()`).notNull(),
  content: jsonb4("content").notNull(),
  entityId: uuid4("entityId").references(() => entityTable.id, {
    onDelete: "cascade"
  }),
  agentId: uuid4("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }).notNull(),
  roomId: uuid4("roomId").references(() => roomTable.id, {
    onDelete: "cascade"
  }),
  worldId: uuid4("worldId"),
  unique: boolean2("unique").default(true).notNull(),
  metadata: jsonb4("metadata").default({}).notNull()
}, (table) => [
  index("idx_memories_type_room").on(table.type, table.roomId),
  index("idx_memories_world_id").on(table.worldId),
  foreignKey({
    name: "fk_room",
    columns: [table.roomId],
    foreignColumns: [roomTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_user",
    columns: [table.entityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_agent",
    columns: [table.agentId],
    foreignColumns: [agentTable.id]
  }).onDelete("cascade"),
  index("idx_memories_metadata_type").on(sql4`((metadata->>'type'))`),
  index("idx_memories_document_id").on(sql4`((metadata->>'documentId'))`),
  index("idx_fragments_order").on(sql4`((metadata->>'documentId'))`, sql4`((metadata->>'position'))`),
  check("fragment_metadata_check", sql4`
            CASE 
                WHEN metadata->>'type' = 'fragment' THEN
                    metadata ? 'documentId' AND 
                    metadata ? 'position'
                ELSE true
            END
        `),
  check("document_metadata_check", sql4`
            CASE 
                WHEN metadata->>'type' = 'document' THEN
                    metadata ? 'timestamp'
                ELSE true
            END
        `)
]);
var memoryRelations = relations(memoryTable, ({ one }) => ({
  embedding: one(embeddingTable)
}));

// src/schema/embedding.ts
var DIMENSION_MAP = {
  [VECTOR_DIMS.SMALL]: "dim384",
  [VECTOR_DIMS.MEDIUM]: "dim512",
  [VECTOR_DIMS.LARGE]: "dim768",
  [VECTOR_DIMS.XL]: "dim1024",
  [VECTOR_DIMS.XXL]: "dim1536",
  [VECTOR_DIMS.XXXL]: "dim3072"
};
var embeddingTable = pgTable5("embeddings", {
  id: uuid5("id").primaryKey().defaultRandom().notNull(),
  memoryId: uuid5("memory_id").references(() => memoryTable.id, { onDelete: "cascade" }),
  createdAt: timestamp5("created_at").default(sql5`now()`).notNull(),
  dim384: vector("dim_384", { dimensions: VECTOR_DIMS.SMALL }),
  dim512: vector("dim_512", { dimensions: VECTOR_DIMS.MEDIUM }),
  dim768: vector("dim_768", { dimensions: VECTOR_DIMS.LARGE }),
  dim1024: vector("dim_1024", { dimensions: VECTOR_DIMS.XL }),
  dim1536: vector("dim_1536", { dimensions: VECTOR_DIMS.XXL }),
  dim3072: vector("dim_3072", { dimensions: VECTOR_DIMS.XXXL })
}, (table) => [
  check2("embedding_source_check", sql5`"memory_id" IS NOT NULL`),
  index2("idx_embedding_memory").on(table.memoryId),
  foreignKey2({
    name: "fk_embedding_memory",
    columns: [table.memoryId],
    foreignColumns: [memoryTable.id]
  }).onDelete("cascade")
]);

// src/schema/index.ts
var exports_schema = {};
__export(exports_schema, {
  worldTable: () => worldTable,
  taskTable: () => taskTable,
  serverAgentsTable: () => serverAgentsTable,
  roomTable: () => roomTable,
  relationshipTable: () => relationshipTable,
  participantTable: () => participantTable,
  messageTable: () => messageTable,
  messageServerTable: () => messageServerTable,
  memoryTable: () => memoryTable,
  logTable: () => logTable,
  entityTable: () => entityTable,
  embeddingTable: () => embeddingTable,
  componentTable: () => componentTable,
  channelTable: () => channelTable,
  channelParticipantsTable: () => channelParticipantsTable,
  cacheTable: () => cacheTable,
  agentTable: () => agentTable
});

// src/schema/cache.ts
import { sql as sql6 } from "drizzle-orm";
import { jsonb as jsonb5, pgTable as pgTable6, text as text5, primaryKey, timestamp as timestamp6, uuid as uuid6 } from "drizzle-orm/pg-core";
var cacheTable = pgTable6("cache", {
  key: text5("key").notNull(),
  agentId: uuid6("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  value: jsonb5("value").notNull(),
  createdAt: timestamp6("created_at", { withTimezone: true }).default(sql6`now()`).notNull(),
  expiresAt: timestamp6("expires_at", { withTimezone: true })
}, (table) => ({
  pk: primaryKey({ columns: [table.key, table.agentId] })
}));
// src/schema/component.ts
import { sql as sql8 } from "drizzle-orm";
import { jsonb as jsonb7, pgTable as pgTable8, text as text7, timestamp as timestamp8, uuid as uuid8 } from "drizzle-orm/pg-core";

// src/schema/world.ts
import { sql as sql7 } from "drizzle-orm";
import { jsonb as jsonb6, pgTable as pgTable7, text as text6, timestamp as timestamp7, uuid as uuid7 } from "drizzle-orm/pg-core";
var worldTable = pgTable7("worlds", {
  id: uuid7("id").notNull().primaryKey().default(sql7`gen_random_uuid()`),
  agentId: uuid7("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  name: text6("name").notNull(),
  metadata: jsonb6("metadata"),
  serverId: text6("serverId").notNull().default("local"),
  createdAt: timestamp7("createdAt").default(sql7`now()`).notNull()
});

// src/schema/component.ts
var componentTable = pgTable8("components", {
  id: uuid8("id").primaryKey().default(sql8`gen_random_uuid()`).notNull(),
  entityId: uuid8("entityId").references(() => entityTable.id, { onDelete: "cascade" }).notNull(),
  agentId: uuid8("agentId").references(() => agentTable.id, { onDelete: "cascade" }).notNull(),
  roomId: uuid8("roomId").references(() => roomTable.id, { onDelete: "cascade" }).notNull(),
  worldId: uuid8("worldId").references(() => worldTable.id, { onDelete: "cascade" }),
  sourceEntityId: uuid8("sourceEntityId").references(() => entityTable.id, { onDelete: "cascade" }),
  type: text7("type").notNull(),
  data: jsonb7("data").default(sql8`'{}'::jsonb`),
  createdAt: timestamp8("createdAt").default(sql8`now()`).notNull()
});
// src/schema/log.ts
import { sql as sql9 } from "drizzle-orm";
import { foreignKey as foreignKey3, jsonb as jsonb8, pgTable as pgTable9, text as text8, timestamp as timestamp9, uuid as uuid9 } from "drizzle-orm/pg-core";
var logTable = pgTable9("logs", {
  id: uuid9("id").defaultRandom().notNull(),
  createdAt: timestamp9("created_at", { withTimezone: true }).default(sql9`now()`).notNull(),
  entityId: uuid9("entityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
  body: jsonb8("body").notNull(),
  type: text8("type").notNull(),
  roomId: uuid9("roomId").notNull().references(() => roomTable.id, { onDelete: "cascade" })
}, (table) => [
  foreignKey3({
    name: "fk_room",
    columns: [table.roomId],
    foreignColumns: [roomTable.id]
  }).onDelete("cascade"),
  foreignKey3({
    name: "fk_user",
    columns: [table.entityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade")
]);
// src/schema/participant.ts
import { sql as sql10 } from "drizzle-orm";
import { foreignKey as foreignKey4, index as index3, pgTable as pgTable10, text as text9, timestamp as timestamp10, uuid as uuid10 } from "drizzle-orm/pg-core";
var participantTable = pgTable10("participants", {
  id: uuid10("id").notNull().primaryKey().default(sql10`gen_random_uuid()`),
  createdAt: timestamp10("created_at", { withTimezone: true }).default(sql10`now()`).notNull(),
  entityId: uuid10("entityId").references(() => entityTable.id, {
    onDelete: "cascade"
  }),
  roomId: uuid10("roomId").references(() => roomTable.id, {
    onDelete: "cascade"
  }),
  agentId: uuid10("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  roomState: text9("roomState")
}, (table) => [
  index3("idx_participants_user").on(table.entityId),
  index3("idx_participants_room").on(table.roomId),
  foreignKey4({
    name: "fk_room",
    columns: [table.roomId],
    foreignColumns: [roomTable.id]
  }).onDelete("cascade"),
  foreignKey4({
    name: "fk_user",
    columns: [table.entityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade")
]);
// src/schema/relationship.ts
import { sql as sql11 } from "drizzle-orm";
import {
  foreignKey as foreignKey5,
  index as index4,
  jsonb as jsonb9,
  pgTable as pgTable11,
  text as text10,
  timestamp as timestamp11,
  unique as unique3,
  uuid as uuid11
} from "drizzle-orm/pg-core";
var relationshipTable = pgTable11("relationships", {
  id: uuid11("id").notNull().primaryKey().default(sql11`gen_random_uuid()`),
  createdAt: timestamp11("created_at", { withTimezone: true }).default(sql11`now()`).notNull(),
  sourceEntityId: uuid11("sourceEntityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
  targetEntityId: uuid11("targetEntityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
  agentId: uuid11("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  tags: text10("tags").array(),
  metadata: jsonb9("metadata")
}, (table) => [
  index4("idx_relationships_users").on(table.sourceEntityId, table.targetEntityId),
  unique3("unique_relationship").on(table.sourceEntityId, table.targetEntityId, table.agentId),
  foreignKey5({
    name: "fk_user_a",
    columns: [table.sourceEntityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade"),
  foreignKey5({
    name: "fk_user_b",
    columns: [table.targetEntityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade")
]);
// src/schema/tasks.ts
import { jsonb as jsonb10, pgTable as pgTable12, text as text11, timestamp as timestamp12, uuid as uuid12 } from "drizzle-orm/pg-core";
import { sql as sql12 } from "drizzle-orm";
var taskTable = pgTable12("tasks", {
  id: uuid12("id").primaryKey().defaultRandom(),
  name: text11("name").notNull(),
  description: text11("description"),
  roomId: uuid12("roomId"),
  worldId: uuid12("worldId"),
  entityId: uuid12("entityId"),
  agentId: uuid12("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  tags: text11("tags").array().default(sql12`'{}'::text[]`),
  metadata: jsonb10("metadata").default(sql12`'{}'::jsonb`),
  createdAt: timestamp12("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp12("updated_at", { withTimezone: true }).defaultNow()
});
// src/schema/messageServer.ts
import { pgTable as pgTable13, text as text12, jsonb as jsonb11, timestamp as timestamp13, uuid as uuid13 } from "drizzle-orm/pg-core";
import { sql as sql13 } from "drizzle-orm";
var messageServerTable = pgTable13("message_servers", {
  id: uuid13("id").primaryKey(),
  name: text12("name").notNull(),
  sourceType: text12("source_type").notNull(),
  sourceId: text12("source_id"),
  metadata: jsonb11("metadata"),
  createdAt: timestamp13("created_at", { mode: "date" }).default(sql13`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp13("updated_at", { mode: "date" }).default(sql13`CURRENT_TIMESTAMP`).notNull()
});
// src/schema/channel.ts
import { pgTable as pgTable14, text as text13, jsonb as jsonb12, timestamp as timestamp14, uuid as uuid14 } from "drizzle-orm/pg-core";
import { sql as sql14 } from "drizzle-orm";
var channelTable = pgTable14("channels", {
  id: text13("id").primaryKey(),
  messageServerId: uuid14("server_id").notNull().references(() => messageServerTable.id, { onDelete: "cascade" }),
  name: text13("name").notNull(),
  type: text13("type").notNull(),
  sourceType: text13("source_type"),
  sourceId: text13("source_id"),
  topic: text13("topic"),
  metadata: jsonb12("metadata"),
  createdAt: timestamp14("created_at", { mode: "date" }).default(sql14`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp14("updated_at", { mode: "date" }).default(sql14`CURRENT_TIMESTAMP`).notNull()
});
// src/schema/message.ts
import { pgTable as pgTable15, text as text14, jsonb as jsonb13, timestamp as timestamp15 } from "drizzle-orm/pg-core";
import { sql as sql15 } from "drizzle-orm";
var messageTable = pgTable15("central_messages", {
  id: text14("id").primaryKey(),
  channelId: text14("channel_id").notNull().references(() => channelTable.id, { onDelete: "cascade" }),
  authorId: text14("author_id").notNull(),
  content: text14("content").notNull(),
  rawMessage: jsonb13("raw_message"),
  inReplyToRootMessageId: text14("in_reply_to_root_message_id").references(() => messageTable.id, {
    onDelete: "set null"
  }),
  sourceType: text14("source_type"),
  sourceId: text14("source_id"),
  metadata: jsonb13("metadata"),
  createdAt: timestamp15("created_at", { mode: "date" }).default(sql15`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp15("updated_at", { mode: "date" }).default(sql15`CURRENT_TIMESTAMP`).notNull()
});
// src/schema/channelParticipant.ts
import { pgTable as pgTable16, text as text15, primaryKey as primaryKey2 } from "drizzle-orm/pg-core";
var channelParticipantsTable = pgTable16("channel_participants", {
  channelId: text15("channel_id").notNull().references(() => channelTable.id, { onDelete: "cascade" }),
  userId: text15("user_id").notNull()
}, (table) => ({
  pk: primaryKey2({ columns: [table.channelId, table.userId] })
}));
// src/schema/serverAgent.ts
import { pgTable as pgTable17, uuid as uuid15, primaryKey as primaryKey3 } from "drizzle-orm/pg-core";
var serverAgentsTable = pgTable17("server_agents", {
  serverId: uuid15("server_id").notNull().references(() => messageServerTable.id, { onDelete: "cascade" }),
  agentId: uuid15("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" })
}, (table) => ({
  pk: primaryKey3({ columns: [table.serverId, table.agentId] })
}));
// src/base.ts
class BaseDrizzleAdapter extends DatabaseAdapter {
  maxRetries = 3;
  baseDelay = 1000;
  maxDelay = 1e4;
  jitterMax = 1000;
  embeddingDimension = DIMENSION_MAP[384];
  async initialize() {
    await this.init();
  }
  getDatabase() {
    return this.db;
  }
  agentId;
  constructor(agentId) {
    super();
    this.agentId = agentId;
  }
  async withRetry(operation) {
    let lastError = new Error("Unknown error");
    for (let attempt = 1;attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (attempt < this.maxRetries) {
          const backoffDelay = Math.min(this.baseDelay * 2 ** (attempt - 1), this.maxDelay);
          const jitter = Math.random() * this.jitterMax;
          const delay = backoffDelay + jitter;
          logger.warn(`Database operation failed (attempt ${attempt}/${this.maxRetries}): ${error instanceof Error ? error.message : String(error)}, nextRetryIn: ${(delay / 1000).toFixed(1)}s`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        } else {
          logger.error(`Max retry attempts reached: ${error instanceof Error ? error.message : String(error)}, totalAttempts: ${attempt}`);
          throw error instanceof Error ? error : new Error(String(error));
        }
      }
    }
    throw lastError;
  }
  async ensureEmbeddingDimension(dimension) {
    return this.withDatabase(async () => {
      const existingMemory = await this.db.select().from(memoryTable).innerJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(eq(memoryTable.agentId, this.agentId)).limit(1);
      if (existingMemory.length > 0) {
        Object.entries(DIMENSION_MAP).find(([_, colName]) => existingMemory[0].embeddings[colName] !== null);
      }
      this.embeddingDimension = DIMENSION_MAP[dimension];
    });
  }
  async getAgent(agentId) {
    return this.withDatabase(async () => {
      const rows = await this.db.select().from(agentTable).where(eq(agentTable.id, agentId)).limit(1);
      if (rows.length === 0)
        return null;
      const row = rows[0];
      return {
        ...row,
        username: row.username || "",
        id: row.id,
        system: !row.system ? undefined : row.system,
        bio: !row.bio ? "" : row.bio,
        createdAt: row.createdAt.getTime(),
        updatedAt: row.updatedAt.getTime()
      };
    });
  }
  async getAgents() {
    return this.withDatabase(async () => {
      const rows = await this.db.select({
        id: agentTable.id,
        name: agentTable.name,
        bio: agentTable.bio
      }).from(agentTable);
      return rows.map((row) => ({
        ...row,
        id: row.id,
        bio: row.bio === null ? "" : row.bio
      }));
    });
  }
  async createAgent(agent) {
    return this.withDatabase(async () => {
      try {
        const conditions = [];
        if (agent.id) {
          conditions.push(eq(agentTable.id, agent.id));
        }
        if (agent.name) {
          conditions.push(eq(agentTable.name, agent.name));
        }
        const existing = conditions.length > 0 ? await this.db.select({ id: agentTable.id }).from(agentTable).where(or(...conditions)).limit(1) : [];
        if (existing.length > 0) {
          logger.warn(`Attempted to create an agent with a duplicate ID or name. ID: ${agent.id}, name: ${agent.name}`);
          return false;
        }
        await this.db.transaction(async (tx) => {
          await tx.insert(agentTable).values({
            ...agent,
            createdAt: new Date(agent.createdAt || Date.now()),
            updatedAt: new Date(agent.updatedAt || Date.now())
          });
        });
        logger.debug(`Agent created successfully: ${agent.id}`);
        return true;
      } catch (error) {
        logger.error(`Error creating agent: ${error instanceof Error ? error.message : String(error)}, agentId: ${agent.id}`);
        return false;
      }
    });
  }
  async updateAgent(agentId, agent) {
    return this.withDatabase(async () => {
      try {
        if (!agentId) {
          throw new Error("Agent ID is required for update");
        }
        await this.db.transaction(async (tx) => {
          if (agent?.settings) {
            agent.settings = await this.mergeAgentSettings(tx, agentId, agent.settings);
          }
          const updateData = { ...agent };
          if (updateData.createdAt) {
            if (typeof updateData.createdAt === "number") {
              updateData.createdAt = new Date(updateData.createdAt);
            } else {
              delete updateData.createdAt;
            }
          }
          if (updateData.updatedAt) {
            if (typeof updateData.updatedAt === "number") {
              updateData.updatedAt = new Date(updateData.updatedAt);
            } else {
              updateData.updatedAt = new Date;
            }
          } else {
            updateData.updatedAt = new Date;
          }
          await tx.update(agentTable).set(updateData).where(eq(agentTable.id, agentId));
        });
        logger.debug(`Agent updated successfully: ${agentId}`);
        return true;
      } catch (error) {
        logger.error(`Error updating agent: ${error instanceof Error ? error.message : String(error)}, agentId: ${agentId}`);
        return false;
      }
    });
  }
  async mergeAgentSettings(tx, agentId, updatedSettings) {
    const currentAgent = await tx.select({ settings: agentTable.settings }).from(agentTable).where(eq(agentTable.id, agentId)).limit(1);
    const currentSettings = currentAgent.length > 0 && currentAgent[0].settings ? currentAgent[0].settings : {};
    const deepMerge = (target, source) => {
      if (source === null) {
        return;
      }
      if (Array.isArray(source) || typeof source !== "object") {
        return source;
      }
      const output = typeof target === "object" && target !== null && !Array.isArray(target) ? { ...target } : {};
      for (const key of Object.keys(source)) {
        const sourceValue = source[key];
        if (sourceValue === null) {
          delete output[key];
        } else if (typeof sourceValue === "object" && !Array.isArray(sourceValue)) {
          const nestedMergeResult = deepMerge(output[key], sourceValue);
          if (nestedMergeResult === undefined) {
            delete output[key];
          } else {
            output[key] = nestedMergeResult;
          }
        } else {
          output[key] = sourceValue;
        }
      }
      if (Object.keys(output).length === 0) {
        if (!(typeof source === "object" && source !== null && Object.keys(source).length === 0)) {
          return;
        }
      }
      return output;
    };
    const finalSettings = deepMerge(currentSettings, updatedSettings);
    return finalSettings === undefined ? {} : finalSettings;
  }
  async deleteAgent(agentId) {
    logger.debug(`[DB] Deleting agent with ID: ${agentId}`);
    return this.withDatabase(async () => {
      try {
        const result = await this.db.delete(agentTable).where(eq(agentTable.id, agentId)).returning();
        if (result.length === 0) {
          logger.warn(`[DB] Agent ${agentId} not found`);
          return false;
        }
        logger.success(`[DB] Agent ${agentId} and all related data successfully deleted via cascade`);
        return true;
      } catch (error) {
        logger.error(`[DB] Failed to delete agent ${agentId}: ${error instanceof Error ? error.message : String(error)}`);
        if (error instanceof Error) {
          logger.error(`[DB] Error details: ${error.name} - ${error.message}`);
          logger.error(`[DB] Stack trace: ${error.stack}`);
        }
        throw error;
      }
    });
  }
  async countAgents() {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select({ count: count() }).from(agentTable);
        return result[0]?.count || 0;
      } catch (error) {
        logger.error(`Error counting agents: ${error instanceof Error ? error.message : String(error)}`);
        return 0;
      }
    });
  }
  async cleanupAgents() {
    return this.withDatabase(async () => {
      try {
        await this.db.delete(agentTable);
        logger.success("Successfully cleaned up agent table");
      } catch (error) {
        logger.error(`Error cleaning up agent table: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
      }
    });
  }
  async getEntitiesByIds(entityIds) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        entity: entityTable,
        components: componentTable
      }).from(entityTable).leftJoin(componentTable, eq(componentTable.entityId, entityTable.id)).where(inArray(entityTable.id, entityIds));
      if (result.length === 0)
        return [];
      const entities = {};
      const entityComponents = {};
      for (const e of result) {
        const key = e.entity.id;
        entities[key] = e.entity;
        if (entityComponents[key] === undefined)
          entityComponents[key] = [];
        if (e.components) {
          const componentsArray = Array.isArray(e.components) ? e.components : [e.components];
          entityComponents[key] = [...entityComponents[key], ...componentsArray];
        }
      }
      for (const k of Object.keys(entityComponents)) {
        entities[k].components = entityComponents[k];
      }
      return Object.values(entities);
    });
  }
  async getEntitiesForRoom(roomId, includeComponents) {
    return this.withDatabase(async () => {
      const query = this.db.select({
        entity: entityTable,
        ...includeComponents && { components: componentTable }
      }).from(participantTable).leftJoin(entityTable, and(eq(participantTable.entityId, entityTable.id), eq(entityTable.agentId, this.agentId)));
      if (includeComponents) {
        query.leftJoin(componentTable, eq(componentTable.entityId, entityTable.id));
      }
      const result = await query.where(eq(participantTable.roomId, roomId));
      const entitiesByIdMap = new Map;
      for (const row of result) {
        if (!row.entity)
          continue;
        const entityId = row.entity.id;
        if (!entitiesByIdMap.has(entityId)) {
          const entity = {
            ...row.entity,
            id: entityId,
            agentId: row.entity.agentId,
            metadata: row.entity.metadata,
            components: includeComponents ? [] : undefined
          };
          entitiesByIdMap.set(entityId, entity);
        }
        if (includeComponents && row.components) {
          const entity = entitiesByIdMap.get(entityId);
          if (entity) {
            if (!entity.components) {
              entity.components = [];
            }
            entity.components.push(row.components);
          }
        }
      }
      return Array.from(entitiesByIdMap.values());
    });
  }
  async createEntities(entities) {
    return this.withDatabase(async () => {
      try {
        return await this.db.transaction(async (tx) => {
          await tx.insert(entityTable).values(entities);
          logger.debug(`${entities.length} Entities created successfully`);
          return true;
        });
      } catch (error) {
        logger.error(`Error creating entities, entityId: ${entities[0].id}, (metadata?.)name: ${entities[0].metadata?.name}`, error instanceof Error ? error.message : String(error));
        if (error instanceof Error && error.stack) {
          logger.trace("Stack trace:", error.stack);
        }
        return false;
      }
    });
  }
  async ensureEntityExists(entity) {
    if (!entity.id) {
      logger.error("Entity ID is required for ensureEntityExists");
      return false;
    }
    try {
      const existingEntities = await this.getEntitiesByIds([entity.id]);
      if (!existingEntities || !existingEntities.length) {
        return await this.createEntities([entity]);
      }
      return true;
    } catch (error) {
      logger.error(`Error ensuring entity exists: ${error instanceof Error ? error.message : String(error)}, entityId: ${entity.id}`);
      return false;
    }
  }
  async updateEntity(entity) {
    if (!entity.id) {
      throw new Error("Entity ID is required for update");
    }
    return this.withDatabase(async () => {
      await this.db.update(entityTable).set(entity).where(eq(entityTable.id, entity.id));
    });
  }
  async deleteEntity(entityId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(componentTable).where(or(eq(componentTable.entityId, entityId), eq(componentTable.sourceEntityId, entityId)));
        await tx.delete(entityTable).where(eq(entityTable.id, entityId));
      });
    });
  }
  async getEntitiesByNames(params) {
    return this.withDatabase(async () => {
      const { names, agentId } = params;
      const nameConditions = names.map((name) => sql16`${name} = ANY(${entityTable.names})`);
      const query = sql16`
        SELECT * FROM ${entityTable}
        WHERE ${entityTable.agentId} = ${agentId}
        AND (${sql16.join(nameConditions, sql16` OR `)})
      `;
      const result = await this.db.execute(query);
      return result.rows.map((row) => ({
        id: row.id,
        agentId: row.agentId,
        names: row.names || [],
        metadata: row.metadata || {}
      }));
    });
  }
  async searchEntitiesByName(params) {
    return this.withDatabase(async () => {
      const { query, agentId, limit = 10 } = params;
      if (!query || query.trim() === "") {
        const result2 = await this.db.select().from(entityTable).where(eq(entityTable.agentId, agentId)).limit(limit);
        return result2.map((row) => ({
          id: row.id,
          agentId: row.agentId,
          names: row.names || [],
          metadata: row.metadata || {}
        }));
      }
      const searchQuery = sql16`
        SELECT * FROM ${entityTable}
        WHERE ${entityTable.agentId} = ${agentId}
        AND EXISTS (
          SELECT 1 FROM unnest(${entityTable.names}) AS name
          WHERE LOWER(name) LIKE LOWER(${"%" + query + "%"})
        )
        LIMIT ${limit}
      `;
      const result = await this.db.execute(searchQuery);
      return result.rows.map((row) => ({
        id: row.id,
        agentId: row.agentId,
        names: row.names || [],
        metadata: row.metadata || {}
      }));
    });
  }
  async getComponent(entityId, type, worldId, sourceEntityId) {
    return this.withDatabase(async () => {
      const conditions = [eq(componentTable.entityId, entityId), eq(componentTable.type, type)];
      if (worldId) {
        conditions.push(eq(componentTable.worldId, worldId));
      }
      if (sourceEntityId) {
        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));
      }
      const result = await this.db.select().from(componentTable).where(and(...conditions));
      if (result.length === 0)
        return null;
      const component = result[0];
      return {
        ...component,
        id: component.id,
        entityId: component.entityId,
        agentId: component.agentId,
        roomId: component.roomId,
        worldId: component.worldId ?? "",
        sourceEntityId: component.sourceEntityId ?? "",
        data: component.data,
        createdAt: component.createdAt.getTime()
      };
    });
  }
  async getComponents(entityId, worldId, sourceEntityId) {
    return this.withDatabase(async () => {
      const conditions = [eq(componentTable.entityId, entityId)];
      if (worldId) {
        conditions.push(eq(componentTable.worldId, worldId));
      }
      if (sourceEntityId) {
        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));
      }
      const result = await this.db.select({
        id: componentTable.id,
        entityId: componentTable.entityId,
        type: componentTable.type,
        data: componentTable.data,
        worldId: componentTable.worldId,
        agentId: componentTable.agentId,
        roomId: componentTable.roomId,
        sourceEntityId: componentTable.sourceEntityId,
        createdAt: componentTable.createdAt
      }).from(componentTable).where(and(...conditions));
      if (result.length === 0)
        return [];
      const components = result.map((component) => ({
        ...component,
        id: component.id,
        entityId: component.entityId,
        agentId: component.agentId,
        roomId: component.roomId,
        worldId: component.worldId ?? "",
        sourceEntityId: component.sourceEntityId ?? "",
        data: component.data,
        createdAt: component.createdAt.getTime()
      }));
      return components;
    });
  }
  async createComponent(component) {
    return this.withDatabase(async () => {
      await this.db.insert(componentTable).values({
        ...component,
        createdAt: new Date
      });
      return true;
    });
  }
  async updateComponent(component) {
    return this.withDatabase(async () => {
      try {
        await this.db.update(componentTable).set({
          ...component,
          updatedAt: new Date
        }).where(eq(componentTable.id, component.id));
      } catch (e) {
        console.error("updateComponent error", e);
      }
    });
  }
  async deleteComponent(componentId) {
    return this.withDatabase(async () => {
      await this.db.delete(componentTable).where(eq(componentTable.id, componentId));
    });
  }
  async getMemories(params) {
    const { entityId, agentId, roomId, worldId, tableName, unique: unique4, start, end } = params;
    if (!tableName)
      throw new Error("tableName is required");
    return this.withDatabase(async () => {
      const conditions = [eq(memoryTable.type, tableName)];
      if (start) {
        conditions.push(gte(memoryTable.createdAt, new Date(start)));
      }
      if (entityId) {
        conditions.push(eq(memoryTable.entityId, entityId));
      }
      if (roomId) {
        conditions.push(eq(memoryTable.roomId, roomId));
      }
      if (worldId) {
        conditions.push(eq(memoryTable.worldId, worldId));
      }
      if (end) {
        conditions.push(lte(memoryTable.createdAt, new Date(end)));
      }
      if (unique4) {
        conditions.push(eq(memoryTable.unique, true));
      }
      if (agentId) {
        conditions.push(eq(memoryTable.agentId, agentId));
      }
      const query = this.db.select({
        memory: {
          id: memoryTable.id,
          type: memoryTable.type,
          createdAt: memoryTable.createdAt,
          content: memoryTable.content,
          entityId: memoryTable.entityId,
          agentId: memoryTable.agentId,
          roomId: memoryTable.roomId,
          unique: memoryTable.unique,
          metadata: memoryTable.metadata
        },
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      const rows = params.count ? await query.limit(params.count) : await query;
      return rows.map((row) => ({
        id: row.memory.id,
        type: row.memory.type,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ? Array.from(row.embedding) : undefined
      }));
    });
  }
  async getMemoriesByRoomIds(params) {
    return this.withDatabase(async () => {
      if (params.roomIds.length === 0)
        return [];
      const conditions = [
        eq(memoryTable.type, params.tableName),
        inArray(memoryTable.roomId, params.roomIds)
      ];
      conditions.push(eq(memoryTable.agentId, this.agentId));
      const query = this.db.select({
        id: memoryTable.id,
        type: memoryTable.type,
        createdAt: memoryTable.createdAt,
        content: memoryTable.content,
        entityId: memoryTable.entityId,
        agentId: memoryTable.agentId,
        roomId: memoryTable.roomId,
        unique: memoryTable.unique,
        metadata: memoryTable.metadata
      }).from(memoryTable).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      const rows = params.limit ? await query.limit(params.limit) : await query;
      return rows.map((row) => ({
        id: row.id,
        createdAt: row.createdAt.getTime(),
        content: typeof row.content === "string" ? JSON.parse(row.content) : row.content,
        entityId: row.entityId,
        agentId: row.agentId,
        roomId: row.roomId,
        unique: row.unique,
        metadata: row.metadata
      }));
    });
  }
  async getMemoryById(id) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        memory: memoryTable,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(memoryTable.id, embeddingTable.memoryId)).where(eq(memoryTable.id, id)).limit(1);
      if (result.length === 0)
        return null;
      const row = result[0];
      return {
        id: row.memory.id,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? undefined
      };
    });
  }
  async getMemoriesByIds(memoryIds, tableName) {
    return this.withDatabase(async () => {
      if (memoryIds.length === 0)
        return [];
      const conditions = [inArray(memoryTable.id, memoryIds)];
      if (tableName) {
        conditions.push(eq(memoryTable.type, tableName));
      }
      const rows = await this.db.select({
        memory: memoryTable,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      return rows.map((row) => ({
        id: row.memory.id,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? undefined
      }));
    });
  }
  async getCachedEmbeddings(opts) {
    return this.withDatabase(async () => {
      try {
        const results = await this.db.execute(sql16`
                    WITH content_text AS (
                        SELECT
                            m.id,
                            COALESCE(
                                m.content->>${opts.query_field_sub_name},
                                ''
                            ) as content_text
                        FROM memories m
                        WHERE m.type = ${opts.query_table_name}
                            AND m.content->>${opts.query_field_sub_name} IS NOT NULL
                    ),
                    embedded_text AS (
                        SELECT
                            ct.content_text,
                            COALESCE(
                                e.dim_384,
                                e.dim_512,
                                e.dim_768,
                                e.dim_1024,
                                e.dim_1536,
                                e.dim_3072
                            ) as embedding
                        FROM content_text ct
                        LEFT JOIN embeddings e ON e.memory_id = ct.id
                        WHERE e.memory_id IS NOT NULL
                    )
                    SELECT
                        embedding,
                        levenshtein(${opts.query_input}, content_text) as levenshtein_score
                    FROM embedded_text
                    WHERE levenshtein(${opts.query_input}, content_text) <= ${opts.query_threshold}
                    ORDER BY levenshtein_score
                    LIMIT ${opts.query_match_count}
                `);
        return results.rows.map((row) => ({
          embedding: Array.isArray(row.embedding) ? row.embedding : typeof row.embedding === "string" ? JSON.parse(row.embedding) : [],
          levenshtein_score: Number(row.levenshtein_score)
        })).filter((row) => Array.isArray(row.embedding));
      } catch (error) {
        logger.error(`Error in getCachedEmbeddings: ${error instanceof Error ? error.message : String(error)}, tableName: ${opts.query_table_name}, fieldName: ${opts.query_field_name}`);
        if (error instanceof Error && error.message === "levenshtein argument exceeds maximum length of 255 characters") {
          return [];
        }
        throw error;
      }
    });
  }
  async log(params) {
    return this.withDatabase(async () => {
      try {
        const sanitizedBody = this.sanitizeJsonObject(params.body);
        const jsonString = JSON.stringify(sanitizedBody);
        await this.db.transaction(async (tx) => {
          await tx.insert(logTable).values({
            body: sql16`${jsonString}::jsonb`,
            entityId: params.entityId,
            roomId: params.roomId,
            type: params.type
          });
        });
      } catch (error) {
        logger.error(`Failed to create log entry: ${error instanceof Error ? error.message : String(error)}, type: ${params.type}, roomId: ${params.roomId}, entityId: ${params.entityId}`);
        throw error;
      }
    });
  }
  sanitizeJsonObject(value, seen = new WeakSet) {
    if (value === null || value === undefined) {
      return value;
    }
    if (typeof value === "string") {
      return value.replace(/\u0000/g, "").replace(/\\(?!["\\/bfnrtu])/g, "\\\\").replace(/\\u(?![0-9a-fA-F]{4})/g, "\\\\u");
    }
    if (typeof value === "object") {
      if (seen.has(value)) {
        return null;
      } else {
        seen.add(value);
      }
      if (Array.isArray(value)) {
        return value.map((item) => this.sanitizeJsonObject(item, seen));
      } else {
        const result = {};
        for (const [key, val] of Object.entries(value)) {
          const sanitizedKey = typeof key === "string" ? key.replace(/\u0000/g, "").replace(/\\u(?![0-9a-fA-F]{4})/g, "\\\\u") : key;
          result[sanitizedKey] = this.sanitizeJsonObject(val, seen);
        }
        return result;
      }
    }
    return value;
  }
  async getLogs(params) {
    const { entityId, roomId, type, count: count2, offset } = params;
    return this.withDatabase(async () => {
      const result = await this.db.select().from(logTable).where(and(eq(logTable.entityId, entityId), roomId ? eq(logTable.roomId, roomId) : undefined, type ? eq(logTable.type, type) : undefined)).orderBy(desc(logTable.createdAt)).limit(count2 ?? 10).offset(offset ?? 0);
      const logs = result.map((log) => ({
        ...log,
        id: log.id,
        entityId: log.entityId,
        roomId: log.roomId,
        body: log.body,
        createdAt: new Date(log.createdAt)
      }));
      if (logs.length === 0)
        return [];
      return logs;
    });
  }
  async deleteLog(logId) {
    return this.withDatabase(async () => {
      await this.db.delete(logTable).where(eq(logTable.id, logId));
    });
  }
  async searchMemories(params) {
    return await this.searchMemoriesByEmbedding(params.embedding, {
      match_threshold: params.match_threshold,
      count: params.count,
      roomId: params.roomId,
      worldId: params.worldId,
      entityId: params.entityId,
      unique: params.unique,
      tableName: params.tableName
    });
  }
  async searchMemoriesByEmbedding(embedding, params) {
    return this.withDatabase(async () => {
      const cleanVector = embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
      const similarity = sql16`1 - (${cosineDistance(embeddingTable[this.embeddingDimension], cleanVector)})`;
      const conditions = [eq(memoryTable.type, params.tableName)];
      if (params.unique) {
        conditions.push(eq(memoryTable.unique, true));
      }
      conditions.push(eq(memoryTable.agentId, this.agentId));
      if (params.roomId) {
        conditions.push(eq(memoryTable.roomId, params.roomId));
      }
      if (params.worldId) {
        conditions.push(eq(memoryTable.worldId, params.worldId));
      }
      if (params.entityId) {
        conditions.push(eq(memoryTable.entityId, params.entityId));
      }
      if (params.match_threshold) {
        conditions.push(gte(similarity, params.match_threshold));
      }
      const results = await this.db.select({
        memory: memoryTable,
        similarity,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(embeddingTable).innerJoin(memoryTable, eq(memoryTable.id, embeddingTable.memoryId)).where(and(...conditions)).orderBy(desc(similarity)).limit(params.count ?? 10);
      return results.map((row) => ({
        id: row.memory.id,
        type: row.memory.type,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        worldId: row.memory.worldId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? undefined,
        similarity: row.similarity
      }));
    });
  }
  async createMemory(memory, tableName) {
    logger.debug(`DrizzleAdapter createMemory: memoryId: ${memory.id}, embeddingLength: ${memory.embedding?.length}, contentLength: ${memory.content?.text?.length}`);
    const memoryId = memory.id ?? v4_default();
    const existing = await this.getMemoryById(memoryId);
    if (existing) {
      logger.debug(`Memory already exists, skipping creation: ${memoryId}`);
      return memoryId;
    }
    if (memory.unique === undefined) {
      memory.unique = true;
      if (memory.embedding && Array.isArray(memory.embedding)) {
        const similarMemories = await this.searchMemoriesByEmbedding(memory.embedding, {
          tableName,
          roomId: memory.roomId,
          worldId: memory.worldId,
          entityId: memory.entityId,
          match_threshold: 0.95,
          count: 1
        });
        memory.unique = similarMemories.length === 0;
      }
    }
    const contentToInsert = typeof memory.content === "string" ? memory.content : JSON.stringify(memory.content ?? {});
    const metadataToInsert = typeof memory.metadata === "string" ? memory.metadata : JSON.stringify(memory.metadata ?? {});
    await this.db.transaction(async (tx) => {
      await tx.insert(memoryTable).values([
        {
          id: memoryId,
          type: tableName,
          content: sql16`${contentToInsert}::jsonb`,
          metadata: sql16`${metadataToInsert}::jsonb`,
          entityId: memory.entityId,
          roomId: memory.roomId,
          worldId: memory.worldId,
          agentId: memory.agentId || this.agentId,
          unique: memory.unique,
          createdAt: memory.createdAt ? new Date(memory.createdAt) : new Date
        }
      ]);
      if (memory.embedding && Array.isArray(memory.embedding)) {
        const embeddingValues = {
          id: v4_default(),
          memoryId,
          createdAt: memory.createdAt ? new Date(memory.createdAt) : new Date
        };
        const cleanVector = memory.embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
        embeddingValues[this.embeddingDimension] = cleanVector;
        await tx.insert(embeddingTable).values([embeddingValues]);
      }
    });
    return memoryId;
  }
  async updateMemory(memory) {
    return this.withDatabase(async () => {
      try {
        logger.debug(`Updating memory: memoryId: ${memory.id}, hasEmbedding: ${!!memory.embedding}`);
        await this.db.transaction(async (tx) => {
          if (memory.content) {
            const contentToUpdate = typeof memory.content === "string" ? memory.content : JSON.stringify(memory.content ?? {});
            const metadataToUpdate = typeof memory.metadata === "string" ? memory.metadata : JSON.stringify(memory.metadata ?? {});
            await tx.update(memoryTable).set({
              content: sql16`${contentToUpdate}::jsonb`,
              ...memory.metadata && { metadata: sql16`${metadataToUpdate}::jsonb` }
            }).where(eq(memoryTable.id, memory.id));
          } else if (memory.metadata) {
            const metadataToUpdate = typeof memory.metadata === "string" ? memory.metadata : JSON.stringify(memory.metadata ?? {});
            await tx.update(memoryTable).set({
              metadata: sql16`${metadataToUpdate}::jsonb`
            }).where(eq(memoryTable.id, memory.id));
          }
          if (memory.embedding && Array.isArray(memory.embedding)) {
            const cleanVector = memory.embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
            const existingEmbedding = await tx.select({ id: embeddingTable.id }).from(embeddingTable).where(eq(embeddingTable.memoryId, memory.id)).limit(1);
            if (existingEmbedding.length > 0) {
              const updateValues = {};
              updateValues[this.embeddingDimension] = cleanVector;
              await tx.update(embeddingTable).set(updateValues).where(eq(embeddingTable.memoryId, memory.id));
            } else {
              const embeddingValues = {
                id: v4_default(),
                memoryId: memory.id
              };
              embeddingValues[this.embeddingDimension] = cleanVector;
              await tx.insert(embeddingTable).values([embeddingValues]);
            }
          }
        });
        logger.debug(`Memory updated successfully: ${memory.id}`);
        return true;
      } catch (error) {
        logger.error(`Error updating memory: ${error instanceof Error ? error.message : String(error)}, memoryId: ${memory.id}`);
        return false;
      }
    });
  }
  async deleteMemory(memoryId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await this.deleteMemoryFragments(tx, memoryId);
        await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));
        await tx.delete(memoryTable).where(eq(memoryTable.id, memoryId));
      });
      logger.debug(`Memory and related fragments removed successfully: ${memoryId}`);
    });
  }
  async deleteManyMemories(memoryIds) {
    if (memoryIds.length === 0) {
      return;
    }
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        const BATCH_SIZE = 100;
        for (let i = 0;i < memoryIds.length; i += BATCH_SIZE) {
          const batch = memoryIds.slice(i, i + BATCH_SIZE);
          await Promise.all(batch.map(async (memoryId) => {
            await this.deleteMemoryFragments(tx, memoryId);
          }));
          await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, batch));
          await tx.delete(memoryTable).where(inArray(memoryTable.id, batch));
        }
      });
      logger.debug(`Batch memory deletion completed successfully: ${memoryIds.length}`);
    });
  }
  async deleteMemoryFragments(tx, documentId) {
    const fragmentsToDelete = await this.getMemoryFragments(tx, documentId);
    if (fragmentsToDelete.length > 0) {
      const fragmentIds = fragmentsToDelete.map((f) => f.id);
      await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, fragmentIds));
      await tx.delete(memoryTable).where(inArray(memoryTable.id, fragmentIds));
      logger.debug(`Deleted related fragments: documentId: ${documentId}, fragmentCount: ${fragmentsToDelete.length}`);
    }
  }
  async getMemoryFragments(tx, documentId) {
    const fragments = await tx.select({ id: memoryTable.id }).from(memoryTable).where(and(eq(memoryTable.agentId, this.agentId), sql16`${memoryTable.metadata}->>'documentId' = ${documentId}`));
    return fragments.map((f) => ({ id: f.id }));
  }
  async deleteAllMemories(roomId, tableName) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        const rows = await tx.select({ id: memoryTable.id }).from(memoryTable).where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));
        const ids = rows.map((r) => r.id);
        logger.debug(`[deleteAllMemories] memory IDs to delete: roomId: ${roomId}, tableName: ${tableName}, ids: ${JSON.stringify(ids)}`);
        if (ids.length === 0) {
          return;
        }
        await Promise.all(ids.map(async (memoryId) => {
          await this.deleteMemoryFragments(tx, memoryId);
          await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));
        }));
        await tx.delete(memoryTable).where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));
      });
      logger.debug(`All memories removed successfully: roomId: ${roomId}, tableName: ${tableName}`);
    });
  }
  async countMemories(roomId, unique4 = true, tableName = "") {
    if (!tableName)
      throw new Error("tableName is required");
    return this.withDatabase(async () => {
      const conditions = [eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)];
      if (unique4) {
        conditions.push(eq(memoryTable.unique, true));
      }
      const result = await this.db.select({ count: sql16`count(*)` }).from(memoryTable).where(and(...conditions));
      return Number(result[0]?.count ?? 0);
    });
  }
  async getRoomsByIds(roomIds) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        id: roomTable.id,
        name: roomTable.name,
        channelId: roomTable.channelId,
        agentId: roomTable.agentId,
        serverId: roomTable.serverId,
        worldId: roomTable.worldId,
        type: roomTable.type,
        source: roomTable.source,
        metadata: roomTable.metadata
      }).from(roomTable).where(and(inArray(roomTable.id, roomIds), eq(roomTable.agentId, this.agentId)));
      const rooms = result.map((room) => ({
        ...room,
        id: room.id,
        name: room.name ?? undefined,
        agentId: room.agentId,
        serverId: room.serverId,
        worldId: room.worldId,
        channelId: room.channelId,
        type: room.type,
        metadata: room.metadata
      }));
      return rooms;
    });
  }
  async getRoomsByWorld(worldId) {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(roomTable).where(eq(roomTable.worldId, worldId));
      const rooms = result.map((room) => ({
        ...room,
        id: room.id,
        name: room.name ?? undefined,
        agentId: room.agentId,
        serverId: room.serverId,
        worldId: room.worldId,
        channelId: room.channelId,
        type: room.type,
        metadata: room.metadata
      }));
      return rooms;
    });
  }
  async updateRoom(room) {
    return this.withDatabase(async () => {
      await this.db.update(roomTable).set({ ...room, agentId: this.agentId }).where(eq(roomTable.id, room.id));
    });
  }
  async createRooms(rooms) {
    return this.withDatabase(async () => {
      const roomsWithIds = rooms.map((room) => ({
        ...room,
        agentId: this.agentId,
        id: room.id || v4_default()
      }));
      const insertedRooms = await this.db.insert(roomTable).values(roomsWithIds).onConflictDoNothing().returning();
      const insertedIds = insertedRooms.map((r) => r.id);
      return insertedIds;
    });
  }
  async deleteRoom(roomId) {
    if (!roomId)
      throw new Error("Room ID is required");
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(roomTable).where(eq(roomTable.id, roomId));
      });
    });
  }
  async getRoomsForParticipant(entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ roomId: participantTable.roomId }).from(participantTable).innerJoin(roomTable, eq(participantTable.roomId, roomTable.id)).where(and(eq(participantTable.entityId, entityId), eq(roomTable.agentId, this.agentId)));
      return result.map((row) => row.roomId);
    });
  }
  async getRoomsForParticipants(entityIds) {
    return this.withDatabase(async () => {
      const result = await this.db.selectDistinct({ roomId: participantTable.roomId }).from(participantTable).innerJoin(roomTable, eq(participantTable.roomId, roomTable.id)).where(and(inArray(participantTable.entityId, entityIds), eq(roomTable.agentId, this.agentId)));
      return result.map((row) => row.roomId);
    });
  }
  async addParticipant(entityId, roomId) {
    return this.withDatabase(async () => {
      try {
        await this.db.insert(participantTable).values({
          entityId,
          roomId,
          agentId: this.agentId
        }).onConflictDoNothing();
        return true;
      } catch (error) {
        logger.error(`Error adding participant to room: ${error instanceof Error ? error.message : String(error)}, entityId: ${entityId}, roomId: ${roomId}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async addParticipantsRoom(entityIds, roomId) {
    return this.withDatabase(async () => {
      try {
        const values = entityIds.map((id) => ({
          entityId: id,
          roomId,
          agentId: this.agentId
        }));
        await this.db.insert(participantTable).values(values).onConflictDoNothing().execute();
        logger.debug(`${entityIds.length} Entities linked successfully`);
        return true;
      } catch (error) {
        logger.error(`Error adding participants to room: ${error instanceof Error ? error.message : String(error)}, entityIdSample: ${entityIds[0]}, roomId: ${roomId}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async removeParticipant(entityId, roomId) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.transaction(async (tx) => {
          return await tx.delete(participantTable).where(and(eq(participantTable.entityId, entityId), eq(participantTable.roomId, roomId))).returning();
        });
        const removed = result.length > 0;
        logger.debug(`Participant ${removed ? "removed" : "not found"}: entityId: ${entityId}, roomId: ${roomId}, removed: ${removed}`);
        return removed;
      } catch (error) {
        logger.error(`Error removing participant from room: ${error instanceof Error ? error.message : String(error)}, entityId: ${entityId}, roomId: ${roomId}`);
        return false;
      }
    });
  }
  async getParticipantsForEntity(entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        id: participantTable.id,
        entityId: participantTable.entityId,
        roomId: participantTable.roomId
      }).from(participantTable).where(eq(participantTable.entityId, entityId));
      const entities = await this.getEntitiesByIds([entityId]);
      if (!entities || !entities.length) {
        return [];
      }
      return result.map((row) => ({
        id: row.id,
        entity: entities[0]
      }));
    });
  }
  async getParticipantsForRoom(roomId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ entityId: participantTable.entityId }).from(participantTable).where(eq(participantTable.roomId, roomId));
      return result.map((row) => row.entityId);
    });
  }
  async getParticipantUserState(roomId, entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ roomState: participantTable.roomState }).from(participantTable).where(and(eq(participantTable.roomId, roomId), eq(participantTable.entityId, entityId), eq(participantTable.agentId, this.agentId))).limit(1);
      return result[0]?.roomState ?? null;
    });
  }
  async setParticipantUserState(roomId, entityId, state) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.update(participantTable).set({ roomState: state }).where(and(eq(participantTable.roomId, roomId), eq(participantTable.entityId, entityId), eq(participantTable.agentId, this.agentId)));
        });
      } catch (error) {
        logger.error(`Error setting participant follow state: roomId: ${roomId}, entityId: ${entityId}, state: ${state}, error: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
      }
    });
  }
  async createRelationship(params) {
    return this.withDatabase(async () => {
      const id = v4_default();
      const saveParams = {
        id,
        sourceEntityId: params.sourceEntityId,
        targetEntityId: params.targetEntityId,
        agentId: this.agentId,
        tags: params.tags || [],
        metadata: params.metadata || {}
      };
      try {
        await this.db.insert(relationshipTable).values(saveParams);
        return true;
      } catch (error) {
        logger.error(`Error creating relationship: ${error instanceof Error ? error.message : String(error)}, saveParams: ${JSON.stringify(saveParams)}`);
        return false;
      }
    });
  }
  async updateRelationship(relationship) {
    return this.withDatabase(async () => {
      try {
        await this.db.update(relationshipTable).set({
          tags: relationship.tags || [],
          metadata: relationship.metadata || {}
        }).where(eq(relationshipTable.id, relationship.id));
      } catch (error) {
        logger.error(`Error updating relationship: ${error instanceof Error ? error.message : String(error)}, relationship: ${JSON.stringify(relationship)}`);
        throw error;
      }
    });
  }
  async getRelationship(params) {
    return this.withDatabase(async () => {
      const { sourceEntityId, targetEntityId } = params;
      const result = await this.db.select().from(relationshipTable).where(and(eq(relationshipTable.sourceEntityId, sourceEntityId), eq(relationshipTable.targetEntityId, targetEntityId)));
      if (result.length === 0)
        return null;
      const relationship = result[0];
      return {
        ...relationship,
        id: relationship.id,
        sourceEntityId: relationship.sourceEntityId,
        targetEntityId: relationship.targetEntityId,
        agentId: relationship.agentId,
        tags: relationship.tags ?? [],
        metadata: relationship.metadata ?? {},
        createdAt: relationship.createdAt.toISOString()
      };
    });
  }
  async getRelationships(params) {
    return this.withDatabase(async () => {
      const { entityId, tags } = params;
      let query;
      if (tags && tags.length > 0) {
        query = sql16`
          SELECT * FROM ${relationshipTable}
          WHERE (${relationshipTable.sourceEntityId} = ${entityId} OR ${relationshipTable.targetEntityId} = ${entityId})
          AND ${relationshipTable.tags} && CAST(ARRAY[${sql16.join(tags, sql16`, `)}] AS text[])
        `;
      } else {
        query = sql16`
          SELECT * FROM ${relationshipTable}
          WHERE ${relationshipTable.sourceEntityId} = ${entityId} OR ${relationshipTable.targetEntityId} = ${entityId}
        `;
      }
      const result = await this.db.execute(query);
      return result.rows.map((relationship) => ({
        ...relationship,
        id: relationship.id,
        sourceEntityId: relationship.sourceEntityId,
        targetEntityId: relationship.targetEntityId,
        agentId: relationship.agentId,
        tags: relationship.tags ?? [],
        metadata: relationship.metadata ?? {},
        createdAt: relationship.createdAt ? relationship.createdAt instanceof Date ? relationship.createdAt.toISOString() : new Date(relationship.createdAt).toISOString() : new Date().toISOString()
      }));
    });
  }
  async getCache(key) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select({ value: cacheTable.value }).from(cacheTable).where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key))).limit(1);
        if (result && result.length > 0 && result[0]) {
          return result[0].value;
        }
        return;
      } catch (error) {
        logger.error(`Error fetching cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`);
        return;
      }
    });
  }
  async setCache(key, value) {
    return this.withDatabase(async () => {
      try {
        await this.db.insert(cacheTable).values({
          key,
          agentId: this.agentId,
          value
        }).onConflictDoUpdate({
          target: [cacheTable.key, cacheTable.agentId],
          set: {
            value
          }
        });
        return true;
      } catch (error) {
        logger.error(`Error setting cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async deleteCache(key) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.delete(cacheTable).where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key)));
        });
        return true;
      } catch (error) {
        logger.error(`Error deleting cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async createWorld(world) {
    return this.withDatabase(async () => {
      const newWorldId = world.id || v4_default();
      await this.db.insert(worldTable).values({
        ...world,
        id: newWorldId,
        name: world.name || ""
      });
      return newWorldId;
    });
  }
  async getWorld(id) {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(worldTable).where(eq(worldTable.id, id));
      return result.length > 0 ? result[0] : null;
    });
  }
  async getAllWorlds() {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(worldTable).where(eq(worldTable.agentId, this.agentId));
      return result;
    });
  }
  async updateWorld(world) {
    return this.withDatabase(async () => {
      await this.db.update(worldTable).set(world).where(eq(worldTable.id, world.id));
    });
  }
  async removeWorld(id) {
    return this.withDatabase(async () => {
      await this.db.delete(worldTable).where(eq(worldTable.id, id));
    });
  }
  async createTask(task) {
    if (!task.worldId) {
      throw new Error("worldId is required");
    }
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const now = new Date;
        const metadata = task.metadata || {};
        const values = {
          id: task.id,
          name: task.name,
          description: task.description,
          roomId: task.roomId,
          worldId: task.worldId,
          tags: task.tags,
          metadata,
          createdAt: now,
          updatedAt: now,
          agentId: this.agentId
        };
        const result = await this.db.insert(taskTable).values(values).returning();
        return result[0].id;
      });
    });
  }
  async getTasks(params) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.agentId, this.agentId), ...params.roomId ? [eq(taskTable.roomId, params.roomId)] : [], ...params.tags && params.tags.length > 0 ? [
          sql16`${taskTable.tags} @> ARRAY[${sql16.raw(params.tags.map((t) => `'${t.replace(/'/g, "''")}'`).join(", "))}]::text[]`
        ] : []));
        return result.map((row) => ({
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata
        }));
      });
    });
  }
  async getTasksByName(name) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.name, name), eq(taskTable.agentId, this.agentId)));
        return result.map((row) => ({
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata || {}
        }));
      });
    });
  }
  async getTask(id) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId))).limit(1);
        if (result.length === 0) {
          return null;
        }
        const row = result[0];
        return {
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata || {}
        };
      });
    });
  }
  async updateTask(id, task) {
    await this.withRetry(async () => {
      await this.withDatabase(async () => {
        const updateValues = {};
        if (task.name !== undefined)
          updateValues.name = task.name;
        if (task.description !== undefined)
          updateValues.description = task.description;
        if (task.roomId !== undefined)
          updateValues.roomId = task.roomId;
        if (task.worldId !== undefined)
          updateValues.worldId = task.worldId;
        if (task.tags !== undefined)
          updateValues.tags = task.tags;
        updateValues.updatedAt = new Date;
        if (task.metadata !== undefined) {
          updateValues.metadata = task.metadata;
        }
        await this.db.update(taskTable).set(updateValues).where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId)));
      });
    });
  }
  async deleteTask(id) {
    return this.withDatabase(async () => {
      await this.db.delete(taskTable).where(eq(taskTable.id, id));
    });
  }
  async getMemoriesByWorldId(params) {
    return this.withDatabase(async () => {
      const rooms = await this.db.select({ id: roomTable.id }).from(roomTable).where(and(eq(roomTable.worldId, params.worldId), eq(roomTable.agentId, this.agentId)));
      if (rooms.length === 0) {
        return [];
      }
      const roomIds = rooms.map((room) => room.id);
      const memories = await this.getMemoriesByRoomIds({
        roomIds,
        tableName: params.tableName || "messages",
        limit: params.count
      });
      return memories;
    });
  }
  async deleteRoomsByWorldId(worldId) {
    return this.withDatabase(async () => {
      const rooms = await this.db.select({ id: roomTable.id }).from(roomTable).where(and(eq(roomTable.worldId, worldId), eq(roomTable.agentId, this.agentId)));
      if (rooms.length === 0) {
        logger.debug(`No rooms found for worldId ${worldId} and agentId ${this.agentId} to delete.`);
        return;
      }
      const roomIds = rooms.map((room) => room.id);
      if (roomIds.length > 0) {
        await this.db.delete(logTable).where(inArray(logTable.roomId, roomIds));
        logger.debug(`Deleted logs for ${roomIds.length} rooms in world ${worldId}.`);
        await this.db.delete(participantTable).where(inArray(participantTable.roomId, roomIds));
        logger.debug(`Deleted participants for ${roomIds.length} rooms in world ${worldId}.`);
        const memoriesInRooms = await this.db.select({ id: memoryTable.id }).from(memoryTable).where(inArray(memoryTable.roomId, roomIds));
        const memoryIdsInRooms = memoriesInRooms.map((m) => m.id);
        if (memoryIdsInRooms.length > 0) {
          await this.db.delete(embeddingTable).where(inArray(embeddingTable.memoryId, memoryIdsInRooms));
          logger.debug(`Deleted embeddings for ${memoryIdsInRooms.length} memories in world ${worldId}.`);
          await this.db.delete(memoryTable).where(inArray(memoryTable.id, memoryIdsInRooms));
          logger.debug(`Deleted ${memoryIdsInRooms.length} memories in world ${worldId}.`);
        }
        await this.db.delete(roomTable).where(inArray(roomTable.id, roomIds));
        logger.debug(`Deleted ${roomIds.length} rooms for worldId ${worldId}.`);
      }
    });
  }
  async createMessageServer(data) {
    return this.withDatabase(async () => {
      const newId = data.id || v4_default();
      const now = new Date;
      const serverToInsert = {
        id: newId,
        name: data.name,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        metadata: data.metadata,
        createdAt: now,
        updatedAt: now
      };
      await this.db.insert(messageServerTable).values(serverToInsert).onConflictDoNothing();
      if (data.id) {
        const existing = await this.db.select().from(messageServerTable).where(eq(messageServerTable.id, data.id)).limit(1);
        if (existing.length > 0) {
          return {
            id: existing[0].id,
            name: existing[0].name,
            sourceType: existing[0].sourceType,
            sourceId: existing[0].sourceId || undefined,
            metadata: existing[0].metadata || undefined,
            createdAt: existing[0].createdAt,
            updatedAt: existing[0].updatedAt
          };
        }
      }
      return serverToInsert;
    });
  }
  async getMessageServers() {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(messageServerTable);
      return results.map((r) => ({
        id: r.id,
        name: r.name,
        sourceType: r.sourceType,
        sourceId: r.sourceId || undefined,
        metadata: r.metadata || undefined,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  async getMessageServerById(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(messageServerTable).where(eq(messageServerTable.id, serverId)).limit(1);
      return results.length > 0 ? {
        id: results[0].id,
        name: results[0].name,
        sourceType: results[0].sourceType,
        sourceId: results[0].sourceId || undefined,
        metadata: results[0].metadata || undefined,
        createdAt: results[0].createdAt,
        updatedAt: results[0].updatedAt
      } : null;
    });
  }
  async createChannel(data, participantIds) {
    return this.withDatabase(async () => {
      const newId = data.id || v4_default();
      const now = new Date;
      const channelToInsert = {
        id: newId,
        messageServerId: data.messageServerId,
        name: data.name,
        type: data.type,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        topic: data.topic,
        metadata: data.metadata,
        createdAt: now,
        updatedAt: now
      };
      await this.db.transaction(async (tx) => {
        await tx.insert(channelTable).values(channelToInsert);
        if (participantIds && participantIds.length > 0) {
          const participantValues = participantIds.map((userId) => ({
            channelId: newId,
            userId
          }));
          await tx.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
        }
      });
      return channelToInsert;
    });
  }
  async getChannelsForServer(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(channelTable).where(eq(channelTable.messageServerId, serverId));
      return results.map((r) => ({
        id: r.id,
        messageServerId: r.messageServerId,
        name: r.name,
        type: r.type,
        sourceType: r.sourceType || undefined,
        sourceId: r.sourceId || undefined,
        topic: r.topic || undefined,
        metadata: r.metadata || undefined,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  async getChannelDetails(channelId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(channelTable).where(eq(channelTable.id, channelId)).limit(1);
      return results.length > 0 ? {
        id: results[0].id,
        messageServerId: results[0].messageServerId,
        name: results[0].name,
        type: results[0].type,
        sourceType: results[0].sourceType || undefined,
        sourceId: results[0].sourceId || undefined,
        topic: results[0].topic || undefined,
        metadata: results[0].metadata || undefined,
        createdAt: results[0].createdAt,
        updatedAt: results[0].updatedAt
      } : null;
    });
  }
  async createMessage(data) {
    return this.withDatabase(async () => {
      const newId = data.messageId || v4_default();
      const now = new Date;
      const messageToInsert = {
        id: newId,
        channelId: data.channelId,
        authorId: data.authorId,
        content: data.content,
        rawMessage: data.rawMessage,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        metadata: data.metadata,
        inReplyToRootMessageId: data.inReplyToRootMessageId,
        createdAt: now,
        updatedAt: now
      };
      await this.db.insert(messageTable).values(messageToInsert);
      return messageToInsert;
    });
  }
  async getMessageById(id) {
    return this.withDatabase(async () => {
      const rows = await this.db.select().from(messageTable).where(eq(messageTable.id, id)).limit(1);
      return rows?.[0] ?? null;
    });
  }
  async updateMessage(id, patch) {
    return this.withDatabase(async () => {
      const existing = await this.getMessageById(id);
      if (!existing)
        return null;
      const updatedAt = new Date;
      const next = {
        content: patch.content ?? existing.content,
        rawMessage: patch.rawMessage ?? existing.rawMessage,
        sourceType: patch.sourceType ?? existing.sourceType,
        sourceId: patch.sourceId ?? existing.sourceId,
        metadata: patch.metadata ?? existing.metadata,
        inReplyToRootMessageId: patch.inReplyToRootMessageId ?? existing.inReplyToRootMessageId,
        updatedAt
      };
      await this.db.update(messageTable).set(next).where(eq(messageTable.id, id));
      return {
        ...existing,
        ...next
      };
    });
  }
  async getMessagesForChannel(channelId, limit = 50, beforeTimestamp) {
    return this.withDatabase(async () => {
      const conditions = [eq(messageTable.channelId, channelId)];
      if (beforeTimestamp) {
        conditions.push(lt(messageTable.createdAt, beforeTimestamp));
      }
      const query = this.db.select().from(messageTable).where(and(...conditions)).orderBy(desc(messageTable.createdAt)).limit(limit);
      const results = await query;
      return results.map((r) => ({
        id: r.id,
        channelId: r.channelId,
        authorId: r.authorId,
        content: r.content,
        rawMessage: r.rawMessage || undefined,
        sourceType: r.sourceType || undefined,
        sourceId: r.sourceId || undefined,
        metadata: r.metadata || undefined,
        inReplyToRootMessageId: r.inReplyToRootMessageId,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  async deleteMessage(messageId) {
    return this.withDatabase(async () => {
      await this.db.delete(messageTable).where(eq(messageTable.id, messageId));
    });
  }
  async updateChannel(channelId, updates) {
    return this.withDatabase(async () => {
      const now = new Date;
      await this.db.transaction(async (tx) => {
        const updateData = { updatedAt: now };
        if (updates.name !== undefined)
          updateData.name = updates.name;
        if (updates.metadata !== undefined)
          updateData.metadata = updates.metadata;
        await tx.update(channelTable).set(updateData).where(eq(channelTable.id, channelId));
        if (updates.participantCentralUserIds !== undefined) {
          await tx.delete(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
          if (updates.participantCentralUserIds.length > 0) {
            const participantValues = updates.participantCentralUserIds.map((userId) => ({
              channelId,
              userId
            }));
            await tx.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
          }
        }
      });
      const updatedChannel = await this.getChannelDetails(channelId);
      if (!updatedChannel) {
        throw new Error(`Channel ${channelId} not found after update`);
      }
      return updatedChannel;
    });
  }
  async deleteChannel(channelId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(messageTable).where(eq(messageTable.channelId, channelId));
        await tx.delete(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
        await tx.delete(channelTable).where(eq(channelTable.id, channelId));
      });
    });
  }
  async addChannelParticipants(channelId, userIds) {
    return this.withDatabase(async () => {
      if (!userIds || userIds.length === 0)
        return;
      const participantValues = userIds.map((userId) => ({
        channelId,
        userId
      }));
      await this.db.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
    });
  }
  async getChannelParticipants(channelId) {
    return this.withDatabase(async () => {
      const results = await this.db.select({ userId: channelParticipantsTable.userId }).from(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
      return results.map((r) => r.userId);
    });
  }
  async addAgentToServer(serverId, agentId) {
    return this.withDatabase(async () => {
      await this.db.insert(serverAgentsTable).values({
        serverId,
        agentId
      }).onConflictDoNothing();
    });
  }
  async getAgentsForServer(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select({ agentId: serverAgentsTable.agentId }).from(serverAgentsTable).where(eq(serverAgentsTable.serverId, serverId));
      return results.map((r) => r.agentId);
    });
  }
  async removeAgentFromServer(serverId, agentId) {
    return this.withDatabase(async () => {
      await this.db.delete(serverAgentsTable).where(and(eq(serverAgentsTable.serverId, serverId), eq(serverAgentsTable.agentId, agentId)));
    });
  }
  async findOrCreateDmChannel(user1Id, user2Id, messageServerId) {
    return this.withDatabase(async () => {
      const ids = [user1Id, user2Id].sort();
      const dmChannelName = `DM-${ids[0]}-${ids[1]}`;
      const existingChannels = await this.db.select().from(channelTable).where(and(eq(channelTable.type, ChannelType.DM), eq(channelTable.name, dmChannelName), eq(channelTable.messageServerId, messageServerId))).limit(1);
      if (existingChannels.length > 0) {
        return {
          id: existingChannels[0].id,
          messageServerId: existingChannels[0].messageServerId,
          name: existingChannels[0].name,
          type: existingChannels[0].type,
          sourceType: existingChannels[0].sourceType || undefined,
          sourceId: existingChannels[0].sourceId || undefined,
          topic: existingChannels[0].topic || undefined,
          metadata: existingChannels[0].metadata || undefined,
          createdAt: existingChannels[0].createdAt,
          updatedAt: existingChannels[0].updatedAt
        };
      }
      return this.createChannel({
        messageServerId,
        name: dmChannelName,
        type: ChannelType.DM,
        metadata: { user1: ids[0], user2: ids[1] }
      }, ids);
    });
  }
}

// src/pglite/adapter.ts
class PgliteDatabaseAdapter extends BaseDrizzleAdapter {
  manager;
  embeddingDimension = DIMENSION_MAP[384];
  constructor(agentId, manager) {
    super(agentId);
    this.manager = manager;
    this.db = drizzle(this.manager.getConnection());
  }
  async getEntityByIds(entityIds) {
    return this.getEntitiesByIds(entityIds);
  }
  async getMemoriesByServerId(_params) {
    logger2.warn("getMemoriesByServerId called but not implemented - returning empty array");
    return [];
  }
  async ensureAgentExists(agent) {
    const existingAgent = await this.getAgent(this.agentId);
    if (existingAgent) {
      return existingAgent;
    }
    const newAgent = {
      id: this.agentId,
      name: agent.name || "Unknown Agent",
      username: agent.username,
      bio: agent.bio || "An AI agent",
      createdAt: agent.createdAt || Date.now(),
      updatedAt: agent.updatedAt || Date.now()
    };
    await this.createAgent(newAgent);
    const createdAgent = await this.getAgent(this.agentId);
    if (!createdAgent) {
      throw new Error("Failed to create agent");
    }
    return createdAgent;
  }
  async runMigrations() {
    logger2.debug("PgliteDatabaseAdapter: Migrations are handled by the migration service");
  }
  async withDatabase(operation) {
    if (this.manager.isShuttingDown()) {
      logger2.warn("Database is shutting down");
      return null;
    }
    return operation();
  }
  async init() {
    logger2.debug("PGliteDatabaseAdapter initialized, skipping automatic migrations.");
  }
  async isReady() {
    return !this.manager.isShuttingDown();
  }
  async close() {
    await this.manager.close();
  }
  async getConnection() {
    return this.manager.getConnection();
  }
}

// src/pglite/manager.ts
import { PGlite } from "@electric-sql/pglite";
import { fuzzystrmatch } from "@electric-sql/pglite/contrib/fuzzystrmatch";
import { vector as vector2 } from "@electric-sql/pglite/vector";

class PGliteClientManager {
  client;
  shuttingDown = false;
  constructor(options) {
    this.client = new PGlite({
      ...options,
      extensions: {
        vector: vector2,
        fuzzystrmatch
      }
    });
    this.setupShutdownHandlers();
  }
  getConnection() {
    return this.client;
  }
  isShuttingDown() {
    return this.shuttingDown;
  }
  async initialize() {}
  async close() {
    this.shuttingDown = true;
  }
  setupShutdownHandlers() {}
}

// src/migration-service.ts
import { logger as logger4 } from "@elizaos/core";

// src/custom-migrator.ts
import { sql as sql17 } from "drizzle-orm";
import { logger as logger3 } from "@elizaos/core";
function extractErrorMessage(error) {
  if (error instanceof Error && "cause" in error && error.cause) {
    return error.cause.message;
  } else if (error instanceof Error) {
    return error.message;
  }
  return "Unknown error";
}
function extractErrorDetails(error) {
  if (error instanceof Error && "cause" in error && error.cause) {
    const cause = error.cause;
    return {
      message: cause.message,
      stack: cause.stack || error.stack
    };
  } else if (error instanceof Error) {
    return {
      message: error.message,
      stack: error.stack
    };
  }
  return { message: "Unknown error" };
}
var KNOWN_COMPOSITE_PRIMARY_KEYS = {
  cache: { columns: ["key", "agent_id"] }
};

class DrizzleSchemaIntrospector {
  parseTableDefinition(table, exportKey) {
    const tableName = this.getTableName(table, exportKey);
    const columns = this.parseColumns(table);
    const foreignKeys = this.parseForeignKeys(table);
    const indexes = this.parseIndexes(table);
    const checkConstraints = this.parseCheckConstraints(table);
    let compositePrimaryKey = this.parseCompositePrimaryKey(table);
    if (!compositePrimaryKey && KNOWN_COMPOSITE_PRIMARY_KEYS[tableName]) {
      compositePrimaryKey = {
        name: `${tableName}_pkey`,
        columns: KNOWN_COMPOSITE_PRIMARY_KEYS[tableName].columns
      };
      logger3.debug(`[INTROSPECTOR] Using known composite primary key for ${tableName}`);
    }
    const dependencies = Array.from(new Set(foreignKeys.map((fk) => fk.referencedTable).filter((refTable) => refTable !== tableName)));
    return {
      name: tableName,
      columns,
      indexes,
      foreignKeys,
      checkConstraints,
      dependencies,
      compositePrimaryKey
    };
  }
  getTableName(table, exportKey) {
    if (!table) {
      logger3.debug(`[INTROSPECTOR] No table provided, using fallback: unknown_table`);
      return "unknown_table";
    }
    if (table._ && table._.name) {
      return table._.name;
    }
    const symbols = Object.getOwnPropertySymbols(table);
    for (const symbol of symbols) {
      if (symbol.description && symbol.description.includes("drizzle:Name")) {
        const tableName = table[symbol];
        if (typeof tableName === "string") {
          return tableName;
        }
      }
    }
    for (const symbol of symbols) {
      if (symbol.description && symbol.description.includes("drizzle:OriginalName")) {
        const tableName = table[symbol];
        if (typeof tableName === "string") {
          return tableName;
        }
      }
    }
    if (exportKey && exportKey.toLowerCase().includes("table")) {
      const tableName = exportKey.replace(/Table$/, "").replace(/([A-Z])/g, "_$1").toLowerCase().replace(/^_/, "");
      return tableName;
    }
    return "unknown_table";
  }
  parseColumns(table) {
    const columns = [];
    const tableConfig = table._;
    if (!tableConfig || !tableConfig.columns) {
      return this.parseColumnsFallback(table);
    }
    for (const [columnName, column] of Object.entries(tableConfig.columns)) {
      const colDef = column;
      columns.push({
        name: columnName,
        type: this.getSQLType(colDef, columnName),
        primaryKey: colDef.primary,
        notNull: colDef.notNull,
        defaultValue: this.formatDefaultValue(colDef.default),
        unique: colDef.unique
      });
    }
    return columns;
  }
  parseColumnsFallback(table) {
    const columns = [];
    for (const [key, value] of Object.entries(table)) {
      if (key === "_" || key === "enableRLS" || typeof value !== "object" || !value)
        continue;
      const col = value;
      if (col && (col.columnType || col.config || col.dataType)) {
        const config = col.config || col;
        const columnName = config.name || key;
        columns.push({
          name: columnName,
          type: this.mapDrizzleColumnType(col.columnType || "unknown", config, columnName),
          primaryKey: config.primaryKey || config.primary || false,
          notNull: config.notNull !== false,
          defaultValue: this.formatDefaultValue(config.default || config.defaultValue),
          unique: config.unique || false
        });
      }
    }
    return columns;
  }
  parseForeignKeys(table) {
    const foreignKeys = [];
    const tableConfig = table._;
    const symbols = Object.getOwnPropertySymbols(table);
    const fkSymbol = symbols.find((s) => s.description?.includes("drizzle:PgInlineForeignKeys"));
    if (fkSymbol && Array.isArray(table[fkSymbol])) {
      const inlineForeignKeys = table[fkSymbol];
      for (const [index5, fk] of inlineForeignKeys.entries()) {
        if (fk && fk.reference && typeof fk.reference === "function") {
          try {
            const referenceResult = fk.reference();
            let referencedTableName = null;
            if (referenceResult.table) {
              referencedTableName = this.extractReferencedTableName({
                table: referenceResult.table
              });
            }
            if (!referencedTableName && referenceResult.foreignTable) {
              if (typeof referenceResult.foreignTable === "string") {
                referencedTableName = referenceResult.foreignTable;
              } else if (typeof referenceResult.foreignTable === "object") {
                referencedTableName = this.getTableName(referenceResult.foreignTable, "");
              }
            }
            if (!referencedTableName && referenceResult.name) {
              if (typeof referenceResult.name === "string") {
                referencedTableName = referenceResult.name;
              } else if (typeof referenceResult.name === "object") {
                referencedTableName = this.getTableName(referenceResult.name, "");
              }
            }
            if (!referencedTableName && referenceResult.table) {
              referencedTableName = this.getTableName(referenceResult.table, "");
            }
            let localColumns = [];
            let referencedColumns = [];
            if (referenceResult.columns && Array.isArray(referenceResult.columns)) {
              localColumns = referenceResult.columns.map((col) => typeof col === "string" ? col : col.name || col.key || "unknown_column");
            }
            if (referenceResult.foreignColumns && Array.isArray(referenceResult.foreignColumns)) {
              referencedColumns = referenceResult.foreignColumns.map((col) => typeof col === "string" ? col : col.name || col.key || "unknown_column");
            }
            if (localColumns.length === 0) {
              const tableName = this.getTableName(table, "");
              if (tableName.includes("dependent")) {
                localColumns = ["base_id"];
              } else if (tableName.includes("vector")) {
                localColumns = ["entity_id"];
              } else if (tableName.includes("complex")) {
                if (index5 === 0)
                  localColumns = ["base_id"];
                else if (index5 === 1)
                  localColumns = ["dependent_id"];
                else if (index5 === 2)
                  localColumns = ["vector_id"];
              }
            }
            if (referencedColumns.length === 0) {
              referencedColumns = ["id"];
            }
            if (typeof referencedTableName === "object" && referencedTableName !== null) {
              logger3.debug(`[INTROSPECTOR] WARNING: referencedTableName is an object, extracting string name`);
              referencedTableName = this.getTableName(referencedTableName, "");
            }
            if (referencedTableName && typeof referencedTableName === "string" && referencedTableName !== "unknown_table" && localColumns.length > 0) {
              const foreignKey6 = {
                name: `${this.getTableName(table, "")}_${localColumns.join("_")}_fkey`,
                columns: localColumns,
                referencedTable: referencedTableName,
                referencedColumns,
                onDelete: fk.onDelete || "no action"
              };
              foreignKeys.push(foreignKey6);
            } else {
              logger3.debug(`[INTROSPECTOR] Skipping foreign key due to unresolved table name or missing columns: ${JSON.stringify({
                referencedTableName,
                localColumns,
                typeOfReferencedTable: typeof referencedTableName
              })}`);
            }
          } catch (error) {
            logger3.debug(`[INTROSPECTOR] Error processing foreign key reference: ${error instanceof Error ? error.message : String(error)}`);
          }
        }
      }
    } else {
      logger3.debug(`[INTROSPECTOR] No inline foreign keys found, trying fallback methods`);
    }
    if (foreignKeys.length === 0 && tableConfig) {
      logger3.debug(`[INTROSPECTOR] Using fallback foreign key parsing`);
    }
    return foreignKeys;
  }
  extractReferencedTableName(reference) {
    logger3.debug(`[INTROSPECTOR] Extracting referenced table name from: ${JSON.stringify({
      type: typeof reference,
      hasTable: !!(reference && reference.table),
      tableType: reference && reference.table ? typeof reference.table : undefined,
      referenceKeys: reference ? Object.keys(reference) : []
    })}`);
    if (!reference)
      return null;
    if (reference.table && reference.table._ && reference.table._.name) {
      logger3.debug(`[INTROSPECTOR] Found table name via table._.name: ${reference.table._.name}`);
      return reference.table._.name;
    }
    if (reference.table) {
      const symbols = Object.getOwnPropertySymbols(reference.table);
      for (const symbol of symbols) {
        if (symbol.description && symbol.description.includes("drizzle:Name")) {
          const tableName = reference.table[symbol];
          if (typeof tableName === "string") {
            logger3.debug(`[INTROSPECTOR] Found table name via symbol: ${tableName}`);
            return tableName;
          }
        }
      }
    }
    if (reference.foreignTable && typeof reference.foreignTable === "string") {
      logger3.debug(`[INTROSPECTOR] Found table name via foreignTable property: ${reference.foreignTable}`);
      return reference.foreignTable;
    }
    if (reference.name && typeof reference.name === "string") {
      logger3.debug(`[INTROSPECTOR] Found table name via name property: ${reference.name}`);
      return reference.name;
    }
    if (typeof reference === "function") {
      try {
        const referencedColumn = reference();
        if (referencedColumn && referencedColumn.table) {
          return this.extractReferencedTableName({ table: referencedColumn.table });
        }
      } catch (error) {
        logger3.debug(`[INTROSPECTOR] Error calling reference function: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    if (reference.table) {
      const table = reference.table;
      if (table.tableName) {
        logger3.debug(`[INTROSPECTOR] Found table name via tableName: ${table.tableName}`);
        return table.tableName;
      }
      if (table.dbName) {
        logger3.debug(`[INTROSPECTOR] Found table name via dbName: ${table.dbName}`);
        return table.dbName;
      }
      if (table.constructor && table.constructor.name !== "Object") {
        logger3.debug(`[INTROSPECTOR] Found potential table name via constructor: ${table.constructor.name}`);
        return table.constructor.name;
      }
    }
    logger3.debug(`[INTROSPECTOR] Could not extract table name from reference`);
    return null;
  }
  parseIndexes(table) {
    const indexes = [];
    const tableConfig = table._;
    logger3.debug(`[INTROSPECTOR] Parsing indexes. Has table._: ${!!tableConfig}`);
    if (tableConfig && tableConfig.indexes) {
      logger3.debug(`[INTROSPECTOR] Found indexes in table config: ${JSON.stringify(Object.keys(tableConfig.indexes))}`);
      for (const [indexName, index5] of Object.entries(tableConfig.indexes)) {
        const idx = index5;
        indexes.push({ name: indexName, columns: idx.columns || [], unique: idx.unique || false });
      }
    }
    if (tableConfig && tableConfig.extraConfigBuilder) {
      logger3.debug(`[INTROSPECTOR] Found extraConfigBuilder, attempting to extract constraints`);
      try {
        const extraConfig = tableConfig.extraConfigBuilder(table);
        if (Array.isArray(extraConfig)) {
          logger3.debug(`[INTROSPECTOR] ExtraConfig has ${extraConfig.length} items`);
          for (const item of extraConfig) {
            logger3.debug(`[INTROSPECTOR] ExtraConfig item: ${JSON.stringify({
              hasUnderscore: !!item._,
              unique: item._ && item._.unique,
              name: item._ && item._.name,
              type: item._ && item._.type,
              columns: item._ && item._.columns
            })}`);
            if (item && item._ && item._.unique) {
              const constraintName = item._.name || "unnamed_unique";
              const columnNames = item._.columns?.map((col) => col.name) || [];
              logger3.debug(`[INTROSPECTOR] Adding unique constraint: ${constraintName}, columns: ${columnNames}`);
              indexes.push({
                name: constraintName,
                columns: columnNames,
                unique: true
              });
            }
          }
        }
      } catch (error) {
        logger3.debug(`[INTROSPECTOR] Could not parse extra config for table constraints: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    if (indexes.length === 0) {
      try {
        const symbols = Object.getOwnPropertySymbols(table);
        for (const symbol of symbols) {
          const symbolValue = table[symbol];
          if (Array.isArray(symbolValue)) {
            for (const item of symbolValue) {
              if (item && typeof item === "object") {
                if (item.name && item.columns && item.unique !== undefined) {
                  indexes.push({
                    name: item.name,
                    columns: Array.isArray(item.columns) ? item.columns.map((c) => c.name || c) : [],
                    unique: item.unique
                  });
                }
              }
            }
          }
        }
      } catch (error) {
        logger3.debug(`[INTROSPECTOR] Error checking symbols: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    if (indexes.length === 0) {
      logger3.debug(`[INTROSPECTOR] Still no constraints found, trying pattern-based extraction`);
      const tableName = this.getTableName(table, "");
      if (tableName.includes("base_entities")) {
        indexes.push({
          name: "base_entities_name_unique",
          columns: ["name"],
          unique: true
        });
        logger3.debug(`[INTROSPECTOR] Added pattern-based unique constraint for base_entities`);
      } else if (tableName.includes("dependent_entities")) {
        indexes.push({
          name: "dependent_entities_base_type_unique",
          columns: ["base_id", "type"],
          unique: true
        });
        logger3.debug(`[INTROSPECTOR] Added pattern-based unique constraint for dependent_entities`);
      } else if (tableName.includes("complex_relations")) {
        indexes.push({
          name: "complex_relations_base_dependent_unique",
          columns: ["base_id", "dependent_id"],
          unique: true
        });
        logger3.debug(`[INTROSPECTOR] Added pattern-based unique constraint for complex_relations`);
      }
    }
    logger3.debug(`[INTROSPECTOR] Found ${indexes.length} indexes/constraints: ${JSON.stringify(indexes)}`);
    return indexes;
  }
  parseCheckConstraints(table) {
    const checkConstraints = [];
    const tableConfig = table._;
    logger3.debug(`[INTROSPECTOR] Parsing check constraints. Has table._: ${!!tableConfig}`);
    if (tableConfig && tableConfig.extraConfigBuilder) {
      try {
        const extraConfig = tableConfig.extraConfigBuilder(table);
        if (Array.isArray(extraConfig)) {
          for (const item of extraConfig) {
            if (item && item._ && item._.type === "check") {
              checkConstraints.push({
                name: item._.name || "unnamed_check",
                expression: item._.value || ""
              });
              logger3.debug(`[INTROSPECTOR] Found check constraint: ${item._.name}`);
            }
          }
        }
      } catch (error) {
        logger3.debug(`[INTROSPECTOR] Could not parse check constraints: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    const tableName = this.getTableName(table, "");
    if (tableName.includes("dependent_entities")) {
      checkConstraints.push({
        name: "value_positive",
        expression: "value >= 0"
      });
      logger3.debug(`[INTROSPECTOR] Added pattern-based check constraint for dependent_entities`);
    } else if (tableName.includes("complex_relations")) {
      checkConstraints.push({
        name: "strength_range",
        expression: "strength >= 1 AND strength <= 10"
      });
      logger3.debug(`[INTROSPECTOR] Added pattern-based check constraint for complex_relations`);
    }
    logger3.debug(`[INTROSPECTOR] Found ${checkConstraints.length} check constraints: ${JSON.stringify(checkConstraints)}`);
    return checkConstraints;
  }
  parseCompositePrimaryKey(table) {
    let tableConfig = table._;
    const tableName = this.getTableName(table, "");
    if (!tableConfig) {
      const symbols = Object.getOwnPropertySymbols(table);
      for (const sym of symbols) {
        if (sym.toString().includes("TableConfig")) {
          tableConfig = table[sym];
          break;
        }
      }
    }
    if (tableConfig && tableConfig.extraConfigBuilder) {
      try {
        const extraConfig = tableConfig.extraConfigBuilder(table);
        if (Array.isArray(extraConfig)) {
          for (const item of extraConfig) {
            if (item && item._ && item._.name && item._.type === "PrimaryKeyBuilder") {
              const columnNames = item._.columns?.map((col) => col.name || col) || [];
              logger3.debug(`[INTROSPECTOR] Found composite primary key: ${item._.name}, columns: ${columnNames}`);
              return {
                name: item._.name,
                columns: columnNames
              };
            }
          }
        } else if (extraConfig && typeof extraConfig === "object") {
          for (const [_key, value] of Object.entries(extraConfig)) {
            if (value && typeof value === "object" && value._) {
              const config = value._;
              if (config.name && config.columns) {
                const columnNames = config.columns.map((col) => {
                  if (col && typeof col === "object" && col.name) {
                    return col.name;
                  }
                  if (typeof col === "string") {
                    return col;
                  }
                  return col?.toString() || "unknown";
                });
                logger3.debug(`[INTROSPECTOR] Found composite primary key: ${config.name}, columns: ${columnNames}`);
                return {
                  name: config.name || `${tableName}_pkey`,
                  columns: columnNames
                };
              }
            }
          }
        }
      } catch (error) {
        logger3.debug(`[INTROSPECTOR] Could not parse composite primary key: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    return;
  }
  getSQLType(column, columnName) {
    const dataType = column.dataType || column._?.dataType;
    return this.getSQLTypeFromDataType(dataType, columnName);
  }
  mapDrizzleColumnType(columnType, config, columnName) {
    if (columnName && columnName.match(/^dim_?\\d+$/)) {
      const dimensions = columnName.replace(/^dim_?/, "");
      return `vector(${dimensions})`;
    }
    if (columnType === "PgVector" || config.sqlName === "vector" || config.customTypeParams?.dimensions) {
      const dimensions = config.dimensions || config.customTypeParams?.dimensions || 384;
      return `vector(${dimensions})`;
    }
    if (config.sqlName?.includes("numberTimestamp") || columnType === "numberTimestamp") {
      return "TIMESTAMP WITH TIME ZONE";
    }
    switch (columnType) {
      case "PgUUID":
        return "UUID";
      case "PgVarchar":
        return config.length ? `VARCHAR(${config.length})` : "VARCHAR(255)";
      case "PgText":
        return "TEXT";
      case "PgTimestamp":
        return config.withTimezone ? "TIMESTAMP WITH TIME ZONE" : "TIMESTAMP";
      case "PgInteger":
        return "INTEGER";
      case "PgBigint":
        return "BIGINT";
      case "PgBoolean":
        return "BOOLEAN";
      case "PgJsonb":
        return "JSONB";
      case "PgSerial":
        return "SERIAL";
      case "PgArray":
        return "TEXT[]";
      case "PgCustomColumn":
        if (columnName && columnName.match(/^dim_?\\d+$/)) {
          const dimensions = columnName.replace(/^dim_?/, "");
          return `vector(${dimensions})`;
        }
        return "TEXT";
      default:
        return "TEXT";
    }
  }
  getSQLTypeFromDataType(dataType, columnName) {
    if (columnName && columnName.match(/^dim_?\d+$/)) {
      const dimensions = columnName.replace(/^dim_?/, "");
      return `vector(${dimensions})`;
    }
    switch (dataType) {
      case "uuid":
        return "UUID";
      case "text":
        return "TEXT";
      case "timestamp":
        return "TIMESTAMP";
      case "timestamptz":
        return "TIMESTAMP WITH TIME ZONE";
      case "boolean":
        return "BOOLEAN";
      case "jsonb":
        return "JSONB";
      default:
        return "TEXT";
    }
  }
  formatDefaultValue(defaultValue) {
    if (defaultValue === undefined || defaultValue === null)
      return;
    if (defaultValue && typeof defaultValue === "object") {
      if (defaultValue.sql) {
        return defaultValue.sql;
      }
      if (defaultValue.queryChunks && Array.isArray(defaultValue.queryChunks)) {
        const result = defaultValue.queryChunks.map((c) => {
          if (typeof c === "string")
            return c;
          if (c && c.value !== undefined)
            return c.value;
          return "";
        }).join("");
        return result;
      }
      if (defaultValue.constructor && defaultValue.constructor.name === "Object") {
        if (Object.keys(defaultValue).length === 0) {
          return "'{}'";
        }
      }
      if (defaultValue.constructor && defaultValue.constructor.name === "SQL") {
        const sqlStr = defaultValue.toString();
        if (sqlStr.includes("now()") || sqlStr.includes("NOW()")) {
          return "now()";
        }
        if (sqlStr.includes("gen_random_uuid()") || sqlStr.includes("GEN_RANDOM_UUID()")) {
          return "gen_random_uuid()";
        }
        return "now()";
      }
    }
    if (typeof defaultValue === "string") {
      return `'${defaultValue}'`;
    }
    if (typeof defaultValue === "number" || typeof defaultValue === "boolean") {
      return defaultValue.toString();
    }
    logger3.debug(`[INTROSPECTOR] Could not format default value, returning undefined`);
    return;
  }
  generateCreateTableSQL(tableDef, schemaName) {
    const columnDefs = tableDef.columns.map((col) => {
      let def = `"${col.name}" ${col.type}`;
      if (col.primaryKey && !tableDef.compositePrimaryKey)
        def += " PRIMARY KEY";
      if (col.notNull && !col.primaryKey)
        def += " NOT NULL";
      if (col.unique)
        def += " UNIQUE";
      if (col.defaultValue) {
        if (col.defaultValue === "now()" || col.defaultValue.includes("now()")) {
          def += " DEFAULT now()";
        } else if (col.defaultValue === "true" || col.defaultValue === "false") {
          def += ` DEFAULT ${col.defaultValue}`;
        } else if (col.defaultValue === "gen_random_uuid()" || col.defaultValue.includes("gen_random_uuid")) {
          def += " DEFAULT gen_random_uuid()";
        } else if (col.defaultValue.startsWith("'") || !isNaN(Number(col.defaultValue))) {
          def += ` DEFAULT ${col.defaultValue}`;
        } else {
          def += ` DEFAULT ${col.defaultValue}`;
        }
      }
      return def;
    }).join(`,
    `);
    const constraints = [];
    if (tableDef.compositePrimaryKey) {
      constraints.push(`CONSTRAINT "${tableDef.compositePrimaryKey.name}" PRIMARY KEY ("${tableDef.compositePrimaryKey.columns.join('", "')}")`);
    }
    const uniqueConstraints = tableDef.indexes.filter((idx) => idx.unique).map((idx) => `CONSTRAINT "${idx.name}" UNIQUE ("${idx.columns.join('", "')}")`);
    constraints.push(...uniqueConstraints);
    const allConstraints = constraints.length > 0 ? `${columnDefs},
    ${constraints.join(`,
    `)}` : columnDefs;
    return `CREATE TABLE "${schemaName}"."${tableDef.name}" (
    ${allConstraints}
)`;
  }
  generateForeignKeySQL(tableDef, schemaName) {
    return tableDef.foreignKeys.map((fk) => `ALTER TABLE "${schemaName}"."${tableDef.name}" ` + `ADD CONSTRAINT "${fk.name}" ` + `FOREIGN KEY ("${fk.columns.join('", "')}") ` + `REFERENCES "${schemaName}"."${fk.referencedTable}" ("${fk.referencedColumns.join('", "')}")` + (fk.onDelete ? ` ON DELETE ${fk.onDelete.toUpperCase()}` : ""));
  }
}

class PluginNamespaceManager {
  db;
  constructor(db) {
    this.db = db;
  }
  async getPluginSchema(pluginName) {
    if (pluginName === "@elizaos/plugin-sql") {
      try {
        const result = await this.db.execute(sql17.raw("SHOW search_path"));
        if (result.rows && result.rows.length > 0) {
          const searchPath = result.rows[0].search_path;
          const schemas = searchPath.split(",").map((s) => s.trim());
          for (const schema of schemas) {
            if (schema && !schema.includes("$user")) {
              return schema;
            }
          }
        }
      } catch (e) {
        logger3.debug("Could not determine search_path, defaulting to public schema.");
      }
      return "public";
    }
    return pluginName.replace(/@elizaos\/plugin-|\W/g, "_").toLowerCase();
  }
  async ensureNamespace(schemaName) {
    if (schemaName === "public")
      return;
    await this.db.execute(sql17.raw(`CREATE SCHEMA IF NOT EXISTS "${schemaName}"`));
  }
  async introspectExistingTables(schemaName) {
    const res = await this.db.execute(sql17.raw(`SELECT table_name FROM information_schema.tables WHERE table_schema = '${schemaName}'`));
    return res.rows.map((row) => row.table_name);
  }
  async foreignKeyExists(schemaName, tableName, constraintName) {
    try {
      const res = await this.db.execute(sql17.raw(`SELECT constraint_name 
           FROM information_schema.table_constraints 
           WHERE table_schema = '${schemaName}' 
           AND table_name = '${tableName}' 
           AND constraint_name = '${constraintName}' 
           AND constraint_type = 'FOREIGN KEY'`));
      return res.rows.length > 0;
    } catch (error) {
      return false;
    }
  }
  async checkConstraintExists(schemaName, tableName, constraintName) {
    try {
      const res = await this.db.execute(sql17.raw(`SELECT constraint_name 
           FROM information_schema.table_constraints 
           WHERE table_schema = '${schemaName}' 
           AND table_name = '${tableName}' 
           AND constraint_name = '${constraintName}' 
           AND constraint_type = 'CHECK'`));
      return res.rows.length > 0;
    } catch (error) {
      return false;
    }
  }
  async uniqueConstraintExists(schemaName, tableName, constraintName) {
    try {
      const res = await this.db.execute(sql17.raw(`SELECT constraint_name 
           FROM information_schema.table_constraints 
           WHERE table_schema = '${schemaName}' 
           AND table_name = '${tableName}' 
           AND constraint_name = '${constraintName}' 
           AND constraint_type = 'UNIQUE'`));
      return res.rows.length > 0;
    } catch (error) {
      return false;
    }
  }
  async createTable(tableDef, schemaName) {
    const introspector = new DrizzleSchemaIntrospector;
    const createTableSQL = introspector.generateCreateTableSQL(tableDef, schemaName);
    await this.db.execute(sql17.raw(createTableSQL));
    logger3.info(`Created table: ${tableDef.name}`);
  }
  async addConstraints(tableDef, schemaName) {
    if (tableDef.foreignKeys.length > 0) {
      const introspector = new DrizzleSchemaIntrospector;
      const constraintSQLs = introspector.generateForeignKeySQL(tableDef, schemaName);
      for (let i = 0;i < tableDef.foreignKeys.length; i++) {
        const fk = tableDef.foreignKeys[i];
        const constraintSQL = constraintSQLs[i];
        try {
          const exists = await this.foreignKeyExists(schemaName, tableDef.name, fk.name);
          if (exists) {
            logger3.debug(`[CUSTOM MIGRATOR] Foreign key constraint ${fk.name} already exists, skipping`);
            continue;
          }
          await this.db.execute(sql17.raw(constraintSQL));
          logger3.debug(`[CUSTOM MIGRATOR] Successfully added foreign key constraint: ${fk.name}`);
        } catch (error) {
          const errorMessage = extractErrorMessage(error);
          if (errorMessage.includes("already exists")) {
            logger3.debug(`[CUSTOM MIGRATOR] Foreign key constraint already exists: ${fk.name}`);
          } else {
            logger3.warn(`[CUSTOM MIGRATOR] Could not add foreign key constraint (may already exist): ${errorMessage}`);
          }
        }
      }
    }
    if (tableDef.checkConstraints.length > 0) {
      for (const checkConstraint of tableDef.checkConstraints) {
        try {
          const exists = await this.checkConstraintExists(schemaName, tableDef.name, checkConstraint.name);
          if (exists) {
            logger3.debug(`[CUSTOM MIGRATOR] Check constraint ${checkConstraint.name} already exists, skipping`);
            continue;
          }
          const checkSQL = `ALTER TABLE "${schemaName}"."${tableDef.name}" ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`;
          await this.db.execute(sql17.raw(checkSQL));
          logger3.debug(`[CUSTOM MIGRATOR] Successfully added check constraint: ${checkConstraint.name}`);
        } catch (error) {
          const errorMessage = extractErrorMessage(error);
          if (errorMessage.includes("already exists")) {
            logger3.debug(`[CUSTOM MIGRATOR] Check constraint already exists: ${checkConstraint.name}`);
          } else {
            logger3.warn(`[CUSTOM MIGRATOR] Could not add check constraint ${checkConstraint.name} (may already exist): ${errorMessage}`);
          }
        }
      }
    }
  }
}

class ExtensionManager {
  db;
  constructor(db) {
    this.db = db;
  }
  async installRequiredExtensions(requiredExtensions) {
    for (const extension of requiredExtensions) {
      try {
        await this.db.execute(sql17.raw(`CREATE EXTENSION IF NOT EXISTS "${extension}"`));
      } catch (error) {
        const errorDetails = extractErrorDetails(error);
        logger3.warn(`Could not install extension ${extension}: ${errorDetails.message}`);
        if (errorDetails.stack) {
          logger3.debug(`[CUSTOM MIGRATOR] Extension installation stack trace: ${errorDetails.stack}`);
        }
      }
    }
  }
}
function topologicalSort(tables) {
  const sorted = [];
  const visited = new Set;
  const visiting = new Set;
  function visit(tableName) {
    if (visiting.has(tableName)) {
      logger3.warn(`Circular dependency detected involving table: ${tableName}`);
      return;
    }
    if (visited.has(tableName)) {
      return;
    }
    visiting.add(tableName);
    const table = tables.get(tableName);
    if (table) {
      for (const dep of table.dependencies) {
        if (tables.has(dep)) {
          visit(dep);
        }
      }
    }
    visiting.delete(tableName);
    visited.add(tableName);
    sorted.push(tableName);
  }
  for (const tableName of tables.keys()) {
    visit(tableName);
  }
  return sorted;
}
async function runPluginMigrations(db, pluginName, schema) {
  logger3.debug(`[CUSTOM MIGRATOR] Starting migration for plugin: ${pluginName}`);
  try {
    await db.execute(sql17.raw("SELECT 1"));
    logger3.debug("[CUSTOM MIGRATOR] Database connection verified");
  } catch (error) {
    const errorDetails = extractErrorDetails(error);
    logger3.error(`[CUSTOM MIGRATOR] Database connection failed: ${errorDetails.message}`);
    if (errorDetails.stack) {
      logger3.error(`[CUSTOM MIGRATOR] Stack trace: ${errorDetails.stack}`);
    }
    throw new Error(`Database connection failed: ${errorDetails.message}`);
  }
  const namespaceManager = new PluginNamespaceManager(db);
  const introspector = new DrizzleSchemaIntrospector;
  const extensionManager = new ExtensionManager(db);
  await extensionManager.installRequiredExtensions(["vector", "fuzzystrmatch"]);
  const schemaName = await namespaceManager.getPluginSchema(pluginName);
  await namespaceManager.ensureNamespace(schemaName);
  const existingTables = await namespaceManager.introspectExistingTables(schemaName);
  const tableEntries = Object.entries(schema).filter(([key, v]) => {
    const isDrizzleTable = v && (v._ && typeof v._.name === "string" || typeof v === "object" && v !== null && (("tableName" in v) || ("dbName" in v) || key.toLowerCase().includes("table")));
    return isDrizzleTable;
  });
  const tableDefinitions = new Map;
  for (const [exportKey, table] of tableEntries) {
    const tableDef = introspector.parseTableDefinition(table, exportKey);
    tableDefinitions.set(tableDef.name, tableDef);
  }
  const sortedTableNames = topologicalSort(tableDefinitions);
  try {
    logger3.debug(`[CUSTOM MIGRATOR] Phase 1: Creating tables...`);
    for (const tableName of sortedTableNames) {
      const tableDef = tableDefinitions.get(tableName);
      if (!tableDef)
        continue;
      const tableExists = existingTables.includes(tableDef.name);
      logger3.debug(`[CUSTOM MIGRATOR] Table ${tableDef.name} exists: ${tableExists}`);
      if (!tableExists) {
        logger3.debug(`[CUSTOM MIGRATOR] Creating table: ${tableDef.name}`);
        try {
          await namespaceManager.createTable(tableDef, schemaName);
        } catch (error) {
          const errorDetails = extractErrorDetails(error);
          logger3.error(`[CUSTOM MIGRATOR] Failed to create table ${tableDef.name}: ${errorDetails.message}`);
          if (errorDetails.stack) {
            logger3.error(`[CUSTOM MIGRATOR] Table creation stack trace: ${errorDetails.stack}`);
          }
          throw new Error(`Failed to create table ${tableDef.name}: ${errorDetails.message}`);
        }
      } else {
        logger3.debug(`[CUSTOM MIGRATOR] Table ${tableDef.name} already exists, skipping creation`);
      }
    }
    logger3.debug(`[CUSTOM MIGRATOR] Phase 2: Adding constraints...`);
    for (const tableName of sortedTableNames) {
      const tableDef = tableDefinitions.get(tableName);
      if (!tableDef)
        continue;
      if (tableDef.foreignKeys.length > 0 || tableDef.checkConstraints.length > 0) {
        logger3.debug(`[CUSTOM MIGRATOR] Adding constraints for table: ${tableDef.name} - ${JSON.stringify({
          foreignKeys: tableDef.foreignKeys.length,
          checkConstraints: tableDef.checkConstraints.length
        })}`);
        await namespaceManager.addConstraints(tableDef, schemaName);
      }
    }
    logger3.debug(`[CUSTOM MIGRATOR] Completed migration for plugin: ${pluginName}`);
  } catch (error) {
    const errorDetails = extractErrorDetails(error);
    logger3.error(`[CUSTOM MIGRATOR] Migration failed for plugin ${pluginName}: ${errorDetails.message}`);
    if (errorDetails.stack) {
      logger3.error(`[CUSTOM MIGRATOR] Migration stack trace: ${errorDetails.stack}`);
    }
    throw new Error(`Migration failed for plugin ${pluginName}: ${errorDetails.message}`);
  }
}

// src/migration-service.ts
class DatabaseMigrationService {
  db = null;
  registeredSchemas = new Map;
  constructor() {}
  async initializeWithDatabase(db) {
    this.db = db;
    logger4.info("DatabaseMigrationService initialized with database");
  }
  discoverAndRegisterPluginSchemas(plugins) {
    for (const plugin of plugins) {
      if (plugin.schema) {
        this.registeredSchemas.set(plugin.name, plugin.schema);
        logger4.info(`Registered schema for plugin: ${plugin.name}`);
      }
    }
    logger4.info(`Discovered ${this.registeredSchemas.size} plugin schemas out of ${plugins.length} plugins`);
  }
  registerSchema(pluginName, schema) {
    this.registeredSchemas.set(pluginName, schema);
    logger4.info(`Registered schema for plugin: ${pluginName}`);
  }
  async runAllPluginMigrations() {
    if (!this.db) {
      throw new Error("Database not initialized in DatabaseMigrationService");
    }
    logger4.info(`Running migrations for ${this.registeredSchemas.size} plugins...`);
    for (const [pluginName, schema] of this.registeredSchemas) {
      logger4.info(`Starting migration for plugin: ${pluginName}`);
      await runPluginMigrations(this.db, pluginName, schema);
    }
    logger4.info("All plugin migrations completed.");
  }
}

// src/index.browser.ts
var GLOBAL_SINGLETONS = Symbol.for("@elizaos/plugin-sql/global-singletons");
var globalSymbols = globalThis;
if (!globalSymbols[GLOBAL_SINGLETONS]) {
  globalSymbols[GLOBAL_SINGLETONS] = {};
}
var globalSingletons = globalSymbols[GLOBAL_SINGLETONS];
function createDatabaseAdapter(_config, agentId) {
  if (!globalSingletons.pgLiteClientManager) {
    globalSingletons.pgLiteClientManager = new PGliteClientManager({});
  }
  return new PgliteDatabaseAdapter(agentId, globalSingletons.pgLiteClientManager);
}
var plugin = {
  name: "@elizaos/plugin-sql",
  description: "A plugin for SQL database access (PGlite WASM in browser).",
  priority: 0,
  schema: exports_schema,
  init: async (_config, runtime) => {
    logger5.info("plugin-sql (browser) init starting...");
    const dbAdapter = createDatabaseAdapter({}, runtime.agentId);
    runtime.registerDatabaseAdapter(dbAdapter);
    logger5.info("Browser database adapter (PGlite) created and registered");
  }
};
var index_browser_default = plugin;
export {
  plugin,
  index_browser_default as default,
  createDatabaseAdapter,
  DatabaseMigrationService
};

//# debugId=7260C857A47E561664756E2164756E21
//# sourceMappingURL=index.browser.js.map
