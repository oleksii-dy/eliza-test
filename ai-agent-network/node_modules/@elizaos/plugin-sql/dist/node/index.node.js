var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// src/index.node.ts
import { logger as logger7 } from "@elizaos/core";

// src/pglite/adapter.ts
import { logger as logger2 } from "@elizaos/core";

// ../../node_modules/drizzle-orm/pglite/driver.js
import { PGlite } from "@electric-sql/pglite";

// ../../node_modules/drizzle-orm/entity.js
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// ../../node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {}
}

// ../../node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// ../../node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.keyAsName = config.keyAsName;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.onUpdateFn = config.onUpdateFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
    this.generated = config.generated;
    this.generatedIdentity = config.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  generated = undefined;
  generatedIdentity = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  shouldDisableInsert() {
    return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
  }
}

// ../../node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      keyAsName: name === "",
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType,
      generated: undefined
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  $onUpdateFn(fn) {
    this.config.onUpdateFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $onUpdate = this.$onUpdateFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
  setName(name) {
    if (this.config.name !== "")
      return;
    this.config.name = name;
  }
}

// ../../node_modules/drizzle-orm/table.utils.js
var TableName = Symbol.for("drizzle:Name");

// ../../node_modules/drizzle-orm/pg-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "PgForeignKeyBuilder";
  reference;
  _onUpdate = "no action";
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === undefined ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === undefined ? "no action" : action;
    return this;
  }
  build(table) {
    return new ForeignKey(table, this);
  }
}

class ForeignKey {
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
}
function foreignKey(config) {
  function mappedConfig() {
    const { name, columns, foreignColumns } = config;
    return {
      name,
      columns,
      foreignColumns
    };
  }
  return new ForeignKeyBuilder(mappedConfig);
}

// ../../node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}

// ../../node_modules/drizzle-orm/pg-core/unique-constraint.js
function unique(name) {
  return new UniqueOnConstraintBuilder(name);
}
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

class UniqueConstraintBuilder {
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  static [entityKind] = "PgUniqueConstraintBuilder";
  columns;
  nullsNotDistinctConfig = false;
  nullsNotDistinct() {
    this.nullsNotDistinctConfig = true;
    return this;
  }
  build(table) {
    return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
  }
}

class UniqueOnConstraintBuilder {
  static [entityKind] = "PgUniqueOnConstraintBuilder";
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder(columns, this.name);
  }
}

class UniqueConstraint {
  constructor(table, columns, nullsNotDistinct, name) {
    this.table = table;
    this.columns = columns;
    this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    this.nullsNotDistinct = nullsNotDistinct;
  }
  static [entityKind] = "PgUniqueConstraint";
  columns;
  name;
  nullsNotDistinct = false;
  getName() {
    return this.name;
  }
}

// ../../node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i = startFrom;i < arrayString.length; i++) {
    const char = arrayString[i];
    if (char === "\\") {
      i++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char = arrayString[i];
    if (char === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value);
    i = newStartFrom;
  }
  return [result, i];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// ../../node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumnBuilder extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  generatedAlwaysAs(as) {
    this.config.generated = {
      as,
      type: "always",
      mode: "stored"
    };
    return this;
  }
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife((ref2, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      }, ref, actions);
    });
  }
  buildExtraConfigColumn(table) {
    return new ExtraConfigColumn(table, this.config);
  }
}

class PgColumn extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
  static [entityKind] = "PgColumn";
}

class ExtraConfigColumn extends PgColumn {
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: undefined
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
}

class IndexedColumn {
  static [entityKind] = "IndexedColumn";
  constructor(name, keyAsName, type, indexConfig) {
    this.name = name;
    this.keyAsName = keyAsName;
    this.type = type;
    this.indexConfig = indexConfig;
  }
  name;
  keyAsName;
  type;
  indexConfig;
}

class PgArrayBuilder extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(table, this.config, baseColumn);
  }
}

class PgArray extends PgColumn {
  constructor(table, config, baseColumn, range) {
    super(table, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v) => this.baseColumn.mapFromDriverValue(v));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a = value.map((v) => v === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v));
    if (isNestedArray)
      return a;
    return makePgArray(a);
  }
}

// ../../node_modules/drizzle-orm/pg-core/columns/enum.js
class PgEnumObjectColumn extends PgColumn {
  static [entityKind] = "PgEnumObjectColumn";
  enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// ../../node_modules/drizzle-orm/subquery.js
class Subquery {
  static [entityKind] = "Subquery";
  constructor(sql, fields, alias, isWith = false, usedTables = []) {
    this._ = {
      brand: "Subquery",
      sql,
      selectedFields: fields,
      alias,
      isWith,
      usedTables
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// ../../node_modules/drizzle-orm/version.js
var version = "0.44.5";

// ../../node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// ../../node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// ../../node_modules/drizzle-orm/table.js
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [ExtraConfigColumns];
  [BaseName];
  [IsAlias] = false;
  [IsDrizzleTable] = true;
  [ExtraConfigBuilder] = undefined;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}

// ../../node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== undefined && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}

class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
    for (const chunk of queryChunks) {
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        this.usedTables.push(schemaName === undefined ? chunk[Table.Symbol.Name] : schemaName + "." + chunk[Table.Symbol.Name]);
      }
    }
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  usedTables = [];
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i, p] of chunk.entries()) {
          result.push(p);
          if (i < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        const schemaName = chunk.table[Table.Symbol.Schema];
        return {
          sql: chunk.table[IsAlias] || schemaName === undefined ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
          params: []
        };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        if (is(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  if(condition) {
    return condition ? this : undefined;
  }
}

class Name {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {

  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values[p.value.name]);
    }
    return p;
  });
}
var IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  [IsDrizzleView] = true;
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// ../../node_modules/drizzle-orm/alias.js
class ColumnAliasProxyHandler {
  constructor(table) {
    this.table = table;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}

// ../../node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(subquery._.selectedFields, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new SelectionProxyHandler(this.config));
  }
}

// ../../node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["schema"];
    if (type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["casing"];
    if (type !== "string" && type !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== undefined)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}
var textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder;

// ../../node_modules/drizzle-orm/pg-core/columns/int.common.js
class PgIntColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntColumnBaseBuilder";
  generatedAlwaysAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "always",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "always"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
  generatedByDefaultAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "byDefault",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "byDefault"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
}

// ../../node_modules/drizzle-orm/pg-core/columns/bigint.js
class PgBigInt53Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt53Builder";
  constructor(name) {
    super(name, "number", "PgBigInt53");
  }
  build(table) {
    return new PgBigInt53(table, this.config);
  }
}

class PgBigInt53 extends PgColumn {
  static [entityKind] = "PgBigInt53";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigInt64Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigInt64");
  }
  build(table) {
    return new PgBigInt64(table, this.config);
  }
}

class PgBigInt64 extends PgColumn {
  static [entityKind] = "PgBigInt64";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigint(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigInt53Builder(name);
  }
  return new PgBigInt64Builder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/bigserial.js
class PgBigSerial53Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial53Builder";
  constructor(name) {
    super(name, "number", "PgBigSerial53");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgBigSerial53(table, this.config);
  }
}

class PgBigSerial53 extends PgColumn {
  static [entityKind] = "PgBigSerial53";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigSerial64Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigSerial64");
    this.config.hasDefault = true;
  }
  build(table) {
    return new PgBigSerial64(table, this.config);
  }
}

class PgBigSerial64 extends PgColumn {
  static [entityKind] = "PgBigSerial64";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigserial(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigSerial53Builder(name);
  }
  return new PgBigSerial64Builder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/boolean.js
class PgBooleanBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBooleanBuilder";
  constructor(name) {
    super(name, "boolean", "PgBoolean");
  }
  build(table) {
    return new PgBoolean(table, this.config);
  }
}

class PgBoolean extends PgColumn {
  static [entityKind] = "PgBoolean";
  getSQLType() {
    return "boolean";
  }
}
function boolean(name) {
  return new PgBooleanBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/char.js
class PgCharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCharBuilder";
  constructor(name, config) {
    super(name, "string", "PgChar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgChar(table, this.config);
  }
}

class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}
function char(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgCharBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/cidr.js
class PgCidrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCidrBuilder";
  constructor(name) {
    super(name, "string", "PgCidr");
  }
  build(table) {
    return new PgCidr(table, this.config);
  }
}

class PgCidr extends PgColumn {
  static [entityKind] = "PgCidr";
  getSQLType() {
    return "cidr";
  }
}
function cidr(name) {
  return new PgCidrBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/custom.js
class PgCustomColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCustomColumnBuilder";
  constructor(name, fieldConfig, customTypeParams) {
    super(name, "custom", "PgCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  build(table) {
    return new PgCustomColumn(table, this.config);
  }
}

class PgCustomColumn extends PgColumn {
  static [entityKind] = "PgCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config) {
    super(table, config);
    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
    this.mapTo = config.customTypeParams.toDriver;
    this.mapFrom = config.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
}
function customType(customTypeParams) {
  return (a, b) => {
    const { name, config } = getColumnNameAndConfig(a, b);
    return new PgCustomColumnBuilder(name, config, customTypeParams);
  };
}

// ../../node_modules/drizzle-orm/pg-core/columns/date.common.js
class PgDateColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql`now()`);
  }
}

// ../../node_modules/drizzle-orm/pg-core/columns/date.js
class PgDateBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateBuilder";
  constructor(name) {
    super(name, "date", "PgDate");
  }
  build(table) {
    return new PgDate(table, this.config);
  }
}

class PgDate extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
}

class PgDateStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateStringBuilder";
  constructor(name) {
    super(name, "string", "PgDateString");
  }
  build(table) {
    return new PgDateString(table, this.config);
  }
}

class PgDateString extends PgColumn {
  static [entityKind] = "PgDateString";
  getSQLType() {
    return "date";
  }
}
function date(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "date") {
    return new PgDateBuilder(name);
  }
  return new PgDateStringBuilder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/double-precision.js
class PgDoublePrecisionBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDoublePrecisionBuilder";
  constructor(name) {
    super(name, "number", "PgDoublePrecision");
  }
  build(table) {
    return new PgDoublePrecision(table, this.config);
  }
}

class PgDoublePrecision extends PgColumn {
  static [entityKind] = "PgDoublePrecision";
  getSQLType() {
    return "double precision";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  }
}
function doublePrecision(name) {
  return new PgDoublePrecisionBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/inet.js
class PgInetBuilder extends PgColumnBuilder {
  static [entityKind] = "PgInetBuilder";
  constructor(name) {
    super(name, "string", "PgInet");
  }
  build(table) {
    return new PgInet(table, this.config);
  }
}

class PgInet extends PgColumn {
  static [entityKind] = "PgInet";
  getSQLType() {
    return "inet";
  }
}
function inet(name) {
  return new PgInetBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/integer.js
class PgIntegerBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  build(table) {
    return new PgInteger(table, this.config);
  }
}

class PgInteger extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
}
function integer(name) {
  return new PgIntegerBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/interval.js
class PgIntervalBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntervalBuilder";
  constructor(name, intervalConfig) {
    super(name, "string", "PgInterval");
    this.config.intervalConfig = intervalConfig;
  }
  build(table) {
    return new PgInterval(table, this.config);
  }
}

class PgInterval extends PgColumn {
  static [entityKind] = "PgInterval";
  fields = this.config.intervalConfig.fields;
  precision = this.config.intervalConfig.precision;
  getSQLType() {
    const fields = this.fields ? ` ${this.fields}` : "";
    const precision = this.precision ? `(${this.precision})` : "";
    return `interval${fields}${precision}`;
  }
}
function interval(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgIntervalBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/json.js
class PgJsonBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonBuilder";
  constructor(name) {
    super(name, "json", "PgJson");
  }
  build(table) {
    return new PgJson(table, this.config);
  }
}

class PgJson extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function json(name) {
  return new PgJsonBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/jsonb.js
class PgJsonbBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonbBuilder";
  constructor(name) {
    super(name, "json", "PgJsonb");
  }
  build(table) {
    return new PgJsonb(table, this.config);
  }
}

class PgJsonb extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function jsonb(name) {
  return new PgJsonbBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/line.js
class PgLineBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineBuilder";
  constructor(name) {
    super(name, "array", "PgLine");
  }
  build(table) {
    return new PgLineTuple(table, this.config);
  }
}

class PgLineTuple extends PgColumn {
  static [entityKind] = "PgLine";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b, c] = value.slice(1, -1).split(",");
    return [Number.parseFloat(a), Number.parseFloat(b), Number.parseFloat(c)];
  }
  mapToDriverValue(value) {
    return `{${value[0]},${value[1]},${value[2]}}`;
  }
}

class PgLineABCBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineABCBuilder";
  constructor(name) {
    super(name, "json", "PgLineABC");
  }
  build(table) {
    return new PgLineABC(table, this.config);
  }
}

class PgLineABC extends PgColumn {
  static [entityKind] = "PgLineABC";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b, c] = value.slice(1, -1).split(",");
    return { a: Number.parseFloat(a), b: Number.parseFloat(b), c: Number.parseFloat(c) };
  }
  mapToDriverValue(value) {
    return `{${value.a},${value.b},${value.c}}`;
  }
}
function line(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgLineBuilder(name);
  }
  return new PgLineABCBuilder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/macaddr.js
class PgMacaddrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddrBuilder";
  constructor(name) {
    super(name, "string", "PgMacaddr");
  }
  build(table) {
    return new PgMacaddr(table, this.config);
  }
}

class PgMacaddr extends PgColumn {
  static [entityKind] = "PgMacaddr";
  getSQLType() {
    return "macaddr";
  }
}
function macaddr(name) {
  return new PgMacaddrBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/macaddr8.js
class PgMacaddr8Builder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddr8Builder";
  constructor(name) {
    super(name, "string", "PgMacaddr8");
  }
  build(table) {
    return new PgMacaddr8(table, this.config);
  }
}

class PgMacaddr8 extends PgColumn {
  static [entityKind] = "PgMacaddr8";
  getSQLType() {
    return "macaddr8";
  }
}
function macaddr8(name) {
  return new PgMacaddr8Builder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/numeric.js
class PgNumericBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBuilder";
  constructor(name, precision, scale) {
    super(name, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumeric(table, this.config);
  }
}

class PgNumeric extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string")
      return value;
    return String(value);
  }
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericNumberBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericNumberBuilder";
  constructor(name, precision, scale) {
    super(name, "number", "PgNumericNumber");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericNumber(table, this.config);
  }
}

class PgNumericNumber extends PgColumn {
  static [entityKind] = "PgNumericNumber";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "number")
      return value;
    return Number(value);
  }
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericBigIntBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBigIntBuilder";
  constructor(name, precision, scale) {
    super(name, "bigint", "PgNumericBigInt");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericBigInt(table, this.config);
  }
}

class PgNumericBigInt extends PgColumn {
  static [entityKind] = "PgNumericBigInt";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue = BigInt;
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}
function numeric(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  const mode = config?.mode;
  return mode === "number" ? new PgNumericNumberBuilder(name, config?.precision, config?.scale) : mode === "bigint" ? new PgNumericBigIntBuilder(name, config?.precision, config?.scale) : new PgNumericBuilder(name, config?.precision, config?.scale);
}

// ../../node_modules/drizzle-orm/pg-core/columns/point.js
class PgPointTupleBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointTupleBuilder";
  constructor(name) {
    super(name, "array", "PgPointTuple");
  }
  build(table) {
    return new PgPointTuple(table, this.config);
  }
}

class PgPointTuple extends PgColumn {
  static [entityKind] = "PgPointTuple";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x, y] = value.slice(1, -1).split(",");
      return [Number.parseFloat(x), Number.parseFloat(y)];
    }
    return [value.x, value.y];
  }
  mapToDriverValue(value) {
    return `(${value[0]},${value[1]})`;
  }
}

class PgPointObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointObjectBuilder";
  constructor(name) {
    super(name, "json", "PgPointObject");
  }
  build(table) {
    return new PgPointObject(table, this.config);
  }
}

class PgPointObject extends PgColumn {
  static [entityKind] = "PgPointObject";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x, y] = value.slice(1, -1).split(",");
      return { x: Number.parseFloat(x), y: Number.parseFloat(y) };
    }
    return value;
  }
  mapToDriverValue(value) {
    return `(${value.x},${value.y})`;
  }
}
function point(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgPointTupleBuilder(name);
  }
  return new PgPointObjectBuilder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex) {
  const bytes = [];
  for (let c = 0;c < hex.length; c += 2) {
    bytes.push(Number.parseInt(hex.slice(c, c + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  for (let i = 0;i < 8; i++) {
    view.setUint8(i, bytes[offset + i]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex) {
  const bytes = hexToBytes(hex);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x = bytesToFloat64(bytes, offset);
    offset += 8;
    const y = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x, y];
  }
  throw new Error("Unsupported geometry type");
}

// ../../node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
class PgGeometryBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryBuilder";
  constructor(name) {
    super(name, "array", "PgGeometry");
  }
  build(table) {
    return new PgGeometry(table, this.config);
  }
}

class PgGeometry extends PgColumn {
  static [entityKind] = "PgGeometry";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    return parseEWKB(value);
  }
  mapToDriverValue(value) {
    return `point(${value[0]} ${value[1]})`;
  }
}

class PgGeometryObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryObjectBuilder";
  constructor(name) {
    super(name, "json", "PgGeometryObject");
  }
  build(table) {
    return new PgGeometryObject(table, this.config);
  }
}

class PgGeometryObject extends PgColumn {
  static [entityKind] = "PgGeometryObject";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    const parsed = parseEWKB(value);
    return { x: parsed[0], y: parsed[1] };
  }
  mapToDriverValue(value) {
    return `point(${value.x} ${value.y})`;
  }
}
function geometry(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgGeometryBuilder(name);
  }
  return new PgGeometryObjectBuilder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/real.js
class PgRealBuilder extends PgColumnBuilder {
  static [entityKind] = "PgRealBuilder";
  constructor(name, length) {
    super(name, "number", "PgReal");
    this.config.length = length;
  }
  build(table) {
    return new PgReal(table, this.config);
  }
}

class PgReal extends PgColumn {
  static [entityKind] = "PgReal";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "real";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  };
}
function real(name) {
  return new PgRealBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/serial.js
class PgSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSerial(table, this.config);
  }
}

class PgSerial extends PgColumn {
  static [entityKind] = "PgSerial";
  getSQLType() {
    return "serial";
  }
}
function serial(name) {
  return new PgSerialBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/smallint.js
class PgSmallIntBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgSmallIntBuilder";
  constructor(name) {
    super(name, "number", "PgSmallInt");
  }
  build(table) {
    return new PgSmallInt(table, this.config);
  }
}

class PgSmallInt extends PgColumn {
  static [entityKind] = "PgSmallInt";
  getSQLType() {
    return "smallint";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  };
}
function smallint(name) {
  return new PgSmallIntBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/smallserial.js
class PgSmallSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSmallSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSmallSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSmallSerial(table, this.config);
  }
}

class PgSmallSerial extends PgColumn {
  static [entityKind] = "PgSmallSerial";
  getSQLType() {
    return "smallserial";
  }
}
function smallserial(name) {
  return new PgSmallSerialBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/text.js
class PgTextBuilder extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name, config) {
    super(name, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgText(table, this.config);
  }
}

class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}
function text(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgTextBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/time.js
class PgTimeBuilder extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  static [entityKind] = "PgTimeBuilder";
  build(table) {
    return new PgTime(table, this.config);
  }
}

class PgTime extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function time(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);
}

// ../../node_modules/drizzle-orm/pg-core/columns/timestamp.js
class PgTimestampBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestamp(table, this.config);
  }
}

class PgTimestamp extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return value.toISOString();
  };
}

class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestampString(table, this.config);
  }
}

class PgTimestampString extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function timestamp(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config?.withTimezone ?? false, config?.precision);
}

// ../../node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUIDBuilder extends PgColumnBuilder {
  static [entityKind] = "PgUUIDBuilder";
  constructor(name) {
    super(name, "string", "PgUUID");
  }
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  build(table) {
    return new PgUUID(table, this.config);
  }
}

class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}
function uuid(name) {
  return new PgUUIDBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/varchar.js
class PgVarcharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVarcharBuilder";
  constructor(name, config) {
    super(name, "string", "PgVarchar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgVarchar(table, this.config);
  }
}

class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}
function varchar(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgVarcharBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
class PgBinaryVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBinaryVectorBuilder";
  constructor(name, config) {
    super(name, "string", "PgBinaryVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgBinaryVector(table, this.config);
  }
}

class PgBinaryVector extends PgColumn {
  static [entityKind] = "PgBinaryVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `bit(${this.dimensions})`;
  }
}
function bit(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgBinaryVectorBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
class PgHalfVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgHalfVectorBuilder";
  constructor(name, config) {
    super(name, "array", "PgHalfVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgHalfVector(table, this.config);
  }
}

class PgHalfVector extends PgColumn {
  static [entityKind] = "PgHalfVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `halfvec(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function halfvec(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgHalfVectorBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
class PgSparseVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSparseVectorBuilder";
  constructor(name, config) {
    super(name, "string", "PgSparseVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgSparseVector(table, this.config);
  }
}

class PgSparseVector extends PgColumn {
  static [entityKind] = "PgSparseVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `sparsevec(${this.dimensions})`;
  }
}
function sparsevec(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgSparseVectorBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
class PgVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVectorBuilder";
  constructor(name, config) {
    super(name, "array", "PgVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgVector(table, this.config);
  }
}

class PgVector extends PgColumn {
  static [entityKind] = "PgVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `vector(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function vector(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgVectorBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/all.js
function getPgColumnBuilders() {
  return {
    bigint,
    bigserial,
    boolean,
    char,
    cidr,
    customType,
    date,
    doublePrecision,
    inet,
    integer,
    interval,
    json,
    jsonb,
    line,
    macaddr,
    macaddr8,
    numeric,
    point,
    geometry,
    real,
    serial,
    smallint,
    smallserial,
    text,
    time,
    timestamp,
    uuid,
    varchar,
    bit,
    halfvec,
    sparsevec,
    vector
  };
}

// ../../node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var EnableRLS = Symbol.for("drizzle:EnableRLS");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys,
    EnableRLS
  });
  [InlineForeignKeys] = [];
  [EnableRLS] = false;
  [Table.Symbol.ExtraConfigBuilder] = undefined;
  [Table.Symbol.ExtraConfigColumns] = {};
}
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getPgColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name2, column];
  }));
  const builtColumnsForExtraConfig = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.buildExtraConfigColumn(rawTable);
    return [name2, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return Object.assign(table, {
    enableRLS: () => {
      table[PgTable.Symbol.EnableRLS] = true;
      return table;
    }
  });
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, undefined);
};

// ../../node_modules/drizzle-orm/pg-core/checks.js
class CheckBuilder {
  constructor(name, value) {
    this.name = name;
    this.value = value;
  }
  static [entityKind] = "PgCheckBuilder";
  brand;
  build(table) {
    return new Check(table, this);
  }
}

class Check {
  constructor(table, builder) {
    this.table = table;
    this.name = builder.name;
    this.value = builder.value;
  }
  static [entityKind] = "PgCheck";
  name;
  value;
}
function check(name, value) {
  return new CheckBuilder(name, value);
}

// ../../node_modules/drizzle-orm/pg-core/indexes.js
class IndexBuilderOn {
  constructor(unique2, name) {
    this.unique = unique2;
    this.name = name;
  }
  static [entityKind] = "PgIndexBuilderOn";
  on(...columns) {
    return new IndexBuilder(columns.map((it) => {
      if (is(it, SQL)) {
        return it;
      }
      it = it;
      const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
      it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
      return clonedIndexedColumn;
    }), this.unique, false, this.name);
  }
  onOnly(...columns) {
    return new IndexBuilder(columns.map((it) => {
      if (is(it, SQL)) {
        return it;
      }
      it = it;
      const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
      it.indexConfig = it.defaultConfig;
      return clonedIndexedColumn;
    }), this.unique, true, this.name);
  }
  using(method, ...columns) {
    return new IndexBuilder(columns.map((it) => {
      if (is(it, SQL)) {
        return it;
      }
      it = it;
      const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
      it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
      return clonedIndexedColumn;
    }), this.unique, true, this.name, method);
  }
}

class IndexBuilder {
  static [entityKind] = "PgIndexBuilder";
  config;
  constructor(columns, unique2, only, name, method = "btree") {
    this.config = {
      name,
      columns,
      unique: unique2,
      only,
      method
    };
  }
  concurrently() {
    this.config.concurrently = true;
    return this;
  }
  with(obj) {
    this.config.with = obj;
    return this;
  }
  where(condition) {
    this.config.where = condition;
    return this;
  }
  build(table) {
    return new Index(this.config, table);
  }
}

class Index {
  static [entityKind] = "PgIndex";
  config;
  constructor(config, table) {
    this.config = { ...config, table };
  }
}
function index(name) {
  return new IndexBuilderOn(false, name);
}

// ../../node_modules/drizzle-orm/pg-core/primary-keys.js
function primaryKey(...config) {
  if (config[0].columns) {
    return new PrimaryKeyBuilder(config[0].columns, config[0].name);
  }
  return new PrimaryKeyBuilder(config);
}

class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// ../../node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i) => {
    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}

class CasingCache {
  static [entityKind] = "CasingCache";
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName)
      return column.name;
    const schema = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table) {
    const schema = table[Table.Symbol.Schema] ?? "public";
    const tableName = table[Table.Symbol.OriginalName];
    const tableKey = `${schema}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
}

// ../../node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class DrizzleQueryError extends Error {
  constructor(query, params, cause) {
    super(`Failed query: ${query}
params: ${params}`);
    this.query = query;
    this.params = params;
    this.cause = cause;
    Error.captureStackTrace(this, DrizzleQueryError);
    if (cause)
      this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// ../../node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// ../../node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// ../../node_modules/drizzle-orm/relations.js
class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table, config) {
    this.table = table;
    this.config = config;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey2;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey2) {
            tableConfig.primaryKey.push(...primaryKey2);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey: primaryKey2
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table, relations2) {
  return new Relations(table, (helpers) => Object.fromEntries(Object.entries(relations2(helpers)).map(([key, value]) => [
    key,
    value.withFieldName(key)
  ])));
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(sourceTable, table, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

// ../../node_modules/drizzle-orm/sql/functions/aggregate.js
function count(expression) {
  return sql`count(${expression || sql.raw("*")})`.mapWith(Number);
}

// ../../node_modules/drizzle-orm/sql/functions/vector.js
function toSql(value) {
  return JSON.stringify(value);
}
function cosineDistance(column, value) {
  if (Array.isArray(value)) {
    return sql`${column} <=> ${toSql(value)}`;
  }
  return sql`${column} <=> ${value}`;
}

// ../../node_modules/drizzle-orm/pg-core/view-base.js
class PgViewBase extends View {
  static [entityKind] = "PgViewBase";
}

// ../../node_modules/drizzle-orm/pg-core/dialect.js
class PgDialect {
  static [entityKind] = "PgDialect";
  casing;
  constructor(config) {
    this.casing = new CasingCache(config?.casing);
  }
  async migrate(migrations, session, config) {
    const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config === "string" ? "drizzle" : config.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return;
    const withSqlChunks = [sql`with `];
    for (const [i, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
      if (i < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set) {
    const tableColumns = table[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter((colName) => set[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined);
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i) => {
      const col = tableColumns[colName];
      const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
      if (i < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set, where, returning, withList, from, joins }) {
    const withSql = this.buildWithCTE(withList);
    const tableName = table[PgTable.Symbol.Name];
    const tableSchema = table[PgTable.Symbol.Schema];
    const origTableName = table[PgTable.Symbol.OriginalName];
    const alias = tableName === origTableName ? undefined : tableName;
    const tableSql = sql`${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}`;
    const setSql = this.buildUpdateSet(table, set);
    const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
    const joinsSql = this.buildJoins(joins);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: !from })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}update ${tableSql} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c) => {
            if (is(c, PgColumn)) {
              return sql.identifier(this.casing.getColumnCasing(c));
            }
            return c;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
        } else {
          chunk.push(field);
        }
      }
      if (i < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildJoins(joins) {
    if (!joins || joins.length === 0) {
      return;
    }
    const joinsArray = [];
    for (const [index2, joinMeta] of joins.entries()) {
      if (index2 === 0) {
        joinsArray.push(sql` `);
      }
      const table = joinMeta.table;
      const lateralSql = joinMeta.lateral ? sql` lateral` : undefined;
      const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : undefined;
      if (is(table, PgTable)) {
        const tableName = table[PgTable.Symbol.Name];
        const tableSchema = table[PgTable.Symbol.Schema];
        const origTableName = table[PgTable.Symbol.OriginalName];
        const alias = tableName === origTableName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else if (is(table, View)) {
        const viewName = table[ViewBaseConfig].name;
        const viewSchema = table[ViewBaseConfig].schema;
        const origViewName = table[ViewBaseConfig].originalName;
        const alias = viewName === origViewName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else {
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table}${onSql}`);
      }
      if (index2 < joins.length - 1) {
        joinsArray.push(sql` `);
      }
    }
    return sql.join(joinsArray);
  }
  buildFromTable(table) {
    if (is(table, Table) && table[Table.Symbol.IsAlias]) {
      let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
      if (table[Table.Symbol.Schema]) {
        fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
      }
      return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
    }
    return table;
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = this.buildFromTable(table);
    const joinsSql = this.buildJoins(joins);
    const whereSql = where ? sql` where ${where}` : undefined;
    const havingSql = having ? sql` having ${having}` : undefined;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(sql` of ${sql.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql`, `)}`);
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` nowait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i = 0;i < singleOrderBy.queryChunks.length; i++) {
            const chunk = singleOrderBy.queryChunks[i];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select, overridingSystemValue_ }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
    if (select) {
      const select2 = valuesOrSelect;
      if (is(select2, SQL)) {
        valuesSqlList.push(select2);
      } else {
        valuesSqlList.push(select2.getSQL());
      }
    } else {
      const values = valuesOrSelect;
      valuesSqlList.push(sql.raw("values "));
      for (const [valueIndex, value] of values.entries()) {
        const valueList = [];
        for (const [fieldName, col] of colEntries) {
          const colValue = value[fieldName];
          if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
            if (col.defaultFn !== undefined) {
              const defaultFnResult = col.defaultFn();
              const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
              valueList.push(defaultValue);
            } else if (!col.default && col.onUpdateFn !== undefined) {
              const onUpdateFnResult = col.onUpdateFn();
              const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
              valueList.push(newValue);
            } else {
              valueList.push(sql`default`);
            }
          } else {
            valueList.push(colValue);
          }
        }
        valuesSqlList.push(valueList);
        if (valueIndex < values.length - 1) {
          valuesSqlList.push(sql`, `);
        }
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;
    const overridingSql = overridingSystemValue_ === true ? sql`overriding system value ` : undefined;
    return sql`${withSql}insert into ${table} ${insertOrder} ${overridingSql}${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : undefined;
    const withNoDataSql = withNoData ? sql` with no data` : undefined;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder) {
    if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
      return "json";
    } else if (is(encoder, PgNumeric)) {
      return "decimal";
    } else if (is(encoder, PgTime)) {
      return "time";
    } else if (is(encoder, PgTimestamp) || is(encoder, PgTimestampString)) {
      return "timestamp";
    } else if (is(encoder, PgDate) || is(encoder, PgDateString)) {
      return "date";
    } else if (is(encoder, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql2, invokeSource) {
    return sql2.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping,
      invokeSource
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

// ../../node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/select.js
class PgSelectBuilder {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    const src = source;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(src, Subquery)) {
      fields = Object.fromEntries(Object.keys(src._.selectedFields).map((key) => [key, src[key]]));
    } else if (is(src, PgViewBase)) {
      fields = src[ViewBaseConfig].selectedFields;
    } else if (is(src, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(src);
    }
    return new PgSelectBase({
      table: src,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    }).setToken(this.authToken);
  }
}

class PgSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  cacheConfig = undefined;
  usedTables = /* @__PURE__ */ new Set;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields,
      config: this.config
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
    for (const item of extractUsedTable(table))
      this.usedTables.add(item);
  }
  getUsedTables() {
    return [...this.usedTables];
  }
  createJoin(joinType, lateral) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      for (const item of extractUsedTable(table))
        this.usedTables.add(item);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName, lateral });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "cross":
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left", false);
  leftJoinLateral = this.createJoin("left", true);
  rightJoin = this.createJoin("right", false);
  innerJoin = this.createJoin("inner", false);
  innerJoinLateral = this.createJoin("inner", true);
  fullJoin = this.createJoin("full", false);
  crossJoin = this.createJoin("cross", false);
  crossJoinLateral = this.createJoin("cross", true);
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  intersectAll = this.createSetOperator("intersect", true);
  except = this.createSetOperator("except", false);
  exceptAll = this.createSetOperator("except", true);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    const usedTables = [];
    usedTables.push(...extractUsedTable(this.config.table));
    if (this.config.joins) {
      for (const it of this.config.joins)
        usedTables.push(...extractUsedTable(it.table));
    }
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
  $withCache(config) {
    this.cacheConfig = config === undefined ? { config: {}, enable: true, autoInvalidate: true } : config === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config };
    return this;
  }
}

class PgSelectBase extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  _prepare(name) {
    const { session, config, dialect, joinsNotNullableMap, authToken, cacheConfig, usedTables } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const { fields } = config;
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true, undefined, {
        type: "select",
        tables: [...usedTables]
      }, cacheConfig);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query.setToken(authToken);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// ../../node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect) {
    this.dialect = is(dialect, PgDialect) ? dialect : undefined;
    this.dialectConfig = is(dialect, PgDialect) ? undefined : dialect;
  }
  $with = (alias, selection) => {
    const queryBuilder = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(queryBuilder);
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  with(...queries) {
    const self = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        distinct: { on }
      });
    }
    return { select, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect(this.dialectConfig);
    }
    return this.dialect;
  }
}

// ../../node_modules/drizzle-orm/pg-core/utils.js
function extractUsedTable(table) {
  if (is(table, PgTable)) {
    return [table[Schema] ? `${table[Schema]}.${table[Table.Symbol.BaseName]}` : table[Table.Symbol.BaseName]];
  }
  if (is(table, Subquery)) {
    return table._.usedTables ?? [];
  }
  if (is(table, SQL)) {
    return table.usedTables ?? [];
  }
  return [];
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/delete.js
class PgDeleteBase extends QueryPromise {
  constructor(table, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, withList };
  }
  static [entityKind] = "PgDelete";
  config;
  cacheConfig;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
        type: "delete",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/insert.js
class PgInsertBuilder {
  constructor(table, session, dialect, withList, overridingSystemValue_) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
    this.overridingSystemValue_ = overridingSystemValue_;
  }
  static [entityKind] = "PgInsertBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  overridingSystemValue() {
    this.overridingSystemValue_ = true;
    return this;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList, false, this.overridingSystemValue_).setToken(this.authToken);
  }
  select(selectQuery) {
    const select = typeof selectQuery === "function" ? selectQuery(new QueryBuilder) : selectQuery;
    if (!is(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {
      throw new Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");
    }
    return new PgInsertBase(this.table, select, this.session, this.dialect, this.withList, true);
  }
}

class PgInsertBase extends QueryPromise {
  constructor(table, values, session, dialect, withList, select, overridingSystemValue_) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values, withList, select, overridingSystemValue_ };
  }
  static [entityKind] = "PgInsert";
  config;
  cacheConfig;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config = {}) {
    if (config.target === undefined) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
      const whereSql = config.where ? sql` where ${config.where}` : undefined;
      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
    }
    return this;
  }
  onConflictDoUpdate(config) {
    if (config.where && (config.targetWhere || config.setWhere)) {
      throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');
    }
    const whereSql = config.where ? sql` where ${config.where}` : undefined;
    const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : undefined;
    const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : undefined;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
        type: "insert",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
class PgRefreshMaterializedView extends QueryPromise {
  constructor(view, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/update.js
class PgUpdateBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "PgUpdateBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  set(values) {
    return new PgUpdateBase(this.table, mapUpdateSet(this.table, values), this.session, this.dialect, this.withList).setToken(this.authToken);
  }
}

class PgUpdateBase extends QueryPromise {
  constructor(table, set, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set, table, withList, joins: [] };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  static [entityKind] = "PgUpdate";
  config;
  tableName;
  joinsNotNullableMap;
  cacheConfig;
  from(source) {
    const src = source;
    const tableName = getTableLikeName(src);
    if (typeof tableName === "string") {
      this.joinsNotNullableMap[tableName] = true;
    }
    this.config.from = src;
    return this;
  }
  getTableLikeFields(table) {
    if (is(table, PgTable)) {
      return table[Table.Symbol.Columns];
    } else if (is(table, Subquery)) {
      return table._.selectedFields;
    }
    return table[ViewBaseConfig].selectedFields;
  }
  createJoin(joinType) {
    return (table, on) => {
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (typeof on === "function") {
        const from = this.config.from && !is(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : undefined;
        on = on(new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })), from && new Proxy(from, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields) {
    if (!fields) {
      fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);
      if (this.config.from) {
        const tableName = getTableLikeName(this.config.from);
        if (typeof tableName === "string" && this.config.from && !is(this.config.from, SQL)) {
          const fromFields = this.getTableLikeFields(this.config.from);
          fields[tableName] = fromFields;
        }
        for (const join of this.config.joins) {
          const tableName2 = getTableLikeName(join.table);
          if (typeof tableName2 === "string" && !is(join.table, SQL)) {
            const fromFields = this.getTableLikeFields(join.table);
            fields[tableName2] = fromFields;
          }
        }
      }
    }
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
      type: "insert",
      tables: extractUsedTable(this.config.table)
    }, this.cacheConfig);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues, this.authToken);
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/count.js
class PgCountBuilder extends SQL {
  constructor(params) {
    super(PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.mapWith(Number);
    this.session = params.session;
    this.sql = PgCountBuilder.buildCount(params.source, params.filters);
  }
  sql;
  token;
  static [entityKind] = "PgCountBuilder";
  [Symbol.toStringTag] = "PgCountBuilder";
  session;
  static buildEmbeddedCount(source, filters) {
    return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source, filters) {
    return sql`select count(*) as count from ${source}${sql.raw(" where ").if(filters)}${filters};`;
  }
  setToken(token) {
    this.token = token;
    return this;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql, this.token)).then(onfulfilled, onrejected);
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
  }
  findFirst(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
  }
}

class PgRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(builtQuery, undefined, name, true, (rawRows, mapColumnValue) => {
        const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      });
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(undefined, this.authToken);
    });
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/raw.js
class PgRaw extends QueryPromise {
  constructor(execute, sql2, query, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql2;
    this.query = query;
    this.mapBatchResult = mapBatchResult;
  }
  static [entityKind] = "PgRaw";
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  isResponseInArrayMode() {
    return false;
  }
}

// ../../node_modules/drizzle-orm/pg-core/db.js
class PgDatabase {
  constructor(dialect, session, schema) {
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap,
      session
    } : {
      schema: undefined,
      fullSchema: {},
      tableNamesMap: {},
      session
    };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
      }
    }
    this.$cache = { invalidate: async (_params) => {} };
  }
  static [entityKind] = "PgDatabase";
  query;
  $with = (alias, selection) => {
    const self = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(new QueryBuilder(self.dialect));
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  $count(source, filters) {
    return new PgCountBuilder({ source, filters, session: this.session });
  }
  $cache;
  with(...queries) {
    const self = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries,
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries,
        distinct: { on }
      });
    }
    function update(table) {
      return new PgUpdateBuilder(table, self.session, self.dialect, queries);
    }
    function insert(table) {
      return new PgInsertBuilder(table, self.session, self.dialect, queries);
    }
    function delete_(table) {
      return new PgDeleteBase(table, self.session, self.dialect, queries);
    }
    return { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  authToken;
  execute(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sequel);
    const prepared = this.session.prepareQuery(builtQuery, undefined, undefined, false);
    return new PgRaw(() => prepared.execute(undefined, this.authToken), sequel, builtQuery, (result) => prepared.mapResult(result, true));
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}

// ../../node_modules/drizzle-orm/cache/core/cache.js
class Cache {
  static [entityKind] = "Cache";
}

class NoopCache extends Cache {
  strategy() {
    return "all";
  }
  static [entityKind] = "NoopCache";
  async get(_key) {
    return;
  }
  async put(_hashedQuery, _response, _tables, _config) {}
  async onMutate(_params) {}
}
async function hashQuery(sql2, params) {
  const dataToHash = `${sql2}-${JSON.stringify(params)}`;
  const encoder = new TextEncoder;
  const data = encoder.encode(dataToHash);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = [...new Uint8Array(hashBuffer)];
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}

// ../../node_modules/drizzle-orm/pg-core/session.js
class PgPreparedQuery {
  constructor(query, cache, queryMetadata, cacheConfig) {
    this.query = query;
    this.cache = cache;
    this.queryMetadata = queryMetadata;
    this.cacheConfig = cacheConfig;
    if (cache && cache.strategy() === "all" && cacheConfig === undefined) {
      this.cacheConfig = { enable: true, autoInvalidate: true };
    }
    if (!this.cacheConfig?.enable) {
      this.cacheConfig = undefined;
    }
  }
  authToken;
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  setToken(token) {
    this.authToken = token;
    return this;
  }
  static [entityKind] = "PgPreparedQuery";
  joinsNotNullableMap;
  async queryWithCache(queryString, params, query) {
    if (this.cache === undefined || is(this.cache, NoopCache) || this.queryMetadata === undefined) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.cacheConfig && !this.cacheConfig.enable) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if ((this.queryMetadata.type === "insert" || this.queryMetadata.type === "update" || this.queryMetadata.type === "delete") && this.queryMetadata.tables.length > 0) {
      try {
        const [res] = await Promise.all([
          query(),
          this.cache.onMutate({ tables: this.queryMetadata.tables })
        ]);
        return res;
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (!this.cacheConfig) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.queryMetadata.type === "select") {
      const fromCache = await this.cache.get(this.cacheConfig.tag ?? await hashQuery(queryString, params), this.queryMetadata.tables, this.cacheConfig.tag !== undefined, this.cacheConfig.autoInvalidate);
      if (fromCache === undefined) {
        let result;
        try {
          result = await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
        await this.cache.put(this.cacheConfig.tag ?? await hashQuery(queryString, params), result, this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [], this.cacheConfig.tag !== undefined, this.cacheConfig.config);
        return result;
      }
      return fromCache;
    }
    try {
      return await query();
    } catch (e) {
      throw new DrizzleQueryError(queryString, params, e);
    }
  }
}

class PgSession {
  constructor(dialect) {
    this.dialect = dialect;
  }
  static [entityKind] = "PgSession";
  execute(query, token) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false);
      });
      return prepared.setToken(token).execute(undefined, token);
    });
  }
  all(query) {
    return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false).all();
  }
  async count(sql2, token) {
    const res = await this.execute(sql2, token);
    return Number(res[0]["count"]);
  }
}

class PgTransaction extends PgDatabase {
  constructor(dialect, session, schema, nestedIndex = 0) {
    super(dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
  getTransactionConfigSQL(config) {
    const chunks = [];
    if (config.isolationLevel) {
      chunks.push(`isolation level ${config.isolationLevel}`);
    }
    if (config.accessMode) {
      chunks.push(config.accessMode);
    }
    if (typeof config.deferrable === "boolean") {
      chunks.push(config.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);
  }
}

// ../../node_modules/drizzle-orm/pglite/session.js
import { types } from "@electric-sql/pglite";
class PglitePreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger, cache, queryMetadata, cacheConfig, fields, name, _isResponseInArrayMode, customResultMapper) {
    super({ sql: queryString, params }, cache, queryMetadata, cacheConfig);
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.rawQueryConfig = {
      rowMode: "object",
      parsers: {
        [types.TIMESTAMP]: (value) => value,
        [types.TIMESTAMPTZ]: (value) => value,
        [types.INTERVAL]: (value) => value,
        [types.DATE]: (value) => value,
        [1231]: (value) => value,
        [1115]: (value) => value,
        [1185]: (value) => value,
        [1187]: (value) => value,
        [1182]: (value) => value
      }
    };
    this.queryConfig = {
      rowMode: "array",
      parsers: {
        [types.TIMESTAMP]: (value) => value,
        [types.TIMESTAMPTZ]: (value) => value,
        [types.INTERVAL]: (value) => value,
        [types.DATE]: (value) => value,
        [1231]: (value) => value,
        [1115]: (value) => value,
        [1185]: (value) => value,
        [1187]: (value) => value,
        [1182]: (value) => value
      }
    };
  }
  static [entityKind] = "PglitePreparedQuery";
  rawQueryConfig;
  queryConfig;
  async execute(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.queryString, params);
    const { fields, client, queryConfig, joinsNotNullableMap, customResultMapper, queryString, rawQueryConfig } = this;
    if (!fields && !customResultMapper) {
      return this.queryWithCache(queryString, params, async () => {
        return await client.query(queryString, params, rawQueryConfig);
      });
    }
    const result = await this.queryWithCache(queryString, params, async () => {
      return await client.query(queryString, params, queryConfig);
    });
    return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
  }
  all(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.queryString, params);
    return this.queryWithCache(this.queryString, params, async () => {
      return await this.client.query(this.queryString, params, this.rawQueryConfig);
    }).then((result) => result.rows);
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

class PgliteSession extends PgSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
    this.cache = options.cache ?? new NoopCache;
  }
  static [entityKind] = "PgliteSession";
  logger;
  cache;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return new PglitePreparedQuery(this.client, query.sql, query.params, this.logger, this.cache, queryMetadata, cacheConfig, fields, name, isResponseInArrayMode, customResultMapper);
  }
  async transaction(transaction, config) {
    return this.client.transaction(async (client) => {
      const session = new PgliteSession(client, this.dialect, this.schema, this.options);
      const tx = new PgliteTransaction(this.dialect, session, this.schema);
      if (config) {
        await tx.setTransaction(config);
      }
      return transaction(tx);
    });
  }
  async count(sql2) {
    const res = await this.execute(sql2);
    return Number(res["rows"][0]["count"]);
  }
}

class PgliteTransaction extends PgTransaction {
  static [entityKind] = "PgliteTransaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex + 1}`;
    const tx = new PgliteTransaction(this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await tx.execute(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await tx.execute(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
}

// ../../node_modules/drizzle-orm/pglite/driver.js
class PgliteDriver {
  constructor(client, dialect, options = {}) {
    this.client = client;
    this.dialect = dialect;
    this.options = options;
  }
  static [entityKind] = "PgliteDriver";
  createSession(schema) {
    return new PgliteSession(this.client, this.dialect, schema, {
      logger: this.options.logger,
      cache: this.options.cache
    });
  }
}

class PgliteDatabase extends PgDatabase {
  static [entityKind] = "PgliteDatabase";
}
function construct(client, config = {}) {
  const dialect = new PgDialect({ casing: config.casing });
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger;
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new PgliteDriver(client, dialect, { logger, cache: config.cache });
  const session = driver.createSession(schema);
  const db = new PgliteDatabase(dialect, session, schema);
  db.$client = client;
  db.$cache = config.cache;
  if (db.$cache) {
    db.$cache["invalidate"] = config.cache?.onMutate;
  }
  return db;
}
function drizzle(...params) {
  if (params[0] === undefined || typeof params[0] === "string") {
    const instance = new PGlite(params[0]);
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client)
      return construct(client, drizzleConfig);
    if (typeof connection === "object") {
      const { dataDir, ...options } = connection;
      const instance2 = new PGlite(dataDir, options);
      return construct(instance2, drizzleConfig);
    }
    const instance = new PGlite(connection);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config) {
    return construct({}, config);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// src/base.ts
import {
  ChannelType,
  DatabaseAdapter,
  logger
} from "@elizaos/core";
import { v4 } from "uuid";

// src/schema/embedding.ts
import { VECTOR_DIMS } from "@elizaos/core";

// src/schema/agent.ts
var agentTable = pgTable("agents", {
  id: uuid("id").primaryKey().defaultRandom(),
  enabled: boolean("enabled").default(true).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).default(sql`now()`).notNull(),
  name: text("name").notNull(),
  username: text("username"),
  system: text("system").default(""),
  bio: jsonb("bio").$type().default(sql`'[]'::jsonb`),
  messageExamples: jsonb("message_examples").$type().default(sql`'[]'::jsonb`).notNull(),
  postExamples: jsonb("post_examples").$type().default(sql`'[]'::jsonb`).notNull(),
  topics: jsonb("topics").$type().default(sql`'[]'::jsonb`).notNull(),
  adjectives: jsonb("adjectives").$type().default(sql`'[]'::jsonb`).notNull(),
  knowledge: jsonb("knowledge").$type().default(sql`'[]'::jsonb`).notNull(),
  plugins: jsonb("plugins").$type().default(sql`'[]'::jsonb`).notNull(),
  settings: jsonb("settings").$type().default(sql`'{}'::jsonb`).notNull(),
  style: jsonb("style").$type().default(sql`'{}'::jsonb`).notNull()
}, (table) => {
  return {
    nameUnique: unique("name_unique").on(table.name)
  };
});

// src/schema/entity.ts
var entityTable = pgTable("entities", {
  id: uuid("id").notNull().primaryKey(),
  agentId: uuid("agent_id").notNull().references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  createdAt: timestamp("created_at").default(sql`now()`).notNull(),
  names: text("names").array().default(sql`'{}'::text[]`).notNull(),
  metadata: jsonb("metadata").default(sql`'{}'::jsonb`).notNull()
}, (table) => {
  return {
    idAgentIdUnique: unique("id_agent_id_unique").on(table.id, table.agentId)
  };
});

// src/schema/room.ts
var roomTable = pgTable("rooms", {
  id: uuid("id").notNull().primaryKey().default(sql`gen_random_uuid()`),
  agentId: uuid("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  source: text("source").notNull(),
  type: text("type").notNull(),
  serverId: text("serverId"),
  worldId: uuid("worldId"),
  name: text("name"),
  metadata: jsonb("metadata"),
  channelId: text("channelId"),
  createdAt: timestamp("createdAt").default(sql`now()`).notNull()
});

// src/schema/memory.ts
var memoryTable = pgTable("memories", {
  id: uuid("id").primaryKey().notNull(),
  type: text("type").notNull(),
  createdAt: timestamp("createdAt").default(sql`now()`).notNull(),
  content: jsonb("content").notNull(),
  entityId: uuid("entityId").references(() => entityTable.id, {
    onDelete: "cascade"
  }),
  agentId: uuid("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }).notNull(),
  roomId: uuid("roomId").references(() => roomTable.id, {
    onDelete: "cascade"
  }),
  worldId: uuid("worldId"),
  unique: boolean("unique").default(true).notNull(),
  metadata: jsonb("metadata").default({}).notNull()
}, (table) => [
  index("idx_memories_type_room").on(table.type, table.roomId),
  index("idx_memories_world_id").on(table.worldId),
  foreignKey({
    name: "fk_room",
    columns: [table.roomId],
    foreignColumns: [roomTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_user",
    columns: [table.entityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_agent",
    columns: [table.agentId],
    foreignColumns: [agentTable.id]
  }).onDelete("cascade"),
  index("idx_memories_metadata_type").on(sql`((metadata->>'type'))`),
  index("idx_memories_document_id").on(sql`((metadata->>'documentId'))`),
  index("idx_fragments_order").on(sql`((metadata->>'documentId'))`, sql`((metadata->>'position'))`),
  check("fragment_metadata_check", sql`
            CASE 
                WHEN metadata->>'type' = 'fragment' THEN
                    metadata ? 'documentId' AND 
                    metadata ? 'position'
                ELSE true
            END
        `),
  check("document_metadata_check", sql`
            CASE 
                WHEN metadata->>'type' = 'document' THEN
                    metadata ? 'timestamp'
                ELSE true
            END
        `)
]);
var memoryRelations = relations(memoryTable, ({ one }) => ({
  embedding: one(embeddingTable)
}));

// src/schema/embedding.ts
var DIMENSION_MAP = {
  [VECTOR_DIMS.SMALL]: "dim384",
  [VECTOR_DIMS.MEDIUM]: "dim512",
  [VECTOR_DIMS.LARGE]: "dim768",
  [VECTOR_DIMS.XL]: "dim1024",
  [VECTOR_DIMS.XXL]: "dim1536",
  [VECTOR_DIMS.XXXL]: "dim3072"
};
var embeddingTable = pgTable("embeddings", {
  id: uuid("id").primaryKey().defaultRandom().notNull(),
  memoryId: uuid("memory_id").references(() => memoryTable.id, { onDelete: "cascade" }),
  createdAt: timestamp("created_at").default(sql`now()`).notNull(),
  dim384: vector("dim_384", { dimensions: VECTOR_DIMS.SMALL }),
  dim512: vector("dim_512", { dimensions: VECTOR_DIMS.MEDIUM }),
  dim768: vector("dim_768", { dimensions: VECTOR_DIMS.LARGE }),
  dim1024: vector("dim_1024", { dimensions: VECTOR_DIMS.XL }),
  dim1536: vector("dim_1536", { dimensions: VECTOR_DIMS.XXL }),
  dim3072: vector("dim_3072", { dimensions: VECTOR_DIMS.XXXL })
}, (table) => [
  check("embedding_source_check", sql`"memory_id" IS NOT NULL`),
  index("idx_embedding_memory").on(table.memoryId),
  foreignKey({
    name: "fk_embedding_memory",
    columns: [table.memoryId],
    foreignColumns: [memoryTable.id]
  }).onDelete("cascade")
]);

// src/schema/index.ts
var exports_schema = {};
__export(exports_schema, {
  worldTable: () => worldTable,
  taskTable: () => taskTable,
  serverAgentsTable: () => serverAgentsTable,
  roomTable: () => roomTable,
  relationshipTable: () => relationshipTable,
  participantTable: () => participantTable,
  messageTable: () => messageTable,
  messageServerTable: () => messageServerTable,
  memoryTable: () => memoryTable,
  logTable: () => logTable,
  entityTable: () => entityTable,
  embeddingTable: () => embeddingTable,
  componentTable: () => componentTable,
  channelTable: () => channelTable,
  channelParticipantsTable: () => channelParticipantsTable,
  cacheTable: () => cacheTable,
  agentTable: () => agentTable
});

// src/schema/cache.ts
var cacheTable = pgTable("cache", {
  key: text("key").notNull(),
  agentId: uuid("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  value: jsonb("value").notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  expiresAt: timestamp("expires_at", { withTimezone: true })
}, (table) => ({
  pk: primaryKey({ columns: [table.key, table.agentId] })
}));
// src/schema/world.ts
var worldTable = pgTable("worlds", {
  id: uuid("id").notNull().primaryKey().default(sql`gen_random_uuid()`),
  agentId: uuid("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  metadata: jsonb("metadata"),
  serverId: text("serverId").notNull().default("local"),
  createdAt: timestamp("createdAt").default(sql`now()`).notNull()
});

// src/schema/component.ts
var componentTable = pgTable("components", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`).notNull(),
  entityId: uuid("entityId").references(() => entityTable.id, { onDelete: "cascade" }).notNull(),
  agentId: uuid("agentId").references(() => agentTable.id, { onDelete: "cascade" }).notNull(),
  roomId: uuid("roomId").references(() => roomTable.id, { onDelete: "cascade" }).notNull(),
  worldId: uuid("worldId").references(() => worldTable.id, { onDelete: "cascade" }),
  sourceEntityId: uuid("sourceEntityId").references(() => entityTable.id, { onDelete: "cascade" }),
  type: text("type").notNull(),
  data: jsonb("data").default(sql`'{}'::jsonb`),
  createdAt: timestamp("createdAt").default(sql`now()`).notNull()
});
// src/schema/log.ts
var logTable = pgTable("logs", {
  id: uuid("id").defaultRandom().notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  entityId: uuid("entityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
  body: jsonb("body").notNull(),
  type: text("type").notNull(),
  roomId: uuid("roomId").notNull().references(() => roomTable.id, { onDelete: "cascade" })
}, (table) => [
  foreignKey({
    name: "fk_room",
    columns: [table.roomId],
    foreignColumns: [roomTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_user",
    columns: [table.entityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade")
]);
// src/schema/participant.ts
var participantTable = pgTable("participants", {
  id: uuid("id").notNull().primaryKey().default(sql`gen_random_uuid()`),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  entityId: uuid("entityId").references(() => entityTable.id, {
    onDelete: "cascade"
  }),
  roomId: uuid("roomId").references(() => roomTable.id, {
    onDelete: "cascade"
  }),
  agentId: uuid("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  roomState: text("roomState")
}, (table) => [
  index("idx_participants_user").on(table.entityId),
  index("idx_participants_room").on(table.roomId),
  foreignKey({
    name: "fk_room",
    columns: [table.roomId],
    foreignColumns: [roomTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_user",
    columns: [table.entityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade")
]);
// src/schema/relationship.ts
var relationshipTable = pgTable("relationships", {
  id: uuid("id").notNull().primaryKey().default(sql`gen_random_uuid()`),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  sourceEntityId: uuid("sourceEntityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
  targetEntityId: uuid("targetEntityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
  agentId: uuid("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  tags: text("tags").array(),
  metadata: jsonb("metadata")
}, (table) => [
  index("idx_relationships_users").on(table.sourceEntityId, table.targetEntityId),
  unique("unique_relationship").on(table.sourceEntityId, table.targetEntityId, table.agentId),
  foreignKey({
    name: "fk_user_a",
    columns: [table.sourceEntityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_user_b",
    columns: [table.targetEntityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade")
]);
// src/schema/tasks.ts
var taskTable = pgTable("tasks", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name").notNull(),
  description: text("description"),
  roomId: uuid("roomId"),
  worldId: uuid("worldId"),
  entityId: uuid("entityId"),
  agentId: uuid("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  tags: text("tags").array().default(sql`'{}'::text[]`),
  metadata: jsonb("metadata").default(sql`'{}'::jsonb`),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow()
});
// src/schema/messageServer.ts
var messageServerTable = pgTable("message_servers", {
  id: uuid("id").primaryKey(),
  name: text("name").notNull(),
  sourceType: text("source_type").notNull(),
  sourceId: text("source_id"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp("updated_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull()
});
// src/schema/channel.ts
var channelTable = pgTable("channels", {
  id: text("id").primaryKey(),
  messageServerId: uuid("server_id").notNull().references(() => messageServerTable.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  type: text("type").notNull(),
  sourceType: text("source_type"),
  sourceId: text("source_id"),
  topic: text("topic"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp("updated_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull()
});
// src/schema/message.ts
var messageTable = pgTable("central_messages", {
  id: text("id").primaryKey(),
  channelId: text("channel_id").notNull().references(() => channelTable.id, { onDelete: "cascade" }),
  authorId: text("author_id").notNull(),
  content: text("content").notNull(),
  rawMessage: jsonb("raw_message"),
  inReplyToRootMessageId: text("in_reply_to_root_message_id").references(() => messageTable.id, {
    onDelete: "set null"
  }),
  sourceType: text("source_type"),
  sourceId: text("source_id"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp("updated_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull()
});
// src/schema/channelParticipant.ts
var channelParticipantsTable = pgTable("channel_participants", {
  channelId: text("channel_id").notNull().references(() => channelTable.id, { onDelete: "cascade" }),
  userId: text("user_id").notNull()
}, (table) => ({
  pk: primaryKey({ columns: [table.channelId, table.userId] })
}));
// src/schema/serverAgent.ts
var serverAgentsTable = pgTable("server_agents", {
  serverId: uuid("server_id").notNull().references(() => messageServerTable.id, { onDelete: "cascade" }),
  agentId: uuid("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" })
}, (table) => ({
  pk: primaryKey({ columns: [table.serverId, table.agentId] })
}));
// src/base.ts
class BaseDrizzleAdapter extends DatabaseAdapter {
  maxRetries = 3;
  baseDelay = 1000;
  maxDelay = 1e4;
  jitterMax = 1000;
  embeddingDimension = DIMENSION_MAP[384];
  async initialize() {
    await this.init();
  }
  getDatabase() {
    return this.db;
  }
  agentId;
  constructor(agentId) {
    super();
    this.agentId = agentId;
  }
  async withRetry(operation) {
    let lastError = new Error("Unknown error");
    for (let attempt = 1;attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (attempt < this.maxRetries) {
          const backoffDelay = Math.min(this.baseDelay * 2 ** (attempt - 1), this.maxDelay);
          const jitter = Math.random() * this.jitterMax;
          const delay = backoffDelay + jitter;
          logger.warn(`Database operation failed (attempt ${attempt}/${this.maxRetries}): ${error instanceof Error ? error.message : String(error)}, nextRetryIn: ${(delay / 1000).toFixed(1)}s`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        } else {
          logger.error(`Max retry attempts reached: ${error instanceof Error ? error.message : String(error)}, totalAttempts: ${attempt}`);
          throw error instanceof Error ? error : new Error(String(error));
        }
      }
    }
    throw lastError;
  }
  async ensureEmbeddingDimension(dimension) {
    return this.withDatabase(async () => {
      const existingMemory = await this.db.select().from(memoryTable).innerJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(eq(memoryTable.agentId, this.agentId)).limit(1);
      if (existingMemory.length > 0) {
        Object.entries(DIMENSION_MAP).find(([_, colName]) => existingMemory[0].embeddings[colName] !== null);
      }
      this.embeddingDimension = DIMENSION_MAP[dimension];
    });
  }
  async getAgent(agentId) {
    return this.withDatabase(async () => {
      const rows = await this.db.select().from(agentTable).where(eq(agentTable.id, agentId)).limit(1);
      if (rows.length === 0)
        return null;
      const row = rows[0];
      return {
        ...row,
        username: row.username || "",
        id: row.id,
        system: !row.system ? undefined : row.system,
        bio: !row.bio ? "" : row.bio,
        createdAt: row.createdAt.getTime(),
        updatedAt: row.updatedAt.getTime()
      };
    });
  }
  async getAgents() {
    return this.withDatabase(async () => {
      const rows = await this.db.select({
        id: agentTable.id,
        name: agentTable.name,
        bio: agentTable.bio
      }).from(agentTable);
      return rows.map((row) => ({
        ...row,
        id: row.id,
        bio: row.bio === null ? "" : row.bio
      }));
    });
  }
  async createAgent(agent) {
    return this.withDatabase(async () => {
      try {
        const conditions = [];
        if (agent.id) {
          conditions.push(eq(agentTable.id, agent.id));
        }
        if (agent.name) {
          conditions.push(eq(agentTable.name, agent.name));
        }
        const existing = conditions.length > 0 ? await this.db.select({ id: agentTable.id }).from(agentTable).where(or(...conditions)).limit(1) : [];
        if (existing.length > 0) {
          logger.warn(`Attempted to create an agent with a duplicate ID or name. ID: ${agent.id}, name: ${agent.name}`);
          return false;
        }
        await this.db.transaction(async (tx) => {
          await tx.insert(agentTable).values({
            ...agent,
            createdAt: new Date(agent.createdAt || Date.now()),
            updatedAt: new Date(agent.updatedAt || Date.now())
          });
        });
        logger.debug(`Agent created successfully: ${agent.id}`);
        return true;
      } catch (error) {
        logger.error(`Error creating agent: ${error instanceof Error ? error.message : String(error)}, agentId: ${agent.id}`);
        return false;
      }
    });
  }
  async updateAgent(agentId, agent) {
    return this.withDatabase(async () => {
      try {
        if (!agentId) {
          throw new Error("Agent ID is required for update");
        }
        await this.db.transaction(async (tx) => {
          if (agent?.settings) {
            agent.settings = await this.mergeAgentSettings(tx, agentId, agent.settings);
          }
          const updateData = { ...agent };
          if (updateData.createdAt) {
            if (typeof updateData.createdAt === "number") {
              updateData.createdAt = new Date(updateData.createdAt);
            } else {
              delete updateData.createdAt;
            }
          }
          if (updateData.updatedAt) {
            if (typeof updateData.updatedAt === "number") {
              updateData.updatedAt = new Date(updateData.updatedAt);
            } else {
              updateData.updatedAt = new Date;
            }
          } else {
            updateData.updatedAt = new Date;
          }
          await tx.update(agentTable).set(updateData).where(eq(agentTable.id, agentId));
        });
        logger.debug(`Agent updated successfully: ${agentId}`);
        return true;
      } catch (error) {
        logger.error(`Error updating agent: ${error instanceof Error ? error.message : String(error)}, agentId: ${agentId}`);
        return false;
      }
    });
  }
  async mergeAgentSettings(tx, agentId, updatedSettings) {
    const currentAgent = await tx.select({ settings: agentTable.settings }).from(agentTable).where(eq(agentTable.id, agentId)).limit(1);
    const currentSettings = currentAgent.length > 0 && currentAgent[0].settings ? currentAgent[0].settings : {};
    const deepMerge = (target, source) => {
      if (source === null) {
        return;
      }
      if (Array.isArray(source) || typeof source !== "object") {
        return source;
      }
      const output = typeof target === "object" && target !== null && !Array.isArray(target) ? { ...target } : {};
      for (const key of Object.keys(source)) {
        const sourceValue = source[key];
        if (sourceValue === null) {
          delete output[key];
        } else if (typeof sourceValue === "object" && !Array.isArray(sourceValue)) {
          const nestedMergeResult = deepMerge(output[key], sourceValue);
          if (nestedMergeResult === undefined) {
            delete output[key];
          } else {
            output[key] = nestedMergeResult;
          }
        } else {
          output[key] = sourceValue;
        }
      }
      if (Object.keys(output).length === 0) {
        if (!(typeof source === "object" && source !== null && Object.keys(source).length === 0)) {
          return;
        }
      }
      return output;
    };
    const finalSettings = deepMerge(currentSettings, updatedSettings);
    return finalSettings === undefined ? {} : finalSettings;
  }
  async deleteAgent(agentId) {
    logger.debug(`[DB] Deleting agent with ID: ${agentId}`);
    return this.withDatabase(async () => {
      try {
        const result = await this.db.delete(agentTable).where(eq(agentTable.id, agentId)).returning();
        if (result.length === 0) {
          logger.warn(`[DB] Agent ${agentId} not found`);
          return false;
        }
        logger.success(`[DB] Agent ${agentId} and all related data successfully deleted via cascade`);
        return true;
      } catch (error) {
        logger.error(`[DB] Failed to delete agent ${agentId}: ${error instanceof Error ? error.message : String(error)}`);
        if (error instanceof Error) {
          logger.error(`[DB] Error details: ${error.name} - ${error.message}`);
          logger.error(`[DB] Stack trace: ${error.stack}`);
        }
        throw error;
      }
    });
  }
  async countAgents() {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select({ count: count() }).from(agentTable);
        return result[0]?.count || 0;
      } catch (error) {
        logger.error(`Error counting agents: ${error instanceof Error ? error.message : String(error)}`);
        return 0;
      }
    });
  }
  async cleanupAgents() {
    return this.withDatabase(async () => {
      try {
        await this.db.delete(agentTable);
        logger.success("Successfully cleaned up agent table");
      } catch (error) {
        logger.error(`Error cleaning up agent table: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
      }
    });
  }
  async getEntitiesByIds(entityIds) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        entity: entityTable,
        components: componentTable
      }).from(entityTable).leftJoin(componentTable, eq(componentTable.entityId, entityTable.id)).where(inArray(entityTable.id, entityIds));
      if (result.length === 0)
        return [];
      const entities = {};
      const entityComponents = {};
      for (const e of result) {
        const key = e.entity.id;
        entities[key] = e.entity;
        if (entityComponents[key] === undefined)
          entityComponents[key] = [];
        if (e.components) {
          const componentsArray = Array.isArray(e.components) ? e.components : [e.components];
          entityComponents[key] = [...entityComponents[key], ...componentsArray];
        }
      }
      for (const k of Object.keys(entityComponents)) {
        entities[k].components = entityComponents[k];
      }
      return Object.values(entities);
    });
  }
  async getEntitiesForRoom(roomId, includeComponents) {
    return this.withDatabase(async () => {
      const query = this.db.select({
        entity: entityTable,
        ...includeComponents && { components: componentTable }
      }).from(participantTable).leftJoin(entityTable, and(eq(participantTable.entityId, entityTable.id), eq(entityTable.agentId, this.agentId)));
      if (includeComponents) {
        query.leftJoin(componentTable, eq(componentTable.entityId, entityTable.id));
      }
      const result = await query.where(eq(participantTable.roomId, roomId));
      const entitiesByIdMap = new Map;
      for (const row of result) {
        if (!row.entity)
          continue;
        const entityId = row.entity.id;
        if (!entitiesByIdMap.has(entityId)) {
          const entity = {
            ...row.entity,
            id: entityId,
            agentId: row.entity.agentId,
            metadata: row.entity.metadata,
            components: includeComponents ? [] : undefined
          };
          entitiesByIdMap.set(entityId, entity);
        }
        if (includeComponents && row.components) {
          const entity = entitiesByIdMap.get(entityId);
          if (entity) {
            if (!entity.components) {
              entity.components = [];
            }
            entity.components.push(row.components);
          }
        }
      }
      return Array.from(entitiesByIdMap.values());
    });
  }
  async createEntities(entities) {
    return this.withDatabase(async () => {
      try {
        return await this.db.transaction(async (tx) => {
          await tx.insert(entityTable).values(entities);
          logger.debug(`${entities.length} Entities created successfully`);
          return true;
        });
      } catch (error) {
        logger.error(`Error creating entities, entityId: ${entities[0].id}, (metadata?.)name: ${entities[0].metadata?.name}`, error instanceof Error ? error.message : String(error));
        if (error instanceof Error && error.stack) {
          logger.trace("Stack trace:", error.stack);
        }
        return false;
      }
    });
  }
  async ensureEntityExists(entity) {
    if (!entity.id) {
      logger.error("Entity ID is required for ensureEntityExists");
      return false;
    }
    try {
      const existingEntities = await this.getEntitiesByIds([entity.id]);
      if (!existingEntities || !existingEntities.length) {
        return await this.createEntities([entity]);
      }
      return true;
    } catch (error) {
      logger.error(`Error ensuring entity exists: ${error instanceof Error ? error.message : String(error)}, entityId: ${entity.id}`);
      return false;
    }
  }
  async updateEntity(entity) {
    if (!entity.id) {
      throw new Error("Entity ID is required for update");
    }
    return this.withDatabase(async () => {
      await this.db.update(entityTable).set(entity).where(eq(entityTable.id, entity.id));
    });
  }
  async deleteEntity(entityId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(componentTable).where(or(eq(componentTable.entityId, entityId), eq(componentTable.sourceEntityId, entityId)));
        await tx.delete(entityTable).where(eq(entityTable.id, entityId));
      });
    });
  }
  async getEntitiesByNames(params) {
    return this.withDatabase(async () => {
      const { names, agentId } = params;
      const nameConditions = names.map((name) => sql`${name} = ANY(${entityTable.names})`);
      const query = sql`
        SELECT * FROM ${entityTable}
        WHERE ${entityTable.agentId} = ${agentId}
        AND (${sql.join(nameConditions, sql` OR `)})
      `;
      const result = await this.db.execute(query);
      return result.rows.map((row) => ({
        id: row.id,
        agentId: row.agentId,
        names: row.names || [],
        metadata: row.metadata || {}
      }));
    });
  }
  async searchEntitiesByName(params) {
    return this.withDatabase(async () => {
      const { query, agentId, limit = 10 } = params;
      if (!query || query.trim() === "") {
        const result2 = await this.db.select().from(entityTable).where(eq(entityTable.agentId, agentId)).limit(limit);
        return result2.map((row) => ({
          id: row.id,
          agentId: row.agentId,
          names: row.names || [],
          metadata: row.metadata || {}
        }));
      }
      const searchQuery = sql`
        SELECT * FROM ${entityTable}
        WHERE ${entityTable.agentId} = ${agentId}
        AND EXISTS (
          SELECT 1 FROM unnest(${entityTable.names}) AS name
          WHERE LOWER(name) LIKE LOWER(${"%" + query + "%"})
        )
        LIMIT ${limit}
      `;
      const result = await this.db.execute(searchQuery);
      return result.rows.map((row) => ({
        id: row.id,
        agentId: row.agentId,
        names: row.names || [],
        metadata: row.metadata || {}
      }));
    });
  }
  async getComponent(entityId, type, worldId, sourceEntityId) {
    return this.withDatabase(async () => {
      const conditions = [eq(componentTable.entityId, entityId), eq(componentTable.type, type)];
      if (worldId) {
        conditions.push(eq(componentTable.worldId, worldId));
      }
      if (sourceEntityId) {
        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));
      }
      const result = await this.db.select().from(componentTable).where(and(...conditions));
      if (result.length === 0)
        return null;
      const component = result[0];
      return {
        ...component,
        id: component.id,
        entityId: component.entityId,
        agentId: component.agentId,
        roomId: component.roomId,
        worldId: component.worldId ?? "",
        sourceEntityId: component.sourceEntityId ?? "",
        data: component.data,
        createdAt: component.createdAt.getTime()
      };
    });
  }
  async getComponents(entityId, worldId, sourceEntityId) {
    return this.withDatabase(async () => {
      const conditions = [eq(componentTable.entityId, entityId)];
      if (worldId) {
        conditions.push(eq(componentTable.worldId, worldId));
      }
      if (sourceEntityId) {
        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));
      }
      const result = await this.db.select({
        id: componentTable.id,
        entityId: componentTable.entityId,
        type: componentTable.type,
        data: componentTable.data,
        worldId: componentTable.worldId,
        agentId: componentTable.agentId,
        roomId: componentTable.roomId,
        sourceEntityId: componentTable.sourceEntityId,
        createdAt: componentTable.createdAt
      }).from(componentTable).where(and(...conditions));
      if (result.length === 0)
        return [];
      const components = result.map((component) => ({
        ...component,
        id: component.id,
        entityId: component.entityId,
        agentId: component.agentId,
        roomId: component.roomId,
        worldId: component.worldId ?? "",
        sourceEntityId: component.sourceEntityId ?? "",
        data: component.data,
        createdAt: component.createdAt.getTime()
      }));
      return components;
    });
  }
  async createComponent(component) {
    return this.withDatabase(async () => {
      await this.db.insert(componentTable).values({
        ...component,
        createdAt: new Date
      });
      return true;
    });
  }
  async updateComponent(component) {
    return this.withDatabase(async () => {
      try {
        await this.db.update(componentTable).set({
          ...component,
          updatedAt: new Date
        }).where(eq(componentTable.id, component.id));
      } catch (e) {
        console.error("updateComponent error", e);
      }
    });
  }
  async deleteComponent(componentId) {
    return this.withDatabase(async () => {
      await this.db.delete(componentTable).where(eq(componentTable.id, componentId));
    });
  }
  async getMemories(params) {
    const { entityId, agentId, roomId, worldId, tableName, unique: unique2, start, end } = params;
    if (!tableName)
      throw new Error("tableName is required");
    return this.withDatabase(async () => {
      const conditions = [eq(memoryTable.type, tableName)];
      if (start) {
        conditions.push(gte(memoryTable.createdAt, new Date(start)));
      }
      if (entityId) {
        conditions.push(eq(memoryTable.entityId, entityId));
      }
      if (roomId) {
        conditions.push(eq(memoryTable.roomId, roomId));
      }
      if (worldId) {
        conditions.push(eq(memoryTable.worldId, worldId));
      }
      if (end) {
        conditions.push(lte(memoryTable.createdAt, new Date(end)));
      }
      if (unique2) {
        conditions.push(eq(memoryTable.unique, true));
      }
      if (agentId) {
        conditions.push(eq(memoryTable.agentId, agentId));
      }
      const query = this.db.select({
        memory: {
          id: memoryTable.id,
          type: memoryTable.type,
          createdAt: memoryTable.createdAt,
          content: memoryTable.content,
          entityId: memoryTable.entityId,
          agentId: memoryTable.agentId,
          roomId: memoryTable.roomId,
          unique: memoryTable.unique,
          metadata: memoryTable.metadata
        },
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      const rows = params.count ? await query.limit(params.count) : await query;
      return rows.map((row) => ({
        id: row.memory.id,
        type: row.memory.type,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ? Array.from(row.embedding) : undefined
      }));
    });
  }
  async getMemoriesByRoomIds(params) {
    return this.withDatabase(async () => {
      if (params.roomIds.length === 0)
        return [];
      const conditions = [
        eq(memoryTable.type, params.tableName),
        inArray(memoryTable.roomId, params.roomIds)
      ];
      conditions.push(eq(memoryTable.agentId, this.agentId));
      const query = this.db.select({
        id: memoryTable.id,
        type: memoryTable.type,
        createdAt: memoryTable.createdAt,
        content: memoryTable.content,
        entityId: memoryTable.entityId,
        agentId: memoryTable.agentId,
        roomId: memoryTable.roomId,
        unique: memoryTable.unique,
        metadata: memoryTable.metadata
      }).from(memoryTable).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      const rows = params.limit ? await query.limit(params.limit) : await query;
      return rows.map((row) => ({
        id: row.id,
        createdAt: row.createdAt.getTime(),
        content: typeof row.content === "string" ? JSON.parse(row.content) : row.content,
        entityId: row.entityId,
        agentId: row.agentId,
        roomId: row.roomId,
        unique: row.unique,
        metadata: row.metadata
      }));
    });
  }
  async getMemoryById(id) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        memory: memoryTable,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(memoryTable.id, embeddingTable.memoryId)).where(eq(memoryTable.id, id)).limit(1);
      if (result.length === 0)
        return null;
      const row = result[0];
      return {
        id: row.memory.id,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? undefined
      };
    });
  }
  async getMemoriesByIds(memoryIds, tableName) {
    return this.withDatabase(async () => {
      if (memoryIds.length === 0)
        return [];
      const conditions = [inArray(memoryTable.id, memoryIds)];
      if (tableName) {
        conditions.push(eq(memoryTable.type, tableName));
      }
      const rows = await this.db.select({
        memory: memoryTable,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      return rows.map((row) => ({
        id: row.memory.id,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? undefined
      }));
    });
  }
  async getCachedEmbeddings(opts) {
    return this.withDatabase(async () => {
      try {
        const results = await this.db.execute(sql`
                    WITH content_text AS (
                        SELECT
                            m.id,
                            COALESCE(
                                m.content->>${opts.query_field_sub_name},
                                ''
                            ) as content_text
                        FROM memories m
                        WHERE m.type = ${opts.query_table_name}
                            AND m.content->>${opts.query_field_sub_name} IS NOT NULL
                    ),
                    embedded_text AS (
                        SELECT
                            ct.content_text,
                            COALESCE(
                                e.dim_384,
                                e.dim_512,
                                e.dim_768,
                                e.dim_1024,
                                e.dim_1536,
                                e.dim_3072
                            ) as embedding
                        FROM content_text ct
                        LEFT JOIN embeddings e ON e.memory_id = ct.id
                        WHERE e.memory_id IS NOT NULL
                    )
                    SELECT
                        embedding,
                        levenshtein(${opts.query_input}, content_text) as levenshtein_score
                    FROM embedded_text
                    WHERE levenshtein(${opts.query_input}, content_text) <= ${opts.query_threshold}
                    ORDER BY levenshtein_score
                    LIMIT ${opts.query_match_count}
                `);
        return results.rows.map((row) => ({
          embedding: Array.isArray(row.embedding) ? row.embedding : typeof row.embedding === "string" ? JSON.parse(row.embedding) : [],
          levenshtein_score: Number(row.levenshtein_score)
        })).filter((row) => Array.isArray(row.embedding));
      } catch (error) {
        logger.error(`Error in getCachedEmbeddings: ${error instanceof Error ? error.message : String(error)}, tableName: ${opts.query_table_name}, fieldName: ${opts.query_field_name}`);
        if (error instanceof Error && error.message === "levenshtein argument exceeds maximum length of 255 characters") {
          return [];
        }
        throw error;
      }
    });
  }
  async log(params) {
    return this.withDatabase(async () => {
      try {
        const sanitizedBody = this.sanitizeJsonObject(params.body);
        const jsonString = JSON.stringify(sanitizedBody);
        await this.db.transaction(async (tx) => {
          await tx.insert(logTable).values({
            body: sql`${jsonString}::jsonb`,
            entityId: params.entityId,
            roomId: params.roomId,
            type: params.type
          });
        });
      } catch (error) {
        logger.error(`Failed to create log entry: ${error instanceof Error ? error.message : String(error)}, type: ${params.type}, roomId: ${params.roomId}, entityId: ${params.entityId}`);
        throw error;
      }
    });
  }
  sanitizeJsonObject(value, seen = new WeakSet) {
    if (value === null || value === undefined) {
      return value;
    }
    if (typeof value === "string") {
      return value.replace(/\u0000/g, "").replace(/\\(?!["\\/bfnrtu])/g, "\\\\").replace(/\\u(?![0-9a-fA-F]{4})/g, "\\\\u");
    }
    if (typeof value === "object") {
      if (seen.has(value)) {
        return null;
      } else {
        seen.add(value);
      }
      if (Array.isArray(value)) {
        return value.map((item) => this.sanitizeJsonObject(item, seen));
      } else {
        const result = {};
        for (const [key, val] of Object.entries(value)) {
          const sanitizedKey = typeof key === "string" ? key.replace(/\u0000/g, "").replace(/\\u(?![0-9a-fA-F]{4})/g, "\\\\u") : key;
          result[sanitizedKey] = this.sanitizeJsonObject(val, seen);
        }
        return result;
      }
    }
    return value;
  }
  async getLogs(params) {
    const { entityId, roomId, type, count: count2, offset } = params;
    return this.withDatabase(async () => {
      const result = await this.db.select().from(logTable).where(and(eq(logTable.entityId, entityId), roomId ? eq(logTable.roomId, roomId) : undefined, type ? eq(logTable.type, type) : undefined)).orderBy(desc(logTable.createdAt)).limit(count2 ?? 10).offset(offset ?? 0);
      const logs = result.map((log) => ({
        ...log,
        id: log.id,
        entityId: log.entityId,
        roomId: log.roomId,
        body: log.body,
        createdAt: new Date(log.createdAt)
      }));
      if (logs.length === 0)
        return [];
      return logs;
    });
  }
  async deleteLog(logId) {
    return this.withDatabase(async () => {
      await this.db.delete(logTable).where(eq(logTable.id, logId));
    });
  }
  async searchMemories(params) {
    return await this.searchMemoriesByEmbedding(params.embedding, {
      match_threshold: params.match_threshold,
      count: params.count,
      roomId: params.roomId,
      worldId: params.worldId,
      entityId: params.entityId,
      unique: params.unique,
      tableName: params.tableName
    });
  }
  async searchMemoriesByEmbedding(embedding, params) {
    return this.withDatabase(async () => {
      const cleanVector = embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
      const similarity = sql`1 - (${cosineDistance(embeddingTable[this.embeddingDimension], cleanVector)})`;
      const conditions = [eq(memoryTable.type, params.tableName)];
      if (params.unique) {
        conditions.push(eq(memoryTable.unique, true));
      }
      conditions.push(eq(memoryTable.agentId, this.agentId));
      if (params.roomId) {
        conditions.push(eq(memoryTable.roomId, params.roomId));
      }
      if (params.worldId) {
        conditions.push(eq(memoryTable.worldId, params.worldId));
      }
      if (params.entityId) {
        conditions.push(eq(memoryTable.entityId, params.entityId));
      }
      if (params.match_threshold) {
        conditions.push(gte(similarity, params.match_threshold));
      }
      const results = await this.db.select({
        memory: memoryTable,
        similarity,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(embeddingTable).innerJoin(memoryTable, eq(memoryTable.id, embeddingTable.memoryId)).where(and(...conditions)).orderBy(desc(similarity)).limit(params.count ?? 10);
      return results.map((row) => ({
        id: row.memory.id,
        type: row.memory.type,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        worldId: row.memory.worldId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? undefined,
        similarity: row.similarity
      }));
    });
  }
  async createMemory(memory, tableName) {
    logger.debug(`DrizzleAdapter createMemory: memoryId: ${memory.id}, embeddingLength: ${memory.embedding?.length}, contentLength: ${memory.content?.text?.length}`);
    const memoryId = memory.id ?? v4();
    const existing = await this.getMemoryById(memoryId);
    if (existing) {
      logger.debug(`Memory already exists, skipping creation: ${memoryId}`);
      return memoryId;
    }
    if (memory.unique === undefined) {
      memory.unique = true;
      if (memory.embedding && Array.isArray(memory.embedding)) {
        const similarMemories = await this.searchMemoriesByEmbedding(memory.embedding, {
          tableName,
          roomId: memory.roomId,
          worldId: memory.worldId,
          entityId: memory.entityId,
          match_threshold: 0.95,
          count: 1
        });
        memory.unique = similarMemories.length === 0;
      }
    }
    const contentToInsert = typeof memory.content === "string" ? memory.content : JSON.stringify(memory.content ?? {});
    const metadataToInsert = typeof memory.metadata === "string" ? memory.metadata : JSON.stringify(memory.metadata ?? {});
    await this.db.transaction(async (tx) => {
      await tx.insert(memoryTable).values([
        {
          id: memoryId,
          type: tableName,
          content: sql`${contentToInsert}::jsonb`,
          metadata: sql`${metadataToInsert}::jsonb`,
          entityId: memory.entityId,
          roomId: memory.roomId,
          worldId: memory.worldId,
          agentId: memory.agentId || this.agentId,
          unique: memory.unique,
          createdAt: memory.createdAt ? new Date(memory.createdAt) : new Date
        }
      ]);
      if (memory.embedding && Array.isArray(memory.embedding)) {
        const embeddingValues = {
          id: v4(),
          memoryId,
          createdAt: memory.createdAt ? new Date(memory.createdAt) : new Date
        };
        const cleanVector = memory.embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
        embeddingValues[this.embeddingDimension] = cleanVector;
        await tx.insert(embeddingTable).values([embeddingValues]);
      }
    });
    return memoryId;
  }
  async updateMemory(memory) {
    return this.withDatabase(async () => {
      try {
        logger.debug(`Updating memory: memoryId: ${memory.id}, hasEmbedding: ${!!memory.embedding}`);
        await this.db.transaction(async (tx) => {
          if (memory.content) {
            const contentToUpdate = typeof memory.content === "string" ? memory.content : JSON.stringify(memory.content ?? {});
            const metadataToUpdate = typeof memory.metadata === "string" ? memory.metadata : JSON.stringify(memory.metadata ?? {});
            await tx.update(memoryTable).set({
              content: sql`${contentToUpdate}::jsonb`,
              ...memory.metadata && { metadata: sql`${metadataToUpdate}::jsonb` }
            }).where(eq(memoryTable.id, memory.id));
          } else if (memory.metadata) {
            const metadataToUpdate = typeof memory.metadata === "string" ? memory.metadata : JSON.stringify(memory.metadata ?? {});
            await tx.update(memoryTable).set({
              metadata: sql`${metadataToUpdate}::jsonb`
            }).where(eq(memoryTable.id, memory.id));
          }
          if (memory.embedding && Array.isArray(memory.embedding)) {
            const cleanVector = memory.embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
            const existingEmbedding = await tx.select({ id: embeddingTable.id }).from(embeddingTable).where(eq(embeddingTable.memoryId, memory.id)).limit(1);
            if (existingEmbedding.length > 0) {
              const updateValues = {};
              updateValues[this.embeddingDimension] = cleanVector;
              await tx.update(embeddingTable).set(updateValues).where(eq(embeddingTable.memoryId, memory.id));
            } else {
              const embeddingValues = {
                id: v4(),
                memoryId: memory.id
              };
              embeddingValues[this.embeddingDimension] = cleanVector;
              await tx.insert(embeddingTable).values([embeddingValues]);
            }
          }
        });
        logger.debug(`Memory updated successfully: ${memory.id}`);
        return true;
      } catch (error) {
        logger.error(`Error updating memory: ${error instanceof Error ? error.message : String(error)}, memoryId: ${memory.id}`);
        return false;
      }
    });
  }
  async deleteMemory(memoryId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await this.deleteMemoryFragments(tx, memoryId);
        await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));
        await tx.delete(memoryTable).where(eq(memoryTable.id, memoryId));
      });
      logger.debug(`Memory and related fragments removed successfully: ${memoryId}`);
    });
  }
  async deleteManyMemories(memoryIds) {
    if (memoryIds.length === 0) {
      return;
    }
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        const BATCH_SIZE = 100;
        for (let i = 0;i < memoryIds.length; i += BATCH_SIZE) {
          const batch = memoryIds.slice(i, i + BATCH_SIZE);
          await Promise.all(batch.map(async (memoryId) => {
            await this.deleteMemoryFragments(tx, memoryId);
          }));
          await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, batch));
          await tx.delete(memoryTable).where(inArray(memoryTable.id, batch));
        }
      });
      logger.debug(`Batch memory deletion completed successfully: ${memoryIds.length}`);
    });
  }
  async deleteMemoryFragments(tx, documentId) {
    const fragmentsToDelete = await this.getMemoryFragments(tx, documentId);
    if (fragmentsToDelete.length > 0) {
      const fragmentIds = fragmentsToDelete.map((f) => f.id);
      await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, fragmentIds));
      await tx.delete(memoryTable).where(inArray(memoryTable.id, fragmentIds));
      logger.debug(`Deleted related fragments: documentId: ${documentId}, fragmentCount: ${fragmentsToDelete.length}`);
    }
  }
  async getMemoryFragments(tx, documentId) {
    const fragments = await tx.select({ id: memoryTable.id }).from(memoryTable).where(and(eq(memoryTable.agentId, this.agentId), sql`${memoryTable.metadata}->>'documentId' = ${documentId}`));
    return fragments.map((f) => ({ id: f.id }));
  }
  async deleteAllMemories(roomId, tableName) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        const rows = await tx.select({ id: memoryTable.id }).from(memoryTable).where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));
        const ids = rows.map((r) => r.id);
        logger.debug(`[deleteAllMemories] memory IDs to delete: roomId: ${roomId}, tableName: ${tableName}, ids: ${JSON.stringify(ids)}`);
        if (ids.length === 0) {
          return;
        }
        await Promise.all(ids.map(async (memoryId) => {
          await this.deleteMemoryFragments(tx, memoryId);
          await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));
        }));
        await tx.delete(memoryTable).where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));
      });
      logger.debug(`All memories removed successfully: roomId: ${roomId}, tableName: ${tableName}`);
    });
  }
  async countMemories(roomId, unique2 = true, tableName = "") {
    if (!tableName)
      throw new Error("tableName is required");
    return this.withDatabase(async () => {
      const conditions = [eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)];
      if (unique2) {
        conditions.push(eq(memoryTable.unique, true));
      }
      const result = await this.db.select({ count: sql`count(*)` }).from(memoryTable).where(and(...conditions));
      return Number(result[0]?.count ?? 0);
    });
  }
  async getRoomsByIds(roomIds) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        id: roomTable.id,
        name: roomTable.name,
        channelId: roomTable.channelId,
        agentId: roomTable.agentId,
        serverId: roomTable.serverId,
        worldId: roomTable.worldId,
        type: roomTable.type,
        source: roomTable.source,
        metadata: roomTable.metadata
      }).from(roomTable).where(and(inArray(roomTable.id, roomIds), eq(roomTable.agentId, this.agentId)));
      const rooms = result.map((room) => ({
        ...room,
        id: room.id,
        name: room.name ?? undefined,
        agentId: room.agentId,
        serverId: room.serverId,
        worldId: room.worldId,
        channelId: room.channelId,
        type: room.type,
        metadata: room.metadata
      }));
      return rooms;
    });
  }
  async getRoomsByWorld(worldId) {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(roomTable).where(eq(roomTable.worldId, worldId));
      const rooms = result.map((room) => ({
        ...room,
        id: room.id,
        name: room.name ?? undefined,
        agentId: room.agentId,
        serverId: room.serverId,
        worldId: room.worldId,
        channelId: room.channelId,
        type: room.type,
        metadata: room.metadata
      }));
      return rooms;
    });
  }
  async updateRoom(room) {
    return this.withDatabase(async () => {
      await this.db.update(roomTable).set({ ...room, agentId: this.agentId }).where(eq(roomTable.id, room.id));
    });
  }
  async createRooms(rooms) {
    return this.withDatabase(async () => {
      const roomsWithIds = rooms.map((room) => ({
        ...room,
        agentId: this.agentId,
        id: room.id || v4()
      }));
      const insertedRooms = await this.db.insert(roomTable).values(roomsWithIds).onConflictDoNothing().returning();
      const insertedIds = insertedRooms.map((r) => r.id);
      return insertedIds;
    });
  }
  async deleteRoom(roomId) {
    if (!roomId)
      throw new Error("Room ID is required");
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(roomTable).where(eq(roomTable.id, roomId));
      });
    });
  }
  async getRoomsForParticipant(entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ roomId: participantTable.roomId }).from(participantTable).innerJoin(roomTable, eq(participantTable.roomId, roomTable.id)).where(and(eq(participantTable.entityId, entityId), eq(roomTable.agentId, this.agentId)));
      return result.map((row) => row.roomId);
    });
  }
  async getRoomsForParticipants(entityIds) {
    return this.withDatabase(async () => {
      const result = await this.db.selectDistinct({ roomId: participantTable.roomId }).from(participantTable).innerJoin(roomTable, eq(participantTable.roomId, roomTable.id)).where(and(inArray(participantTable.entityId, entityIds), eq(roomTable.agentId, this.agentId)));
      return result.map((row) => row.roomId);
    });
  }
  async addParticipant(entityId, roomId) {
    return this.withDatabase(async () => {
      try {
        await this.db.insert(participantTable).values({
          entityId,
          roomId,
          agentId: this.agentId
        }).onConflictDoNothing();
        return true;
      } catch (error) {
        logger.error(`Error adding participant to room: ${error instanceof Error ? error.message : String(error)}, entityId: ${entityId}, roomId: ${roomId}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async addParticipantsRoom(entityIds, roomId) {
    return this.withDatabase(async () => {
      try {
        const values = entityIds.map((id) => ({
          entityId: id,
          roomId,
          agentId: this.agentId
        }));
        await this.db.insert(participantTable).values(values).onConflictDoNothing().execute();
        logger.debug(`${entityIds.length} Entities linked successfully`);
        return true;
      } catch (error) {
        logger.error(`Error adding participants to room: ${error instanceof Error ? error.message : String(error)}, entityIdSample: ${entityIds[0]}, roomId: ${roomId}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async removeParticipant(entityId, roomId) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.transaction(async (tx) => {
          return await tx.delete(participantTable).where(and(eq(participantTable.entityId, entityId), eq(participantTable.roomId, roomId))).returning();
        });
        const removed = result.length > 0;
        logger.debug(`Participant ${removed ? "removed" : "not found"}: entityId: ${entityId}, roomId: ${roomId}, removed: ${removed}`);
        return removed;
      } catch (error) {
        logger.error(`Error removing participant from room: ${error instanceof Error ? error.message : String(error)}, entityId: ${entityId}, roomId: ${roomId}`);
        return false;
      }
    });
  }
  async getParticipantsForEntity(entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        id: participantTable.id,
        entityId: participantTable.entityId,
        roomId: participantTable.roomId
      }).from(participantTable).where(eq(participantTable.entityId, entityId));
      const entities = await this.getEntitiesByIds([entityId]);
      if (!entities || !entities.length) {
        return [];
      }
      return result.map((row) => ({
        id: row.id,
        entity: entities[0]
      }));
    });
  }
  async getParticipantsForRoom(roomId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ entityId: participantTable.entityId }).from(participantTable).where(eq(participantTable.roomId, roomId));
      return result.map((row) => row.entityId);
    });
  }
  async getParticipantUserState(roomId, entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ roomState: participantTable.roomState }).from(participantTable).where(and(eq(participantTable.roomId, roomId), eq(participantTable.entityId, entityId), eq(participantTable.agentId, this.agentId))).limit(1);
      return result[0]?.roomState ?? null;
    });
  }
  async setParticipantUserState(roomId, entityId, state) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.update(participantTable).set({ roomState: state }).where(and(eq(participantTable.roomId, roomId), eq(participantTable.entityId, entityId), eq(participantTable.agentId, this.agentId)));
        });
      } catch (error) {
        logger.error(`Error setting participant follow state: roomId: ${roomId}, entityId: ${entityId}, state: ${state}, error: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
      }
    });
  }
  async createRelationship(params) {
    return this.withDatabase(async () => {
      const id = v4();
      const saveParams = {
        id,
        sourceEntityId: params.sourceEntityId,
        targetEntityId: params.targetEntityId,
        agentId: this.agentId,
        tags: params.tags || [],
        metadata: params.metadata || {}
      };
      try {
        await this.db.insert(relationshipTable).values(saveParams);
        return true;
      } catch (error) {
        logger.error(`Error creating relationship: ${error instanceof Error ? error.message : String(error)}, saveParams: ${JSON.stringify(saveParams)}`);
        return false;
      }
    });
  }
  async updateRelationship(relationship) {
    return this.withDatabase(async () => {
      try {
        await this.db.update(relationshipTable).set({
          tags: relationship.tags || [],
          metadata: relationship.metadata || {}
        }).where(eq(relationshipTable.id, relationship.id));
      } catch (error) {
        logger.error(`Error updating relationship: ${error instanceof Error ? error.message : String(error)}, relationship: ${JSON.stringify(relationship)}`);
        throw error;
      }
    });
  }
  async getRelationship(params) {
    return this.withDatabase(async () => {
      const { sourceEntityId, targetEntityId } = params;
      const result = await this.db.select().from(relationshipTable).where(and(eq(relationshipTable.sourceEntityId, sourceEntityId), eq(relationshipTable.targetEntityId, targetEntityId)));
      if (result.length === 0)
        return null;
      const relationship = result[0];
      return {
        ...relationship,
        id: relationship.id,
        sourceEntityId: relationship.sourceEntityId,
        targetEntityId: relationship.targetEntityId,
        agentId: relationship.agentId,
        tags: relationship.tags ?? [],
        metadata: relationship.metadata ?? {},
        createdAt: relationship.createdAt.toISOString()
      };
    });
  }
  async getRelationships(params) {
    return this.withDatabase(async () => {
      const { entityId, tags } = params;
      let query;
      if (tags && tags.length > 0) {
        query = sql`
          SELECT * FROM ${relationshipTable}
          WHERE (${relationshipTable.sourceEntityId} = ${entityId} OR ${relationshipTable.targetEntityId} = ${entityId})
          AND ${relationshipTable.tags} && CAST(ARRAY[${sql.join(tags, sql`, `)}] AS text[])
        `;
      } else {
        query = sql`
          SELECT * FROM ${relationshipTable}
          WHERE ${relationshipTable.sourceEntityId} = ${entityId} OR ${relationshipTable.targetEntityId} = ${entityId}
        `;
      }
      const result = await this.db.execute(query);
      return result.rows.map((relationship) => ({
        ...relationship,
        id: relationship.id,
        sourceEntityId: relationship.sourceEntityId,
        targetEntityId: relationship.targetEntityId,
        agentId: relationship.agentId,
        tags: relationship.tags ?? [],
        metadata: relationship.metadata ?? {},
        createdAt: relationship.createdAt ? relationship.createdAt instanceof Date ? relationship.createdAt.toISOString() : new Date(relationship.createdAt).toISOString() : new Date().toISOString()
      }));
    });
  }
  async getCache(key) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select({ value: cacheTable.value }).from(cacheTable).where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key))).limit(1);
        if (result && result.length > 0 && result[0]) {
          return result[0].value;
        }
        return;
      } catch (error) {
        logger.error(`Error fetching cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`);
        return;
      }
    });
  }
  async setCache(key, value) {
    return this.withDatabase(async () => {
      try {
        await this.db.insert(cacheTable).values({
          key,
          agentId: this.agentId,
          value
        }).onConflictDoUpdate({
          target: [cacheTable.key, cacheTable.agentId],
          set: {
            value
          }
        });
        return true;
      } catch (error) {
        logger.error(`Error setting cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async deleteCache(key) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.delete(cacheTable).where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key)));
        });
        return true;
      } catch (error) {
        logger.error(`Error deleting cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async createWorld(world) {
    return this.withDatabase(async () => {
      const newWorldId = world.id || v4();
      await this.db.insert(worldTable).values({
        ...world,
        id: newWorldId,
        name: world.name || ""
      });
      return newWorldId;
    });
  }
  async getWorld(id) {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(worldTable).where(eq(worldTable.id, id));
      return result.length > 0 ? result[0] : null;
    });
  }
  async getAllWorlds() {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(worldTable).where(eq(worldTable.agentId, this.agentId));
      return result;
    });
  }
  async updateWorld(world) {
    return this.withDatabase(async () => {
      await this.db.update(worldTable).set(world).where(eq(worldTable.id, world.id));
    });
  }
  async removeWorld(id) {
    return this.withDatabase(async () => {
      await this.db.delete(worldTable).where(eq(worldTable.id, id));
    });
  }
  async createTask(task) {
    if (!task.worldId) {
      throw new Error("worldId is required");
    }
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const now = new Date;
        const metadata = task.metadata || {};
        const values = {
          id: task.id,
          name: task.name,
          description: task.description,
          roomId: task.roomId,
          worldId: task.worldId,
          tags: task.tags,
          metadata,
          createdAt: now,
          updatedAt: now,
          agentId: this.agentId
        };
        const result = await this.db.insert(taskTable).values(values).returning();
        return result[0].id;
      });
    });
  }
  async getTasks(params) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.agentId, this.agentId), ...params.roomId ? [eq(taskTable.roomId, params.roomId)] : [], ...params.tags && params.tags.length > 0 ? [
          sql`${taskTable.tags} @> ARRAY[${sql.raw(params.tags.map((t) => `'${t.replace(/'/g, "''")}'`).join(", "))}]::text[]`
        ] : []));
        return result.map((row) => ({
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata
        }));
      });
    });
  }
  async getTasksByName(name) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.name, name), eq(taskTable.agentId, this.agentId)));
        return result.map((row) => ({
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata || {}
        }));
      });
    });
  }
  async getTask(id) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId))).limit(1);
        if (result.length === 0) {
          return null;
        }
        const row = result[0];
        return {
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata || {}
        };
      });
    });
  }
  async updateTask(id, task) {
    await this.withRetry(async () => {
      await this.withDatabase(async () => {
        const updateValues = {};
        if (task.name !== undefined)
          updateValues.name = task.name;
        if (task.description !== undefined)
          updateValues.description = task.description;
        if (task.roomId !== undefined)
          updateValues.roomId = task.roomId;
        if (task.worldId !== undefined)
          updateValues.worldId = task.worldId;
        if (task.tags !== undefined)
          updateValues.tags = task.tags;
        updateValues.updatedAt = new Date;
        if (task.metadata !== undefined) {
          updateValues.metadata = task.metadata;
        }
        await this.db.update(taskTable).set(updateValues).where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId)));
      });
    });
  }
  async deleteTask(id) {
    return this.withDatabase(async () => {
      await this.db.delete(taskTable).where(eq(taskTable.id, id));
    });
  }
  async getMemoriesByWorldId(params) {
    return this.withDatabase(async () => {
      const rooms = await this.db.select({ id: roomTable.id }).from(roomTable).where(and(eq(roomTable.worldId, params.worldId), eq(roomTable.agentId, this.agentId)));
      if (rooms.length === 0) {
        return [];
      }
      const roomIds = rooms.map((room) => room.id);
      const memories = await this.getMemoriesByRoomIds({
        roomIds,
        tableName: params.tableName || "messages",
        limit: params.count
      });
      return memories;
    });
  }
  async deleteRoomsByWorldId(worldId) {
    return this.withDatabase(async () => {
      const rooms = await this.db.select({ id: roomTable.id }).from(roomTable).where(and(eq(roomTable.worldId, worldId), eq(roomTable.agentId, this.agentId)));
      if (rooms.length === 0) {
        logger.debug(`No rooms found for worldId ${worldId} and agentId ${this.agentId} to delete.`);
        return;
      }
      const roomIds = rooms.map((room) => room.id);
      if (roomIds.length > 0) {
        await this.db.delete(logTable).where(inArray(logTable.roomId, roomIds));
        logger.debug(`Deleted logs for ${roomIds.length} rooms in world ${worldId}.`);
        await this.db.delete(participantTable).where(inArray(participantTable.roomId, roomIds));
        logger.debug(`Deleted participants for ${roomIds.length} rooms in world ${worldId}.`);
        const memoriesInRooms = await this.db.select({ id: memoryTable.id }).from(memoryTable).where(inArray(memoryTable.roomId, roomIds));
        const memoryIdsInRooms = memoriesInRooms.map((m) => m.id);
        if (memoryIdsInRooms.length > 0) {
          await this.db.delete(embeddingTable).where(inArray(embeddingTable.memoryId, memoryIdsInRooms));
          logger.debug(`Deleted embeddings for ${memoryIdsInRooms.length} memories in world ${worldId}.`);
          await this.db.delete(memoryTable).where(inArray(memoryTable.id, memoryIdsInRooms));
          logger.debug(`Deleted ${memoryIdsInRooms.length} memories in world ${worldId}.`);
        }
        await this.db.delete(roomTable).where(inArray(roomTable.id, roomIds));
        logger.debug(`Deleted ${roomIds.length} rooms for worldId ${worldId}.`);
      }
    });
  }
  async createMessageServer(data) {
    return this.withDatabase(async () => {
      const newId = data.id || v4();
      const now = new Date;
      const serverToInsert = {
        id: newId,
        name: data.name,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        metadata: data.metadata,
        createdAt: now,
        updatedAt: now
      };
      await this.db.insert(messageServerTable).values(serverToInsert).onConflictDoNothing();
      if (data.id) {
        const existing = await this.db.select().from(messageServerTable).where(eq(messageServerTable.id, data.id)).limit(1);
        if (existing.length > 0) {
          return {
            id: existing[0].id,
            name: existing[0].name,
            sourceType: existing[0].sourceType,
            sourceId: existing[0].sourceId || undefined,
            metadata: existing[0].metadata || undefined,
            createdAt: existing[0].createdAt,
            updatedAt: existing[0].updatedAt
          };
        }
      }
      return serverToInsert;
    });
  }
  async getMessageServers() {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(messageServerTable);
      return results.map((r) => ({
        id: r.id,
        name: r.name,
        sourceType: r.sourceType,
        sourceId: r.sourceId || undefined,
        metadata: r.metadata || undefined,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  async getMessageServerById(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(messageServerTable).where(eq(messageServerTable.id, serverId)).limit(1);
      return results.length > 0 ? {
        id: results[0].id,
        name: results[0].name,
        sourceType: results[0].sourceType,
        sourceId: results[0].sourceId || undefined,
        metadata: results[0].metadata || undefined,
        createdAt: results[0].createdAt,
        updatedAt: results[0].updatedAt
      } : null;
    });
  }
  async createChannel(data, participantIds) {
    return this.withDatabase(async () => {
      const newId = data.id || v4();
      const now = new Date;
      const channelToInsert = {
        id: newId,
        messageServerId: data.messageServerId,
        name: data.name,
        type: data.type,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        topic: data.topic,
        metadata: data.metadata,
        createdAt: now,
        updatedAt: now
      };
      await this.db.transaction(async (tx) => {
        await tx.insert(channelTable).values(channelToInsert);
        if (participantIds && participantIds.length > 0) {
          const participantValues = participantIds.map((userId) => ({
            channelId: newId,
            userId
          }));
          await tx.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
        }
      });
      return channelToInsert;
    });
  }
  async getChannelsForServer(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(channelTable).where(eq(channelTable.messageServerId, serverId));
      return results.map((r) => ({
        id: r.id,
        messageServerId: r.messageServerId,
        name: r.name,
        type: r.type,
        sourceType: r.sourceType || undefined,
        sourceId: r.sourceId || undefined,
        topic: r.topic || undefined,
        metadata: r.metadata || undefined,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  async getChannelDetails(channelId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(channelTable).where(eq(channelTable.id, channelId)).limit(1);
      return results.length > 0 ? {
        id: results[0].id,
        messageServerId: results[0].messageServerId,
        name: results[0].name,
        type: results[0].type,
        sourceType: results[0].sourceType || undefined,
        sourceId: results[0].sourceId || undefined,
        topic: results[0].topic || undefined,
        metadata: results[0].metadata || undefined,
        createdAt: results[0].createdAt,
        updatedAt: results[0].updatedAt
      } : null;
    });
  }
  async createMessage(data) {
    return this.withDatabase(async () => {
      const newId = data.messageId || v4();
      const now = new Date;
      const messageToInsert = {
        id: newId,
        channelId: data.channelId,
        authorId: data.authorId,
        content: data.content,
        rawMessage: data.rawMessage,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        metadata: data.metadata,
        inReplyToRootMessageId: data.inReplyToRootMessageId,
        createdAt: now,
        updatedAt: now
      };
      await this.db.insert(messageTable).values(messageToInsert);
      return messageToInsert;
    });
  }
  async getMessageById(id) {
    return this.withDatabase(async () => {
      const rows = await this.db.select().from(messageTable).where(eq(messageTable.id, id)).limit(1);
      return rows?.[0] ?? null;
    });
  }
  async updateMessage(id, patch) {
    return this.withDatabase(async () => {
      const existing = await this.getMessageById(id);
      if (!existing)
        return null;
      const updatedAt = new Date;
      const next = {
        content: patch.content ?? existing.content,
        rawMessage: patch.rawMessage ?? existing.rawMessage,
        sourceType: patch.sourceType ?? existing.sourceType,
        sourceId: patch.sourceId ?? existing.sourceId,
        metadata: patch.metadata ?? existing.metadata,
        inReplyToRootMessageId: patch.inReplyToRootMessageId ?? existing.inReplyToRootMessageId,
        updatedAt
      };
      await this.db.update(messageTable).set(next).where(eq(messageTable.id, id));
      return {
        ...existing,
        ...next
      };
    });
  }
  async getMessagesForChannel(channelId, limit = 50, beforeTimestamp) {
    return this.withDatabase(async () => {
      const conditions = [eq(messageTable.channelId, channelId)];
      if (beforeTimestamp) {
        conditions.push(lt(messageTable.createdAt, beforeTimestamp));
      }
      const query = this.db.select().from(messageTable).where(and(...conditions)).orderBy(desc(messageTable.createdAt)).limit(limit);
      const results = await query;
      return results.map((r) => ({
        id: r.id,
        channelId: r.channelId,
        authorId: r.authorId,
        content: r.content,
        rawMessage: r.rawMessage || undefined,
        sourceType: r.sourceType || undefined,
        sourceId: r.sourceId || undefined,
        metadata: r.metadata || undefined,
        inReplyToRootMessageId: r.inReplyToRootMessageId,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  async deleteMessage(messageId) {
    return this.withDatabase(async () => {
      await this.db.delete(messageTable).where(eq(messageTable.id, messageId));
    });
  }
  async updateChannel(channelId, updates) {
    return this.withDatabase(async () => {
      const now = new Date;
      await this.db.transaction(async (tx) => {
        const updateData = { updatedAt: now };
        if (updates.name !== undefined)
          updateData.name = updates.name;
        if (updates.metadata !== undefined)
          updateData.metadata = updates.metadata;
        await tx.update(channelTable).set(updateData).where(eq(channelTable.id, channelId));
        if (updates.participantCentralUserIds !== undefined) {
          await tx.delete(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
          if (updates.participantCentralUserIds.length > 0) {
            const participantValues = updates.participantCentralUserIds.map((userId) => ({
              channelId,
              userId
            }));
            await tx.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
          }
        }
      });
      const updatedChannel = await this.getChannelDetails(channelId);
      if (!updatedChannel) {
        throw new Error(`Channel ${channelId} not found after update`);
      }
      return updatedChannel;
    });
  }
  async deleteChannel(channelId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(messageTable).where(eq(messageTable.channelId, channelId));
        await tx.delete(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
        await tx.delete(channelTable).where(eq(channelTable.id, channelId));
      });
    });
  }
  async addChannelParticipants(channelId, userIds) {
    return this.withDatabase(async () => {
      if (!userIds || userIds.length === 0)
        return;
      const participantValues = userIds.map((userId) => ({
        channelId,
        userId
      }));
      await this.db.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
    });
  }
  async getChannelParticipants(channelId) {
    return this.withDatabase(async () => {
      const results = await this.db.select({ userId: channelParticipantsTable.userId }).from(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
      return results.map((r) => r.userId);
    });
  }
  async addAgentToServer(serverId, agentId) {
    return this.withDatabase(async () => {
      await this.db.insert(serverAgentsTable).values({
        serverId,
        agentId
      }).onConflictDoNothing();
    });
  }
  async getAgentsForServer(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select({ agentId: serverAgentsTable.agentId }).from(serverAgentsTable).where(eq(serverAgentsTable.serverId, serverId));
      return results.map((r) => r.agentId);
    });
  }
  async removeAgentFromServer(serverId, agentId) {
    return this.withDatabase(async () => {
      await this.db.delete(serverAgentsTable).where(and(eq(serverAgentsTable.serverId, serverId), eq(serverAgentsTable.agentId, agentId)));
    });
  }
  async findOrCreateDmChannel(user1Id, user2Id, messageServerId) {
    return this.withDatabase(async () => {
      const ids = [user1Id, user2Id].sort();
      const dmChannelName = `DM-${ids[0]}-${ids[1]}`;
      const existingChannels = await this.db.select().from(channelTable).where(and(eq(channelTable.type, ChannelType.DM), eq(channelTable.name, dmChannelName), eq(channelTable.messageServerId, messageServerId))).limit(1);
      if (existingChannels.length > 0) {
        return {
          id: existingChannels[0].id,
          messageServerId: existingChannels[0].messageServerId,
          name: existingChannels[0].name,
          type: existingChannels[0].type,
          sourceType: existingChannels[0].sourceType || undefined,
          sourceId: existingChannels[0].sourceId || undefined,
          topic: existingChannels[0].topic || undefined,
          metadata: existingChannels[0].metadata || undefined,
          createdAt: existingChannels[0].createdAt,
          updatedAt: existingChannels[0].updatedAt
        };
      }
      return this.createChannel({
        messageServerId,
        name: dmChannelName,
        type: ChannelType.DM,
        metadata: { user1: ids[0], user2: ids[1] }
      }, ids);
    });
  }
}

// src/pglite/adapter.ts
class PgliteDatabaseAdapter extends BaseDrizzleAdapter {
  manager;
  embeddingDimension = DIMENSION_MAP[384];
  constructor(agentId, manager) {
    super(agentId);
    this.manager = manager;
    this.db = drizzle(this.manager.getConnection());
  }
  async getEntityByIds(entityIds) {
    return this.getEntitiesByIds(entityIds);
  }
  async getMemoriesByServerId(_params) {
    logger2.warn("getMemoriesByServerId called but not implemented - returning empty array");
    return [];
  }
  async ensureAgentExists(agent) {
    const existingAgent = await this.getAgent(this.agentId);
    if (existingAgent) {
      return existingAgent;
    }
    const newAgent = {
      id: this.agentId,
      name: agent.name || "Unknown Agent",
      username: agent.username,
      bio: agent.bio || "An AI agent",
      createdAt: agent.createdAt || Date.now(),
      updatedAt: agent.updatedAt || Date.now()
    };
    await this.createAgent(newAgent);
    const createdAgent = await this.getAgent(this.agentId);
    if (!createdAgent) {
      throw new Error("Failed to create agent");
    }
    return createdAgent;
  }
  async runMigrations() {
    logger2.debug("PgliteDatabaseAdapter: Migrations are handled by the migration service");
  }
  async withDatabase(operation) {
    if (this.manager.isShuttingDown()) {
      logger2.warn("Database is shutting down");
      return null;
    }
    return operation();
  }
  async init() {
    logger2.debug("PGliteDatabaseAdapter initialized, skipping automatic migrations.");
  }
  async isReady() {
    return !this.manager.isShuttingDown();
  }
  async close() {
    await this.manager.close();
  }
  async getConnection() {
    return this.manager.getConnection();
  }
}

// src/pglite/manager.ts
import { PGlite as PGlite2 } from "@electric-sql/pglite";
import { fuzzystrmatch } from "@electric-sql/pglite/contrib/fuzzystrmatch";
import { vector as vector2 } from "@electric-sql/pglite/vector";

class PGliteClientManager {
  client;
  shuttingDown = false;
  constructor(options) {
    this.client = new PGlite2({
      ...options,
      extensions: {
        vector: vector2,
        fuzzystrmatch
      }
    });
    this.setupShutdownHandlers();
  }
  getConnection() {
    return this.client;
  }
  isShuttingDown() {
    return this.shuttingDown;
  }
  async initialize() {}
  async close() {
    this.shuttingDown = true;
  }
  setupShutdownHandlers() {}
}

// src/pg/adapter.ts
import { logger as logger3 } from "@elizaos/core";

// ../../node_modules/drizzle-orm/node-postgres/driver.js
import pg2 from "pg";

// ../../node_modules/drizzle-orm/node-postgres/session.js
import pg from "pg";
var { Pool, types: types2 } = pg;

class NodePgPreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger3, cache, queryMetadata, cacheConfig, fields, name, _isResponseInArrayMode, customResultMapper) {
    super({ sql: queryString, params }, cache, queryMetadata, cacheConfig);
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger3;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.rawQueryConfig = {
      name,
      text: queryString,
      types: {
        getTypeParser: (typeId, format) => {
          if (typeId === types2.builtins.TIMESTAMPTZ) {
            return (val) => val;
          }
          if (typeId === types2.builtins.TIMESTAMP) {
            return (val) => val;
          }
          if (typeId === types2.builtins.DATE) {
            return (val) => val;
          }
          if (typeId === types2.builtins.INTERVAL) {
            return (val) => val;
          }
          if (typeId === 1231) {
            return (val) => val;
          }
          if (typeId === 1115) {
            return (val) => val;
          }
          if (typeId === 1185) {
            return (val) => val;
          }
          if (typeId === 1187) {
            return (val) => val;
          }
          if (typeId === 1182) {
            return (val) => val;
          }
          return types2.getTypeParser(typeId, format);
        }
      }
    };
    this.queryConfig = {
      name,
      text: queryString,
      rowMode: "array",
      types: {
        getTypeParser: (typeId, format) => {
          if (typeId === types2.builtins.TIMESTAMPTZ) {
            return (val) => val;
          }
          if (typeId === types2.builtins.TIMESTAMP) {
            return (val) => val;
          }
          if (typeId === types2.builtins.DATE) {
            return (val) => val;
          }
          if (typeId === types2.builtins.INTERVAL) {
            return (val) => val;
          }
          if (typeId === 1231) {
            return (val) => val;
          }
          if (typeId === 1115) {
            return (val) => val;
          }
          if (typeId === 1185) {
            return (val) => val;
          }
          if (typeId === 1187) {
            return (val) => val;
          }
          if (typeId === 1182) {
            return (val) => val;
          }
          return types2.getTypeParser(typeId, format);
        }
      }
    };
  }
  static [entityKind] = "NodePgPreparedQuery";
  rawQueryConfig;
  queryConfig;
  async execute(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async () => {
      const params = fillPlaceholders(this.params, placeholderValues);
      this.logger.logQuery(this.rawQueryConfig.text, params);
      const { fields, rawQueryConfig: rawQuery, client, queryConfig: query, joinsNotNullableMap, customResultMapper } = this;
      if (!fields && !customResultMapper) {
        return tracer.startActiveSpan("drizzle.driver.execute", async (span) => {
          span?.setAttributes({
            "drizzle.query.name": rawQuery.name,
            "drizzle.query.text": rawQuery.text,
            "drizzle.query.params": JSON.stringify(params)
          });
          return this.queryWithCache(rawQuery.text, params, async () => {
            return await client.query(rawQuery, params);
          });
        });
      }
      const result = await tracer.startActiveSpan("drizzle.driver.execute", (span) => {
        span?.setAttributes({
          "drizzle.query.name": query.name,
          "drizzle.query.text": query.text,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.queryWithCache(query.text, params, async () => {
          return await client.query(query, params);
        });
      });
      return tracer.startActiveSpan("drizzle.mapResponse", () => {
        return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      });
    });
  }
  all(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", () => {
      const params = fillPlaceholders(this.params, placeholderValues);
      this.logger.logQuery(this.rawQueryConfig.text, params);
      return tracer.startActiveSpan("drizzle.driver.execute", (span) => {
        span?.setAttributes({
          "drizzle.query.name": this.rawQueryConfig.name,
          "drizzle.query.text": this.rawQueryConfig.text,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.queryWithCache(this.rawQueryConfig.text, params, async () => {
          return this.client.query(this.rawQueryConfig, params);
        }).then((result) => result.rows);
      });
    });
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

class NodePgSession extends PgSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
    this.cache = options.cache ?? new NoopCache;
  }
  static [entityKind] = "NodePgSession";
  logger;
  cache;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return new NodePgPreparedQuery(this.client, query.sql, query.params, this.logger, this.cache, queryMetadata, cacheConfig, fields, name, isResponseInArrayMode, customResultMapper);
  }
  async transaction(transaction, config) {
    const session = this.client instanceof Pool ? new NodePgSession(await this.client.connect(), this.dialect, this.schema, this.options) : this;
    const tx = new NodePgTransaction(this.dialect, session, this.schema);
    await tx.execute(sql`begin${config ? sql` ${tx.getTransactionConfigSQL(config)}` : undefined}`);
    try {
      const result = await transaction(tx);
      await tx.execute(sql`commit`);
      return result;
    } catch (error) {
      await tx.execute(sql`rollback`);
      throw error;
    } finally {
      if (this.client instanceof Pool) {
        session.client.release();
      }
    }
  }
  async count(sql2) {
    const res = await this.execute(sql2);
    return Number(res["rows"][0]["count"]);
  }
}

class NodePgTransaction extends PgTransaction {
  static [entityKind] = "NodePgTransaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex + 1}`;
    const tx = new NodePgTransaction(this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await tx.execute(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await tx.execute(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
}

// ../../node_modules/drizzle-orm/node-postgres/driver.js
class NodePgDriver {
  constructor(client, dialect, options = {}) {
    this.client = client;
    this.dialect = dialect;
    this.options = options;
  }
  static [entityKind] = "NodePgDriver";
  createSession(schema) {
    return new NodePgSession(this.client, this.dialect, schema, {
      logger: this.options.logger,
      cache: this.options.cache
    });
  }
}

class NodePgDatabase extends PgDatabase {
  static [entityKind] = "NodePgDatabase";
}
function construct2(client, config = {}) {
  const dialect = new PgDialect({ casing: config.casing });
  let logger3;
  if (config.logger === true) {
    logger3 = new DefaultLogger;
  } else if (config.logger !== false) {
    logger3 = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new NodePgDriver(client, dialect, { logger: logger3, cache: config.cache });
  const session = driver.createSession(schema);
  const db = new NodePgDatabase(dialect, session, schema);
  db.$client = client;
  db.$cache = config.cache;
  if (db.$cache) {
    db.$cache["invalidate"] = config.cache?.onMutate;
  }
  return db;
}
function drizzle2(...params) {
  if (typeof params[0] === "string") {
    const instance = new pg2.Pool({
      connectionString: params[0]
    });
    return construct2(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client)
      return construct2(client, drizzleConfig);
    const instance = typeof connection === "string" ? new pg2.Pool({
      connectionString: connection
    }) : new pg2.Pool(connection);
    return construct2(instance, drizzleConfig);
  }
  return construct2(params[0], params[1]);
}
((drizzle22) => {
  function mock(config) {
    return construct2({}, config);
  }
  drizzle22.mock = mock;
})(drizzle2 || (drizzle2 = {}));

// src/pg/adapter.ts
class PgDatabaseAdapter extends BaseDrizzleAdapter {
  embeddingDimension = DIMENSION_MAP[384];
  manager;
  constructor(agentId, manager, _schema) {
    super(agentId);
    this.manager = manager;
    this.db = manager.getDatabase();
  }
  async getEntityByIds(entityIds) {
    return this.getEntitiesByIds(entityIds);
  }
  async getMemoriesByServerId(_params) {
    logger3.warn("getMemoriesByServerId called but not implemented - returning empty array");
    return [];
  }
  async ensureAgentExists(agent) {
    const existingAgent = await this.getAgent(this.agentId);
    if (existingAgent) {
      return existingAgent;
    }
    const newAgent = {
      id: this.agentId,
      name: agent.name || "Unknown Agent",
      username: agent.username,
      bio: agent.bio || "An AI agent",
      createdAt: agent.createdAt || Date.now(),
      updatedAt: agent.updatedAt || Date.now()
    };
    await this.createAgent(newAgent);
    const createdAgent = await this.getAgent(this.agentId);
    if (!createdAgent) {
      throw new Error("Failed to create agent");
    }
    return createdAgent;
  }
  async runMigrations() {
    logger3.debug("PgDatabaseAdapter: Migrations should be handled externally");
  }
  async withDatabase(operation) {
    return await this.withRetry(async () => {
      const client = await this.manager.getClient();
      try {
        const db = drizzle2(client);
        this.db = db;
        return await operation();
      } finally {
        client.release();
      }
    });
  }
  async init() {
    logger3.debug("PgDatabaseAdapter initialized, skipping automatic migrations.");
  }
  async isReady() {
    return this.manager.testConnection();
  }
  async close() {
    await this.manager.close();
  }
  async getConnection() {
    return this.manager.getConnection();
  }
  async createAgent(agent) {
    return super.createAgent(agent);
  }
  getAgent(agentId) {
    return super.getAgent(agentId);
  }
  updateAgent(agentId, agent) {
    return super.updateAgent(agentId, agent);
  }
  deleteAgent(agentId) {
    return super.deleteAgent(agentId);
  }
  createEntities(entities) {
    return super.createEntities(entities);
  }
  getEntitiesByIds(entityIds) {
    return super.getEntitiesByIds(entityIds).then((result) => result || []);
  }
  updateEntity(entity) {
    return super.updateEntity(entity);
  }
  createMemory(memory, tableName) {
    return super.createMemory(memory, tableName);
  }
  getMemoryById(memoryId) {
    return super.getMemoryById(memoryId);
  }
  searchMemories(params) {
    return super.searchMemories(params);
  }
  updateMemory(memory) {
    return super.updateMemory(memory);
  }
  deleteMemory(memoryId) {
    return super.deleteMemory(memoryId);
  }
  createComponent(component) {
    return super.createComponent(component);
  }
  getComponent(entityId, type, worldId, sourceEntityId) {
    return super.getComponent(entityId, type, worldId, sourceEntityId);
  }
  updateComponent(component) {
    return super.updateComponent(component);
  }
  deleteComponent(componentId) {
    return super.deleteComponent(componentId);
  }
}

// src/pg/manager.ts
import { Pool as Pool2 } from "pg";
import { logger as logger4 } from "@elizaos/core";

class PostgresConnectionManager {
  pool;
  db;
  constructor(connectionString) {
    this.pool = new Pool2({ connectionString });
    this.db = drizzle2(this.pool);
  }
  getDatabase() {
    return this.db;
  }
  getConnection() {
    return this.pool;
  }
  async getClient() {
    return this.pool.connect();
  }
  async testConnection() {
    let client = null;
    try {
      client = await this.pool.connect();
      await client.query("SELECT 1");
      return true;
    } catch (error) {
      logger4.error(`Failed to connect to the database: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    } finally {
      if (client) {
        client.release();
      }
    }
  }
  async close() {
    await this.pool.end();
  }
}

// src/utils.node.ts
import dotenv from "dotenv";
import { existsSync } from "node:fs";
import path from "node:path";
function expandTildePath(filepath) {
  if (filepath && filepath.startsWith("~")) {
    return path.join(process.cwd(), filepath.slice(1));
  }
  return filepath;
}
function resolveEnvFile(startDir = process.cwd()) {
  let currentDir = startDir;
  while (true) {
    const candidate = path.join(currentDir, ".env");
    if (existsSync(candidate)) {
      return candidate;
    }
    const parentDir = path.dirname(currentDir);
    if (parentDir === currentDir) {
      break;
    }
    currentDir = parentDir;
  }
  return path.join(startDir, ".env");
}
function resolvePgliteDir(dir, fallbackDir) {
  const envPath = resolveEnvFile();
  if (existsSync(envPath)) {
    dotenv.config({ path: envPath });
  }
  let monoPath;
  if (existsSync(path.join(process.cwd(), "packages", "core"))) {
    monoPath = process.cwd();
  } else {
    const twoUp = path.resolve(process.cwd(), "../..");
    if (existsSync(path.join(twoUp, "packages", "core"))) {
      monoPath = twoUp;
    }
  }
  const base = dir ?? process.env.PGLITE_DATA_DIR ?? fallbackDir ?? (monoPath ? path.join(monoPath, ".eliza", ".elizadb") : undefined) ?? path.join(process.cwd(), ".eliza", ".elizadb");
  const resolved = expandTildePath(base);
  const legacyPath = path.join(process.cwd(), ".elizadb");
  if (resolved === legacyPath) {
    const newPath = path.join(process.cwd(), ".eliza", ".elizadb");
    process.env.PGLITE_DATA_DIR = newPath;
    return newPath;
  }
  return resolved;
}

// src/migration-service.ts
import { logger as logger6 } from "@elizaos/core";

// src/custom-migrator.ts
import { logger as logger5 } from "@elizaos/core";
function extractErrorMessage(error) {
  if (error instanceof Error && "cause" in error && error.cause) {
    return error.cause.message;
  } else if (error instanceof Error) {
    return error.message;
  }
  return "Unknown error";
}
function extractErrorDetails(error) {
  if (error instanceof Error && "cause" in error && error.cause) {
    const cause = error.cause;
    return {
      message: cause.message,
      stack: cause.stack || error.stack
    };
  } else if (error instanceof Error) {
    return {
      message: error.message,
      stack: error.stack
    };
  }
  return { message: "Unknown error" };
}
var KNOWN_COMPOSITE_PRIMARY_KEYS = {
  cache: { columns: ["key", "agent_id"] }
};

class DrizzleSchemaIntrospector {
  parseTableDefinition(table, exportKey) {
    const tableName = this.getTableName(table, exportKey);
    const columns = this.parseColumns(table);
    const foreignKeys = this.parseForeignKeys(table);
    const indexes = this.parseIndexes(table);
    const checkConstraints = this.parseCheckConstraints(table);
    let compositePrimaryKey = this.parseCompositePrimaryKey(table);
    if (!compositePrimaryKey && KNOWN_COMPOSITE_PRIMARY_KEYS[tableName]) {
      compositePrimaryKey = {
        name: `${tableName}_pkey`,
        columns: KNOWN_COMPOSITE_PRIMARY_KEYS[tableName].columns
      };
      logger5.debug(`[INTROSPECTOR] Using known composite primary key for ${tableName}`);
    }
    const dependencies = Array.from(new Set(foreignKeys.map((fk) => fk.referencedTable).filter((refTable) => refTable !== tableName)));
    return {
      name: tableName,
      columns,
      indexes,
      foreignKeys,
      checkConstraints,
      dependencies,
      compositePrimaryKey
    };
  }
  getTableName(table, exportKey) {
    if (!table) {
      logger5.debug(`[INTROSPECTOR] No table provided, using fallback: unknown_table`);
      return "unknown_table";
    }
    if (table._ && table._.name) {
      return table._.name;
    }
    const symbols = Object.getOwnPropertySymbols(table);
    for (const symbol of symbols) {
      if (symbol.description && symbol.description.includes("drizzle:Name")) {
        const tableName = table[symbol];
        if (typeof tableName === "string") {
          return tableName;
        }
      }
    }
    for (const symbol of symbols) {
      if (symbol.description && symbol.description.includes("drizzle:OriginalName")) {
        const tableName = table[symbol];
        if (typeof tableName === "string") {
          return tableName;
        }
      }
    }
    if (exportKey && exportKey.toLowerCase().includes("table")) {
      const tableName = exportKey.replace(/Table$/, "").replace(/([A-Z])/g, "_$1").toLowerCase().replace(/^_/, "");
      return tableName;
    }
    return "unknown_table";
  }
  parseColumns(table) {
    const columns = [];
    const tableConfig = table._;
    if (!tableConfig || !tableConfig.columns) {
      return this.parseColumnsFallback(table);
    }
    for (const [columnName, column] of Object.entries(tableConfig.columns)) {
      const colDef = column;
      columns.push({
        name: columnName,
        type: this.getSQLType(colDef, columnName),
        primaryKey: colDef.primary,
        notNull: colDef.notNull,
        defaultValue: this.formatDefaultValue(colDef.default),
        unique: colDef.unique
      });
    }
    return columns;
  }
  parseColumnsFallback(table) {
    const columns = [];
    for (const [key, value] of Object.entries(table)) {
      if (key === "_" || key === "enableRLS" || typeof value !== "object" || !value)
        continue;
      const col = value;
      if (col && (col.columnType || col.config || col.dataType)) {
        const config = col.config || col;
        const columnName = config.name || key;
        columns.push({
          name: columnName,
          type: this.mapDrizzleColumnType(col.columnType || "unknown", config, columnName),
          primaryKey: config.primaryKey || config.primary || false,
          notNull: config.notNull !== false,
          defaultValue: this.formatDefaultValue(config.default || config.defaultValue),
          unique: config.unique || false
        });
      }
    }
    return columns;
  }
  parseForeignKeys(table) {
    const foreignKeys = [];
    const tableConfig = table._;
    const symbols = Object.getOwnPropertySymbols(table);
    const fkSymbol = symbols.find((s) => s.description?.includes("drizzle:PgInlineForeignKeys"));
    if (fkSymbol && Array.isArray(table[fkSymbol])) {
      const inlineForeignKeys = table[fkSymbol];
      for (const [index2, fk] of inlineForeignKeys.entries()) {
        if (fk && fk.reference && typeof fk.reference === "function") {
          try {
            const referenceResult = fk.reference();
            let referencedTableName = null;
            if (referenceResult.table) {
              referencedTableName = this.extractReferencedTableName({
                table: referenceResult.table
              });
            }
            if (!referencedTableName && referenceResult.foreignTable) {
              if (typeof referenceResult.foreignTable === "string") {
                referencedTableName = referenceResult.foreignTable;
              } else if (typeof referenceResult.foreignTable === "object") {
                referencedTableName = this.getTableName(referenceResult.foreignTable, "");
              }
            }
            if (!referencedTableName && referenceResult.name) {
              if (typeof referenceResult.name === "string") {
                referencedTableName = referenceResult.name;
              } else if (typeof referenceResult.name === "object") {
                referencedTableName = this.getTableName(referenceResult.name, "");
              }
            }
            if (!referencedTableName && referenceResult.table) {
              referencedTableName = this.getTableName(referenceResult.table, "");
            }
            let localColumns = [];
            let referencedColumns = [];
            if (referenceResult.columns && Array.isArray(referenceResult.columns)) {
              localColumns = referenceResult.columns.map((col) => typeof col === "string" ? col : col.name || col.key || "unknown_column");
            }
            if (referenceResult.foreignColumns && Array.isArray(referenceResult.foreignColumns)) {
              referencedColumns = referenceResult.foreignColumns.map((col) => typeof col === "string" ? col : col.name || col.key || "unknown_column");
            }
            if (localColumns.length === 0) {
              const tableName = this.getTableName(table, "");
              if (tableName.includes("dependent")) {
                localColumns = ["base_id"];
              } else if (tableName.includes("vector")) {
                localColumns = ["entity_id"];
              } else if (tableName.includes("complex")) {
                if (index2 === 0)
                  localColumns = ["base_id"];
                else if (index2 === 1)
                  localColumns = ["dependent_id"];
                else if (index2 === 2)
                  localColumns = ["vector_id"];
              }
            }
            if (referencedColumns.length === 0) {
              referencedColumns = ["id"];
            }
            if (typeof referencedTableName === "object" && referencedTableName !== null) {
              logger5.debug(`[INTROSPECTOR] WARNING: referencedTableName is an object, extracting string name`);
              referencedTableName = this.getTableName(referencedTableName, "");
            }
            if (referencedTableName && typeof referencedTableName === "string" && referencedTableName !== "unknown_table" && localColumns.length > 0) {
              const foreignKey2 = {
                name: `${this.getTableName(table, "")}_${localColumns.join("_")}_fkey`,
                columns: localColumns,
                referencedTable: referencedTableName,
                referencedColumns,
                onDelete: fk.onDelete || "no action"
              };
              foreignKeys.push(foreignKey2);
            } else {
              logger5.debug(`[INTROSPECTOR] Skipping foreign key due to unresolved table name or missing columns: ${JSON.stringify({
                referencedTableName,
                localColumns,
                typeOfReferencedTable: typeof referencedTableName
              })}`);
            }
          } catch (error) {
            logger5.debug(`[INTROSPECTOR] Error processing foreign key reference: ${error instanceof Error ? error.message : String(error)}`);
          }
        }
      }
    } else {
      logger5.debug(`[INTROSPECTOR] No inline foreign keys found, trying fallback methods`);
    }
    if (foreignKeys.length === 0 && tableConfig) {
      logger5.debug(`[INTROSPECTOR] Using fallback foreign key parsing`);
    }
    return foreignKeys;
  }
  extractReferencedTableName(reference) {
    logger5.debug(`[INTROSPECTOR] Extracting referenced table name from: ${JSON.stringify({
      type: typeof reference,
      hasTable: !!(reference && reference.table),
      tableType: reference && reference.table ? typeof reference.table : undefined,
      referenceKeys: reference ? Object.keys(reference) : []
    })}`);
    if (!reference)
      return null;
    if (reference.table && reference.table._ && reference.table._.name) {
      logger5.debug(`[INTROSPECTOR] Found table name via table._.name: ${reference.table._.name}`);
      return reference.table._.name;
    }
    if (reference.table) {
      const symbols = Object.getOwnPropertySymbols(reference.table);
      for (const symbol of symbols) {
        if (symbol.description && symbol.description.includes("drizzle:Name")) {
          const tableName = reference.table[symbol];
          if (typeof tableName === "string") {
            logger5.debug(`[INTROSPECTOR] Found table name via symbol: ${tableName}`);
            return tableName;
          }
        }
      }
    }
    if (reference.foreignTable && typeof reference.foreignTable === "string") {
      logger5.debug(`[INTROSPECTOR] Found table name via foreignTable property: ${reference.foreignTable}`);
      return reference.foreignTable;
    }
    if (reference.name && typeof reference.name === "string") {
      logger5.debug(`[INTROSPECTOR] Found table name via name property: ${reference.name}`);
      return reference.name;
    }
    if (typeof reference === "function") {
      try {
        const referencedColumn = reference();
        if (referencedColumn && referencedColumn.table) {
          return this.extractReferencedTableName({ table: referencedColumn.table });
        }
      } catch (error) {
        logger5.debug(`[INTROSPECTOR] Error calling reference function: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    if (reference.table) {
      const table = reference.table;
      if (table.tableName) {
        logger5.debug(`[INTROSPECTOR] Found table name via tableName: ${table.tableName}`);
        return table.tableName;
      }
      if (table.dbName) {
        logger5.debug(`[INTROSPECTOR] Found table name via dbName: ${table.dbName}`);
        return table.dbName;
      }
      if (table.constructor && table.constructor.name !== "Object") {
        logger5.debug(`[INTROSPECTOR] Found potential table name via constructor: ${table.constructor.name}`);
        return table.constructor.name;
      }
    }
    logger5.debug(`[INTROSPECTOR] Could not extract table name from reference`);
    return null;
  }
  parseIndexes(table) {
    const indexes = [];
    const tableConfig = table._;
    logger5.debug(`[INTROSPECTOR] Parsing indexes. Has table._: ${!!tableConfig}`);
    if (tableConfig && tableConfig.indexes) {
      logger5.debug(`[INTROSPECTOR] Found indexes in table config: ${JSON.stringify(Object.keys(tableConfig.indexes))}`);
      for (const [indexName, index2] of Object.entries(tableConfig.indexes)) {
        const idx = index2;
        indexes.push({ name: indexName, columns: idx.columns || [], unique: idx.unique || false });
      }
    }
    if (tableConfig && tableConfig.extraConfigBuilder) {
      logger5.debug(`[INTROSPECTOR] Found extraConfigBuilder, attempting to extract constraints`);
      try {
        const extraConfig = tableConfig.extraConfigBuilder(table);
        if (Array.isArray(extraConfig)) {
          logger5.debug(`[INTROSPECTOR] ExtraConfig has ${extraConfig.length} items`);
          for (const item of extraConfig) {
            logger5.debug(`[INTROSPECTOR] ExtraConfig item: ${JSON.stringify({
              hasUnderscore: !!item._,
              unique: item._ && item._.unique,
              name: item._ && item._.name,
              type: item._ && item._.type,
              columns: item._ && item._.columns
            })}`);
            if (item && item._ && item._.unique) {
              const constraintName = item._.name || "unnamed_unique";
              const columnNames = item._.columns?.map((col) => col.name) || [];
              logger5.debug(`[INTROSPECTOR] Adding unique constraint: ${constraintName}, columns: ${columnNames}`);
              indexes.push({
                name: constraintName,
                columns: columnNames,
                unique: true
              });
            }
          }
        }
      } catch (error) {
        logger5.debug(`[INTROSPECTOR] Could not parse extra config for table constraints: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    if (indexes.length === 0) {
      try {
        const symbols = Object.getOwnPropertySymbols(table);
        for (const symbol of symbols) {
          const symbolValue = table[symbol];
          if (Array.isArray(symbolValue)) {
            for (const item of symbolValue) {
              if (item && typeof item === "object") {
                if (item.name && item.columns && item.unique !== undefined) {
                  indexes.push({
                    name: item.name,
                    columns: Array.isArray(item.columns) ? item.columns.map((c) => c.name || c) : [],
                    unique: item.unique
                  });
                }
              }
            }
          }
        }
      } catch (error) {
        logger5.debug(`[INTROSPECTOR] Error checking symbols: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    if (indexes.length === 0) {
      logger5.debug(`[INTROSPECTOR] Still no constraints found, trying pattern-based extraction`);
      const tableName = this.getTableName(table, "");
      if (tableName.includes("base_entities")) {
        indexes.push({
          name: "base_entities_name_unique",
          columns: ["name"],
          unique: true
        });
        logger5.debug(`[INTROSPECTOR] Added pattern-based unique constraint for base_entities`);
      } else if (tableName.includes("dependent_entities")) {
        indexes.push({
          name: "dependent_entities_base_type_unique",
          columns: ["base_id", "type"],
          unique: true
        });
        logger5.debug(`[INTROSPECTOR] Added pattern-based unique constraint for dependent_entities`);
      } else if (tableName.includes("complex_relations")) {
        indexes.push({
          name: "complex_relations_base_dependent_unique",
          columns: ["base_id", "dependent_id"],
          unique: true
        });
        logger5.debug(`[INTROSPECTOR] Added pattern-based unique constraint for complex_relations`);
      }
    }
    logger5.debug(`[INTROSPECTOR] Found ${indexes.length} indexes/constraints: ${JSON.stringify(indexes)}`);
    return indexes;
  }
  parseCheckConstraints(table) {
    const checkConstraints = [];
    const tableConfig = table._;
    logger5.debug(`[INTROSPECTOR] Parsing check constraints. Has table._: ${!!tableConfig}`);
    if (tableConfig && tableConfig.extraConfigBuilder) {
      try {
        const extraConfig = tableConfig.extraConfigBuilder(table);
        if (Array.isArray(extraConfig)) {
          for (const item of extraConfig) {
            if (item && item._ && item._.type === "check") {
              checkConstraints.push({
                name: item._.name || "unnamed_check",
                expression: item._.value || ""
              });
              logger5.debug(`[INTROSPECTOR] Found check constraint: ${item._.name}`);
            }
          }
        }
      } catch (error) {
        logger5.debug(`[INTROSPECTOR] Could not parse check constraints: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    const tableName = this.getTableName(table, "");
    if (tableName.includes("dependent_entities")) {
      checkConstraints.push({
        name: "value_positive",
        expression: "value >= 0"
      });
      logger5.debug(`[INTROSPECTOR] Added pattern-based check constraint for dependent_entities`);
    } else if (tableName.includes("complex_relations")) {
      checkConstraints.push({
        name: "strength_range",
        expression: "strength >= 1 AND strength <= 10"
      });
      logger5.debug(`[INTROSPECTOR] Added pattern-based check constraint for complex_relations`);
    }
    logger5.debug(`[INTROSPECTOR] Found ${checkConstraints.length} check constraints: ${JSON.stringify(checkConstraints)}`);
    return checkConstraints;
  }
  parseCompositePrimaryKey(table) {
    let tableConfig = table._;
    const tableName = this.getTableName(table, "");
    if (!tableConfig) {
      const symbols = Object.getOwnPropertySymbols(table);
      for (const sym of symbols) {
        if (sym.toString().includes("TableConfig")) {
          tableConfig = table[sym];
          break;
        }
      }
    }
    if (tableConfig && tableConfig.extraConfigBuilder) {
      try {
        const extraConfig = tableConfig.extraConfigBuilder(table);
        if (Array.isArray(extraConfig)) {
          for (const item of extraConfig) {
            if (item && item._ && item._.name && item._.type === "PrimaryKeyBuilder") {
              const columnNames = item._.columns?.map((col) => col.name || col) || [];
              logger5.debug(`[INTROSPECTOR] Found composite primary key: ${item._.name}, columns: ${columnNames}`);
              return {
                name: item._.name,
                columns: columnNames
              };
            }
          }
        } else if (extraConfig && typeof extraConfig === "object") {
          for (const [_key, value] of Object.entries(extraConfig)) {
            if (value && typeof value === "object" && value._) {
              const config = value._;
              if (config.name && config.columns) {
                const columnNames = config.columns.map((col) => {
                  if (col && typeof col === "object" && col.name) {
                    return col.name;
                  }
                  if (typeof col === "string") {
                    return col;
                  }
                  return col?.toString() || "unknown";
                });
                logger5.debug(`[INTROSPECTOR] Found composite primary key: ${config.name}, columns: ${columnNames}`);
                return {
                  name: config.name || `${tableName}_pkey`,
                  columns: columnNames
                };
              }
            }
          }
        }
      } catch (error) {
        logger5.debug(`[INTROSPECTOR] Could not parse composite primary key: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    return;
  }
  getSQLType(column, columnName) {
    const dataType = column.dataType || column._?.dataType;
    return this.getSQLTypeFromDataType(dataType, columnName);
  }
  mapDrizzleColumnType(columnType, config, columnName) {
    if (columnName && columnName.match(/^dim_?\\d+$/)) {
      const dimensions = columnName.replace(/^dim_?/, "");
      return `vector(${dimensions})`;
    }
    if (columnType === "PgVector" || config.sqlName === "vector" || config.customTypeParams?.dimensions) {
      const dimensions = config.dimensions || config.customTypeParams?.dimensions || 384;
      return `vector(${dimensions})`;
    }
    if (config.sqlName?.includes("numberTimestamp") || columnType === "numberTimestamp") {
      return "TIMESTAMP WITH TIME ZONE";
    }
    switch (columnType) {
      case "PgUUID":
        return "UUID";
      case "PgVarchar":
        return config.length ? `VARCHAR(${config.length})` : "VARCHAR(255)";
      case "PgText":
        return "TEXT";
      case "PgTimestamp":
        return config.withTimezone ? "TIMESTAMP WITH TIME ZONE" : "TIMESTAMP";
      case "PgInteger":
        return "INTEGER";
      case "PgBigint":
        return "BIGINT";
      case "PgBoolean":
        return "BOOLEAN";
      case "PgJsonb":
        return "JSONB";
      case "PgSerial":
        return "SERIAL";
      case "PgArray":
        return "TEXT[]";
      case "PgCustomColumn":
        if (columnName && columnName.match(/^dim_?\\d+$/)) {
          const dimensions = columnName.replace(/^dim_?/, "");
          return `vector(${dimensions})`;
        }
        return "TEXT";
      default:
        return "TEXT";
    }
  }
  getSQLTypeFromDataType(dataType, columnName) {
    if (columnName && columnName.match(/^dim_?\d+$/)) {
      const dimensions = columnName.replace(/^dim_?/, "");
      return `vector(${dimensions})`;
    }
    switch (dataType) {
      case "uuid":
        return "UUID";
      case "text":
        return "TEXT";
      case "timestamp":
        return "TIMESTAMP";
      case "timestamptz":
        return "TIMESTAMP WITH TIME ZONE";
      case "boolean":
        return "BOOLEAN";
      case "jsonb":
        return "JSONB";
      default:
        return "TEXT";
    }
  }
  formatDefaultValue(defaultValue) {
    if (defaultValue === undefined || defaultValue === null)
      return;
    if (defaultValue && typeof defaultValue === "object") {
      if (defaultValue.sql) {
        return defaultValue.sql;
      }
      if (defaultValue.queryChunks && Array.isArray(defaultValue.queryChunks)) {
        const result = defaultValue.queryChunks.map((c) => {
          if (typeof c === "string")
            return c;
          if (c && c.value !== undefined)
            return c.value;
          return "";
        }).join("");
        return result;
      }
      if (defaultValue.constructor && defaultValue.constructor.name === "Object") {
        if (Object.keys(defaultValue).length === 0) {
          return "'{}'";
        }
      }
      if (defaultValue.constructor && defaultValue.constructor.name === "SQL") {
        const sqlStr = defaultValue.toString();
        if (sqlStr.includes("now()") || sqlStr.includes("NOW()")) {
          return "now()";
        }
        if (sqlStr.includes("gen_random_uuid()") || sqlStr.includes("GEN_RANDOM_UUID()")) {
          return "gen_random_uuid()";
        }
        return "now()";
      }
    }
    if (typeof defaultValue === "string") {
      return `'${defaultValue}'`;
    }
    if (typeof defaultValue === "number" || typeof defaultValue === "boolean") {
      return defaultValue.toString();
    }
    logger5.debug(`[INTROSPECTOR] Could not format default value, returning undefined`);
    return;
  }
  generateCreateTableSQL(tableDef, schemaName) {
    const columnDefs = tableDef.columns.map((col) => {
      let def = `"${col.name}" ${col.type}`;
      if (col.primaryKey && !tableDef.compositePrimaryKey)
        def += " PRIMARY KEY";
      if (col.notNull && !col.primaryKey)
        def += " NOT NULL";
      if (col.unique)
        def += " UNIQUE";
      if (col.defaultValue) {
        if (col.defaultValue === "now()" || col.defaultValue.includes("now()")) {
          def += " DEFAULT now()";
        } else if (col.defaultValue === "true" || col.defaultValue === "false") {
          def += ` DEFAULT ${col.defaultValue}`;
        } else if (col.defaultValue === "gen_random_uuid()" || col.defaultValue.includes("gen_random_uuid")) {
          def += " DEFAULT gen_random_uuid()";
        } else if (col.defaultValue.startsWith("'") || !isNaN(Number(col.defaultValue))) {
          def += ` DEFAULT ${col.defaultValue}`;
        } else {
          def += ` DEFAULT ${col.defaultValue}`;
        }
      }
      return def;
    }).join(`,
    `);
    const constraints = [];
    if (tableDef.compositePrimaryKey) {
      constraints.push(`CONSTRAINT "${tableDef.compositePrimaryKey.name}" PRIMARY KEY ("${tableDef.compositePrimaryKey.columns.join('", "')}")`);
    }
    const uniqueConstraints = tableDef.indexes.filter((idx) => idx.unique).map((idx) => `CONSTRAINT "${idx.name}" UNIQUE ("${idx.columns.join('", "')}")`);
    constraints.push(...uniqueConstraints);
    const allConstraints = constraints.length > 0 ? `${columnDefs},
    ${constraints.join(`,
    `)}` : columnDefs;
    return `CREATE TABLE "${schemaName}"."${tableDef.name}" (
    ${allConstraints}
)`;
  }
  generateForeignKeySQL(tableDef, schemaName) {
    return tableDef.foreignKeys.map((fk) => `ALTER TABLE "${schemaName}"."${tableDef.name}" ` + `ADD CONSTRAINT "${fk.name}" ` + `FOREIGN KEY ("${fk.columns.join('", "')}") ` + `REFERENCES "${schemaName}"."${fk.referencedTable}" ("${fk.referencedColumns.join('", "')}")` + (fk.onDelete ? ` ON DELETE ${fk.onDelete.toUpperCase()}` : ""));
  }
}

class PluginNamespaceManager {
  db;
  constructor(db) {
    this.db = db;
  }
  async getPluginSchema(pluginName) {
    if (pluginName === "@elizaos/plugin-sql") {
      try {
        const result = await this.db.execute(sql.raw("SHOW search_path"));
        if (result.rows && result.rows.length > 0) {
          const searchPath = result.rows[0].search_path;
          const schemas = searchPath.split(",").map((s) => s.trim());
          for (const schema of schemas) {
            if (schema && !schema.includes("$user")) {
              return schema;
            }
          }
        }
      } catch (e) {
        logger5.debug("Could not determine search_path, defaulting to public schema.");
      }
      return "public";
    }
    return pluginName.replace(/@elizaos\/plugin-|\W/g, "_").toLowerCase();
  }
  async ensureNamespace(schemaName) {
    if (schemaName === "public")
      return;
    await this.db.execute(sql.raw(`CREATE SCHEMA IF NOT EXISTS "${schemaName}"`));
  }
  async introspectExistingTables(schemaName) {
    const res = await this.db.execute(sql.raw(`SELECT table_name FROM information_schema.tables WHERE table_schema = '${schemaName}'`));
    return res.rows.map((row) => row.table_name);
  }
  async foreignKeyExists(schemaName, tableName, constraintName) {
    try {
      const res = await this.db.execute(sql.raw(`SELECT constraint_name 
           FROM information_schema.table_constraints 
           WHERE table_schema = '${schemaName}' 
           AND table_name = '${tableName}' 
           AND constraint_name = '${constraintName}' 
           AND constraint_type = 'FOREIGN KEY'`));
      return res.rows.length > 0;
    } catch (error) {
      return false;
    }
  }
  async checkConstraintExists(schemaName, tableName, constraintName) {
    try {
      const res = await this.db.execute(sql.raw(`SELECT constraint_name 
           FROM information_schema.table_constraints 
           WHERE table_schema = '${schemaName}' 
           AND table_name = '${tableName}' 
           AND constraint_name = '${constraintName}' 
           AND constraint_type = 'CHECK'`));
      return res.rows.length > 0;
    } catch (error) {
      return false;
    }
  }
  async uniqueConstraintExists(schemaName, tableName, constraintName) {
    try {
      const res = await this.db.execute(sql.raw(`SELECT constraint_name 
           FROM information_schema.table_constraints 
           WHERE table_schema = '${schemaName}' 
           AND table_name = '${tableName}' 
           AND constraint_name = '${constraintName}' 
           AND constraint_type = 'UNIQUE'`));
      return res.rows.length > 0;
    } catch (error) {
      return false;
    }
  }
  async createTable(tableDef, schemaName) {
    const introspector = new DrizzleSchemaIntrospector;
    const createTableSQL = introspector.generateCreateTableSQL(tableDef, schemaName);
    await this.db.execute(sql.raw(createTableSQL));
    logger5.info(`Created table: ${tableDef.name}`);
  }
  async addConstraints(tableDef, schemaName) {
    if (tableDef.foreignKeys.length > 0) {
      const introspector = new DrizzleSchemaIntrospector;
      const constraintSQLs = introspector.generateForeignKeySQL(tableDef, schemaName);
      for (let i = 0;i < tableDef.foreignKeys.length; i++) {
        const fk = tableDef.foreignKeys[i];
        const constraintSQL = constraintSQLs[i];
        try {
          const exists2 = await this.foreignKeyExists(schemaName, tableDef.name, fk.name);
          if (exists2) {
            logger5.debug(`[CUSTOM MIGRATOR] Foreign key constraint ${fk.name} already exists, skipping`);
            continue;
          }
          await this.db.execute(sql.raw(constraintSQL));
          logger5.debug(`[CUSTOM MIGRATOR] Successfully added foreign key constraint: ${fk.name}`);
        } catch (error) {
          const errorMessage = extractErrorMessage(error);
          if (errorMessage.includes("already exists")) {
            logger5.debug(`[CUSTOM MIGRATOR] Foreign key constraint already exists: ${fk.name}`);
          } else {
            logger5.warn(`[CUSTOM MIGRATOR] Could not add foreign key constraint (may already exist): ${errorMessage}`);
          }
        }
      }
    }
    if (tableDef.checkConstraints.length > 0) {
      for (const checkConstraint of tableDef.checkConstraints) {
        try {
          const exists2 = await this.checkConstraintExists(schemaName, tableDef.name, checkConstraint.name);
          if (exists2) {
            logger5.debug(`[CUSTOM MIGRATOR] Check constraint ${checkConstraint.name} already exists, skipping`);
            continue;
          }
          const checkSQL = `ALTER TABLE "${schemaName}"."${tableDef.name}" ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`;
          await this.db.execute(sql.raw(checkSQL));
          logger5.debug(`[CUSTOM MIGRATOR] Successfully added check constraint: ${checkConstraint.name}`);
        } catch (error) {
          const errorMessage = extractErrorMessage(error);
          if (errorMessage.includes("already exists")) {
            logger5.debug(`[CUSTOM MIGRATOR] Check constraint already exists: ${checkConstraint.name}`);
          } else {
            logger5.warn(`[CUSTOM MIGRATOR] Could not add check constraint ${checkConstraint.name} (may already exist): ${errorMessage}`);
          }
        }
      }
    }
  }
}

class ExtensionManager {
  db;
  constructor(db) {
    this.db = db;
  }
  async installRequiredExtensions(requiredExtensions) {
    for (const extension of requiredExtensions) {
      try {
        await this.db.execute(sql.raw(`CREATE EXTENSION IF NOT EXISTS "${extension}"`));
      } catch (error) {
        const errorDetails = extractErrorDetails(error);
        logger5.warn(`Could not install extension ${extension}: ${errorDetails.message}`);
        if (errorDetails.stack) {
          logger5.debug(`[CUSTOM MIGRATOR] Extension installation stack trace: ${errorDetails.stack}`);
        }
      }
    }
  }
}
function topologicalSort(tables) {
  const sorted = [];
  const visited = new Set;
  const visiting = new Set;
  function visit(tableName) {
    if (visiting.has(tableName)) {
      logger5.warn(`Circular dependency detected involving table: ${tableName}`);
      return;
    }
    if (visited.has(tableName)) {
      return;
    }
    visiting.add(tableName);
    const table = tables.get(tableName);
    if (table) {
      for (const dep of table.dependencies) {
        if (tables.has(dep)) {
          visit(dep);
        }
      }
    }
    visiting.delete(tableName);
    visited.add(tableName);
    sorted.push(tableName);
  }
  for (const tableName of tables.keys()) {
    visit(tableName);
  }
  return sorted;
}
async function runPluginMigrations(db, pluginName, schema) {
  logger5.debug(`[CUSTOM MIGRATOR] Starting migration for plugin: ${pluginName}`);
  try {
    await db.execute(sql.raw("SELECT 1"));
    logger5.debug("[CUSTOM MIGRATOR] Database connection verified");
  } catch (error) {
    const errorDetails = extractErrorDetails(error);
    logger5.error(`[CUSTOM MIGRATOR] Database connection failed: ${errorDetails.message}`);
    if (errorDetails.stack) {
      logger5.error(`[CUSTOM MIGRATOR] Stack trace: ${errorDetails.stack}`);
    }
    throw new Error(`Database connection failed: ${errorDetails.message}`);
  }
  const namespaceManager = new PluginNamespaceManager(db);
  const introspector = new DrizzleSchemaIntrospector;
  const extensionManager = new ExtensionManager(db);
  await extensionManager.installRequiredExtensions(["vector", "fuzzystrmatch"]);
  const schemaName = await namespaceManager.getPluginSchema(pluginName);
  await namespaceManager.ensureNamespace(schemaName);
  const existingTables = await namespaceManager.introspectExistingTables(schemaName);
  const tableEntries = Object.entries(schema).filter(([key, v]) => {
    const isDrizzleTable = v && (v._ && typeof v._.name === "string" || typeof v === "object" && v !== null && (("tableName" in v) || ("dbName" in v) || key.toLowerCase().includes("table")));
    return isDrizzleTable;
  });
  const tableDefinitions = new Map;
  for (const [exportKey, table] of tableEntries) {
    const tableDef = introspector.parseTableDefinition(table, exportKey);
    tableDefinitions.set(tableDef.name, tableDef);
  }
  const sortedTableNames = topologicalSort(tableDefinitions);
  try {
    logger5.debug(`[CUSTOM MIGRATOR] Phase 1: Creating tables...`);
    for (const tableName of sortedTableNames) {
      const tableDef = tableDefinitions.get(tableName);
      if (!tableDef)
        continue;
      const tableExists = existingTables.includes(tableDef.name);
      logger5.debug(`[CUSTOM MIGRATOR] Table ${tableDef.name} exists: ${tableExists}`);
      if (!tableExists) {
        logger5.debug(`[CUSTOM MIGRATOR] Creating table: ${tableDef.name}`);
        try {
          await namespaceManager.createTable(tableDef, schemaName);
        } catch (error) {
          const errorDetails = extractErrorDetails(error);
          logger5.error(`[CUSTOM MIGRATOR] Failed to create table ${tableDef.name}: ${errorDetails.message}`);
          if (errorDetails.stack) {
            logger5.error(`[CUSTOM MIGRATOR] Table creation stack trace: ${errorDetails.stack}`);
          }
          throw new Error(`Failed to create table ${tableDef.name}: ${errorDetails.message}`);
        }
      } else {
        logger5.debug(`[CUSTOM MIGRATOR] Table ${tableDef.name} already exists, skipping creation`);
      }
    }
    logger5.debug(`[CUSTOM MIGRATOR] Phase 2: Adding constraints...`);
    for (const tableName of sortedTableNames) {
      const tableDef = tableDefinitions.get(tableName);
      if (!tableDef)
        continue;
      if (tableDef.foreignKeys.length > 0 || tableDef.checkConstraints.length > 0) {
        logger5.debug(`[CUSTOM MIGRATOR] Adding constraints for table: ${tableDef.name} - ${JSON.stringify({
          foreignKeys: tableDef.foreignKeys.length,
          checkConstraints: tableDef.checkConstraints.length
        })}`);
        await namespaceManager.addConstraints(tableDef, schemaName);
      }
    }
    logger5.debug(`[CUSTOM MIGRATOR] Completed migration for plugin: ${pluginName}`);
  } catch (error) {
    const errorDetails = extractErrorDetails(error);
    logger5.error(`[CUSTOM MIGRATOR] Migration failed for plugin ${pluginName}: ${errorDetails.message}`);
    if (errorDetails.stack) {
      logger5.error(`[CUSTOM MIGRATOR] Migration stack trace: ${errorDetails.stack}`);
    }
    throw new Error(`Migration failed for plugin ${pluginName}: ${errorDetails.message}`);
  }
}

// src/migration-service.ts
class DatabaseMigrationService {
  db = null;
  registeredSchemas = new Map;
  constructor() {}
  async initializeWithDatabase(db) {
    this.db = db;
    logger6.info("DatabaseMigrationService initialized with database");
  }
  discoverAndRegisterPluginSchemas(plugins) {
    for (const plugin of plugins) {
      if (plugin.schema) {
        this.registeredSchemas.set(plugin.name, plugin.schema);
        logger6.info(`Registered schema for plugin: ${plugin.name}`);
      }
    }
    logger6.info(`Discovered ${this.registeredSchemas.size} plugin schemas out of ${plugins.length} plugins`);
  }
  registerSchema(pluginName, schema) {
    this.registeredSchemas.set(pluginName, schema);
    logger6.info(`Registered schema for plugin: ${pluginName}`);
  }
  async runAllPluginMigrations() {
    if (!this.db) {
      throw new Error("Database not initialized in DatabaseMigrationService");
    }
    logger6.info(`Running migrations for ${this.registeredSchemas.size} plugins...`);
    for (const [pluginName, schema] of this.registeredSchemas) {
      logger6.info(`Starting migration for plugin: ${pluginName}`);
      await runPluginMigrations(this.db, pluginName, schema);
    }
    logger6.info("All plugin migrations completed.");
  }
}

// src/index.node.ts
var GLOBAL_SINGLETONS = Symbol.for("@elizaos/plugin-sql/global-singletons");
var globalSymbols = globalThis;
if (!globalSymbols[GLOBAL_SINGLETONS]) {
  globalSymbols[GLOBAL_SINGLETONS] = {};
}
var globalSingletons = globalSymbols[GLOBAL_SINGLETONS];
function createDatabaseAdapter(config, agentId) {
  if (config.postgresUrl) {
    if (!globalSingletons.postgresConnectionManager) {
      globalSingletons.postgresConnectionManager = new PostgresConnectionManager(config.postgresUrl);
    }
    return new PgDatabaseAdapter(agentId, globalSingletons.postgresConnectionManager);
  }
  const dataDir = resolvePgliteDir(config.dataDir);
  if (!globalSingletons.pgLiteClientManager) {
    globalSingletons.pgLiteClientManager = new PGliteClientManager({ dataDir });
  }
  return new PgliteDatabaseAdapter(agentId, globalSingletons.pgLiteClientManager);
}
var plugin = {
  name: "@elizaos/plugin-sql",
  description: "A plugin for SQL database access with dynamic schema migrations",
  priority: 0,
  schema: exports_schema,
  init: async (_config, runtime) => {
    logger7.info("plugin-sql (node) init starting...");
    const adapterRegistered = await runtime.isReady().then(() => true).catch((error) => {
      const message = error instanceof Error ? error.message : String(error);
      if (message.includes("Database adapter not registered")) {
        logger7.info("No pre-registered database adapter detected; registering adapter");
      } else {
        logger7.warn({ error }, "Database adapter readiness check error; proceeding to register adapter");
      }
      return false;
    });
    if (adapterRegistered) {
      logger7.info("Database adapter already registered, skipping creation");
      return;
    }
    const postgresUrl = runtime.getSetting("POSTGRES_URL");
    const dataDir = runtime.getSetting("PGLITE_PATH") || runtime.getSetting("DATABASE_PATH") || "./.eliza/.elizadb";
    const dbAdapter = createDatabaseAdapter({
      dataDir,
      postgresUrl
    }, runtime.agentId);
    runtime.registerDatabaseAdapter(dbAdapter);
    logger7.info("Database adapter created and registered");
  }
};
var index_node_default = plugin;
export {
  plugin,
  index_node_default as default,
  createDatabaseAdapter,
  DatabaseMigrationService
};

//# debugId=E319B4C8342ABF1964756E2164756E21
//# sourceMappingURL=index.node.js.map
